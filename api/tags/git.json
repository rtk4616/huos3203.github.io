{"name":"git","postlist":[{"title":"用Git将代码恢复到一个历史的版本","slug":"git/用Git将代码恢复到一个历史的版本","date":"2017-02-10T18:19:48.000Z","updated":"2017-02-10T18:29:19.000Z","comments":true,"path":"api/articles/git/用Git将代码恢复到一个历史的版本.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>经历：将代码全提交到默认的head分支中，切换分支后，无法找到分支的严重后果：<br>目的：在当前分支上，将代码恢复到一个历史的提交版本上。</p>\n<h2 id=\"暴力的方式\"><a href=\"#暴力的方式\" class=\"headerlink\" title=\"暴力的方式\"></a>暴力的方式</h2><p>如果仓库是自己在用（不影响别人），那么可以使用<code>git reset --hard &lt;target_commit_id&gt;</code> 来恢复到指定的提交，再用 git push -f 来强制更新远程的分支指针。为了保证万一需要找回历史提交，我们可以先打一个 tag 来备份。</p>\n<ol>\n<li>第一步：查看本地的索引的提交日志：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git reflog \t\t</span></span><br><span class=\"line\">a1d09fd HEAD@&#123;0&#125;: checkout: moving from all to master</span><br><span class=\"line\">a1d09fd HEAD@&#123;1&#125;: checkout: moving from master to all</span><br><span class=\"line\">a1d09fd HEAD@&#123;2&#125;: checkout: moving from HEAD to master</span><br><span class=\"line\">a1d09fd HEAD@&#123;3&#125;: checkout: moving from all to HEAD</span><br></pre></td></tr></table></figure></li>\n<li>第二步：根据上面的sh2值，回滚：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset  —hard  a1d09fd</span><br></pre></td></tr></table></figure>\n这样就可以找回代码.</li>\n</ol>\n<h2 id=\"温柔的方式\"><a href=\"#温柔的方式\" class=\"headerlink\" title=\"温柔的方式\"></a>温柔的方式</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">回滚</span></span><br><span class=\"line\">git reset  —hard  a1d09fd</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">将当前代码切换回最新的提交</span></span><br><span class=\"line\">git reset --soft origin/source</span><br></pre></td></tr></table></figure>\n<p>此时工作区变成了历史的提交内容，这个时候用 <code>git add</code> 和 <code>git commit</code> 即可.</p>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"恢复","path":"api/categories/恢复.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"git","path":"api/tags/git.json"}]},{"title":"迁移SVN库到git库保留branchs和tags","slug":"git/迁移SVN库到git库保留branchs和tags","date":"2017-01-18T12:21:46.000Z","updated":"2017-02-17T16:28:51.000Z","comments":true,"path":"api/articles/git/迁移SVN库到git库保留branchs和tags.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>SVN was a great advance in its day, but it’s now clear that distributed version control systems are the way forward and that Git is the de facto standard. Having helped many clients migrate from SVN to Git, here are my notes for a pain-free transition that will preserve the tags and branches in your SVN repository.</p>\n<h2 id=\"首先导入一个本地存储库\"><a href=\"#首先导入一个本地存储库\" class=\"headerlink\" title=\"首先导入一个本地存储库\"></a>首先导入一个本地存储库</h2><h3 id=\"在本地创建一个存储库的目录\"><a href=\"#在本地创建一个存储库的目录\" class=\"headerlink\" title=\"在本地创建一个存储库的目录\"></a>在本地创建一个存储库的目录</h3><figure class=\"highlight bash\"><figcaption><span>新建目录</span><a href=\"http://www.sailmaker.co.uk/blog/2013/05/05/migrating-from-svn-to-git-preserving-branches-and-tags-3/#import-staging\" target=\"_blank\" rel=\"noopener\">Create a local staging directory</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">mkdir staging</span><br><span class=\"line\"><span class=\"built_in\">cd</span> staging</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：staging 可以用任何你喜欢的字符串命名，也可以放在本地的任何目录中。</p>\n</blockquote>\n<h3 id=\"初始化git-svn\"><a href=\"#初始化git-svn\" class=\"headerlink\" title=\"初始化git svn\"></a>初始化git svn</h3><h4 id=\"使用SVN标准库结构初始化\"><a href=\"#使用SVN标准库结构初始化\" class=\"headerlink\" title=\"使用SVN标准库结构初始化\"></a>使用SVN标准库结构初始化</h4><figure class=\"highlight bash\"><figcaption><span>标准初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git svn init SVNRepo_ROOT_URL --stdlayout --prefix=svn/</span><br></pre></td></tr></table></figure>\n<p><code>SVNRepo_ROOT_URL</code>: 这里svn_url是完全限定的URL下的标准目录，其目录下包括三个目录：<code>trunk</code>，<code>branches</code>， <code>tags</code>。<br><code>--prefix</code>: 强烈建议使用<code>svn/</code>作为分支和标签的前缀：设置为 <code>--prefix=svn/</code>. 这样有助于防止Git用户混淆原声的Git分支和标签。</p>\n<h4 id=\"使用SVN自定义库结构初始化\"><a href=\"#使用SVN自定义库结构初始化\" class=\"headerlink\" title=\"使用SVN自定义库结构初始化\"></a>使用SVN自定义库结构初始化</h4><p>使用非标准的svn layout 来新建svn库，即可以根据自己喜好来自定义分支，标签目录：<br><figure class=\"highlight bash\"><figcaption><span>非标准化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git svn init SVN_URL -T Trunk -b Branches -t Tags --prefix=svn/</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"查看配置信息\"><a href=\"#查看配置信息\" class=\"headerlink\" title=\"查看配置信息\"></a>查看配置信息</h3><ol>\n<li><code>review</code>命令<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">review the config</span><br></pre></td></tr></table></figure>\n会有以下信息输出：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn-remote.svn.url=svn://svn.example.com</span><br><span class=\"line\">svn-remote.svn.fetch=some/path/trunk:refs/remotes/svn/trunk</span><br><span class=\"line\">svn-remote.svn.tags=some/path/tags/*:refs/remotes/svn/tags/*</span><br></pre></td></tr></table></figure>\n高级用户可以在执行之前，修改相关配置。</li>\n<li><code>git config</code>命令<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --local --list </span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">core.repositoryformatversion=0</span><br><span class=\"line\">core.filemode=true</span><br><span class=\"line\">core.bare=false</span><br><span class=\"line\">core.logallrefupdates=true</span><br><span class=\"line\">core.ignorecase=true</span><br><span class=\"line\">core.precomposeunicode=true</span><br><span class=\"line\">svn-remote.svn.url=https://huoshuguang@192.168.85.6/svn/PBBReader_Mac</span><br><span class=\"line\">svn-remote.svn.fetch=trunk:refs/remotes/origin/trunk</span><br><span class=\"line\">svn-remote.svn.branches=branches/*:refs/remotes/origin/*</span><br><span class=\"line\">svn-remote.svn.tags=tags/*:refs/remotes/origin/tags/*</span><br><span class=\"line\">remote.PBBReader.url=https://git.oschina.net/huosan/PBBReader.git</span><br><span class=\"line\">remote.PBBReader.fetch=+refs/heads/*:refs/remotes/PBBReader/*</span><br><span class=\"line\">branch.master.remote=PBBReader</span><br><span class=\"line\">branch.master.merge=refs/heads/master</span><br><span class=\"line\">remote.server.url=https://server.local/git/PBBReader.git</span><br><span class=\"line\">remote.server.fetch=+refs/heads/*:refs/remotes/server/*</span><br><span class=\"line\">branch.v34.remote=PBBReader</span><br><span class=\"line\">branch.v34.merge=refs/heads/v28</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"从远程SVN服务器拉取代码到新建的本地存储库\"><a href=\"#从远程SVN服务器拉取代码到新建的本地存储库\" class=\"headerlink\" title=\"从远程SVN服务器拉取代码到新建的本地存储库\"></a>从远程SVN服务器拉取代码到新建的本地存储库</h3><figure class=\"highlight bash\"><figcaption><span>拉取</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git svn fetch</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看本地库状态\"><a href=\"#查看本地库状态\" class=\"headerlink\" title=\"查看本地库状态\"></a>查看本地库状态</h2><h3 id=\"status\"><a href=\"#status\" class=\"headerlink\" title=\"status\"></a>status</h3><figure class=\"highlight bash\"><figcaption><span>status</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight bash\"><figcaption><span>内容</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"查看分支信息\"><a href=\"#查看分支信息\" class=\"headerlink\" title=\"查看分支信息\"></a>查看分支信息</h3><figure class=\"highlight bash\"><figcaption><span>branch</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -a</span><br></pre></td></tr></table></figure>\n<p>输出:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* master</span><br><span class=\"line\">remotes/svn/tags/0.1.0</span><br><span class=\"line\">remotes/svn/trunk</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意：SVN标记和分支（在这种情况下，没有任何分支机构）仅作为远程引用存在。</p>\n</blockquote>\n<h2 id=\"SVN分支和标签转为本地git仓库中的标签和分支\"><a href=\"#SVN分支和标签转为本地git仓库中的标签和分支\" class=\"headerlink\" title=\"SVN分支和标签转为本地git仓库中的标签和分支\"></a>SVN分支和标签转为本地git仓库中的标签和分支</h2><h3 id=\"SVN分支迁移\"><a href=\"#SVN分支迁移\" class=\"headerlink\" title=\"SVN分支迁移\"></a>SVN分支迁移</h3><p>把远程svn分支转换为本地git仓库中的分支：<br><figure class=\"highlight bash\"><figcaption><span>分支转分支</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> branch <span class=\"keyword\">in</span> `git branch -r | grep <span class=\"string\">\"branches/\"</span> | sed <span class=\"string\">'s/ branches\\///'</span>`; <span class=\"keyword\">do</span></span><br><span class=\"line\">git branch <span class=\"variable\">$branch</span> refs/remotes/<span class=\"variable\">$branch</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"SVN标签迁移\"><a href=\"#SVN标签迁移\" class=\"headerlink\" title=\"SVN标签迁移\"></a>SVN标签迁移</h3><ol>\n<li>把远程svn标签转换为本地git仓库中的标签 :<figure class=\"highlight bash\"><figcaption><span>tags转换tags</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> tag <span class=\"keyword\">in</span> `git branch -r | grep <span class=\"string\">\"tags/\"</span> | sed <span class=\"string\">'s/ tags\\///'</span>`; <span class=\"keyword\">do</span></span><br><span class=\"line\">git tag -a -m<span class=\"string\">\"Converting SVN tags\"</span> <span class=\"variable\">$tag</span> refs/remotes/<span class=\"variable\">$tag</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"SVN标签转为本地git分支\"><a href=\"#SVN标签转为本地git分支\" class=\"headerlink\" title=\"SVN标签转为本地git分支\"></a>SVN标签转为本地git分支</h3><ol>\n<li>把远程svn标签转换为本地git仓库中的分支:<figure class=\"highlight bash\"><figcaption><span>标签转分支</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> tag <span class=\"keyword\">in</span> `git branch -r | grep <span class=\"string\">\"tags/\"</span> | sed <span class=\"string\">'s/ tags\\///'</span>`; <span class=\"keyword\">do</span></span><br><span class=\"line\">git branch <span class=\"variable\">$tag</span> refs/remotes/<span class=\"variable\">$tag</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"在本地测试git命令push和clone操作\"><a href=\"#在本地测试git命令push和clone操作\" class=\"headerlink\" title=\"在本地测试git命令push和clone操作\"></a>在本地测试git命令push和clone操作</h2><p>在推送到正式远程库之前，可以通过向本地git库中推送和clone操作。</p>\n<h3 id=\"创建一个临时的git库，用于测试push和clone测试\"><a href=\"#创建一个临时的git库，用于测试push和clone测试\" class=\"headerlink\" title=\"创建一个临时的git库，用于测试push和clone测试\"></a>创建一个临时的git库，用于测试push和clone测试</h3><p>在git中的说法，<code>bare</code>库是一个不存在工作空间备份的库。<br><figure class=\"highlight bash\"><figcaption><span>bare创建</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">mkdir <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"built_in\">test</span></span><br><span class=\"line\">git init --bare</span><br></pre></td></tr></table></figure><br>这样，在<code>~/test</code>就生成了一个<code>bare</code>git库。</p>\n<h3 id=\"push-测试\"><a href=\"#push-测试\" class=\"headerlink\" title=\"push 测试\"></a>push 测试</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~/staging</span><br><span class=\"line\">git remote add <span class=\"built_in\">test</span> `~/<span class=\"built_in\">test</span>`</span><br><span class=\"line\">git push --all <span class=\"built_in\">test</span></span><br><span class=\"line\">git push --tags <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<p>把<code>~/test</code>的放在反引号中，反引号在命令行中会<code>~</code>自动补全为一个绝对路径。如果你给一个绝对路径或URL，可以省略反引号。<br>尽管它的名字，<code>--all</code>选项不推送<code>tags</code>，所以需要对标签单独push操作。</p>\n<h3 id=\"clone-测试\"><a href=\"#clone-测试\" class=\"headerlink\" title=\"clone 测试\"></a>clone 测试</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">mkdir aclone</span><br><span class=\"line\"><span class=\"built_in\">cd</span> aclone</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> ~/<span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<p>There should now be a clone with a working copy in ~/aclone/test.<br>在<code>~/aclone/test</code>目录中将会clone出一个工作空间备份，检查确保一切OK，这样就可以向正式服务器上推送。</p>\n<h3 id=\"Push到正式git库中\"><a href=\"#Push到正式git库中\" class=\"headerlink\" title=\"Push到正式git库中\"></a>Push到正式git库中</h3><p>如果你是正式库服务器（github，coding）的管理员，为本地git库设置一个空的git库。<br>以<code>Unfuddle</code>为例,路径如下：<br><code>git@example.unfuddle.com:example/blah.git</code><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~/staging</span><br><span class=\"line\">git remote add unfuddle REAL_HOST_URL</span><br><span class=\"line\">git push --all unfuddle</span><br><span class=\"line\">git push --tags unfuddle</span><br></pre></td></tr></table></figure><br>在上面的例子中，制定了远程名：<code>unfuddle</code>而不是默认的<code>origin</code>。当然，你可以使用任何你喜欢的名字。</p>\n<h2 id=\"清理操作\"><a href=\"#清理操作\" class=\"headerlink\" title=\"清理操作\"></a>清理操作</h2><h3 id=\"删除临时git库\"><a href=\"#删除临时git库\" class=\"headerlink\" title=\"删除临时git库\"></a>删除临时git库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~/staging</span><br><span class=\"line\">git remote rm <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<p><code>staging</code>库忽略<code>test</code>远程仓库.</p>\n<h3 id=\"清除clone生成的库\"><a href=\"#清除clone生成的库\" class=\"headerlink\" title=\"清除clone生成的库\"></a>清除clone生成的库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">rm -rf aclone</span><br><span class=\"line\">rm -rf <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Either-keep-or-delete-the-staging-repo\"><a href=\"#Either-keep-or-delete-the-staging-repo\" class=\"headerlink\" title=\"Either keep or delete the staging repo\"></a>Either keep or delete the staging repo</h3><ol>\n<li>如果需要Git和SVN之间频繁交互，建议保留<code>staging</code>库这会节省你非常耗时的初始化：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git svn fetch</span><br></pre></td></tr></table></figure></li>\n<li>如果你确信svn是报废的，你可以删除：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">rm -rf staging</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"题外小贴士\"><a href=\"#题外小贴士\" class=\"headerlink\" title=\"题外小贴士\"></a>题外小贴士</h1><p>在局域网内访问server搭建服务器提供的git服务：<br><figure class=\"highlight bash\"><figcaption><span>小贴士</span><a href=\"https://confluence.atlassian.com/fishkb/unable-to-clone-git-repository-due-to-self-signed-certificate-376838977.html\" target=\"_blank\" rel=\"noopener\">SSL证书问题</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://.../git/mupdf.git</span><br><span class=\"line\">错误：fatal: unable to access <span class=\"string\">'https://..../git/mupdf.git/'</span>: SSL certificate problem: Invalid certificate chain</span><br></pre></td></tr></table></figure><br>解决：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global http.sslVerify <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"svn","path":"api/categories/svn.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"git","path":"api/tags/git.json"},{"name":"svn","path":"api/tags/svn.json"},{"name":"git-svn","path":"api/tags/git-svn.json"}]},{"title":"清除git历史记录大文件bfg","slug":"git/清除git历史记录大文件bfg","date":"2015-10-20T11:17:27.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/清除git历史记录大文件bfg.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><ol>\n<li><a href=\"https://search.maven.org/remote_content?g=com.madgag&amp;a=bfg&amp;v=LATEST\" target=\"_blank\" rel=\"noopener\">下载bfg</a> 到本地soft/bfg目录下。</li>\n<li>sudo vi ~/.bash_profile  添加如下：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias bfg=&quot;java -jar ~/Downloads/soft/bfg/bfg.jar&quot;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>cd 到库目录，执行bfg命令： <a href=\"https://rtyley.github.io/bfg-repo-cleaner/\" target=\"_blank\" rel=\"noopener\">bfg官网</a> </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd PBB_SSH所属目录下</span><br><span class=\"line\">$ bfg --delete-folders universal --no-blob-protection  PBB_SSH</span><br><span class=\"line\">$ cd PBB_SSH</span><br><span class=\"line\">$ git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</span><br><span class=\"line\">$ git push</span><br></pre></td></tr></table></figure>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"工具","path":"api/categories/工具.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"git","path":"api/tags/git.json"},{"name":"坑","path":"api/tags/坑.json"}]},{"title":"Mac安装gitLab服务器","slug":"git/Mac安装gitLab服务器","date":"2015-09-27T19:25:38.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/Mac安装gitLab服务器.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"必要配置\"><a href=\"#必要配置\" class=\"headerlink\" title=\"必要配置\"></a>必要配置</h4><pre><code>*创建一个名称为&quot;gitlab&quot;管理员用户，然后再创建一个名称为&quot;gitlab&quot;的群组\n*开启gitlab用户的远程登录\n</code></pre><p>在系统启动界面:<br>隐藏gitlab用户 </p>\n<pre><code>sudo defaults write /Library/Preferences/com.apple.loginwindow HiddenUsersList -array-add gitlab\n</code></pre><p>显示git用户</p>\n<pre><code>sudo defaults delete /Library/Preferences/com.apple.loginwindow HiddenUsersList\n</code></pre><h4 id=\"添加系统账户gitlab\"><a href=\"#添加系统账户gitlab\" class=\"headerlink\" title=\"添加系统账户gitlab\"></a>添加系统账户gitlab</h4><h6 id=\"生成gitlab服务器目录，即用户根目录\"><a href=\"#生成gitlab服务器目录，即用户根目录\" class=\"headerlink\" title=\"生成gitlab服务器目录，即用户根目录\"></a>生成gitlab服务器目录，即用户根目录</h6><p>进入<strong>系统偏好设置…</strong>,在管理<strong>用户与群组</strong>中，添加其他用户，暂时定为：gitlab ，登录密码假设为：gitlab，添加完成后，会自动在/Users目录下，生成用户根目录gitlab.</p>\n<h6 id=\"安装-Gitlab-Shell\"><a href=\"#安装-Gitlab-Shell\" class=\"headerlink\" title=\"安装 Gitlab Shell\"></a>安装 Gitlab Shell</h6><pre><code>cd /Users/gitlab\nsudo -u gitlab git clone https://github.com/gitlabhq/gitlab-shell.git\ncd gitlab-shell\nsudo -u gitlab git checkout v1.9.1\nsudo -u gitlab cp config.yml.example config.yml\n</code></pre><p>打开 config.yml,然后进行编辑<br>设置  gitlab_url. 把 gitlab.example.com 替换成你自己的域名 （如果本地就不用了）<br>把所有的/home 替换成 /Users</p>\n<pre><code>sudo -u gitlab sed -i &quot;&quot; &quot;s/\\/home\\//\\/Users\\//g&quot; config.yml\nsudo -u gitlab sed -i &quot;&quot; &quot;s/\\/usr\\/bin\\/redis-cli/\\/usr\\/local\\/bin\\/redis-cli/&quot; config.yml\n</code></pre><p>然后执行安装脚本：<code>sudo -u gitlab -H ./bin/install</code>  <strong>//需在gitlab-shell目录下载执行</strong></p>\n<h6 id=\"安装gitlab\"><a href=\"#安装gitlab\" class=\"headerlink\" title=\"安装gitlab\"></a>安装gitlab</h6><p>先下载gitlab</p>\n<pre><code>cd /Users/gitlab\nsudo -u gitlab git clone https://github.com/gitlabhq/gitlabhq.git\ncd gitlab\nsudo -u gitlab git checkout 6-7-stable\n</code></pre><p>配置gitlab</p>\n<pre><code>sudo -u gitlab cp config/gitlab.yml.example config/gitlab.yml\nsudo -u gitlab sed -i &quot;&quot; &quot;s/\\/usr\\/bin\\/git/\\/usr\\/local\\/bin\\/git/g&quot; config/gitlab.yml\nsudo -u gitlab sed -i &quot;&quot; &quot;s/\\/home/\\/Users/g&quot; config/gitlab.yml\nsudo -u gitlab sed -i &quot;&quot; &quot;s/localhost/domain.com/g&quot; config/gitlab.yml\n</code></pre><p>配置MySQL数据库，创建gitlab用户，数据库，和gitlab用户的管理权限</p>\n<pre><code># Login to MySQL\n$ mysql -u root -p\n\n# Create the GitLab production database\nmysql&gt; CREATE DATABASE IF NOT EXISTS `gitlabhq_production` DEFAULT CHARACTER SET `utf8` COLLATE `utf8_unicode_ci`;\n\n# Create the MySQL User change $password to a real password\nmysql&gt; CREATE USER &apos;gitlab&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;$password&apos;;\n\n# Grant proper permissions to the MySQL User\nmysql&gt; GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER ON `gitlabhq_production`.* TO &apos;gitlab&apos;@&apos;localhost&apos;;\n</code></pre><h6 id=\"安装-Gitolite帮助管理git内部用户\"><a href=\"#安装-Gitolite帮助管理git内部用户\" class=\"headerlink\" title=\"安装 Gitolite帮助管理git内部用户\"></a>安装 Gitolite帮助管理git内部用户</h6><p>克隆gitlab的gitolite分支源代码：</p>\n<pre><code>sudo -H -u gitlab git clone -b gl-v304 https://github.com/gitlabhq/gitolite.git /Users/gitlab/gitolite\n</code></pre><p>安装：</p>\n<pre><code>cd /Users/gitlab\nsudo -u gitlab -H mkdir bin\nsudo -u gitlab sh -c &apos;echo -e &quot;PATH=\\$PATH:/Users/gitlab/bin\\nexport PATH&quot; &gt;&gt; /Users/gitlab/.profile&apos;\nsudo -u gitlab sh -c &apos;gitolite/install -ln /Users/gitlab/bin&apos;\n\nsudo cp ~/.ssh/id_rsa.pub /Users/gitlab/gitlab.pub\nsudo chmod 0444 /Users/gitlab/gitlab.pub\n\nsudo -u gitlab -H sh -c &quot;PATH=/Users/gitlab/bin:$PATH; gitolite setup -pk /Users/gitlab/gitlab.pub&quot;\n</code></pre><p>为 Git 创建用户：    </p>\n<pre><code>sudo adduser \\\n  --system \\\n  --shell /bin/sh \\\n  --gecos &apos;git version control&apos; \\\n  --group \\\n  --disabled-password \\\n  --home /home/git \\\n  git\n</code></pre><p>若干问题解决办法：<a href=\"http://www.cnblogs.com/whj198579/archive/2013/04/09/3009350.html\" target=\"_blank\" rel=\"noopener\">Mac搭建Git服务器—开启SSH</a></p>\n<pre><code>Cloning into &apos;/tmp/gitolite-admin&apos;...\nssh: connect to host localhost port 22: Connection refused\nfatal: Could not read from remote repository.\n</code></pre><p>SSH无密码登陆设置：</p>\n<pre><code>$ cd /etc\n$ chmod 666 sshd_config\n$ vim sshd_config\n\n#PermitRootLogin yes  改为：PermitRootLogin no\n#UsePAM yes             改为: UsePAM no\n</code></pre><p>Remove the # from the following</p>\n<pre><code>#RSAAuthentication yes\n#PubkeyAuthentication yes\n#AuthorizedKeysFile     .ssh/authorized_keys    \n#PasswordAuthentication no\n#PermitEmptyPasswords no\n</code></pre>","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"gitLab","path":"api/categories/gitLab.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"git","path":"api/tags/git.json"},{"name":"gitLab","path":"api/tags/gitLab.json"}]},{"title":"Git中的储藏工具stash","slug":"git/Git中的储藏工具stash","date":"2015-01-19T19:57:04.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/Git中的储藏工具stash.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><ol>\n<li><a href=\"#Stashing\">Stashing</a></li>\n<li><a href=\"#work\">储藏工作</a></li>\n<li><a href=\"#apply\">应用储藏</a></li>\n<li><a href=\"#applyIndex\">被暂存的文件重新暂存</a></li>\n<li><a href=\"#drop\">应用后，移除储藏的内容</a></li>\n<li><a href=\"#unapply\">取消储藏(Un-applying a Stash)</a></li>\n<li><a href=\"#stash-unapply\">新建stash-unapply别名</a></li>\n<li><a href=\"#stashBranch\">从储藏中创建分支</a></li>\n</ol>\n<h3 id=\"Git工具-储藏（Stashing）git\"><a href=\"#Git工具-储藏（Stashing）git\" class=\"headerlink\" title=\"Git工具 - 储藏（Stashing）git\"></a><a name=\"Stashing\">Git工具 - 储藏（Stashing）</a>git</h3><hr>\n<p><a href=\"https://git-scm.com/book/zh/v2/Git-工具-储藏与清理\" target=\"_blank\" rel=\"noopener\">原文</a><br>场景：当项目中某一部分正在编码中，突然接到新任务，又必须换至其他分支去完成。</p>\n<p>问题：你不想提交进行了一半的工作，否则以后你无法回到这个工作点。</p>\n<p>解决：<strong><font color=\"red\">git stash </font></strong>命令。</p>\n<p>“Stashing”可以获取工作目录的中间状态，即：将修改过的被追踪的文件和暂存的变更，保存到一个未完结变更的堆栈中，随时可以重新应用。</p>\n<h3 id=\"储藏工作\"><a href=\"#储藏工作\" class=\"headerlink\" title=\"储藏工作\"></a><a name=\"work\">储藏工作</a></h3><hr>\n<ol>\n<li>进入项目目录，修改某个文件，有可能还暂存其中的一个变更。</li>\n<li><strong><font color=\"red\">git status </font></strong>命令,查看中间状态：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\"># Changes to be committed:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   index.html</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   lib/simplegit.rb</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure></li>\n<li>切换分支，但不提交step 1 中的变更，所以储藏这些变更。<br>执行<strong><font color=\"red\">git stash </font></strong>命令，往堆栈中推送一个新的储藏：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash</span><br><span class=\"line\">Saved working directory and index state \\</span><br><span class=\"line\">  <span class=\"string\">\"WIP on master: 049d078 added the index file\"</span></span><br><span class=\"line\">HEAD is now at 049d078 added the index file</span><br><span class=\"line\">(To restore them <span class=\"built_in\">type</span> <span class=\"string\">\"git stash apply\"</span>)</span><br></pre></td></tr></table></figure></li>\n<li>执行step 2查看目录库，中间状态就不见了：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\"><span class=\"comment\">#######On branch master</span></span><br><span class=\"line\">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>\n这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。</li>\n<li>使用<strong><font color=\"red\">git stash list</font></strong>要查看现有的储藏：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash list</span><br><span class=\"line\">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class=\"line\">stash@&#123;1&#125;: WIP on master: c264051 Revert <span class=\"string\">\"added file_size\"</span></span><br><span class=\"line\">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to <span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n在这个案例中，之前已经进行了两次储藏，所以你可以访问到三个不同的储藏。<h3 id=\"应用储藏\"><a href=\"#应用储藏\" class=\"headerlink\" title=\"应用储藏\"></a><a name=\"apply\">应用储藏</a></h3></li>\n</ol>\n<hr>\n<p>执行<strong><font color=\"red\">git stash apply</font></strong>命令, 可以重新应用最近的一次储藏；<br>执行<strong><font color=\"red\">git stash apply stash@{2}</font></strong>命令，即通过指定储藏的名字，来应用更早的储藏。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash apply</span><br><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   index.html</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   lib/simplegit.rb</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure><br><a id=\"more\"></a><br>可以看到 Git 重新修改了你所储藏的那些当时尚未提交的文件。在这个案例里，你尝试应用储藏的工作目录是干净的，并且属于同一分支；但是一个干净的工作目录和应用到相同的分支上并不是应用储藏的必要条件。你可以在其中一个分支上保留一份储藏，随后切换到另外一个分支，再重新应用这些变更。在工作目录里包含已修改和未提交的文件时，你也可以应用储藏——Git 会给出归并冲突如果有任何变更无法干净地被应用。</p>\n<h3 id=\"被暂存的文件重新暂存\"><a href=\"#被暂存的文件重新暂存\" class=\"headerlink\" title=\"被暂存的文件重新暂存\"></a><a name=\"applyIndex\">被暂存的文件重新暂存</a></h3><hr>\n<p>执行<strong><font color=\"red\">git stash apply</font></strong>命令,虽然对文件的变更被重新应用，但是被暂存的文件没有重新被暂存。<br>执行<strong><font color=\"red\">git stash apply –index</font></strong>命令,即可让被暂存的文件重新暂存。<br><strong>–index</strong>选项告诉命令重新应用被暂存的变更：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash apply --index</span><br><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\"># Changes to be committed:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   index.html</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   lib/simplegit.rb</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"应用后，移除储藏的内容\"><a href=\"#应用后，移除储藏的内容\" class=\"headerlink\" title=\"应用后，移除储藏的内容\"></a><a name=\"drop\">应用后，移除储藏的内容</a></h3><hr>\n<p><strong>apply </strong>选项只尝试应用储藏的工作——储藏的内容仍然在栈上。<br>执行<strong><font color=\"red\">git stash drop 储藏的名字</font></strong>命令，，即可从栈中彻底移除储藏内容：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash list</span><br><span class=\"line\">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class=\"line\">stash@&#123;1&#125;: WIP on master: c264051 Revert <span class=\"string\">\"added file_size\"</span></span><br><span class=\"line\">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to <span class=\"built_in\">log</span></span><br><span class=\"line\">$ git stash drop stash@&#123;0&#125;</span><br><span class=\"line\">Dropped stash@&#123;0&#125; (364e91f3f268f0900bc3ee613f9f733e82aaed43)</span><br></pre></td></tr></table></figure><br>你也可以运行 <strong><font color=\"red\">git stash pop</font></strong>命令，来重新应用储藏，同时立刻将其从堆栈中移走。</p>\n<h3 id=\"取消储藏-Un-applying-a-Stash\"><a href=\"#取消储藏-Un-applying-a-Stash\" class=\"headerlink\" title=\"取消储藏(Un-applying a Stash)\"></a><a name=\"unapply\">取消储藏(Un-applying a Stash)</a></h3><hr>\n<p>在某些情况下，重新应用了之前的储藏的变更，进行了一些其他的修改后，又想要取消之前所应用储藏的修改。<br>Git没有提供类似于 <strong><font color=\"red\">stash unapply</font></strong>的命令，但是可以通过取消该储藏的补丁达到同样的效果：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash show -p stash@&#123;0&#125; | git apply -R</span><br></pre></td></tr></table></figure><br>同样的，如果你沒有指定具体的某个储藏，Git 会选择最近的储藏：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash show -p | git apply -R</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"新建stash-unapply别名\"><a href=\"#新建stash-unapply别名\" class=\"headerlink\" title=\"新建stash-unapply别名\"></a><a name=\"stash-unapply\">新建stash-unapply别名</a></h4><hr>\n<p>你可能会想要新建一个別名，在你的 Git 里增加一个<strong><font color=\"red\">stash-unapply</font></strong> 命，这样更有效率。例如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global alias.stash-unapply <span class=\"string\">'!git stash show -p | git apply -R'</span></span><br><span class=\"line\">$ git stash apply</span><br><span class=\"line\">$ <span class=\"comment\">#... work work work</span></span><br><span class=\"line\">$ git stash-unapply</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"从储藏中创建分支\"><a href=\"#从储藏中创建分支\" class=\"headerlink\" title=\"从储藏中创建分支\"></a><a name=\"stashBranch\">从储藏中创建分支</a></h3><hr>\n<p>如果你储藏了一些工作，暂时不去理会，然后继续在你储藏工作的分支上工作，你在重新应用工作时可能会碰到一些问题。如果尝试应用的变更是针对一个你那之后修改过的文件，你会碰到一个归并冲突并且必须去化解它。如果你想用更方便的方法来重新检验你储藏的变更，你可以运行 git stash branch，这会创建一个新的分支，检出你储藏工作时的所处的提交，重新应用你的工作，如果成功，将会丢弃储藏。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash branch testchanges</span><br><span class=\"line\">Switched to a new branch <span class=\"string\">\"testchanges\"</span></span><br><span class=\"line\"><span class=\"comment\"># On branch testchanges</span></span><br><span class=\"line\"><span class=\"comment\"># Changes to be committed:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   index.html</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   lib/simplegit.rb</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">Dropped refs/stash@&#123;0&#125; (f0dfc4d5dc332d1cee34a634182e168c4efc3359)</span><br></pre></td></tr></table></figure><br>这是一个很棒的捷径来恢复储藏的工作然后在新的分支上继续当时的工作。</p>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"工具","path":"api/categories/工具.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"git","path":"api/tags/git.json"},{"name":"坑","path":"api/tags/坑.json"}]}]}