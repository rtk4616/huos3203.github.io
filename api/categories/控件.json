{"name":"控件","postlist":[{"title":"WKWebView控件和JS脚本传参及交互","slug":"iOS/WKWebView控件和JS脚本传参及交互","date":"2017-07-07T09:54:41.000Z","updated":"2017-09-09T08:07:47.000Z","comments":true,"path":"api/articles/iOS/WKWebView控件和JS脚本传参及交互.json","excerpt":null,"keywords":null,"cover":"http://www.plantuml.com/plantuml/svg/XLPjJzjM5FxkNt55f2O19rAtRnv2cfYg3THr6jloOR3AYI_1O6paE6HexKGfwLBUaa61bVSEA6YZZ0eDQ4B8d_6z3f_w5tQkhvqub6ht0_ZQvzpddESyvznOggLXbEXDuEGFAiwHnRcUllhq6jqu4b9Ojx29Xh2iO5Emoy_g1xlsvGufJf65RQVq36pjyfvTNgGRPL8u4x2kUBP2k9qlvBojaDqJ-iS2FNn5DbUHzpuiXDcNhLaffScPZ2WdCvOffonHPP23SWgBiguRbcofXYvYFJiA7lNZslNgCTdUbYAng7FmX6uy5oEXg5tRf3DxOkJNA9dB-wyxeYH_14zXYEMEkrWeJcMQb0fUAB3tdhZ17O0W-JVEmRndjdDEBelIruQ2nMznofBrj8R5UuO66OhtJ7aKYzsQaLN4BsHBJieP71R6vDI8dCQeJNtGnpXwiVtvDr-rTNPofwwkNmG4oqqPAEziiEvzOElXGqHNtj7JPGW2Dett7IYYAb5LLws4QWsvy5BAq0VLTDPqMPA2fkC66EDnMSlA5kwHn-M-bAcEMU0nEgPXPlwbh2iQDhdNOo4G63-r6Lnt42KGQIo6oDijEdd08et50l29tkyps0G_2nJ4_fc61bYeFNlRwq3gZSo3YVjvVnYfUrntvqVWMaYz_MIN9bbHE3ltSIO3rVEPqHd5jnWpC8zEBoJsDn2MWZMS1juXiDiEzkAAnUpABdGHZypZpqEvbIT9KHNG8LR7SSkn7uaYuzfuv7271ZBTchwUt24l3_sojQghpyYQAIof-Z387eh-dGfC31hcVLdLNUKzqBK9wJCF5qhYwzuV7QWfUHGoiHBK_N26smI5T9sVTwh7K9s0Z4PRICj8mncwi4-AkwGqtx0PCp8-2p2LwF99CwHmo5tk0DhxZPuUDhlU6qWRVvEJAxjQSruSIZ1gCBAhB0e9SVkGlyA2-zKonf0n2DeMwB_5-a41sBClAdPrYSqzn4oudQccXoncoVi8XTAcF240Y5rU81k7dFf4BrqzUtyvT_tdD9dPgLUhFYlmhdvynSXO_vsKZdhwUDBq8a_cbsyW9GtBCaOP56y4wMwS5alsrNhZLByUT6dUhcxqwv_48O87tVR56tfU0HCEugnD1r7UNwxvVeqlG7g__caSQ27vVQvR8BA563y32TLFdaAwVFxrwoYdwegHY-TmSaIruZVA6W-KDHuePuJNCmh-_Cc-AAiAlpE08r9Tegli9k9Od4nkoEa3SpshQJTAudUc56mzo9VElgQ5lrefPvLOE2V5bPu-kFIk9nU138v09Y_xTI2Ih6y1F939xUh_x3U-mvbUel6aeKo07BlSvSelV-gSLiZw5IdEr6jR32qeq2vlkRSHiwpFJ3bJxvoZrrBaKLVKgHpGvpKnqXvbLrIXXCI84Qq_MOETY4Z-pAwiXCIVnSTYX_WJWkETSirrZSMYv9Zj42GMYSUZzPThi0iBYTwsksseFVOZQzI1668xBbt96nDkKgYpXKiTQQe-WaAv8HNaU4FKRZVd-Eq1h84SeIXqyvLTEMjAMF3wWo6dJOnrmFPqJ7SkIEqfZ0Dm05o1Zp9an3GyQFbnDlJMQCSFP0--YTx_TUCI2lZmADp0abeM3pHbG_QccV9TdP322UGMSFEjKEUZE4TCQZ0N1-8mCoJKQ9ecW1yO6n0G6SzIuZtMEDN_5JPe06cca3GciCcKiZNBgEHl_mC0","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"WebKit简介\"><a href=\"#WebKit简介\" class=\"headerlink\" title=\"WebKit简介\"></a>WebKit简介</h3><div id=\"badge-container-huos3203-WKWebView-JS-d03bc0e\" class=\"hexo-github\" style=\"width: =\"></div>\n<script src=\"/hexo-github/badge.js\"></script>\n<script type=\"text/javascript\">\n  loadStyle(\"/hexo-github/style.css\");\n  loadStyle(\"/hexo-github/octicons/octicons.css\");\n  new Badge(\"#badge-container-huos3203-WKWebView-JS-d03bc0e\", \"huos3203\", \"WKWebView-JS\", \"d03bc0e\", false);\n</script>\n\n<p>自iOS8 以后，苹果推出了新框架 WebKit，提供了替换 UIWebView 的组件 WKWebView。各种 UIWebView 的性能问题没有了，速度更快了，占用内存少了，体验更好了，下面列举一些其它的优势:<br>1、在性能、稳定性、功能方面有很大提升（加载速度，内存的提升谁用谁知道）<br>2、更多的支持 HTML5 的特性<br>3、官方宣称的高达60fps的滚动刷新率以及内置手势<br>4、Safari 相同的 JavaScript 引擎<br>5、将 UIWebViewDelegate 与 UIWebView 拆分成了14类与3个协议，包含该更细节功能的实现。</p>\n<p><img src=\"http://www.plantuml.com/plantuml/svg/XLPjJzjM5FxkNt55f2O19rAtRnv2cfYg3THr6jloOR3AYI_1O6paE6HexKGfwLBUaa61bVSEA6YZZ0eDQ4B8d_6z3f_w5tQkhvqub6ht0_ZQvzpddESyvznOggLXbEXDuEGFAiwHnRcUllhq6jqu4b9Ojx29Xh2iO5Emoy_g1xlsvGufJf65RQVq36pjyfvTNgGRPL8u4x2kUBP2k9qlvBojaDqJ-iS2FNn5DbUHzpuiXDcNhLaffScPZ2WdCvOffonHPP23SWgBiguRbcofXYvYFJiA7lNZslNgCTdUbYAng7FmX6uy5oEXg5tRf3DxOkJNA9dB-wyxeYH_14zXYEMEkrWeJcMQb0fUAB3tdhZ17O0W-JVEmRndjdDEBelIruQ2nMznofBrj8R5UuO66OhtJ7aKYzsQaLN4BsHBJieP71R6vDI8dCQeJNtGnpXwiVtvDr-rTNPofwwkNmG4oqqPAEziiEvzOElXGqHNtj7JPGW2Dett7IYYAb5LLws4QWsvy5BAq0VLTDPqMPA2fkC66EDnMSlA5kwHn-M-bAcEMU0nEgPXPlwbh2iQDhdNOo4G63-r6Lnt42KGQIo6oDijEdd08et50l29tkyps0G_2nJ4_fc61bYeFNlRwq3gZSo3YVjvVnYfUrntvqVWMaYz_MIN9bbHE3ltSIO3rVEPqHd5jnWpC8zEBoJsDn2MWZMS1juXiDiEzkAAnUpABdGHZypZpqEvbIT9KHNG8LR7SSkn7uaYuzfuv7271ZBTchwUt24l3_sojQghpyYQAIof-Z387eh-dGfC31hcVLdLNUKzqBK9wJCF5qhYwzuV7QWfUHGoiHBK_N26smI5T9sVTwh7K9s0Z4PRICj8mncwi4-AkwGqtx0PCp8-2p2LwF99CwHmo5tk0DhxZPuUDhlU6qWRVvEJAxjQSruSIZ1gCBAhB0e9SVkGlyA2-zKonf0n2DeMwB_5-a41sBClAdPrYSqzn4oudQccXoncoVi8XTAcF240Y5rU81k7dFf4BrqzUtyvT_tdD9dPgLUhFYlmhdvynSXO_vsKZdhwUDBq8a_cbsyW9GtBCaOP56y4wMwS5alsrNhZLByUT6dUhcxqwv_48O87tVR56tfU0HCEugnD1r7UNwxvVeqlG7g__caSQ27vVQvR8BA563y32TLFdaAwVFxrwoYdwegHY-TmSaIruZVA6W-KDHuePuJNCmh-_Cc-AAiAlpE08r9Tegli9k9Od4nkoEa3SpshQJTAudUc56mzo9VElgQ5lrefPvLOE2V5bPu-kFIk9nU138v09Y_xTI2Ih6y1F939xUh_x3U-mvbUel6aeKo07BlSvSelV-gSLiZw5IdEr6jR32qeq2vlkRSHiwpFJ3bJxvoZrrBaKLVKgHpGvpKnqXvbLrIXXCI84Qq_MOETY4Z-pAwiXCIVnSTYX_WJWkETSirrZSMYv9Zj42GMYSUZzPThi0iBYTwsksseFVOZQzI1668xBbt96nDkKgYpXKiTQQe-WaAv8HNaU4FKRZVd-Eq1h84SeIXqyvLTEMjAMF3wWo6dJOnrmFPqJ7SkIEqfZ0Dm05o1Zp9an3GyQFbnDlJMQCSFP0--YTx_TUCI2lZmADp0abeM3pHbG_QccV9TdP322UGMSFEjKEUZE4TCQZ0N1-8mCoJKQ9ecW1yO6n0G6SzIuZtMEDN_5JPe06cca3GciCcKiZNBgEHl_mC0\"></p>\n<h4 id=\"添加监听代理和JS接口\"><a href=\"#添加监听代理和JS接口\" class=\"headerlink\" title=\"添加监听代理和JS接口\"></a>添加监听代理和JS接口</h4><p>在OC中添加监听的接口清单：以JS脚本的接口<code>showMobile</code>为例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">WKWebViewConfiguration</span> *config = [[<span class=\"built_in\">WKWebViewConfiguration</span> alloc] init];</span><br><span class=\"line\"><span class=\"built_in\">WKUserContentController</span> *userCC = config.userContentController;</span><br><span class=\"line\"><span class=\"comment\">//MARK:在OC中添加监听的接口清单：JS脚本的接口名</span></span><br><span class=\"line\">[userCC addScriptMessageHandler:<span class=\"keyword\">self</span> name:<span class=\"string\">@\"showMobile\"</span>];</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"设置WKUserContentController的代理\"><a href=\"#设置WKUserContentController的代理\" class=\"headerlink\" title=\"设置WKUserContentController的代理\"></a>设置WKUserContentController的代理</h4><ol>\n<li><p>设置代理类遵守<code>WKScriptMessageHandler</code>协议</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> () &lt;<span class=\"title\">WKScriptMessageHandler</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注册对JS接口监听，注入代理类</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[userCC addScriptMessageHandler:<span class=\"keyword\">self</span> name:<span class=\"string\">@\"showMobile\"</span>];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>实现<code>WKUserContentController</code>代理的回调方法,响应JS接口事件</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)userContentController:(<span class=\"built_in\">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class=\"built_in\">WKScriptMessage</span> *)message &#123;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,message.body);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"JS脚本接口\"><a href=\"#JS脚本接口\" class=\"headerlink\" title=\"JS脚本接口\"></a>JS脚本接口</h4><p>js接口声明格式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.webkit.messageHandlers.接口名.postMessage(<span class=\"string\">'参数'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>接口名: 在WKWebView中，当JS执行该接口时，OC会拦截预先监听的接口，并处理相关事件。</p>\n<p>参数：object类型，多个参数时需要封装为集合类型来实现多参传递。</p>\n<p>当OC拦截到该接口时，可以在<code>WKScriptMessageHandler</code>回调方法中的<code>WKScriptMessage</code>参数实例中获取该参数值: <code>message.body</code>。</p>\n<p>三个例子：</p>\n<ol>\n<li><p>JS无参调用OC<br><br>当无参调用OC时，参数必须为<code>null</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.webkit.messageHandlers.showMobile.postMessage(<span class=\"literal\">null</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>JS传参调用OC<br><br>传递单个参数时，直接写入即可，例如：<code>xiao黄</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.webkit.messageHandlers.showName.postMessage(<span class=\"string\">'xiao黄'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>传递多个参数时，需要封装为集合类型实现多参传递。<br><br>例如:当传递一个电话，一条信息，需要封装为<code>[&#39;13300001111&#39;,&#39;Go Climbing This Weekend !!!&#39;]</code><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.webkit.messageHandlers.showSendMsg.postMessage([<span class=\"string\">'13300001111'</span>, <span class=\"string\">'Go Climbing This Weekend !!!'</span>])</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"iOS原生API调用JS脚本\"><a href=\"#iOS原生API调用JS脚本\" class=\"headerlink\" title=\"iOS原生API调用JS脚本\"></a>iOS原生API调用JS脚本</h3><p>在网页加载完成之后调用JS代码才会执行，因为这个时候html页面已经注入到webView中并且可以响应到对应方法。<br><br>例如调用JS函数<code>alertMobile()</code>：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span>.wkWebView evaluateJavaScript:<span class=\"string\">@\"alertMobile()\"</span> completionHandler:^(<span class=\"keyword\">id</span> _Nullable response, <span class=\"built_in\">NSError</span> * _Nullable error) &#123;</span><br><span class=\"line\"><span class=\"comment\">//TODO</span></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ %@\"</span>,response,error);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"在OC中为JS定义属性-函数\"><a href=\"#在OC中为JS定义属性-函数\" class=\"headerlink\" title=\"在OC中为JS定义属性/函数\"></a>在OC中为JS定义属性/函数</h4><ul>\n<li>当注入的类型字符串类型时，必须用<code>&#39;&#39;</code>括起来。<br></li>\n<li>OC注入的参数为全局属性，在html中的JS脚本可以直接调用属性名来获取值。<br></li>\n</ul>\n<p>通过NSString形式，编写JS脚本，通过以下两种方式注入网页</p>\n<p>方式一：在初始化<code>WKWebView</code>时，通过配置<code>WKWebViewConfiguration&gt;userContentController</code>注入JS脚本  。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//MARK:向网页中注入JS脚本例如，参数/函数等</span></span><br><span class=\"line\"><span class=\"built_in\">WKUserScript</span> *script = [[<span class=\"built_in\">WKUserScript</span> alloc] initWithSource:<span class=\"string\">@\"var number=0;\"</span></span><br><span class=\"line\">injectionTime:<span class=\"built_in\">WKUserScriptInjectionTimeAtDocumentStart</span></span><br><span class=\"line\">forMainFrameOnly:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"><span class=\"built_in\">WKUserContentController</span> *userCC = config.userContentController;</span><br><span class=\"line\">[userCC addUserScript:script];</span><br></pre></td></tr></table></figure></p>\n<p>方式二：使用WKWebView实例方法<code>evaluateJavaScript</code>动态注入JS脚本</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span>.wkWebView evaluateJavaScript:<span class=\"string\">@\"var number=0;\"</span> completionHandler:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n<h4 id=\"iOS原生API调用JS函数\"><a href=\"#iOS原生API调用JS函数\" class=\"headerlink\" title=\"iOS原生API调用JS函数\"></a>iOS原生API调用JS函数</h4><p>使用WKWebView实例方法<code>evaluateJavaScript</code>动态调用JS函数<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span>.wkWebView evaluateJavaScript:<span class=\"string\">@\"alertSendMsg('18870707070','下午好！')\"</span> completionHandler:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"控件","path":"api/categories/控件.json"}],"tags":[]},{"title":"UIStackView教程：了解Stack View","slug":"iOS/UIStackView教程了解StackView","date":"2017-02-24T18:12:14.000Z","updated":"2017-02-25T14:33:14.000Z","comments":true,"path":"api/articles/iOS/UIStackView教程了解StackView.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><a href=\"http://blog.csdn.net/kmyhy/article/details/50456444\" target=\"_blank\" rel=\"noopener\">原地址</a></p>\n<h2 id=\"UIStackView简单介绍\"><a href=\"#UIStackView简单介绍\" class=\"headerlink\" title=\"UIStackView简单介绍\"></a>UIStackView简单介绍</h2><p>一个Stack View能够将它所含的View以各种方式沿其轴向进行分布，同时也可以将View沿某个方向等距分布，要隐藏<code>Stack View</code>中的视图，你只需要设置该View的<code>Hidden</code>属性为<code>true</code>，剩下的工作Stack View会自己完成。。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0.png?imageMogr2/2/w/800\"><br>坐标（Axis）、间隔（Spacing）、对齐（Alignment）以及分布（Distribution ）等。<br>distribution属性：决定Stack View如何沿它轴向的水平方向摆放它的subview，当属性值是Fill，这表示subview会沿轴向完全占据Stack View。因此，Stack View会拉伸其中一个subview使其填充剩余空间，尤其是水平内容优先级最低的那个，如果所有subview优先级相同，则拉伸第一个subview。<br>Alignment属性：决定了Stack View如何沿它轴向的垂直方向摆放它的subview，对于一个垂直的Stack View，这个属性可以设置为Fill、Leading、Center和Trailing。<br>对于水平的Stack View，这个属性则稍有不同：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack006.png?imageMogr2/2/w/800\"><br>.Top取代了.Leading，.Bottom取代了.Trailing。此外，水平Stack View还多出了两个属性值：.FirstBaseLine和.LastBaseLine。<br>对于水平的Stack View，这个属性则稍有不同：<br>Fill:<br><img title=\"Fill\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack007.png?imageMogr2/2/w/800\"><br>Leading:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack008.png?imageMogr2/2/w/800\"><br>Center:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack009.png?imageMogr2/2/w/800\"><br>Trailing:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack000.png?imageMogr2/2/w/800\"></p>\n<p>布局方式对比<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack01.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"添加一个新的Stack-View\"><a href=\"#添加一个新的Stack-View\" class=\"headerlink\" title=\"添加一个新的Stack View\"></a>添加一个新的Stack View</h3><p>点击故事板画布左下角<code>Auto Layout工具栏</code>中的<code>Stack按钮</code>：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack3.png?imageMogr2/2/w/800\"><br>另一种解散的方法是选中Stack View，然后点击<code>Editor\\Emebed in\\stack view</code>菜单。</p>\n<h3 id=\"解散一个废弃的Stack-View\"><a href=\"#解散一个废弃的Stack-View\" class=\"headerlink\" title=\"解散一个废弃的Stack View\"></a>解散一个废弃的Stack View</h3><p>首先，选定想解散的Stack View。按下<code>Option键</code>，点击<code>Stack 按钮</code>。这将弹出一个上下文菜单，然后点击Unembed：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack001.png?imageMogr2/2/w/800\"><br>另一种解散的方法是选中Stack View，然后点击<code>Editor\\Unemebed</code>菜单。</p>\n<h2 id=\"使用场景描述\"><a href=\"#使用场景描述\" class=\"headerlink\" title=\"使用场景描述\"></a>使用场景描述</h2><p>当APP运行中增加或删除一个<code>view</code>时，需要重新调整邻近<code>view</code>的位置布局。<br>预见困境：</p>\n<ol>\n<li>在故事板中新建一些布局约束连接，以便能够安装或卸载其中的一些约束</li>\n<li>使用第三方库来实现</li>\n<li>根据任务复杂程度完全用代码实现<br>也许这个在视图附近的视图树中的所有View都不需要在运行时改变，但当你将新视图添加到故事板时，仍然要想方设法为它挤出空间来。</li>\n</ol>\n<p><code>UIStackView</code>提供了一个对多个视图进行水平或垂直布局的方法。通过对几个属性进行简单设置，比如对齐、分布和间距，可以让我们让其所包含的视图适应于其有效空间。</p>\n<h2 id=\"实现需求\"><a href=\"#实现需求\" class=\"headerlink\" title=\"实现需求\"></a>实现需求</h2><p>存在着这几方面的问题:</p>\n<h3 id=\"问题一：自适应横竖屏\"><a href=\"#问题一：自适应横竖屏\" class=\"headerlink\" title=\"问题一：自适应横竖屏\"></a>问题一：自适应横竖屏</h3><p>在横屏状态下（command+左箭头旋转为横屏），发现截图中的一排按钮位置无法适应屏幕宽度的变化。这时可以使用<code>UIStackView</code>来帮助实现自动适应横竖屏的效果。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/UIStackView.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"问题二：控件间留白不紧凑\"><a href=\"#问题二：控件间留白不紧凑\" class=\"headerlink\" title=\"问题二：控件间留白不紧凑\"></a>问题二：控件间留白不紧凑</h3><p>点击WEATHER旁边的Hide按钮。隐藏了下面的文本内容后，留下了一大块的空白区域。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/WEATHERhide.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"Storyboard引入界面\"><a href=\"#Storyboard引入界面\" class=\"headerlink\" title=\"Storyboard引入界面\"></a>Storyboard引入界面</h3><p>打开<code>Main.storyboard</code>，找到<code>Spot Info View Controller</code>这个Scene。将这些标签和按钮设为不同的背景色，是为了在运行时效果更直观。就是在故事板中，这也有助于看到<code>Stack View</code>属性的改变导致其内部视图的变化。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack1.png?imageMogr2/2/w/800\"><br>如果想在运行App时看见这些颜色，在<code>SpotInfoViewController</code>的<code>viewDidLoad()</code>方法中将下列语句注释：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 清空标签和按钮的背景色</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> view <span class=\"keyword\">in</span> backgroundColoredViews </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    view.backgroundColor = <span class=\"type\">UIColor</span>.clearColor()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Size类便于使用storyboard\"><a href=\"#Size类便于使用storyboard\" class=\"headerlink\" title=\"Size类便于使用storyboard\"></a>Size类便于使用storyboard</h3><p>在本案例中，故事板中Scene大小不是默认<code>600x600</code>，在这里Simulated Metrics下的Size属性被设置成iPhone 4-inch。Simulated Metrics属性在运行时并没有任何影响——不同设备上视图的大小仍然会自动改变。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/05-simulated-metrics-iphone-4-inch_639x173.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"创建水平UIStackView\"><a href=\"#创建水平UIStackView\" class=\"headerlink\" title=\"创建水平UIStackView\"></a>创建水平<code>UIStackView</code></h2><h3 id=\"按钮模块\"><a href=\"#按钮模块\" class=\"headerlink\" title=\"按钮模块\"></a>按钮模块</h3><ol>\n<li>选中按钮<br>用<code>Command+左键</code>同时选中<code>Spot Info View Controller</code>底下一排的所有按钮：<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack2.png?imageMogr2/2/w/800\"></li>\n<li>Stack按钮添加一个新的Stack View<br>点击故事板画布左下角<code>Auto Layout工具栏</code>中新增的<code>Stack按钮</code>：    </li>\n</ol>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/Stack按钮?imageMogr2/2/w/800\">\n<p>这些按钮被嵌到一个新的Stack View中：</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack4.png?imageMogr2/2/w/800\">\n<h4 id=\"给新的Stack-View添加布局约束\"><a href=\"#给新的Stack-View添加布局约束\" class=\"headerlink\" title=\"给新的Stack View添加布局约束\"></a>给新的Stack View添加布局约束</h4><p>要在故事板选取一个充满了子视图的Stack View还是比较难的，介绍两种选择技巧。<br>3.1 在<code>Outline视图</code>中选取Stack View</p>\n<img title=\"Outline视图\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack5.png?imageMogr2/2/w/800\">\n<p>3.2 Shift+右键调出View树<br>在Stack View 的任意地方按下<code>Shift+右键</code>或者<code>Control+Shift+左键</code>（如果你正在用触控板的话）。这时将弹出一个上下文菜单，列出了位于所点击的地方的View树，你可以在这个菜单中选择Stack View。</p>\n<img title=\"Shift+右键\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack6.png?imageMogr2/2/w/800\">\n<ol>\n<li>自动布局工具栏中的Pin按钮,添加一个约束<img title=\"自动布局工具栏中的Pin按钮\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack7.png?imageMogr2/2/w/800\">\n</li>\n</ol>\n<p>首先勾选Constrain to margins。然后在Stack View四周添加下列约束：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Top</span>: <span class=\"number\">20</span>, <span class=\"type\">Leading</span>: <span class=\"number\">0</span>, <span class=\"type\">Trailing</span>: <span class=\"number\">0</span>, <span class=\"type\">Bottom</span>: <span class=\"number\">0</span></span><br></pre></td></tr></table></figure><br>仔细检查top、leading、trailing、bottom中的数字并确保它们的I型柱都被选中。然后点击Add 4 Constraints：<br><img title=\"Add4Constraints\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack8.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"按钮等间距分布\"><a href=\"#按钮等间距分布\" class=\"headerlink\" title=\"按钮等间距分布\"></a>按钮等间距分布</h4><p>添加约束后，导致第一个按钮被拉伸：<br><img title=\"第一个按钮被拉伸填充所有剩余空间\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack9.png?imageMogr2/2/w/800\"></p>\n<h5 id=\"使用等宽约束的Spacer-View实现\"><a href=\"#使用等宽约束的Spacer-View实现\" class=\"headerlink\" title=\"使用等宽约束的Spacer View实现\"></a>使用等宽约束的<code>Spacer View</code>实现</h5><p>解决这个问题只能使用空白的View来分隔这些按钮，在按钮之间摆放上一些用于分隔空间的 Spacer View。所有的Spacer View都要添加等宽约束，以及许多额外的约束，才能将这些Spacer View布局正确。<br>这看起来如下图所示。为了直观起见，这些Spacer View的背景色设置成了浅灰色：<br><img title=\"SpacerView添加等宽约束实现\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack04.png?imageMogr2/2/w/800\"><br>如果要在运行时添加一个按钮或者隐藏/删除一个按钮时，要想调整这些Spacer View和约束就要命了。</p>\n<h5 id=\"Distribution属性：沿轴向水平分布\"><a href=\"#Distribution属性：沿轴向水平分布\" class=\"headerlink\" title=\"Distribution属性：沿轴向水平分布\"></a><code>Distribution</code>属性：沿轴向水平分布</h5><p>distribution属性：决定Stack View如何将它的subview沿轴向分布，当属性值是Fill，这表示subview会沿轴向完全占据Stack View。因此，Stack View会拉伸其中一个subview使其填充剩余空间，尤其是水平内容优先级最低的那个，如果所有subview优先级相同，则拉伸第一个subview。<br>打开Stack View属性面板。将<code>Distribution</code>属性由<code>Fill</code>修改为<code>Equal Spacing</code>：<br><img title=\"`Fill`修改为`Equal\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack02.png?imageMogr2/2/w/800\"><br>编译运行，点击某个单元格，旋转模拟器（⌘→）。你将看到最下一排按钮现在按照等间距排列了！<br><img title=\"`Distribution`属性值`Equal\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack03.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"Rating版块\"><a href=\"#Rating版块\" class=\"headerlink\" title=\"Rating版块\"></a>Rating版块</h3><p>选中RATING标签，以及旁边的显示为几个星形图标的标签：<br><img title=\"选中RATING标签\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack05.png?imageMogr2/2/w/800\"><br>然后点击Stack按钮将它们嵌到一个Stack View中：<br><img title=\"Stack按钮\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack3.png?imageMogr2/2/w/800\"><br><img title=\"RATING标签嵌到一个StackView中\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack06.png?imageMogr2/2/w/800\"><br>然后点击Pin按钮。勾选Constrain to margins，并添加如下约束：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Top</span>: <span class=\"number\">20</span>, <span class=\"type\">Leading</span>: <span class=\"number\">0</span>, <span class=\"type\">Bottom</span>: <span class=\"number\">20</span></span><br></pre></td></tr></table></figure><br><img title=\"添加约束\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack07.png?imageMogr2/2/w/800\"><br>打开属性面板，将间距设置为8：<br><img title=\"间距设置为8\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack08.png?imageMogr2/2/w/800\"><br>你可能会看到一个 Misplaced Views的布局约束警告，同时星星标签会显示将会被拉伸到视图之外：<br><img title=\"MisplacedViews的布局约束警告\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack09.png?imageMogr2/2/w/800\"><br>有时候Xcode会临时提示一些警告，或者显示Stack View的位置不正确，这些警告会在你添加其他约束后消失。你完全可以忽略这些警告。<br>要解决这个警告，我们可以修改一下Stack View的Frame然后又改回，或者临时修改它的一条布局约束。<br>让我们试一下。先将Alignment 属性从Fill修改为Top，然后又改回原来的Fill。你将看到这下星星标签显示正常了：<br><img title=\"布局约束警告消失\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack00.png?imageMogr2/2/w/800\"><br>编译运行，进行测试</p>\n<h2 id=\"创建垂直的Stack-View\"><a href=\"#创建垂直的Stack-View\" class=\"headerlink\" title=\"创建垂直的Stack View\"></a>创建垂直的Stack View</h2><p>Xcode会自动根据这两者的位置推断出这将是一个垂直的Stack View，Stack View没有添加任何约束时，会自动适应了两个标签中的最宽的一个的宽度。</p>\n<h3 id=\"WHY-VISIT模块\"><a href=\"#WHY-VISIT模块\" class=\"headerlink\" title=\"WHY VISIT模块\"></a>WHY VISIT模块</h3><p>选中WHY VISIT标签及下面的标签,创建一个垂直的Stack View：<br><img title=\"选中WHY\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack002.png?imageMogr2/2/w/800\"><br>点击Stack 按钮将二者嵌到一个Stack View：<br><img title=\"嵌到一个垂直的StackView\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack003.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"添加约束\"><a href=\"#添加约束\" class=\"headerlink\" title=\"添加约束\"></a>添加约束</h4><p>默认，约束是相对于距离最近的对象，对于Bottom约束来说就是距离它15像素的Hide按钮。但我们其实是想让约束相对于WEATHER标签。<br>选中Stack View，点击Pin按钮。勾选Constrain to margins，设置Top、Leading、Trainling为0。<br>然后，点击Bottom右边的下拉按钮，从列表中选择WEATHER（curent distance =20）：<br><img title=\"Top、Leading、Trainling为0\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack004.png?imageMogr2/2/w/800\"><br>最后点击Add 4 Constraints按钮。显示结果如下图所示：<br><img title=\"Top、Leading、Trainling为0\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack005.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"alignment属性：轴向的垂直方向\"><a href=\"#alignment属性：轴向的垂直方向\" class=\"headerlink\" title=\"alignment属性：轴向的垂直方向\"></a>alignment属性：轴向的垂直方向</h4><p>Stack View问题，它的右边对齐于View的右边。但是底下的标签仍然是原来的宽度。需要使用alignment属性解决这个问题。<br>当你测试完所有Alignment值的布局效果后，将Alignment修改为Fill：<br><img title=\"Top、Leading、Trainling为0\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0001.png?imageMogr2/2/w/800\"><br>将<code>Alignment</code>设置为<code>Fill</code>，表示所有View将沿与Stack View轴向垂直的方向进行全占式分布。这会让WHY VISIT标签扩展它的宽度到100%.</p>\n<p>如果我们只想让底下的标签将宽度扩展到100%怎么办？</p>\n<p>这个问题现在看来还不是多大的问题，因为两个标签在运行时的背景色都是透明的。但对于Weather版块来说就不同了。</p>\n<p>我们将用另外一个Stack View来说明这个问题。</p>\n<h2 id=\"垂直／水平Stack-View嵌套使用\"><a href=\"#垂直／水平Stack-View嵌套使用\" class=\"headerlink\" title=\"垂直／水平Stack View嵌套使用\"></a>垂直／水平Stack View嵌套使用</h2><h3 id=\"Weather版块\"><a href=\"#Weather版块\" class=\"headerlink\" title=\"Weather版块\"></a>Weather版块</h3><p>在Weather版块相对复杂一些，因为它多了一个Hide按钮。<br>要隐藏<code>Stack View</code>中的视图，你只需要设置该View的<code>Hidden</code>属性为<code>true</code>，剩下的工作Stack View会自己完成。这也是我们解决用户隐藏WEATHER标签下文本的主要思路。<br>一种方法是使用嵌套的Stack View，先将WEATHER标签和Hide按钮嵌到一个水平StackView，再将这个Stack View和标签嵌到一个垂直Stack View。<br><img title=\"垂直/水平StackView嵌套使用\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0002.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"垂直stackView\"><a href=\"#垂直stackView\" class=\"headerlink\" title=\"垂直stackView\"></a>垂直stackView</h4><p>注意Alignment属性负责Stack View轴向垂直的方向上的布局。所以，我们需要将Alignment属性设置为 Bottom：<br><img title=\"垂直/水平StackView嵌套使用\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0003.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"水平StackView中出现按钮拉伸标签的问题\"><a href=\"#水平StackView中出现按钮拉伸标签的问题\" class=\"headerlink\" title=\"水平StackView中出现按钮拉伸标签的问题\"></a>水平StackView中出现按钮拉伸标签的问题</h4><p>注意，WEATHER标签被拉伸为和Hide按钮一样高了。这并不合适，因为这会导致WEATHER标签和下面的文本之间多出了一些空间。<br>正确的方法是让 Hide 按钮不要和 Weather 版块呆在同一个Stack View中，或者任何别的Stack View中。<br>这样，在顶层View中还会保留一个subview，你将为它添加一个相对于WEATHER标签的约束——WEATHER标签嵌在Stack View里的。也就是说，你要为位于Stack View之外的按钮加一个约束，这个约束是相对于Stack View内的一个标签！</p>\n<h4 id=\"垂直stack-View1-嵌套WEATHER标签和标签\"><a href=\"#垂直stack-View1-嵌套WEATHER标签和标签\" class=\"headerlink\" title=\"垂直stack View1:嵌套WEATHER标签和标签\"></a>垂直stack View1:嵌套WEATHER标签和标签</h4><p>选中WEATHER标签和标签：<br><img title=\"选中嵌套标签\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0004.png?imageMogr2/2/w/800\"><br>点击 Stack 按钮：<br><img title=\"Stack按钮创建stackView\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0005.png?imageMogr2/2/w/800\"><br>点击Pin 按钮，勾上Constrain to margins，然后添加如下约束：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Top</span>: <span class=\"number\">20</span>, <span class=\"type\">Leading</span>: <span class=\"number\">0</span>, <span class=\"type\">Trailing</span>: <span class=\"number\">0</span>, <span class=\"type\">Bottom</span>: <span class=\"number\">20</span></span><br></pre></td></tr></table></figure><br>将Stack View的Alignment设为Fill：<br><img title=\"Alignment设为Fill\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0006.png?imageMogr2/2/w/800\"><br>我们需要在 Hide 按钮左边和WEATHER标签右边加一条约束，这样WEATHER 标签的宽度就不会拉满整个Stack View了。</p>\n<p>当然，底下的标签宽度还是需要100%占满的。</p>\n<p>我们是通过将WEATHER标签嵌到一个垂直Stack View 来实现的。注意，垂直Stack View的Alignment 属性可以设置为 .Leading，如果将Stack View拉宽，则它里面的View 会保持左对齐。</p>\n<h4 id=\"垂直stack-View2-仅嵌套WEATHER标签\"><a href=\"#垂直stack-View2-仅嵌套WEATHER标签\" class=\"headerlink\" title=\"垂直stack View2: 仅嵌套WEATHER标签\"></a>垂直stack View2: 仅嵌套WEATHER标签</h4><p>从Outline视图中选取WEATHER 标签，或者用Control+Shift+左键的方式选取WEATHER 标签：<br><img title=\"Stack按钮创建stackView\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0006.png?imageMogr2/2/w/800\"><br>然后点击Stack 按钮：<br><img title=\"Stack按钮创建stackView\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0007.png?imageMogr2/2/w/800\"><br>确保Axis 为 Vertical 的情况下，将Alignment 设置为 Leading：<br><img title=\"Alignment设置为Leading\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0008.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"按钮和WEATHER标签两个约束\"><a href=\"#按钮和WEATHER标签两个约束\" class=\"headerlink\" title=\"按钮和WEATHER标签两个约束\"></a>按钮和WEATHER标签两个约束</h4><p>从Hide 按钮用右键拖一条新的约束到 WEATHER 标签：<br><img title=\"AddConstraints\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0009.png?imageMogr2/2/w/800\"><br>按下Shift键，同时选择Horizontal Spacing 和 Baseline。然后点击 Add Constraints：<br><img title=\"AddConstraints\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0000.png?imageMogr2/2/w/800\"><br>编译运行。Hide 按钮的位置现在对了，而且当按下Hide 按钮，位于Stack View 中的标签被隐藏后，下面的视图也会被调整——根本不需要我们进行手动调整。<br><img title=\"编译运行\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack010.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"顶级-Stack-View\"><a href=\"#顶级-Stack-View\" class=\"headerlink\" title=\"顶级 Stack View\"></a>顶级 Stack View</h2><p>在Outline 视图中，用Command+左键选择5个最顶级的 Stack View：<br><img title=\"选中视图\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack011.png?imageMogr2/2/w/800\"><br>然后点击 Stack 按钮：<br><img title=\"Stack按钮\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack012.png?imageMogr2/2/w/800\"><br>点击Pin 按钮，勾上 Constrain to margins，将 4 个边的约束都设为0。然后将Spacing 设置为20，Alignment 设为 Fill。现在故事板会是这个样子：<br><img title=\"添加约束\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack013.png?imageMogr2/2/w/800\"><br>编译运行：<br><img title=\"编译运行\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack014.png?imageMogr2/2/w/800\"><br>噢！这个 Hide 按钮又失去了它 的约束！因为包含 WEATHER 标签的Stack View的外边又套了一层 Stack View。这不是什么大问题，就像之前你做过的那样，再重新为它添加约束就是了。</p>\n<p>右键从Hide 按钮拖一条约束到 WEATHER标签，按下 Shift 键，同时选择 Horizontal Spacing 和 Baseline。然后点击 Add Constraints：<br><img title=\"AddConstraints\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack015.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"重新调整视图位置\"><a href=\"#重新调整视图位置\" class=\"headerlink\" title=\"重新调整视图位置\"></a>重新调整视图位置</h2><p>现在，所有的版块都被嵌到一个顶级的 Stack View中了，我们想修改一下 what to see版块的位置，让它位于 weather 版块之后。</p>\n<p>从 Outline 视图中选择中间的的 Stack View，然后将它拖到第一、二个 Stack View 之间。<br>注意：让箭头稍微偏向你正在拖的Stack View左边一点，以便它能够作为外层 Stack View 的 subview 添加。蓝色的小圆圈应当位于两个 Stack View 之间的左端而不是右端：<br><img title=\"调整视图位置\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack016.png?imageMogr2/2/w/800\"></p>\n<p>现在，weather版块是从上到下的第三个版块，由于 Hide 按钮它并不是 Stack View的subview，所以它不会参与移动，它的frame当前是不正确的。</p>\n<p>点击 Hide 按钮，选中它：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack017.png?imageMogr2/2/w/800\"></p>\n<p>然后点击自动布局工具栏中的 Resolve Auto Layout Issues 按钮，选择 Update Frames：<br><img title=\"Update\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack018.png?imageMogr2/2/w/800\"><br>现在 Hide 按钮将回到正确的位置：<br><img title=\"UpdateHide按钮\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack019.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"基于配置的-Size-类\"><a href=\"#基于配置的-Size-类\" class=\"headerlink\" title=\"基于配置的 Size 类\"></a>基于配置的 Size 类</h2><p>最后还有一个任务没有完成。在横屏模式，垂直空间是比较珍贵的，你想将这些版块之间靠得更近一些。要实现这个，你需要判断当垂直Size类为compact时，将顶层 Stack View的 Spacing属性由 20 改成 10.</p>\n<p>选择顶层 Stack View，点击 Spacing 前面的+按钮：<br><img title=\"前面的+按钮Spacing\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack020.png?imageMogr2/2/w/800\"></p>\n<p>选择 Any Width &gt; Compact Height：<br><img title=\"CompactHeight\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack021.png?imageMogr2/2/w/800\"></p>\n<p>在新出现的 wAny hC 一栏中，将 Spacing 设为 10：<br><img title=\"Spacing设为10\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack022.png?imageMogr2/2/w/800\"><br>编译运行。在竖屏模式下Spacing不会改变。旋转模拟器（⌘←），你会看到各版块之间的间距减少了，现在底部按钮之间的空间也变大了：<br><img title=\"编译运行\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack023.png?imageMogr2/2/w/800\"><br>如果你没有添加最外层的 Stack View，你仍然可以使用 Size 类将每个版块之间的垂直间距设置为 10，但这就不是仅仅设置一个地方就能够办到的了。</p>\n<h2 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h2><p>现在，在隐藏和显示天气信息时仍然会觉得有一些突兀。你将增加一个动画使这个转换变得更平滑。</p>\n<p>Stack View完全支持 <code>UIView 动画</code>。也就是说要以动画方式显示/隐藏它所包含的subview，只需要简单地在一个动画块中切换它的 hidden 属性。</p>\n<p>让我们来看看代码怎么实现。打开 <code>SpotInfoViewController.Swift</code>，找到<br><code>updateWeatherInfoViews(hideWeatherInfo:animated:)</code>方法。</p>\n<p>将方法的最后一行：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br></pre></td></tr></table></figure><br>替换为：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> animated </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">UIView</span>.animateWithDuration(<span class=\"number\">0.3</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">else</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>编译运行，点击Hide 按钮或 Show 按钮。是不是加入动画之后看起来要好得多呢？</p>\n<p>除了对 Stack View 中的视图以动画的方式设置 hidden 属性，你也可以对 Stack View 自身的属性使用 UIView 动画，例如 Alignment 属性、 Distribution 属性、 Spacing 属性和 Axis 属性。<br><a href=\"http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Starter.zip\" target=\"_blank\" rel=\"noopener\">开始项目源码</a><br><a href=\"http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Complete.zip\" target=\"_blank\" rel=\"noopener\">完整项目源码</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2>","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"控件","path":"api/categories/控件.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"}]},{"title":"UIImage的渲染模式","slug":"iOS/UIImage的渲染模式","date":"2015-11-26T16:15:11.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/UIImage的渲染模式.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>设置UIImage的渲染模式：UIImage.renderingMode<br>在 iOS 7 中 UIImage 添加了一个 <code>renderingMode</code> 属性。我们可以使用 <code>imageWithRenderingMode:</code>并传入一个合适的<code>UIImageRenderingMode</code> 来指定这个 image 要不要以 Template 的方式进行渲染。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIImageRenderingModeAutomatic</span> <span class=\"comment\">// 根据图片的使用环境和所处的绘图上下文自动调整渲染模式。</span></span><br><span class=\"line\"><span class=\"built_in\">UIImageRenderingModeAlwaysOriginal</span> <span class=\"comment\">// 始终绘制图片原始状态，不使用Tint Color。</span></span><br><span class=\"line\"><span class=\"built_in\">UIImageRenderingModeAlwaysTemplate</span> <span class=\"comment\">// 始终根据Tint Color绘制图片，忽略图片的颜色信息。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UIImage</span> *img = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"myimage\"</span>];</span><br><span class=\"line\">img = [img imageWithRenderingMode:<span class=\"built_in\">UIImageRenderingModeAlwaysTemplate</span>];</span><br><span class=\"line\"><span class=\"comment\">//实际效果，效果依旧显示为baritem的Tint Color</span></span><br><span class=\"line\"><span class=\"built_in\">UIBarButtonItem</span> *barButtonItem = [[<span class=\"built_in\">UIBarButtonItem</span> alloc] initWithImage:setImage</span><br><span class=\"line\">                                                   style:<span class=\"built_in\">UIBarButtonItemStylePlain</span></span><br><span class=\"line\">                                                  target:<span class=\"keyword\">self</span></span><br><span class=\"line\">                                                  action:<span class=\"keyword\">@selector</span>(setAction:)];</span><br><span class=\"line\">```    </span><br><span class=\"line\">在新的 Xcode 中，我们可以直接在 Image Asset 里的 Render As 选项来指定是不是需要作为 template 使用。相应的，在`<span class=\"built_in\">UIApperance</span>`中，Apple 也为我们对于 `Size Classes` 添加了相应的方法。使用 `+appearanceForTraitCollection:` 方法，我们就可以针对不同 trait 下的应用的 apperance 进行很简单的设定。</span><br><span class=\"line\"></span><br><span class=\"line\">```objc</span><br><span class=\"line\"><span class=\"built_in\">UIView</span>.appearanceForTraitCollection(<span class=\"built_in\">UITraitCollection</span>(verticalSizeClass:.Compact)).tintColor = <span class=\"built_in\">UIColor</span>.redColor()  </span><br><span class=\"line\"><span class=\"built_in\">UIView</span>.appearanceForTraitCollection(<span class=\"built_in\">UITraitCollection</span>(verticalSizeClass:.Regular)).tintColor = <span class=\"built_in\">UIColor</span>.greenColor()</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"控件","path":"api/categories/控件.json"}],"tags":[{"name":"UI","path":"api/tags/UI.json"},{"name":"坑","path":"api/tags/坑.json"}]},{"title":"TextKit之便笺实战","slug":"iOS/TextKit之便笺实战","date":"2014-07-03T17:29:00.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/TextKit之便笺实战.json","excerpt":null,"keywords":null,"cover":"/images/bianqian.png","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"便笺练习功能点\"><a href=\"#便笺练习功能点\" class=\"headerlink\" title=\"便笺练习功能点:\"></a>便笺练习功能点:</h2><p>通过实现以下特效，练习并掌握布局管理器（layout manger），文本容器（text containers）和文本存储器（text storage）等用法。</p>\n<ul>\n<li>动态样式（Dynamic type）  </li>\n<li>凸版印刷效果（Letterpress effects）  </li>\n<li>环绕路径（Exclusion paths）  </li>\n<li>动态文本格式及存储（Dynamic text formatting and storage）  </li>\n</ul>\n<p>这个应用中我们将实现回流文本，字体大小的动态变换，以及闪回文本等效果。<br>效果图:<br><img src=\"/images/bianqian.png\" alt=\"image\"><br>App开始运行后自动生成一组便笺实例并利用<code>tableViewController</code>显示出来。<code>Storyboards</code>和<code>segues</code>会将被选中的单元格所对应的便笺内容显示出来以供用户编辑。<br>项目开发包：<a href=\"http://cdn4.raywenderlich.com/wp-content/uploads/2013/09/TextKitNotepad-starter.zip\" target=\"_blank\" rel=\"noopener\">Notepad.zip</a></p>\n<h2 id=\"动态样式\"><a href=\"#动态样式\" class=\"headerlink\" title=\"动态样式\"></a>动态样式</h2><p><code>动态样式（Dynamic type）</code>是iOS 7里面变化最大的特性之一; 它使得app可以遵从用户选择的字体大小和粗细。<br>选择 <strong>通用-&gt;文字大小</strong> 或 <strong>通用-&gt;辅助功能</strong> 来查看app中的字体设置。</p>\n<p><img src=\"/images/UserTextPreferences.png\" alt=\"image\"><br>iOS 7 支持通过<code>粗体</code>、<code>设置字体大小</code>等方式提高支持动态文本的应用的易读性。<br>例如<strong><code>UIFont</code></strong>新增的一个方法： <strong><code>preferredFontForTextStyle</code></strong> 用来根据用户对字体大小的设置来自动制定字体样式。<br>下面表格中是六种可用字体样式的示例：<br><img src=\"/images/TextStyles.png\" alt=\"image\"><br>最左边一列是最小字体；中间一列是最大字体；最右边一列是粗体效果。  </p>\n<h3 id=\"使用系统动态字体样式\"><a href=\"#使用系统动态字体样式\" class=\"headerlink\" title=\"使用系统动态字体样式\"></a>使用系统动态字体样式</h3><p>使用动态文本，是通过给<code>文本字体</code>设置字体样式<strong>style</strong>而不是指定具体的<code>字体名称</code>和<code>大小</code>。这样，系统会在运行时自动根据这一样式以及用户的字体大小设置来选择使用合适的字体。</p>\n<h4 id=\"preferredFontForTextStyle-方法设置字体样式\"><a href=\"#preferredFontForTextStyle-方法设置字体样式\" class=\"headerlink\" title=\"preferredFontForTextStyle:方法设置字体样式\"></a><code>preferredFontForTextStyle:</code>方法设置字体样式</h4><ol>\n<li>打开 <code>NoteEditorViewController.m/swift</code> 在<code>viewDidLoad：</code>方法实现的最后面加入以下代码：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.textView.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.textView.font = <span class=\"type\">UIFont</span>.preferredFont(forTextStyle: .body)</span><br></pre></td></tr></table></figure></li>\n<li>打开 <code>NotesListViewController.m/swift</code> 在 <code>tableView:cellForRowAtIndexPath:</code> 方法中增加如下代码:<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cell.textLabel.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleHeadline</span>];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cell.textLabel?.font = <span class=\"type\">UIFont</span>.preferredFont(forTextStyle: .headline)</span><br></pre></td></tr></table></figure>\n上面两行代码都用到了新版iOS的字体样式.   <blockquote>\n<p>字体样式：通过语义法命名字体，例如 <code>UIFontTextStyleSubHeadline</code>, 可以避免在代码里每一处都指定具体的字体名称和样式， 而且确保app能对用户的字体大小设置做出恰当的回应。</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"APP响应用户字体设置\"><a href=\"#APP响应用户字体设置\" class=\"headerlink\" title=\"APP响应用户字体设置\"></a>APP响应用户字体设置</h4><ol>\n<li>设置系统字体<br>返回到<strong>通用-&gt;文字大小</strong>重新修改字体设置.<br>再运行App, <strong>Note</strong>页面的文字大小是当前设定的字体大小；前后截屏对比,分辨率小了一半。<br><img src=\"/images/NotepadWithDynamicType.png\" alt=\"image\"> </li>\n<li>设置系统字体生效<br>当我们返回到<strong>通用-&gt;文字大小</strong>重新修改字体设置. 再打开<strong>Note</strong>页面, 会发现app并没有<strong>立即</strong>对字体设置的变化做出相应反应。</li>\n</ol>\n<h5 id=\"监听系统通知：实现APP响应用户字体设置\"><a href=\"#监听系统通知：实现APP响应用户字体设置\" class=\"headerlink\" title=\"监听系统通知：实现APP响应用户字体设置\"></a>监听系统通知：实现APP响应用户字体设置</h5><p>当用户修改了他们的字体大小设置之后，这一样式对应的字体并不会自动更新，必须重新请求才能获取新的值。用户设置变化后，<code>preferredFontForTextStyle:</code>方法返回的字体也会变化。</p>\n<ol>\n<li>添加监听系统通知<code>UIContentSizeCategoryDidChangeNotification</code>通知APP响应用户字体设置的变化<br>打开 <code>NoteEditorViewController.m</code> 并在 <code>viewDidLoad</code> 方法的实现的最后加入以下代码：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter]</span><br><span class=\"line\">                              addObserver:<span class=\"keyword\">self</span></span><br><span class=\"line\">                                 selector:<span class=\"keyword\">@selector</span>(preferredContentSizeChanged:)</span><br><span class=\"line\">                                     name:<span class=\"built_in\">UIContentSizeCategoryDidChangeNotification</span></span><br><span class=\"line\">                                   object:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//字体变化通知:调用preferredContentSizeChanged:方法</span></span><br><span class=\"line\"><span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(<span class=\"keyword\">self</span>, selector: #selector(<span class=\"type\">NoteEditorViewController</span>.preferredContentSizeChanged(<span class=\"number\">_</span>:)), name: <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>.<span class=\"type\">UIContentSizeCategoryDidChange</span>, object: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure></li>\n<li>添加系统通知响应事件<br>收到用于指定本类接收字体设定变化的通知后，调用<code>preferredContentSizeChanged:</code>方法<br>在<code>NoteEditorViewController.m</code>中<code>viewDidLoad</code>方法之后紧接着添加以下方法：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)preferredContentSizeChanged:(<span class=\"built_in\">NSNotification</span> *)notification</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.textView.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//字体变化通知时调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">preferredContentSizeChanged</span><span class=\"params\">(<span class=\"number\">_</span> notification:NSNotification)</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.textView.font = <span class=\"type\">UIFont</span>.preferredFont(forTextStyle: .body)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n这一方法作用是根据新的字体设置来设定<code>textView</code>中的字体。<br>Build并运行app，修改字体大小设置，Note页面就可以即时更新字体大小了。<a id=\"more\"></a>\n</li>\n</ol>\n<h3 id=\"更新布局\"><a href=\"#更新布局\" class=\"headerlink\" title=\"更新布局\"></a>更新布局</h3><p>现在，如果你把字体设置到很小，那每个单元格的空白区域是不是太多了，看上去文字比较稀疏，如下面所示：<br>  <img src=\"/images/ChangingLayout.png\" alt=\"image\">  </p>\n<p>这是<strong>动态样式</strong>有点小复杂的部分：要保证App在字体大小变化后，同时也修改文字表格的行高。<br>在<code>NotesListViewController.m</code>中实现<code>tableView:heightForRowAtIndexPath:</code> 代理方法:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">UILabel</span>* label;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!label) &#123;</span><br><span class=\"line\">        label = [[<span class=\"built_in\">UILabel</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, FLT_MAX, FLT_MAX)];</span><br><span class=\"line\">        label.text = <span class=\"string\">@\"test\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    label.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleHeadline</span>];</span><br><span class=\"line\">    [label sizeToFit];  <span class=\"comment\">//自适应文本内容大小</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> label.frame.size.height * <span class=\"number\">1.7</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, heightForRowAt indexPath: IndexPath)</span></span> -&gt; <span class=\"type\">CGFloat</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> label = <span class=\"type\">UILabel</span>.<span class=\"keyword\">init</span>(frame: <span class=\"type\">CGRect</span>.<span class=\"keyword\">init</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"type\">FLT_MAX</span>, height: <span class=\"type\">FLT_MAX</span>))</span><br><span class=\"line\">    label.text = <span class=\"string\">\"test\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> font = <span class=\"type\">UIFont</span>.preferredFont(forTextStyle: .headline)</span><br><span class=\"line\">    label.font = font</span><br><span class=\"line\">    label.sizeToFit()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> label.frame.size.height * <span class=\"number\">1.7</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上代码创建了一个共享的——或者说静态的——<strong>UILabel</strong>实例，设定它的字体和表中单元格内文本字体一致。然后调用它的<code>sizeToFit</code>方法，使这个<code>label</code>的<code>frame</code>恰好能放得下它的内容文字, 然后把这个<code>label</code>的高度乘个<code>1.7</code>作为表内单元格高度。<br>Build并运行app，修改字体大小设置，行高也会随着字体大小的变化而变化。 如下图所示：<br><img src=\"/images/TableViewAdaptsHeights.png\" alt=\"image\">  </p>\n<h3 id=\"凸版印刷效果（Letterpress-effects）\"><a href=\"#凸版印刷效果（Letterpress-effects）\" class=\"headerlink\" title=\"凸版印刷效果（Letterpress effects）\"></a>凸版印刷效果（Letterpress effects）</h3><p>凸版印刷效果（Letterpress effects）给文字加上精致的阴影和高光是文字看上去有一定立体感——就好像轻轻嵌入屏幕里一样。  </p>\n<blockquote>\n<font size=\"3\">注: 使用“凸版印刷（letterpress）”这一印刷术语是向早期印刷业的致敬。所谓凸版印刷，就是将涂上油墨的图文凸版嵌在印版上，然后在纸面上按压就把图文凸版上的油墨转移到纸面上了——纸面受力在文字边缘形成好看的突起。现在这一工艺已广泛被数码打印所取代。</font>  \n\n</blockquote>\n<p>打开NotesListViewController.m 将<code>tableView:cellForRowAtIndexPath:</code>方法中的代码用以下代码替换:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">NSString</span> *CellIdentifier = <span class=\"string\">@\"Cell\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier </span><br><span class=\"line\">                                                        forIndexPath:indexPath];</span><br><span class=\"line\">Note* note = [<span class=\"keyword\">self</span> notes][indexPath.row];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UIFont</span>* font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleHeadline</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UIColor</span>* textColor = [<span class=\"built_in\">UIColor</span> colorWithRed:<span class=\"number\">0.175</span>f green:<span class=\"number\">0.458</span>f blue:<span class=\"number\">0.831</span>f alpha:<span class=\"number\">1.0</span>f];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *attrs = @&#123; <span class=\"built_in\">NSForegroundColorAttributeName</span> : textColor,</span><br><span class=\"line\">                                    <span class=\"built_in\">NSFontAttributeName</span> : font,</span><br><span class=\"line\">                              <span class=\"built_in\">NSTextEffectAttributeName</span> : <span class=\"built_in\">NSTextEffectLetterpressStyle</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSAttributedString</span>* attrString = [[<span class=\"built_in\">NSAttributedString</span> alloc]</span><br><span class=\"line\">                                       initWithString:note.title</span><br><span class=\"line\">                                           attributes:attrs];</span><br><span class=\"line\">cell.textLabel.attributedText = attrString;</span><br><span class=\"line\"><span class=\"keyword\">return</span> cell;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class=\"type\">UITableViewCell</span></span><br><span class=\"line\">&#123;    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class=\"string\">\"noteListCell\"</span>, <span class=\"keyword\">for</span>: indexPath)</span><br><span class=\"line\">    <span class=\"comment\">// Configure the cell...</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> note = notes[indexPath.row] <span class=\"keyword\">as</span>! <span class=\"type\">NoteModel</span></span><br><span class=\"line\">    <span class=\"comment\">//cell.textLabel?.text = note.title</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> font = <span class=\"type\">UIFont</span>.preferredFont(forTextStyle: .headline)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> textColor = <span class=\"type\">UIColor</span>.<span class=\"keyword\">init</span>(red: <span class=\"number\">0.175</span>, green: <span class=\"number\">0.458</span>, blue: <span class=\"number\">0.831</span>, alpha: <span class=\"number\">1.0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//字体凸版印刷效果</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> store:[<span class=\"type\">String</span>:<span class=\"type\">Any</span>] = [<span class=\"type\">NSForegroundColorAttributeName</span>:textColor,</span><br><span class=\"line\">    <span class=\"type\">NSFontAttributeName</span>:font,</span><br><span class=\"line\">    <span class=\"type\">NSTextEffectAttributeName</span>:<span class=\"type\">NSTextEffectLetterpressStyle</span>]</span><br><span class=\"line\">    cell.textLabel?.attributedText = <span class=\"type\">NSAttributedString</span>.<span class=\"keyword\">init</span>(string: note.title, attributes: store)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cell</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码为单元格的标题创建了一个使用了凸版印刷效果的<strong><code>NSAttributedString</code></strong>。  </p><p><br>Build并运行app， 表格将显示凸版印刷效果，如下图所示：<br><img src=\"/images/Letterpress.png\" alt=\"image\"><br>凸版印刷效果是很精巧——但是并不表示你可以随意过度使用它。视觉特效能让文字看上去更有趣，但并不表示一定能让你的文字更清晰易读。</p>\n<h3 id=\"环绕路径（Exclusion-paths）\"><a href=\"#环绕路径（Exclusion-paths）\" class=\"headerlink\" title=\"环绕路径（Exclusion paths）\"></a>环绕路径（Exclusion paths）</h3><p>文字环绕图片或其它内容分布是大多数文字处理软件的标准特性之一。<code>Text Kit</code>允许你通过环绕路径（<code>exclusion paths</code>）将文字按照复杂路径和形状分布。  </p>\n<p>在便笺右上角添加一个曲线形视图，告知用户便笺创建的日期：   </p>\n<ul>\n<li>首先添加一个视图  </li>\n<li>创建一个环绕路径，使文字按照这个路径分布。 </li>\n</ul>\n<h4 id=\"添加视图\"><a href=\"#添加视图\" class=\"headerlink\" title=\"添加视图\"></a>添加视图</h4><p>打开 <code>NoteEditorViewController.m</code> 在顶部的<code>imports</code>和接口实现中添加变量加入以下代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"TimeIndicatorView.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NoteEditorViewController</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TimeIndicatorView* _timeView;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>实例化这个用以显示文本创建日期的视图实例，并把它作为一个子视图添加进去<br>在NoteEditorViewController.m的<code>viewDidLoad</code>方法的最后添加以下代码：<br><figure class=\"highlight objc\"><figcaption><span>objc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_timeView = [[TimeIndicatorView alloc] initWithDate:_note.timestamp];</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:_timeView];</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"设置视图位置及自动适应布局：viewDidLayoutSubviews\"><a href=\"#设置视图位置及自动适应布局：viewDidLayoutSubviews\" class=\"headerlink\" title=\"设置视图位置及自动适应布局：viewDidLayoutSubviews\"></a>设置视图位置及自动适应布局：<code>viewDidLayoutSubviews</code></h4><p>当<strong>NoteEditor</strong>视图的控件调用系统方法<code>viewDidLayoutSubviews</code>方法，对子视图进行布局时，<code>TimeIndicatorView</code>作为子控件也需要有相应的变化。<br>在控件接收到文本内容的尺寸发生了变化的时候调用<code>updateTimeIndicatorFrame</code>： </p>\n<ol>\n<li>第一调用<code>updateSize</code>来设定<code>_timeView</code>的尺寸  </li>\n<li>第二将<code>_timeView</code>放在右上角<br>在NoteEditorViewController.m 的最后添加如下代码：<figure class=\"highlight objc\"><figcaption><span>objc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLayoutSubviews </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> updateTimeIndicatorFrame];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)updateTimeIndicatorFrame</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [_timeView updateSize];</span><br><span class=\"line\">    _timeView.frame = <span class=\"built_in\">CGRectOffset</span>(_timeView.frame,</span><br><span class=\"line\">                          <span class=\"keyword\">self</span>.view.frame.size.width - _timeView.frame.size.width, <span class=\"number\">0.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//视图的控件调用viewDidLayoutSubviews对子视图进行布局时，TimeIndicatorView作为子控件也需要有相应的变化。</span></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLayoutSubviews</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    updateTimeIndicatorFrame()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">updateTimeIndicatorFrame</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//第一调用updateSize来设定_timeView的尺寸</span></span><br><span class=\"line\">    timeIndicatorView.updateSize()</span><br><span class=\"line\">    <span class=\"comment\">//通过偏移frame参数，将timeIndicatorView放在右上角</span></span><br><span class=\"line\">    timeIndicatorView.frame = timeIndicatorView.frame.offsetBy(dx: ibTextView.frame.width - timeIndicatorView.frame.width,</span><br><span class=\"line\">                                                               dy: <span class=\"number\">0.0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"响应系统偏好设置字体样式\"><a href=\"#响应系统偏好设置字体样式\" class=\"headerlink\" title=\"响应系统偏好设置字体样式\"></a>响应系统偏好设置字体样式</h4><p>修改<code>NoteEditorViewController.m</code>中<code>preferredContentSizeChanged:</code>方法如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)preferredContentSizeChanged:(<span class=\"built_in\">NSNotification</span> *)n </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.textView.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> updateTimeIndicatorFrame];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>Build并运行app，点击选择一个便笺，日期显示视图将出现在右上角，如下图所示：<br><img src=\"/images/TimIndicator.png\" alt=\"修改设备中文本大小设置，这个视图也将自动调整到相应的合适尺寸\">    </p>\n<h3 id=\"文本环绕视图\"><a href=\"#文本环绕视图\" class=\"headerlink\" title=\"文本环绕视图\"></a>文本环绕视图</h3><ol>\n<li>根据日期视图<code>_timeView</code>创建基于贝赛尔路径的环绕路径</li>\n<li>设置文本容器的环绕路径：使用文本容器的exclusionPaths属性指定。它是一个UIBezierPath数组类型。</li>\n</ol>\n<h4 id=\"curvePathWithOrigin-创建文本容器的赛尔路径\"><a href=\"#curvePathWithOrigin-创建文本容器的赛尔路径\" class=\"headerlink\" title=\"curvePathWithOrigin:创建文本容器的赛尔路径\"></a>curvePathWithOrigin:创建文本容器的赛尔路径</h4><p>根据日期视图<code>_timeView</code>创建基于贝赛尔路径的环绕路径<br>添加<code>curvePathWithOrigin:</code>方法，定义文本遵循的环绕路径：<br><figure class=\"highlight objc\"><figcaption><span>objc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIBezierPath</span> *)curvePathWithOrigin:(<span class=\"built_in\">CGPoint</span>)origin</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">UIBezierPath</span> bezierPathWithArcCenter:origin</span><br><span class=\"line\">                                          radius: [<span class=\"keyword\">self</span> radiusToSurroundFrame:_label.frame]</span><br><span class=\"line\">                                      startAngle: <span class=\"number\">-180.0</span>f</span><br><span class=\"line\">                                        endAngle: <span class=\"number\">180.0</span>f</span><br><span class=\"line\">                                       clockwise: <span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">curvePathWithOrigin</span><span class=\"params\">(origin:CGPoint)</span></span>-&gt;<span class=\"type\">UIBezierPath</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//画弧形</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = <span class=\"type\">UIBezierPath</span>.<span class=\"keyword\">init</span>(arcCenter: origin,</span><br><span class=\"line\">    radius: radiusToSurroundFrame(frame: timeLabel.frame),</span><br><span class=\"line\">                             startAngle: -<span class=\"number\">180</span>,                <span class=\"comment\">//-180.0</span></span><br><span class=\"line\">                               endAngle: <span class=\"number\">180.0</span>,               <span class=\"comment\">//CGFloat(M_PI * 2),   //180.0</span></span><br><span class=\"line\">                              clockwise: <span class=\"literal\">true</span>)</span><br><span class=\"line\">    <span class=\"comment\">//        UIColor.blueColor().set()</span></span><br><span class=\"line\">    <span class=\"comment\">//        path.fill()</span></span><br><span class=\"line\">    <span class=\"comment\">//        UIColor.blueColor().set()</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> path</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"设置文本容器的环绕路径：exclusionPaths\"><a href=\"#设置文本容器的环绕路径：exclusionPaths\" class=\"headerlink\" title=\"设置文本容器的环绕路径：exclusionPaths\"></a>设置文本容器的环绕路径：exclusionPaths</h4><p><code>exclusionPaths</code>是<code>NSArray</code>类型，因此一个文本容器是可以支持多个环绕路径，文本<strong>环绕路径</strong>发生改变后会通知文本管理器，然后<strong>环绕路径</strong>的变化就可以动态地，甚至是动画式地体现到文本上！<br>在<code>updateTimeIndicatorFrame</code>方法实现的最后面添加如下代码：<br><figure class=\"highlight objc\"><figcaption><span>objc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIBezierPath</span>* exclusionPath = [_timeView curvePathWithOrigin:_timeView.center];</span><br><span class=\"line\">    _textView.textContainer.exclusionPaths  = @[exclusionPath];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> exclusionPath = timeIndicatorView.curvePathWithOrigin(origin: timeIndicatorView.center)</span><br><span class=\"line\">    ibTextView.textContainer.exclusionPaths = [exclusionPath]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>Build并运行app，选择一个便笺项，如下图所示：<br><img src=\"/images/ExclusionPath.png\" alt=\"实现文本环绕效果\">  </p>\n<h2 id=\"动态文本格式及存储（Dynamic-text-formatting-and-storage）\"><a href=\"#动态文本格式及存储（Dynamic-text-formatting-and-storage）\" class=\"headerlink\" title=\"动态文本格式及存储（Dynamic text formatting and storage）\"></a>动态文本格式及存储（Dynamic text formatting and storage）</h2><p>你已经看到了<code>Text Kit</code>可以根据用户设置的字体大小动态地调整字体。但是如果字体也可以根据实际的文字本身来进行动态更新是不是会更酷呢？<br>实现类似markdown语法的效果：  </p>\n<ul>\n<li>把波浪线(~)之间的文本变为艺术字体  </li>\n<li>把下划线(_)之间的文本变为斜体  </li>\n<li>为破折号(-)之间的文本添加删除线  </li>\n<li>把字母全部大写的单词变为红色<br><img src=\"/images/DynamicTextExample.png\" alt=\"利用Text Kit framework来实现的效果\">   </li>\n</ul>\n<h3 id=\"Text-Kit文本系统工作机制\"><a href=\"#Text-Kit文本系统工作机制\" class=\"headerlink\" title=\"Text Kit文本系统工作机制\"></a>Text Kit文本系统工作机制</h3><p><code>Text Kit 堆栈</code>存储、处理以及显示文本：<br><img src=\"/images/TextKitStack-443x320.png\" alt=\"image\"><br>当你创建<code>UITextView</code>, <code>UILabel</code> or <code>UITextField</code>的时候，Apple系统自动在后台帮你创建了这些类。你可以使用这些默认的实现或者是自定义一部分，以便达到想要的效果。</p>\n<ul>\n<li><strong><code>NSTextStorage</code>文本存储器</strong>: 作为一个<code>NSMutableAttributedString</code>的子类，动态处理的文本可以通过<code>attributedString</code>的方式存储，并且将文本内容的任何变化都通知给布局管理器。可以自定义<code>NSTextStorage</code>的子类，当文本发生变化时，动态地对文本属性做出相应改变。  </li>\n<li><strong><code>NSLayoutManager</code>布局引擎</strong>: 获取存储的文本并经过修饰处理再显示在屏幕上； </li>\n<li><strong><code>NSTextContainer</code>文本容器</strong>: 描述所要处理的文本在屏幕上的位置信息。每一个文本容器都有一个关联的<code>UITextView</code>. 可以创建 <code>NSTextContainer</code>的子类来定义<strong>一个复杂的形状</strong>，然后在这个形状内处理文本。  </li>\n</ul>\n<h3 id=\"NSTextStorage文本存储器动态添加文本属性\"><a href=\"#NSTextStorage文本存储器动态添加文本属性\" class=\"headerlink\" title=\"NSTextStorage文本存储器动态添加文本属性\"></a><code>NSTextStorage</code>文本存储器动态添加文本属性</h3><ol>\n<li>需要创建一个<code>NSTextStorage</code>的子类，用以在用户输入文本的时候，动态地添加文本属性。</li>\n<li>将<code>UITextView</code>的默认文本存储器,用自定义的实现替换掉。</li>\n</ol>\n<h4 id=\"创建文本存储器NSTextStorage子类\"><a href=\"#创建文本存储器NSTextStorage子类\" class=\"headerlink\" title=\"创建文本存储器NSTextStorage子类\"></a>创建文本存储器NSTextStorage子类</h4><p>新建<strong><code>NSTextStorage</code></strong>的子类，类命名为<strong><code>SyntaxHighlightTextStorage</code></strong><br>打开<strong>SyntaxHighlightTextStorage.m</strong>并添加实例变量并初始化：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"SyntaxHighlightTextStorage.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">SyntaxHighlightTextStorage</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableAttributedString</span> *\t_backingStore;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _backingStore = [<span class=\"built_in\">NSMutableAttributedString</span> new];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyntaxHighlightTextStorage</span>: <span class=\"title\">NSTextStorage</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//文本存储器子类必须提供它自己的“数据持久化层”。</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> backingStore = <span class=\"type\">NSMutableAttributedString</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"重载文本存储器的数据持久化层方法\"><a href=\"#重载文本存储器的数据持久化层方法\" class=\"headerlink\" title=\"重载文本存储器的数据持久化层方法\"></a>重载文本存储器的数据持久化层方法</h4><p>要使用<strong><code>NSMutableAttributedString</code></strong>作为“后台存储” (后面会详细讲解)，文本存储器子类必须提供它自己的“数据持久化层”：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)string</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [_backingStore string];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSDictionary</span> *)attributesAtIndex:(<span class=\"built_in\">NSUInteger</span>)location</span><br><span class=\"line\">                     effectiveRange:(<span class=\"built_in\">NSRangePointer</span>)range</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [_backingStore attributesAtIndex:location</span><br><span class=\"line\">                             effectiveRange:range];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">var</span> string: <span class=\"type\">String</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> backingStore.string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">attributes</span><span class=\"params\">(at location: Int, effectiveRange range: NSRangePointer?)</span></span> -&gt; [<span class=\"type\">String</span> : <span class=\"type\">Any</span>]</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> range == <span class=\"literal\">nil</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [:]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//print(\"backingStore:location\\(location),effectiveRange:\\(range!)\")</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> backingStore.attributes(at: location, effectiveRange: range!)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>上面两个方法直接把任务代理给了后台存储。  </p>\n<h4 id=\"重载编辑文本时通知布局管理器的方法\"><a href=\"#重载编辑文本时通知布局管理器的方法\" class=\"headerlink\" title=\"重载编辑文本时通知布局管理器的方法\"></a>重载编辑文本时通知布局管理器的方法</h4><p>同样的，这些方法也是把任务代理给后台存储。它们通过调用<code>beginEditing</code> / <code>edited</code> / <code>endEditing</code>这些方法来完成一些编辑任务。这样做是为了在编辑发生后让文本存储器的类通知相关的布局管理器。<br>最后，还在这个文件中，重载以下方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)replaceCharactersInRange:(<span class=\"built_in\">NSRange</span>)range withString:(<span class=\"built_in\">NSString</span> *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"replaceCharactersInRange:%@ withString:%@\"</span>, <span class=\"built_in\">NSStringFromRange</span>(range), str);</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> beginEditing];</span><br><span class=\"line\">    [_backingStore replaceCharactersInRange:range withString:str];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> edited:<span class=\"built_in\">NSTextStorageEditedCharacters</span> | <span class=\"built_in\">NSTextStorageEditedAttributes</span></span><br><span class=\"line\">              range:range</span><br><span class=\"line\">     changeInLength:str.length - range.length];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> endEditing];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setAttributes:(<span class=\"built_in\">NSDictionary</span> *)attrs range:(<span class=\"built_in\">NSRange</span>)range</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"setAttributes:%@ range:%@\"</span>, attrs, <span class=\"built_in\">NSStringFromRange</span>(range));</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> beginEditing];</span><br><span class=\"line\">    [_backingStore setAttributes:attrs range:range];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> edited:<span class=\"built_in\">NSTextStorageEditedAttributes</span> range:range changeInLength:<span class=\"number\">0</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> endEditing];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">replaceCharacters</span><span class=\"params\">(<span class=\"keyword\">in</span> range: NSRange, with str: String)</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"replaceCharactersInRange:\\(NSStringFromRange(range)) withString:\\(str)\"</span>)</span><br><span class=\"line\">    beginEditing()</span><br><span class=\"line\">    backingStore.replaceCharacters(<span class=\"keyword\">in</span>: range, with: str)</span><br><span class=\"line\">    edited([.editedAttributes,.editedCharacters], range: range, changeInLength: str.utf16.<span class=\"built_in\">count</span> - range.length)</span><br><span class=\"line\">    endEditing()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setAttributes</span><span class=\"params\">(<span class=\"number\">_</span> attrs: [String : Any]?, range: NSRange)</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//Sets the attributes for the characters in the specified range to the specified attributes.</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"setAttributes:\\(attrs!) range:\\(NSStringFromRange(range))\"</span>)</span><br><span class=\"line\">    beginEditing()</span><br><span class=\"line\">    backingStore.setAttributes(attrs!, range: range)</span><br><span class=\"line\">    edited(.editedAttributes, range: range, changeInLength: <span class=\"number\">0</span>)</span><br><span class=\"line\">    endEditing()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"类族介绍\"><a href=\"#类族介绍\" class=\"headerlink\" title=\"类族介绍\"></a>类族介绍</h4><p>类族是Apple的framework中广泛用到的一种设计模式。类族就是抽象工厂模式的实现，无需指定具体的类就可以为创建一族相关或从属的对象提供一个公共接口。一些我们很熟悉的类<code>NSArray</code>和<code>NSNumber</code>类似的就是一族类的公共接口。</p>\n<p>上例中<code>NSTextStorage</code>文本存储器就是一个类族的公共接口，需要大量代码来创建文本存储器的子类。在扩展功能时，通过创建子类及重载几个方法之外，有些特定需求是要自己实现的，比方<code>attributedString</code>数据的后台存储。</p>\n<p>Apple使用类族来封装同一个公共<code>抽象超类</code>下的私有具体子类，<code>抽象超类</code>声明了客户在创建<code>私有子类实例</code>时必须要实现的方法。客户是完全无法知道工厂正在用哪一个私有类，它只和公共接口相互协作。<br>使用类族当然可以简化接口，使学习和使用类更加容易，但是必须要需要指出的是要在功能扩展和接口简化之间达到平衡。创建一个类族的抽象超类的定制子类也常常是非常难的。 </p>\n<h3 id=\"创建UITextView使用自定义Text-Kit堆栈\"><a href=\"#创建UITextView使用自定义Text-Kit堆栈\" class=\"headerlink\" title=\"创建UITextView使用自定义Text Kit堆栈\"></a>创建UITextView使用自定义Text Kit堆栈</h3><p>现在有了一个自定义的<code>NSTextStorage</code>，还需创建一个<code>UITextView</code>来使用它。 </p>\n<h4 id=\"storyboard创建UITextView时，Text-Kit组件只读问题\"><a href=\"#storyboard创建UITextView时，Text-Kit组件只读问题\" class=\"headerlink\" title=\"storyboard创建UITextView时，Text Kit组件只读问题\"></a>storyboard创建UITextView时，Text Kit组件只读问题</h4><p>从<strong>storyboard</strong>编辑器实例化<code>UITextView</code>会自动创建<strong><code>NSTextStorage</code></strong>, <strong><code>NSLayoutManager</code></strong>和<strong><code>NSTextContainer</code></strong> (例如<strong>Text Kit</strong>堆栈)实例以及所有的这三个只读属性。<br>虽然没有办法从<strong>storyboard</strong>编辑器中改变这种设定，但可以手动编程创建<code>UITextView</code>和<strong>Text Kit</strong>堆栈。  </p>\n<h4 id=\"在UITextView中使用自定义的SyntaxHighlightTextStorage\"><a href=\"#在UITextView中使用自定义的SyntaxHighlightTextStorage\" class=\"headerlink\" title=\"在UITextView中使用自定义的SyntaxHighlightTextStorage\"></a>在UITextView中使用自定义的SyntaxHighlightTextStorage</h4><h5 id=\"清理IB相关设置\"><a href=\"#清理IB相关设置\" class=\"headerlink\" title=\"清理IB相关设置\"></a>清理IB相关设置</h5><ul>\n<li>在IB中打开<strong>Main.storyboard</strong> 找到<strong>NoteEditorViewController</strong>。 删除<code>UITextView</code>实例。<br>然后，打开<strong>NoteEditorViewController.m</strong>删除<strong>UITextView outlet</strong>。<br>既然不再为文本视图使用<code>IBOutlet</code>，而是要编程添加，所以也就不需要这些代码了。<br>从<code>viewDidLoad</code> 方法中删除以下代码：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.textView.text = <span class=\"keyword\">self</span>.note.contents;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.textView.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.textView.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"手动创建UITextView和Text-Kit堆栈\"><a href=\"#手动创建UITextView和Text-Kit堆栈\" class=\"headerlink\" title=\"手动创建UITextView和Text Kit堆栈\"></a>手动创建<code>UITextView</code>和Text Kit堆栈</h5><ul>\n<li>在<strong>NoteEditorViewController.m</strong>最上面，添加下面一行代码:<figure class=\"highlight objc\"><figcaption><span>objc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"SyntaxHighlightTextStorage.h\"</span></span></span><br></pre></td></tr></table></figure>\n在NoteEditorViewController.m中<code>TimeIndicatorView</code>实例变量后面紧接着添加以下代码：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SyntaxHighlightTextStorage* _textStorage;</span><br><span class=\"line\"><span class=\"built_in\">UITextView</span>* _textView;</span><br></pre></td></tr></table></figure>\n文本存储器子类有两个实例变量，还有一个文本视图稍后需要添加。  </li>\n</ul>\n<h5 id=\"创建Text-Kit堆栈\"><a href=\"#创建Text-Kit堆栈\" class=\"headerlink\" title=\"创建Text Kit堆栈\"></a>创建<code>Text Kit</code>堆栈</h5><ul>\n<li>创建自定义的<code>NSTextStorage</code>文本存储器实例，一个用来承载便笺内容的<code>NSAttributedString</code>  </li>\n<li>创建一个<code>NSLayoutManager</code>布局管理器，并添加到文本存储器。</li>\n<li>创建一个<code>NSTextContainer</code>文本容器，并添加到布局管理器。然后把布局管理器和文本存储器联系起来  </li>\n<li>最后用你自定义的文本容器和代理组创建实际的文本视图，  并把文本视图添加为子视图<br>在NoteEditorViewController.m中，添加下面方法：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)createTextView</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. Create the text storage that backs the editor</span></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* attrs = @&#123;<span class=\"built_in\">NSFontAttributeName</span>:</span><br><span class=\"line\">        [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>]&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">NSAttributedString</span>* attrString = [[<span class=\"built_in\">NSAttributedString</span> alloc]</span><br><span class=\"line\">                                   initWithString:_note.contents</span><br><span class=\"line\">                                       attributes:attrs];</span><br><span class=\"line\">    _textStorage = [SyntaxHighlightTextStorage new];</span><br><span class=\"line\">    [_textStorage appendAttributedString:attrString];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CGRect</span> newTextViewRect = <span class=\"keyword\">self</span>.view.bounds;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. Create the layout manager</span></span><br><span class=\"line\">    <span class=\"built_in\">NSLayoutManager</span> *layoutManager = [[<span class=\"built_in\">NSLayoutManager</span> alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. Create a text container</span></span><br><span class=\"line\">    <span class=\"built_in\">CGSize</span> containerSize = <span class=\"built_in\">CGSizeMake</span>(newTextViewRect.size.width,  <span class=\"built_in\">CGFLOAT_MAX</span>);</span><br><span class=\"line\">    <span class=\"built_in\">NSTextContainer</span> *container = [[<span class=\"built_in\">NSTextContainer</span> alloc] initWithSize:containerSize];</span><br><span class=\"line\">    container.widthTracksTextView = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    [layoutManager addTextContainer:container];</span><br><span class=\"line\">    [_textStorage addLayoutManager:layoutManager];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4. Create a UITextView</span></span><br><span class=\"line\">    _textView = [[<span class=\"built_in\">UITextView</span> alloc] initWithFrame:newTextViewRect</span><br><span class=\"line\">                                    textContainer:container];</span><br><span class=\"line\">    _textView.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:_textView];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建文本区域</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createTextView</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. Create the text storage that backs the editor</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bodyFont = <span class=\"type\">UIFont</span>.preferredFont(forTextStyle: <span class=\"type\">UIFontTextStyle</span>.body)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> attrs = [<span class=\"type\">NSFontAttributeName</span>:bodyFont]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> attrString = <span class=\"type\">NSAttributedString</span>(string: note.contents,attributes: attrs)</span><br><span class=\"line\">    textStorage = <span class=\"type\">SyntaxHighlightTextStorage</span>()</span><br><span class=\"line\">    textStorage.append(attrString)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// --------使用Storyboard声明TextView时,只需一行，可惜为只读属性----------</span></span><br><span class=\"line\">    textStorage.addLayoutManager(ibTextView.layoutManager)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**--------使用代码声明TextView时，4步骤----------</span></span><br><span class=\"line\"><span class=\"comment\">    let newTextViewRect = view.bounds</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    // 2. Create the layout manager</span></span><br><span class=\"line\"><span class=\"comment\">    let layoutManager = NSLayoutManager()</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    // 3. Create a text container</span></span><br><span class=\"line\"><span class=\"comment\">    //文本容器的宽度会自动匹配视图的宽度，但是它的高度是无限高的——或者说无限接近于CGFloat.max，它的值可以是无限大。</span></span><br><span class=\"line\"><span class=\"comment\">    let containerSize = CGSize.init(width: newTextViewRect.size.width,</span></span><br><span class=\"line\"><span class=\"comment\">    height: CGFloat.greatestFiniteMagnitude)</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    let container = NSTextContainer.init(size: containerSize)</span></span><br><span class=\"line\"><span class=\"comment\">    //A Boolean that controls whether the receiver adjusts the width of its bounding rectangle when its text view is resized.</span></span><br><span class=\"line\"><span class=\"comment\">    container.widthTracksTextView = true</span></span><br><span class=\"line\"><span class=\"comment\">    //</span></span><br><span class=\"line\"><span class=\"comment\">    layoutManager.addTextContainer(container)</span></span><br><span class=\"line\"><span class=\"comment\">    textStorage.addLayoutManager(layoutManager)</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    // 4. Create a UITextView</span></span><br><span class=\"line\"><span class=\"comment\">    textView = UITextView()//.init(frame: newTextViewRect, textContainer: container)</span></span><br><span class=\"line\"><span class=\"comment\">    textView.isScrollEnabled = true</span></span><br><span class=\"line\"><span class=\"comment\">    textView.delegate = self</span></span><br><span class=\"line\"><span class=\"comment\">    view.addSubview(textView)</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>现在回顾之前那个图表所展示的四个关键类(文本存储器<code>storage</code>, 布局管理器<code>layout manager</code>, 文本容器<code>container</code> 和文本视图<code>textView</code>)之间的关系，是不是觉得理解起来容易多了。<br><img src=\"/images/TextKitStack-443x320.png\" alt=\"image\"></p>\n<blockquote>\n<font size=\"3\">注意:文本容器的宽度会自动匹配视图的宽度，但是它的高度是无限高的——或者说无限接近于<code>CGFLOAT_MAX</code>，它的值可以是无限大。不管怎么说，它的高度足够让<code>UITextView</code>上下滚动以容纳很长的文本。</font>    \n\n</blockquote>\n<p>在<code>viewDidLoad</code>方法中调用超类的<code>viewDidLoad</code>方法的语句后面添加以下一行代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span> createTextView];</span><br></pre></td></tr></table></figure><br>然后修改<code>preferredContentSizeChanged</code>的第一行代码为：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_textView.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"自定义视图实现在storyboard中自动布局约束的效果\"><a href=\"#自定义视图实现在storyboard中自动布局约束的效果\" class=\"headerlink\" title=\"自定义视图实现在storyboard中自动布局约束的效果\"></a>自定义视图实现在<code>storyboard</code>中自动布局约束的效果</h5><p>用自定义的实例变量来替换掉旧的<code>outlet</code>属性。自定义视图不会自动继承<code>storyboard</code>中的布局约束组的规则。当设备方向变化后，视图的边界是不会自动随之改变的，这样就需要自己来编程设定视图边界。  </p>\n<p>可以在<code>viewDidLayoutSubviews</code>方法的最后添加以下代码来实现：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_textView.frame = <span class=\"keyword\">self</span>.view.bounds;</span><br></pre></td></tr></table></figure><br>Build并运行app，打开一个便笺项，在Xcode控制台上有<code>SyntaxHighlightTextStorage</code>生成的运行日志，用来告诉你这些文本处理的代码确实被调用：<br><img src=\"/images/LogMessages-480x266.png\" alt=\"image\"><br>看来你的文本解析器的基础非常可靠了 —— 那现在来添加动态格式。</p>\n<h3 id=\"通过正则修改文本存储器的动态格式（Dynamic-formatting）\"><a href=\"#通过正则修改文本存储器的动态格式（Dynamic-formatting）\" class=\"headerlink\" title=\"通过正则修改文本存储器的动态格式（Dynamic formatting）\"></a>通过正则修改文本存储器的动态格式（Dynamic formatting）</h3><p>接下来将对你的自定义文本存储器进行修改以将＊星号符之间的文本＊变为黑体：</p>\n<h4 id=\"processEditing：将文本的变化通知给布局管理器\"><a href=\"#processEditing：将文本的变化通知给布局管理器\" class=\"headerlink\" title=\"processEditing：将文本的变化通知给布局管理器\"></a><code>processEditing</code>：将文本的变化通知给布局管理器</h4><p><code>processEditing</code> 将文本的变化通知给布局管理器。它也为文本编辑之后的处理提供便利。<br>打开<strong>SyntaxHighlightTextStorage.m</strong> 添加以下方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)processEditing</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> performReplacementsForRange:[<span class=\"keyword\">self</span> editedRange]];</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> processEditing];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>####<br>NSUnionRange：在range1和range2之间比较，如果一个range完全包含在另一个range内，则返回较大的range<br>上面的代码拓展了受黑体格式类型影响的文本范围。因为<code>changedRange</code>一般只是作用到单独的一个字符； 而<code>lineRangeForRange</code> 则扩展到一整行<br>在 <code>processEditing</code>方法之后紧接着添加以下代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)performReplacementsForRange:(<span class=\"built_in\">NSRange</span>)changedRange</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSRange</span> extendedRange = <span class=\"built_in\">NSUnionRange</span>(changedRange, [[_backingStore string]</span><br><span class=\"line\">                             lineRangeForRange:<span class=\"built_in\">NSMakeRange</span>(changedRange.location, <span class=\"number\">0</span>)]);</span><br><span class=\"line\">    extendedRange = <span class=\"built_in\">NSUnionRange</span>(changedRange, [[_backingStore string] </span><br><span class=\"line\">                          lineRangeForRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"built_in\">NSMaxRange</span>(changedRange), <span class=\"number\">0</span>)]);</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> applyStylesToRange:extendedRange];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在指定的区域中进行替换</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">performReplacementsForRange</span><span class=\"params\">(<span class=\"number\">_</span> changedRange:NSRange)</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//定位正在编辑文本的位置区间</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> locationRange = <span class=\"type\">NSMakeRange</span>(changedRange.location, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//定位到文本当前行的位置区间</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> range1 = (backingStore.string <span class=\"keyword\">as</span> <span class=\"type\">NSString</span>).lineRange(<span class=\"keyword\">for</span>: locationRange)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//扩展范围</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> extendedRange = <span class=\"type\">NSUnionRange</span>(changedRange, range1)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> maxRange = <span class=\"type\">NSMakeRange</span>(<span class=\"type\">NSMaxRange</span>(changedRange), <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> range2 = (backingStore.string <span class=\"keyword\">as</span> <span class=\"type\">NSString</span>).lineRange(<span class=\"keyword\">for</span>: maxRange)</span><br><span class=\"line\">    extendedRange = <span class=\"type\">NSUnionRange</span>(changedRange, range2)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"在指定的区域中进行替换:\\(extendedRange)\"</span>)</span><br><span class=\"line\">    applyStylesToRange(searchRange: extendedRange)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>在 <code>performReplacementsForRange</code>方法之后紧接着添加以下代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)applyStylesToRange:(<span class=\"built_in\">NSRange</span>)searchRange</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. create some fonts</span></span><br><span class=\"line\">    <span class=\"built_in\">UIFontDescriptor</span>* fontDescriptor = [<span class=\"built_in\">UIFontDescriptor</span></span><br><span class=\"line\">                             preferredFontDescriptorWithTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br><span class=\"line\">    <span class=\"built_in\">UIFontDescriptor</span>* boldFontDescriptor = [fontDescriptor</span><br><span class=\"line\">                           fontDescriptorWithSymbolicTraits:<span class=\"built_in\">UIFontDescriptorTraitBold</span>];</span><br><span class=\"line\">    <span class=\"built_in\">UIFont</span>* boldFont =  [<span class=\"built_in\">UIFont</span> fontWithDescriptor:boldFontDescriptor size: <span class=\"number\">0.0</span>];</span><br><span class=\"line\">    <span class=\"built_in\">UIFont</span>* normalFont =  [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. match items surrounded by asterisks</span></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span>* regexStr = <span class=\"string\">@\"(*w+(sw+)**)s\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSRegularExpression</span>* regex = [<span class=\"built_in\">NSRegularExpression</span></span><br><span class=\"line\">                                   regularExpressionWithPattern:regexStr</span><br><span class=\"line\">                                                        options:<span class=\"number\">0</span></span><br><span class=\"line\">                                                          error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* boldAttributes = @&#123; <span class=\"built_in\">NSFontAttributeName</span> : boldFont &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* normalAttributes = @&#123; <span class=\"built_in\">NSFontAttributeName</span> : normalFont &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. iterate over each match, making the text bold</span></span><br><span class=\"line\">    [regex enumerateMatchesInString:[_backingStore string]</span><br><span class=\"line\">              options:<span class=\"number\">0</span></span><br><span class=\"line\">                range:searchRange</span><br><span class=\"line\">           usingBlock:^(<span class=\"built_in\">NSTextCheckingResult</span> *match,</span><br><span class=\"line\">                        <span class=\"built_in\">NSMatchingFlags</span> flags,</span><br><span class=\"line\">                        <span class=\"built_in\">BOOL</span> *stop)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">NSRange</span> matchRange = [match rangeAtIndex:<span class=\"number\">1</span>];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> addAttributes:boldAttributes range:matchRange];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 4. reset the style to the original</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">NSMaxRange</span>(matchRange)+<span class=\"number\">1</span> &lt; <span class=\"keyword\">self</span>.length) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span> addAttributes:normalAttributes</span><br><span class=\"line\">                range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"built_in\">NSMaxRange</span>(matchRange)+<span class=\"number\">1</span>, <span class=\"number\">1</span>)];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码有以下作用：  </p>\n<ol>\n<li>创建一个粗体及一个正常字体并使用字体描述器（<strong>Font descriptors</strong>）来格式化文本。字体描述器能使你无需对字体手动编码来设置字体和样式。  </li>\n<li>创建一个正则表达式来定位星号符包围的文本。例如，在字符串“iOS 7 is *awesome*”中，存储在regExStr中的正则表达式将会匹配并返回文本“*awesome*”。</li>\n<li>对正则表达式匹配到并返回的文本进行枚举并添加粗体属性。  </li>\n</ol>\n<p>将后一个星号符之后的文本都重置为“常规”样式。以保证添加在后一个星号符之后的文本不被粗体风格所影响。</p>\n<blockquote>\n<font size=\"3\">注： 字体描述器（<strong>Font descriptors</strong>）是一种描述性语言，它使你可以通过设置属性来修改字体，或者无需初始化<code>UIFont</code>实例便可获取字体规格的细节。</font>    \n\n</blockquote>\n<p>Build并运行app；向便笺中输入文本，并将其中一个词用星号符包围。这个词将会自动变为黑体，如下面截图所示：<br><img src=\"/images/BoldText.png\" alt=\"image\">  </p>\n<p>##进一步添加样式<br>为限定文本添加风格的基本原则很简单：<strong>使用正则表达式来寻找和替换限定字符，然后用applyStylesToRange来设置想要的文本样式即可。</strong><br>在SyntaxHighlightTextStorage.m中添加以下实例变量：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>) createHighlightPatterns &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIFontDescriptor</span> *scriptFontDescriptor =</span><br><span class=\"line\">      [<span class=\"built_in\">UIFontDescriptor</span> fontDescriptorWithFontAttributes:</span><br><span class=\"line\">          @&#123;<span class=\"built_in\">UIFontDescriptorFamilyAttribute</span>: <span class=\"string\">@\"Zapfino\"</span>&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. base our script font on the preferred body font size</span></span><br><span class=\"line\">    <span class=\"built_in\">UIFontDescriptor</span>* bodyFontDescriptor = [<span class=\"built_in\">UIFontDescriptor</span></span><br><span class=\"line\">      preferredFontDescriptorWithTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSNumber</span>* bodyFontSize = bodyFontDescriptor.</span><br><span class=\"line\">                  fontAttributes[<span class=\"built_in\">UIFontDescriptorSizeAttribute</span>];</span><br><span class=\"line\">    <span class=\"built_in\">UIFont</span>* scriptFont = [<span class=\"built_in\">UIFont</span></span><br><span class=\"line\">              fontWithDescriptor:scriptFontDescriptor size:[bodyFontSize floatValue]];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. create the attributes</span></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* boldAttributes = [<span class=\"keyword\">self</span></span><br><span class=\"line\">     createAttributesForFontStyle:<span class=\"built_in\">UIFontTextStyleBody</span></span><br><span class=\"line\">                        withTrait:<span class=\"built_in\">UIFontDescriptorTraitBold</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* italicAttributes = [<span class=\"keyword\">self</span></span><br><span class=\"line\">     createAttributesForFontStyle:<span class=\"built_in\">UIFontTextStyleBody</span></span><br><span class=\"line\">                        withTrait:<span class=\"built_in\">UIFontDescriptorTraitItalic</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* strikeThroughAttributes = @&#123; <span class=\"built_in\">NSStrikethroughStyleAttributeName</span> : @<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* scriptAttributes = @&#123; <span class=\"built_in\">NSFontAttributeName</span> : scriptFont&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* redTextAttributes =</span><br><span class=\"line\">                          @&#123; <span class=\"built_in\">NSForegroundColorAttributeName</span> : [<span class=\"built_in\">UIColor</span> redColor]&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// construct a dictionary of replacements based on regexes</span></span><br><span class=\"line\">    _replacements = @&#123;</span><br><span class=\"line\">              <span class=\"string\">@\"(\\*w+(sw+)\\*\\*)s\"</span> : boldAttributes,</span><br><span class=\"line\">              <span class=\"string\">@\"(_w+(sw+)\\*_)s\"</span> : italicAttributes,</span><br><span class=\"line\">              <span class=\"string\">@\"([0-9]+.)s\"</span> : boldAttributes,</span><br><span class=\"line\">              <span class=\"string\">@\"(-w+(sw+)\\*-)s\"</span> : strikeThroughAttributes,</span><br><span class=\"line\">              <span class=\"string\">@\"(~w+(sw+)\\*~)s\"</span> : scriptAttributes,</span><br><span class=\"line\">              <span class=\"string\">@\"s([A-Z]&#123;2,&#125;)s\"</span> : redTextAttributes&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个方法的作用：</p>\n<ol>\n<li>首先，它使用Zapfino字体来创建了“<code>script</code>”风格。<strong>Font descriptors</strong>会决定当前正文的首选字体，以保证<code>script</code>不会影响到用户的字体大小设置。  </li>\n<li>然后，它会为每种匹配的字体样式构造各个属性。你稍后将用到 <strong><code>createAttributesForFontStyle:withTrait:</code></strong>。</li>\n<li>最后，它将创建一个<code>NSDictionary</code>并将正则表达式映射到上面声明的属性上。</li>\n</ol>\n<p>如果你对正则表达式不是非常熟悉，上面的的dictionary对你来说可能很陌生。但是，如果你一点一点仔细分析它其中包含的正则表达式，其实不用很费力就能理解了。  </p>\n<p>以上面实现的第一个正则表达式为例，它的工作是匹配星号符包围的文本：<br>(*w+(sw+)**)s<br>上面两个两个相连的斜杠，其中一个是用来将Objective-C中的特殊字符转义成实体字符。去掉用来转义的斜杠，来看下这个正则表达式的核心部分：<br>(*w+(sw+)**)s<br>现在，逐步来分析这个正则表达式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*\t \t \t  ——  匹配星号符  </span><br><span class=\"line\">w+   \t \t —— 后接一个或多个 “word”式 字符串  </span><br><span class=\"line\">(sw+)*\t   —— 后接零个或多组空格然后再接 “word” 式字符串  </span><br><span class=\"line\">*)   \t  —— 后接星号符  </span><br><span class=\"line\">s   \t  —— 以空格结尾  </span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<font size=\"3\">注：如果你想对正则表达式有更多了解，请参考 <a href=\"http://www.raywenderlich.com/30288/nsregularexpression-tutorial-and-cheat-sheet\" target=\"_blank\" rel=\"noopener\">NSRegularExpression tutorial and cheat sheet</a>.</font>  \n\n</blockquote>\n<p>现在你需要调用<code>createHighlightPatterns：</code><br>将<strong>SyntaxHighlightTextStorage.m</strong> 中的<code>init</code>方法更新如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</span><br><span class=\"line\">        _backingStore = [<span class=\"built_in\">NSMutableAttributedString</span> new];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> createHighlightPatterns];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在SyntaxHighlightTextStorage.m方法中添加以下代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSDictionary</span>*)createAttributesForFontStyle:(<span class=\"built_in\">NSString</span>*)style</span><br><span class=\"line\">                                    withTrait:(uint32_t)trait &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIFontDescriptor</span> *fontDescriptor = [<span class=\"built_in\">UIFontDescriptor</span></span><br><span class=\"line\">                               preferredFontDescriptorWithTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">UIFontDescriptor</span> *descriptorWithTrait = [fontDescriptor</span><br><span class=\"line\">                                    fontDescriptorWithSymbolicTraits:trait];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">UIFont</span>* font =  [<span class=\"built_in\">UIFont</span> fontWithDescriptor:descriptorWithTrait size: <span class=\"number\">0.0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> @&#123; <span class=\"built_in\">NSFontAttributeName</span> : font &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码作用是将提供的字体样式作用到正文字体上。它给<code>fontWithDescriptor:size:</code> 提供的<code>size</code>值为0，这样做会迫使<code>UIFont</code>返回用户设置的字体大小。</p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"控件","path":"api/categories/控件.json"}],"tags":[{"name":"TextKit","path":"api/tags/TextKit.json"},{"name":"案例","path":"api/tags/案例.json"}]}]}