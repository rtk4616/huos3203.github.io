{"title":"OSX 应用插件","slug":"macOS/OSX应用插件开发","date":"2017-02-07T12:38:58.000Z","updated":"2017-02-07T13:47:53.000Z","comments":true,"path":"api/articles/macOS/OSX应用插件开发.json","excerpt":null,"covers":["http://p27uwfdhv.bkt.clouddn.com/static/images/xcode8.png","http://p27uwfdhv.bkt.clouddn.com/static/images/xcode6.jpg"],"content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>在以前的 OS X 系统中，给你的 App 在运行时动态载入可执行代码比较困难。现在可以通过<code>NSBundle</code>和 <code>plug-ins</code>插件,可以很方便的向原有APP中添加新功能点。</p>\n<p>目的：在一个修改过的 TextEdit 里面加入加载 bundle 的功能</p>\n<h2 id=\"包-Bundles-和接口-Interfaces\"><a href=\"#包-Bundles-和接口-Interfaces\" class=\"headerlink\" title=\"包 (Bundles) 和接口 (Interfaces)\"></a>包 (Bundles) 和接口 (Interfaces)</h2><p>如果你打开 Xcode8 创建一个新项目，会看见 OS X 所有可以编写APP插件的模版，例如： <code>Screen Savers</code> 到 <code>Image Units</code>等。<br>在<code>Framework &amp; Library</code>中的 <code>Bundle</code> 条目。我会在今天探索一个非常简单的的项目，那就是在一个修改过的 TextEdit 里面加入加载 bundle 的功能。<br><img title=\"项目模版\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcode8.png\"><br><code>bundle 模版</code>项目与APP项目比较：</p>\n<ol>\n<li>一个 <code>Contents</code> 目录，里面包含了 <code>Info.plist</code> 和 <code>Resource</code> 目录。</li>\n<li>如果你在你的项目下加入了新的类，你可以看见包含一个可执行文件的 <code>MacOS</code> 目录。</li>\n<li><code>Bundle</code> 工程里缺少的一个东西是 <code>main()</code> 函数。它是被宿主<code>App</code> 调用执行的。</li>\n</ol>\n<h2 id=\"为-TextEdit-加入-Plugin-支持\"><a href=\"#为-TextEdit-加入-Plugin-支持\" class=\"headerlink\" title=\"为 TextEdit 加入 Plugin 支持\"></a>为 TextEdit 加入 Plugin 支持</h2><p>两种插件的方式:<br>    第一个:用最少的工作来为你的 app 加入插件支持，希望让你知道实现这个有多简单。<br>    第二个:技术有点复杂，它展现来一个为你的 app 加入插件的合理的方式，这可以使你不会在未来陷入到被锁死在某一种实现的窘境中。<br>本文章的项目文件仍然会放在 <a href=\"https://github.com/objcio/issue-14-plugins\" target=\"_blank\" rel=\"noopener\">GitHub</a> 供大家参考。</p>\n<h3 id=\"在-TextEdit-中扫描-Bundle\"><a href=\"#在-TextEdit-中扫描-Bundle\" class=\"headerlink\" title=\"在 TextEdit 中扫描 Bundle\"></a>在 TextEdit 中扫描 Bundle</h3><p>请打开 “01 TextEdit” 目录下面的 <code>TextEdit.xcodeproj</code> 工程，同时浏览它里面包含的代码。<br><code>TextEdit</code> 里面有三个简单的组成部分：扫描 <code>bundle</code>，加载 <code>bundle</code>，调用 <code>bundle 的 UI</code><br><code>loadPlugins</code> 方法：<br>打开 <code>Controller.m</code>，你可以看见 <code>-(void)loadPlugins</code> 方法 (它在 <code>applicationDidFinishLaunching:</code> 中被调用)。</p>\n<ol>\n<li>扩展插件菜单：在界面菜单右侧加入了一个新的 <code>NSMenuItem</code>，为调用插件提供一个入口（通常你会在 <code>MainMenu.xib</code> 做这件事情并且链接 <code>outlets</code>，但是我们这次偷下懒）。</li>\n<li>扫描插件目录：获得插件目录（在 <code>~/Library/Application Support/Text Edit/Plug-Ins/</code> ）下，并且扫描这个目录。<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *pluginsFolder = [<span class=\"keyword\">self</span> pluginsFolder];</span><br><span class=\"line\"><span class=\"built_in\">NSFileManager</span> *fm = [<span class=\"built_in\">NSFileManager</span> defaultManager];</span><br><span class=\"line\"><span class=\"built_in\">NSError</span> *outErr;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *item <span class=\"keyword\">in</span> [fm contentsOfDirectoryAtPath:pluginsFolder error:&amp;outErr]) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (![item hasSuffix:<span class=\"string\">@\".bundle\"</span>])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *bundlePath = [pluginsFolder stringByAppendingPathComponent:item];</span><br><span class=\"line\">    <span class=\"built_in\">NSBundle</span> *b = [<span class=\"built_in\">NSBundle</span> bundleWithPath:bundlePath];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!b) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Could not make a bundle from %@\"</span>, bundlePath);</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取实现插件代理协议方法的类</span></span><br><span class=\"line\">    <span class=\"keyword\">id</span> &lt;TextEditPlugin&gt; plugin = [[b principalClass] new];</span><br><span class=\"line\">    <span class=\"built_in\">NSMenuItem</span> *item = [pluginsMenu addItemWithTitle:[plugin menuItemTitle] action:<span class=\"keyword\">@selector</span>(pluginMenuItemCalledAction:) keyEquivalent:<span class=\"string\">@\"\"</span>];</span><br><span class=\"line\">    [item setRepresentedObject:plugin];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：扫描插件目录，确保得到的是一个 <code>.bundle</code> 文件，然后用 <code>NSBundle</code> 载入你找到的 <code>bundle</code> 并且实例化里面的类。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"插件代理\"><a href=\"#插件代理\" class=\"headerlink\" title=\"插件代理\"></a>插件代理</h3><p>你会注意到一个 <code>TextEditPlugin</code> 的 <code>protocol</code> 的引用。在 <code>TextEditMisc.h</code> 能找它的定义:<br><figure class=\"highlight objc\"><figcaption><span>声明代理协议</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">TextEditPlugin</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span>*)menuItemTitle;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)actionCalledWithTextView:(<span class=\"built_in\">NSTextView</span>*)textView inDocument:(<span class=\"keyword\">id</span>)document;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure><br>这说明你实例化的类需要响应这两个方法。你可以验证这个类是否响应这两个方法。</p>\n<h3 id=\"NSPrincipalClass键-值–实现插件代理协议方法的类名称\"><a href=\"#NSPrincipalClass键-值–实现插件代理协议方法的类名称\" class=\"headerlink\" title=\"NSPrincipalClass键:值–实现插件代理协议方法的类名称\"></a>NSPrincipalClass键:值–实现插件代理协议方法的类名称</h3><p>在 <code>bundle</code> 里面调用的 <code>principalClass</code> 方法是什么呢？<br>当你创建一个 <code>Bundle</code> 的时候，你可以在里面创建一个或者多个类，同时你需要让 <code>TextEdit</code> 知道哪一个类需要被实例化。为了帮助宿主 App 调用，你可以在 <code>Info.plist</code> 文件加入一个 <code>NSPrincipalClass</code> 的键，同时设置它的值为实现插件方法的类的名字。你可以用 <code>[NSBundle principalClass]</code> 方便地从 <code>NSPrincipalClass</code> 的值里面寻找并创建这个类。</p>\n<h3 id=\"添加扩展插件菜单的响应事件\"><a href=\"#添加扩展插件菜单的响应事件\" class=\"headerlink\" title=\"添加扩展插件菜单的响应事件\"></a>添加扩展插件菜单的响应事件</h3><p>在 <code>Plug-Ins</code> 菜单加入一个新的按钮，设置 <code>action</code> 为 <code>pluginMenuItemCalledAction:</code>，并且设置它表示你已经实例化的对象。</p>\n<blockquote>\n<p>如果在 <code>menu item</code> 里面没有设置一个<code>target</code>，即目标是<code>nil</code>，那么它会寻找响应链，来寻找第一个实现 <code>pluginMenuItemCalledAction:</code> 方法的对象。如果它找不到，那么这个菜单选项将会不能用。<br>举一个例子，实现 <code>pluginMenuItemCalledAction</code> 的最好的地方是在 <code>Document</code> 的 <code>window controller</code> 类中。打开 <code>DocumentWindowController.m</code>，然后定位到<code>pluginMenuItemCalledAction</code><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)pluginMenuItemCalledAction:(<span class=\"keyword\">id</span>)sender </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">id</span> &lt;TextEditPlugin&gt;plugin = [sender representedObject];</span><br><span class=\"line\">    [plugin actionCalledWithTextView:[<span class=\"keyword\">self</span> firstTextView] inDocument:[<span class=\"keyword\">self</span> document]];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>代码本身很清晰，搜集插件实例，调用 <code>actionCalledWithTextView:inDocument:</code> 方法（被定义在 <code>protocol</code> 里面的），运行你插件里面的代码。</p>\n<h2 id=\"制作插件\"><a href=\"#制作插件\" class=\"headerlink\" title=\"制作插件\"></a>制作插件</h2><ol>\n<li>新建模版项目<br>打开 “01 MarkYellow” 工程看一下。这是一个 Xcode (通过<code>OS X ▸ Framework &amp; Library ▸ Bundle template</code> 建立) 的标准工程，里面只添加了一个类：<code>TEMarkYellow</code>。</li>\n<li>设置NSPrincipalClass键值<br>如果你打开<code>MarkYellow-Info.plist</code>，你可以看到 <code>NSPrincipalClass</code> 的值设置成了上面提到的 <code>TEMarkYellow</code>。</li>\n<li>实现协议代理<br>接着，打开 <code>TEMarkYellow.m</code>，你将会看见定义在协议里面的方法。<ul>\n<li>第一个方法（<code>menuItemTitle</code>）返回插件的名字，最为入口名显示在 <code>menu</code> 里面。</li>\n<li>第二个方法 (<code>actionCalledWithTextView:inDocument:</code>)，把所有选中的文字变成黄色的背景。<figure class=\"highlight objc\"><figcaption><span>改变字体颜色</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)actionCalledWithTextView:(<span class=\"built_in\">NSTextView</span>*)textView inDocument:(<span class=\"keyword\">id</span>)document </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([textView selectedRange].length) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableAttributedString</span> *ats = [[[textView textStorage] attributedSubstringFromRange:[textView selectedRange]] mutableCopy];</span><br><span class=\"line\">        [ats addAttribute:<span class=\"built_in\">NSBackgroundColorAttributeName</span> value:[<span class=\"built_in\">NSColor</span> yellowColor] range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, [ats length])];</span><br><span class=\"line\">        <span class=\"comment\">//  先测试text view是否能改变文字内容，这样可以自动做正确的撤销操作。</span></span><br><span class=\"line\">        By asking the text view <span class=\"keyword\">if</span> you can change the text first, it will automatically <span class=\"keyword\">do</span> the right thing to enable undoing of attribute changes</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([textView shouldChangeTextInRange:[textView selectedRange] replacementString:[ats string]])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            [[textView textStorage] replaceCharactersInRange:[textView selectedRange] withAttributedString:ats];</span><br><span class=\"line\">            [textView didChangeText];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"集成插件\"><a href=\"#集成插件\" class=\"headerlink\" title=\"集成插件\"></a>集成插件</h2><p>运行 <code>TextEdit</code> （它会创建<code>Plug-Ins</code>目录），然后构建 <code>MarkYellow</code> 工程。把 <code>MarkYellow.bundle</code> 丢到你的 <code>~/Library/Application Support/Text Edit/Plug-Ins/</code> 目录下面，重启你的 <code>TextEdit</code> 应用。<br>一切看起来都很好，扫描，加载，插入一个菜单，然后，当你使用菜单项的时候，传递到参数到插件里面。试一试，点击 <code>Plug-Ins ▸ Mark Selected Text Yellow</code>，选择的文字的背景颜色就变成黄色的了。</p>\n<h2 id=\"XCode8版本问题\"><a href=\"#XCode8版本问题\" class=\"headerlink\" title=\"XCode8版本问题\"></a>XCode8版本问题</h2><p>Xcode8 不再支持<code>Application Plug-in</code>插件<br><img title=\"项目创建模版\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcode6.jpg\"><br><a href=\"http://www.jianshu.com/p/39443429f71d\" target=\"_blank\" rel=\"noopener\">XCode8.2.1继续使用xcode插件</a><br>这个是因为苹果解决xcode ghost，把插件屏蔽了。<br>解决方法<br><code>sudo /usr/libexec/xpccachectl</code><br>然后必须重启电脑后生效.</p>\n","categories":[{"name":"macOS","path":"api/categories/macOS.json"}],"tags":[{"name":"macOS","path":"api/tags/macOS.json"},{"name":"插件","path":"api/tags/插件.json"},{"name":"objc","path":"api/tags/objc.json"}]}