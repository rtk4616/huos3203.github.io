{"name":"iOS","postlist":[{"title":"storyboard的几种方式","slug":"iOS/storyboard的几种方式","date":"2018-06-20T14:49:37.000Z","updated":"2018-06-20T14:49:37.000Z","comments":true,"path":"api/articles/iOS/storyboard的几种方式.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"通过IB（xib-storyboard）创建View的周期方法\"><a href=\"#通过IB（xib-storyboard）创建View的周期方法\" class=\"headerlink\" title=\"通过IB（xib/storyboard）创建View的周期方法\"></a>通过IB（xib/storyboard）创建View的周期方法</h2><ol>\n<li><code>loadView</code>：加载View方法，UI是通过代码绘制时，初始化控制器的视图时，会调用该方法。优先级高于IB视图，当重载时，会直接覆盖IB中的视图,因为无论nib也好，xib也好，最终在执行UIViewController生命周期函数<code>loadView</code>之前，都会转化成可执行的nib文件。</li>\n<li><code>initWithNibName</code>：是类的构造器方法，通过IB创建的类：简称<code>IB类</code>，<code>IB类</code>需要通过这个构造器来实例化对象。</li>\n<li><code>initWithCoder</code>：当<code>IB类</code>实例化时会调用该方法，即通过<code>initWithNibName</code>构造器实例化对象时，会调用该方法来分配<code>IB对象</code>的内存空间。</li>\n<li><code>awakeFromNib</code>：当实例化<code>IB视图类</code>时执行，即当IB文件被加载的时候，会发送一个<code>awakeFromNib</code>的消息到IB文件中的每个的对象，每个对象都可以定义自己的awakeFromNib函数来响应这个消息，执行一些必要的操作。<blockquote>\n<p>帮助记忆：一开始经过<code>initWithCoder</code>创建出来的控件是死的，然后通过<code>awakeFromNib</code>来唤醒，所以这会有一个先后的调用顺序</p>\n</blockquote>\n</li>\n<li><code>viewDidLoad</code>：当view对象被加载到内存后就会执行viewDidLoad，所以不管通过nib文件还是代码的方式创建对象都会执行viewDidLoad 。</li>\n</ol>\n<h2 id=\"加载xib方法\"><a href=\"#加载xib方法\" class=\"headerlink\" title=\"加载xib方法\"></a>加载xib方法</h2><h3 id=\"加载视图\"><a href=\"#加载视图\" class=\"headerlink\" title=\"加载视图\"></a>加载视图</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"built_in\">NSArray</span>* nibView =  [[<span class=\"built_in\">NSBundle</span> mainBundle] loadNibNamed:<span class=\"string\">@\"xibfileName\"</span> owner:<span class=\"literal\">nil</span> options:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"> <span class=\"built_in\">UIView</span> *xibView = nibView.lastObject;</span><br><span class=\"line\"><span class=\"comment\">//=======</span></span><br><span class=\"line\"> <span class=\"comment\">// 这里的bundle参数是nil,(这里nil默认就是mianBundle)</span></span><br><span class=\"line\"> <span class=\"built_in\">UINib</span> *nib = [<span class=\"built_in\">UINib</span> nibWithNibName:<span class=\"string\">@\"xib文件名\"</span> bundle:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"> <span class=\"built_in\">NSArray</span> *views = [nib instantiateWithOwner:<span class=\"literal\">nil</span> options:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p><code>owner</code>:xib中的fileObject参数<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加载所有xib文件</span></span><br><span class=\"line\"><span class=\"built_in\">NSArray</span>* objects = [[<span class=\"built_in\">NSBundle</span> mainBundle] loadNibNamed:nibName owner:<span class=\"keyword\">self</span> options:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//加载指定xib文件</span></span><br><span class=\"line\">ContactsTableViewCell  *cell = [[[<span class=\"built_in\">NSBundle</span> mainBundle]loadNibNamed:<span class=\"string\">@\"ContactsTableViewCell\"</span> owner:<span class=\"literal\">nil</span> options:<span class=\"literal\">nil</span>] objectAtIndex:<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"加载控制器对象\"><a href=\"#加载控制器对象\" class=\"headerlink\" title=\"加载控制器对象\"></a>加载控制器对象</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> initWithNibName:<span class=\"string\">@\"xibName\"</span> bundle:nibBundleOrNil];</span><br></pre></td></tr></table></figure>\n<h2 id=\"加载storyboard\"><a href=\"#加载storyboard\" class=\"headerlink\" title=\"加载storyboard\"></a>加载storyboard</h2><h3 id=\"加载控制器对象-1\"><a href=\"#加载控制器对象-1\" class=\"headerlink\" title=\"加载控制器对象\"></a>加载控制器对象</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 加载storyboard</span></span><br><span class=\"line\"><span class=\"built_in\">UIStoryboard</span> *storyboard = [<span class=\"built_in\">UIStoryboard</span> storyboardWithName:<span class=\"string\">@\"Two\"</span> bundle:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建storyboard里面灰色的控制器</span></span><br><span class=\"line\">　　　<span class=\"comment\">//找到shtoryboard里面设置的初始控制器</span></span><br><span class=\"line\">　　　<span class=\"comment\">//    UIViewController *vc = [storyboard instantiateInitialViewController];</span></span><br><span class=\"line\">　　　　　　　　</span><br><span class=\"line\">　　　　　　　<span class=\"comment\">// 从storyboard里面找出绑定标识的控制器</span></span><br><span class=\"line\">　　　　　　　MJTwoViewController *vc = [storyboard instantiateViewControllerWithIdentifier:<span class=\"string\">@\"pink\"</span>];</span><br><span class=\"line\">　　　　　　　<span class=\"keyword\">self</span>.window.rootViewController = vc;</span><br></pre></td></tr></table></figure>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"}],"tags":[]},{"title":"+0800格式转NSDate","slug":"iOS/+0800格式转NSDate","date":"2018-05-30T18:42:20.000Z","updated":"2018-05-30T18:42:20.000Z","comments":true,"path":"api/articles/iOS/+0800格式转NSDate.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *timstr = [resData objectForKey:<span class=\"string\">@\"Data\"</span>];</span><br><span class=\"line\">timstr = [timstr stringByReplacingOccurrencesOfString:<span class=\"string\">@\"/Date(\"</span> withString:<span class=\"string\">@\"\"</span>];</span><br><span class=\"line\">timstr = [timstr stringByReplacingOccurrencesOfString:<span class=\"string\">@\"+0800)/\"</span> withString:<span class=\"string\">@\"\"</span>];</span><br><span class=\"line\">model.time = [<span class=\"built_in\">NSDate</span> dateWithTimeIntervalSince1970:timstr.longLongValue/<span class=\"number\">1000</span>];</span><br></pre></td></tr></table></figure>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"}],"tags":[]},{"title":"高德地图API使用","slug":"iOS/高德地图API使用","date":"2018-05-30T14:40:56.000Z","updated":"2018-05-30T18:42:20.000Z","comments":true,"path":"api/articles/iOS/高德地图API使用.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"引入头文件\"><a href=\"#引入头文件\" class=\"headerlink\" title=\"引入头文件\"></a>引入头文件</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;AMapFoundationKit/AMapFoundationKit.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;AMapLocationKit/AMapLocationKit.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"调用方法\"><a href=\"#调用方法\" class=\"headerlink\" title=\"调用方法\"></a>调用方法</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *strKey = <span class=\"string\">@\"2d8a96d668576584acebf2bab0ba0c08\"</span>;<span class=\"comment\">//默认值</span></span><br><span class=\"line\"><span class=\"comment\">//配置里面取值</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *strBundleKey = [[<span class=\"built_in\">NSBundle</span> mainBundle] infoDictionary][<span class=\"string\">@\"IOSPostionkey\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (strBundleKey) &#123;</span><br><span class=\"line\">    strKey = strBundleKey;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[AMapServices sharedServices].apiKey = strKey;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 带逆地理信息的一次定位（返回坐标和地址信息）</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.GaodelocationManager = [[AMapLocationManager alloc] init];</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.GaodelocationManager setDesiredAccuracy:kCLLocationAccuracyHundredMeters];</span><br><span class=\"line\"><span class=\"comment\">//   定位超时时间，最低2s，此处设置为2s</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.GaodelocationManager.locationTimeout =<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">//   逆地理请求超时时间，最低2s，此处设置为2s</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.GaodelocationManager.reGeocodeTimeout = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">//设置不允许系统暂停定位</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.GaodelocationManager setPausesLocationUpdatesAutomatically:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"><span class=\"comment\">//    //设置允许在后台定位</span></span><br><span class=\"line\"><span class=\"comment\">//    [locationManager setAllowsBackgroundLocationUpdates:YES];</span></span><br><span class=\"line\"><span class=\"comment\">//设置允许连续定位逆地理</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.GaodelocationManager setLocatingWithReGeocode:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"><span class=\"comment\">//    [locationManager setDelegate:self];</span></span><br><span class=\"line\"><span class=\"comment\">// [self.locationManager startUpdatingLocation];</span></span><br><span class=\"line\"><span class=\"comment\">//    // 带逆地理（返回坐标和地址信息）。将下面代码中的 YES 改成 NO ，则不会返回地址信息。</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.GaodelocationManager requestLocationWithReGeocode:<span class=\"literal\">YES</span> completionBlock:^(<span class=\"built_in\">CLLocation</span> *gaodeLocation, AMapLocationReGeocode *regeocode, <span class=\"built_in\">NSError</span> *error) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (gaodeLocation==<span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"高德没有返回地理位置,使用苹果官方定位经纬度\"</span>);</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> GetGISInfoByByLocationWithjingdu:jingdu AndWeidu:weidu];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"locError:&#123;%ld - %@&#125;;\"</span>, (<span class=\"keyword\">long</span>)error.code, error.localizedDescription);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (error.code == AMapLocationErrorLocateFailed)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"AMapLocationErrorLocateFailed高德没有返回地理位置,使用苹果官方定位经纬度\"</span>);</span><br><span class=\"line\">            [<span class=\"keyword\">self</span> GetGISInfoByByLocationWithjingdu:jingdu AndWeidu:weidu];</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"使用高德location:%@\"</span>, gaodeLocation);</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> * gaodeWeidu =  [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%.9f\"</span>,gaodeLocation.coordinate.latitude];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> * gaodeJingdu =  [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%.9f\"</span>,gaodeLocation.coordinate.longitude];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (regeocode)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"reGeocode:%@\"</span>, regeocode);</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.theRealAdress = regeocode.formattedAddress;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> GetGISInfoByByLocationWithjingdu:gaodeJingdu AndWeidu:gaodeWeidu];</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"}],"tags":[]},{"title":"隐藏导航条底部黑线","slug":"iOS/隐藏导航条底部黑线","date":"2018-03-12T13:51:07.000Z","updated":"2018-03-13T18:00:23.000Z","comments":true,"path":"api/articles/iOS/隐藏导航条底部黑线.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>当需要导航条为透明色，与背景色一体时，需要去除底边线：<br>如下代码：使用空图片设置背景图，并指定bar的样式。</p>\n<pre><code class=\"swift\"><span class=\"keyword\">self</span>.navigationController.navigationBar setBackgroundImage:[<span class=\"type\">UIImage</span> new] forBarMetrics:<span class=\"type\">UIBarMetricsDefault</span>];\n<span class=\"keyword\">self</span>.navigationController.navigationBar.barStyle = <span class=\"type\">UIBarStyleBlackTranslucent</span>;\n</code></pre>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"}],"tags":[]},{"title":"MVVM介绍","slug":"iOS/MVVM介绍","date":"2017-09-24T19:26:28.000Z","updated":"2017-10-02T22:00:42.000Z","comments":true,"path":"api/articles/iOS/MVVM介绍.json","excerpt":null,"keywords":null,"cover":"https://www.objccn.io/images/issues/issue-13/mvvm1.png","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h3><p>所以，MVVM 到底是什么？与其专注于说明 MVVM 的来历，不如让我们看一个典型的 iOS 是如何构建的，并从那里了解 MVVM：</p>\n<p><img src=\"https://www.objccn.io/images/issues/issue-13/mvvm1.png\" alt=\"Typical Model-View-Controller setup\"></p>\n<p>我们看到的是一个典型的 MVC 设置。Model 呈现数据，View 呈现用户界面，而 View Controller 调节它两者之间的交互。</p>\n<p>稍微考虑一下，虽然 View 和 View Controller 是技术上不同的组件，但它们几乎总是手牵手在一起，成对的。你什么时候看到一个 View 能够与不同 View Controller 配对？或者反过来？所以，为什么不正规化它们的连接呢？</p>\n<p><img src=\"https://www.objccn.io/images/issues/issue-13/intermediate.png\" alt=\"Intermediate\"></p>\n<p>这更准确地描述了你可能已经编写的 MVC 代码。但它并没有做太多事情来解决 iOS 应用中日益增长的重量级视图控制器的问题。</p>\n<p>在典型的 MVC 应用里，<em>许多</em>逻辑被放在 View Controller 里。它们中的一些确实属于 View Controller，但更多的是所谓的“表示逻辑（presentation logic）”，以 MVVM 属术语来说，就是那些将 Model 数据转换为 View 可以呈现的东西的事情，例如将一个 <code>NSDate</code> 转换为一个格式化过的 <code>NSString</code>。<br>我们的图解里缺少某些东西，那些使我们可以把所有表示逻辑放进去的东西。我们打算将其称为 “View Model” —— 它位于 View/Controller 与 Model 之间：</p>\n<p><img src=\"https://www.objccn.io/images/issues/issue-13/mvvm.png\" alt=\"Model-View-ViewModel\"></p>\n<p>看起好多了！这个图解准确地描述了什么是 MVVM：一个 MVC 的增强版，我们正式连接了视图和控制器，并将表示逻辑从 Controller 移出放到一个新的对象里，即 View Model。MVVM 听起来很复杂，但它本质上就是一个精心优化的 MVC 架构，而 MVC 你早已熟悉。</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>现在我们知道了<em>什么</em>是 MVVM，但<em>为什么</em>我们会想要去使用它呢？在 iOS 上使用 MVVM 的动机，对我来说，无论如何，就是它能减少 View Controller 的复杂性并使得表示逻辑更易于测试。通过一些例子，我们将看到它如何达到这些目标。</p>\n<p>此处有三个重点是我希望你看完本文能带走的：</p>\n<ul>\n<li>MVVM 可以兼容你当下使用的 MVC 架构。</li>\n<li>MVVM 增加你的应用的可测试性。</li>\n<li>MVVM 配合一个绑定机制效果最好。</li>\n</ul>\n<p>如我们之前所见，MVVM 基本上就是 MVC 的改进版，所以很容易就能看到它如何被整合到现有使用典型 MVC 架构的应用中。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p>让我们看一个简单的 <code>Person</code> Model 以及相应的 View Controller：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Person</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initwithSalutation:(<span class=\"built_in\">NSString</span> *)salutation firstName:(<span class=\"built_in\">NSString</span> *)firstName lastName:(<span class=\"built_in\">NSString</span> *)lastName birthdate:(<span class=\"built_in\">NSDate</span> *)birthdate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *salutation;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *firstName;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *lastName;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSDate</span> *birthdate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>现在我们假设我们有一个 <code>PersonViewController</code> ，在 <code>viewDidLoad</code> 里，只需要基于它的 <code>model</code> 属性设置一些 Label 即可。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.model.salutation.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.nameLabel.text = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@ %@ %@\"</span>, <span class=\"keyword\">self</span>.model.salutation, <span class=\"keyword\">self</span>.model.firstName, <span class=\"keyword\">self</span>.model.lastName];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.nameLabel.text = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@ %@\"</span>, <span class=\"keyword\">self</span>.model.firstName, <span class=\"keyword\">self</span>.model.lastName];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSDateFormatter</span> *dateFormatter = [[<span class=\"built_in\">NSDateFormatter</span> alloc] init];</span><br><span class=\"line\">    [dateFormatter setDateFormat:<span class=\"string\">@\"EEEE MMMM d, yyyy\"</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.birthdateLabel.text = [dateFormatter stringFromDate:model.birthdate];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这全都直截了当，标准的 MVC。现在来看看我们如何用一个 View Model 来增强它。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">PersonViewModel</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithPerson:(Person *)person;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) Person *person;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *nameText;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *birthdateText;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>我们的 View Model 的实现大概如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation PersonViewModel</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithPerson:(Person *)person &#123;</span><br><span class=\"line\">    self = [super init];</span><br><span class=\"line\">    if (!self) return nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    _person = person;</span><br><span class=\"line\">    if (person.salutation.length &gt; 0) &#123;</span><br><span class=\"line\">        _nameText = [NSString stringWithFormat:@&quot;%@ %@ %@&quot;, self.person.salutation, self.person.firstName, self.person.lastName];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        _nameText = [NSString stringWithFormat:@&quot;%@ %@&quot;, self.person.firstName, self.person.lastName];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];</span><br><span class=\"line\">    [dateFormatter setDateFormat:@&quot;EEEE MMMM d, yyyy&quot;];</span><br><span class=\"line\">    _birthdateText = [dateFormatter stringFromDate:person.birthdate];</span><br><span class=\"line\"></span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p>我们已经将 <code>viewDidLoad</code> 中的表示逻辑放入我们的 View Model 里了。此时，我们新的 <code>viewDidLoad</code> 就会非常轻量：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.nameLabel.text = <span class=\"keyword\">self</span>.viewModel.nameText;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.birthdateLabel.text = <span class=\"keyword\">self</span>.viewModel.birthdateText;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>所以，如你所见，并没有对我们的 MVC 架构做太多改变。还是同样的代码，只不过移动了位置。它与 MVC 兼容，带来<a href=\"http://objccn.io/issue-1/\" target=\"_blank\" rel=\"noopener\">更轻量的 View Controllers</a>。</p>\n<h3 id=\"可测试\"><a href=\"#可测试\" class=\"headerlink\" title=\"可测试\"></a>可测试</h3><p>View Controller 是出了名的难以测试，因为它们做了太多事情。在 MVVM 里，我们试着尽可能多的将代码移入 View Model 里。测试 View Controller 就变得容易多了，因为它们不再做一大堆事情，并且 View Model 也非常易于测试。让我们来看看：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SpecBegin(Person)</span><br><span class=\"line\">NSString *salutation = @&quot;Dr.&quot;;</span><br><span class=\"line\">NSString *firstName = @&quot;first&quot;;</span><br><span class=\"line\">NSString *lastName = @&quot;last&quot;;</span><br><span class=\"line\">NSDate *birthdate = [NSDate dateWithTimeIntervalSince1970:0];</span><br><span class=\"line\"></span><br><span class=\"line\">it (@&quot;should use the salutation available. &quot;, ^&#123;</span><br><span class=\"line\">    Person *person = [[Person alloc] initWithSalutation:salutation firstName:firstName lastName:lastName birthdate:birthdate];</span><br><span class=\"line\">    PersonViewModel *viewModel = [[PersonViewModel alloc] initWithPerson:person];</span><br><span class=\"line\">    expect(viewModel.nameText).to.equal(@&quot;Dr. first last&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">it (@&quot;should not use an unavailable salutation. &quot;, ^&#123;</span><br><span class=\"line\">    Person *person = [[Person alloc] initWithSalutation:nil firstName:firstName lastName:lastName birthdate:birthdate];</span><br><span class=\"line\">    PersonViewModel *viewModel = [[PersonViewModel alloc] initWithPerson:person];</span><br><span class=\"line\">    expect(viewModel.nameText).to.equal(@&quot;first last&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">it (@&quot;should use the correct date format. &quot;, ^&#123;</span><br><span class=\"line\">    Person *person = [[Person alloc] initWithSalutation:nil firstName:firstName lastName:lastName birthdate:birthdate];</span><br><span class=\"line\">    PersonViewModel *viewModel = [[PersonViewModel alloc] initWithPerson:person];</span><br><span class=\"line\">    expect(viewModel.birthdateText).to.equal(@&quot;Thursday January 1, 1970&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">SpecEnd</span><br></pre></td></tr></table></figure></p>\n<p>如果我们没有将这个逻辑移入 View Model，我们将不得不实例化一个完整的 View Controller 以及伴随的 View，然后去比较我们 View 中 Label 的值。这样做不只是会变成一个麻烦的间接层，而且它只代表了一个十分脆弱的测试。现在，我们可以按意愿自由地修改视图层级而不必担心破坏我们的单元测试。使用 MVVM 带来的对于测试的好处非常清晰，甚至从这个简单的例子来看也可见一斑，而在有更复杂的表示逻辑的情况下，这个好处会更加明显。</p>\n<h3 id=\"响应式同步\"><a href=\"#响应式同步\" class=\"headerlink\" title=\"响应式同步\"></a>响应式同步</h3><p>注意到在这个简单的例子中， Model 是不可变的，所以我们可以只在初始化的时候指定我们 View Model 的属性。对于可变 Model，我们还需要使用一些绑定机制，这样 View Model 就能在背后的 Model 改变时更新自身的属性。此外，一旦 View Model 上的 Model 发生改变，那 View 的属性也需要更新。Model 的改变应该级联向下通过 View Model 进入 View。</p>\n<p>在 OS X 上，我们可以使用 Cocoa 绑定，但在 iOS 上我们并没有这样好的配置可用。我们想到了 KVO（Key-Value Observation），而且它确实做了很伟大的工作。然而，对于一个简单的绑定都需要很大的样板代码，更不用说有许多属性需要绑定了。作为替代，我个人喜欢使用 ReactiveCocoa，但 MVVM 并未强制我们使用 ReactiveCocoa。MVVM 是一个伟大的典范，它自身独立，只是在有一个良好的绑定框架时做得更好。</p>\n<p>我们覆盖了不少内容：从普通的 MVC 派生出 MVVM，看它们是如何相兼容的范式，从一个可测试的例子观察 MVVM，并看到 MVVM 在有一个配对的绑定机制时工作得更好。如果你有兴趣学习更多关于 MVVM 的知识，你可以看看<a href=\"http://www.teehanlax.com/blog/model-view-viewmodel-for-ios/\" target=\"_blank\" rel=\"noopener\">这篇博客</a>，它用更多细节解释了 MVVM 的好处，或者<a href=\"http://www.teehanlax.com/blog/krush-ios-architecture/\" target=\"_blank\" rel=\"noopener\">这一篇</a>关于我们如何在最近的项目里使用 MVVM 获得巨大的成功的文章。我同样还有一个经过完整测试，基于 MVVM 的应用，叫做 <a href=\"https://github.com/AshFurrow/C-41\" target=\"_blank\" rel=\"noopener\">C-41</a> ，它是开源的。去看看吧，如果你有任何疑问，请<a href=\"https://twitter.com/ashfurrow\" target=\"_blank\" rel=\"noopener\">告诉我</a>。</p>\n<hr>\n<p><a href=\"http://objccn.io/issue-13\" target=\"_blank\" rel=\"noopener\">话题 #13 下的更多文章</a></p>\n<p>原文 <a href=\"http://www.objc.io/issue-13/mvvm.html\" target=\"_blank\" rel=\"noopener\">Introduction to MVVM</a></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"设计","path":"api/categories/设计.json"}],"tags":[]},{"title":"线程安全类的设计","slug":"iOS/线程安全类的设计","date":"2017-09-24T19:06:03.000Z","updated":"2017-09-24T19:06:03.000Z","comments":true,"path":"api/articles/iOS/线程安全类的设计.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>这篇文章将专注于实用技巧，设计模式，以及对于写出线程安全类和使用 GCD 来说所特别需要注意的一些<a href=\"http://zh.wikipedia.org/wiki/反面模式\" target=\"_blank\" rel=\"noopener\">反面模式</a>。</p>\n<h2 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h2><h3 id=\"Apple-的框架\"><a href=\"#Apple-的框架\" class=\"headerlink\" title=\"Apple 的框架\"></a>Apple 的框架</h3><p>首先让我们来看看 Apple 的框架。一般来说除非特别声明，大多数的类默认都不是线程安全的。对于其中的一些类来说，这是很合理的，但是对于另外一些来说就很有趣了。</p>\n<p>就算是在经验丰富的 iOS/Mac 开发者，也难免会犯从后台线程去访问 UIKit/AppKit 这种错误。比如因为图片的内容本身就是从后台的网络请求中获取的话，顺手就在后台线程中设置了 <code>image</code> 之类的属性，这样的错误其实是屡见不鲜的。Apple 的代码都经过了性能的优化，所以即使你从别的线程设置了属性的时候，也不会产生什么警告。</p>\n<p>在设置图片这个例子中，症结其实是你的改变通常要过一会儿才能生效。但是如果有两个线程在同时对图片进行了设定，那么很可能因为当前的图片被释放两次，而导致应用崩溃。这种行为是和时机有关系的，所以很可能在开发阶段没有崩溃，但是你的用户使用时却不断 crash。</p>\n<p>现在没有<strong>官方</strong>的用来寻找类似错误的工具，但我们确实有一些技巧来避免这个问题。<a href=\"https://gist.github.com/steipete/5664345\" target=\"_blank\" rel=\"noopener\">UIKit Main Thread Guard</a> 是一段用来监视每一次对 <code>setNeedsLayout</code> 和 <code>setNeedsDisplay</code> 的调用代码，并检查它们是否是在主线程被调用的。因为这两个方法在 UIKit 的 setter （包括 image 属性）中广泛使用，所以它可以捕获到很多线程相关的错误。虽然这个小技巧并不包含任何私有 API， 但我们还是不建议将它是用在发布产品中，不过在开发过程中使用的话还是相当赞的。</p>\n<p>Apple没有把 UIKit 设计为线程安全的类是有意为之的，将其打造为线程安全的话会使很多操作变慢。而事实上 UIKit 是和主线程绑定的，这一特点使得编写并发程序以及使用 UIKit 十分容易的，你唯一需要确保的就是对于 UIKit 的调用总是在主线程中来进行。</p>\n<h4 id=\"为什么-UIKit-不是线程安全的？\"><a href=\"#为什么-UIKit-不是线程安全的？\" class=\"headerlink\" title=\"为什么 UIKit 不是线程安全的？\"></a>为什么 UIKit 不是线程安全的？</h4><p>对于一个像 UIKit 这样的大型框架，确保它的线程安全将会带来巨大的工作量和成本。将 non-atomic 的属性变为 atomic 的属性只不过是需要做的变化里的微不足道的一小部分。</p>\n<ol>\n<li>通常来说，UI需要同时改变若干个属性，才能看到它所带来的结果。为了解决这个问题，苹果可能不得不提供像 Core Data 中的 <code>performBlock:</code> 和 <code>performBlockAndWait:</code> 那样类似的方法来同步变更。</li>\n<li>绝大多数对 UIKit 类的调用其实都是以<strong>配置</strong>为目的的，这使得将 UIKit 改为线程安全这件事情更显得毫无意义了。</li>\n</ol>\n<p>然而即使是那些与配置共享的内部状态之类事情无关的调用，其实也不是线程安全的。如果你做过 iOS 3.2 或之前的黑暗年代的 app 开发的话，你肯定有过一边在后台准备图像时一边使用 NSString 的 <code>drawInRect:withFont:</code> 时的随机崩溃的经历。值得庆幸的事，在 iOS 4 中 <a href=\"http://developer.apple.com/library/ios/#releasenotes/General/WhatsNewIniOS/Articles/iPhoneOS4.html\" target=\"_blank\" rel=\"noopener\">苹果将大部分绘图的方法和诸如 <code>UIColor</code> 和 <code>UIFont</code> 这样的类改写为了后台线程可用</a>。</p>\n<p>但不幸的是 Apple 在线程安全方面的文档是极度匮乏的。他们推荐只访问主线程，并且甚至是绘图方法他们都没有明确地表示保证线程安全。因此在阅读文档的同时，去读读 <a href=\"http://developer.apple.com/library/ios/#releasenotes/General/WhatsNewIniOS/Articles/iPhoneOS4.html\" target=\"_blank\" rel=\"noopener\">iOS 版本更新说明</a>会是一个很好的选择。</p>\n<p>对于大多数情况来说，UIKit 类确实只应该用在应用的主线程中。这对于那些继承自 UIResponder 的类以及那些操作你的应用的用户界面的类来说，不管如何都是很正确的。</p>\n<h4 id=\"内存回收-deallocation-问题\"><a href=\"#内存回收-deallocation-问题\" class=\"headerlink\" title=\"内存回收 (deallocation) 问题\"></a>内存回收 (deallocation) 问题</h4><p>另一个在后台使用 UIKit 对象的的危险之处在于“内存回收问题”。Apple 在技术笔记 <a href=\"http://developer.apple.com/library/ios/#technotes/tn2109/_index.html\" target=\"_blank\" rel=\"noopener\">TN2109</a> 中概述了这个问题，并提供了多种解决方案。<br>这个问题其实是要求 UI 对象应该在主线程中被回收，因为在它们的 <code>dealloc</code> 方法被调用回收的时候，可能会去改变 view 的结构关系，而如我们所知，这种操作应该放在主线程来进行。</p>\n<p>因为调用者被其他线程持有是非常常见的（不管是由于 operation 还是 block 所导致的），这也是很容易犯错并且难以被修正的问题。在 <a href=\"https://github.com/AFNetworking/AFNetworking/issues/56\" target=\"_blank\" rel=\"noopener\">AFNetworking 中也一直长久存在这样的 bug</a>，但是由于其自身的隐蔽性而鲜为人知，也很难重现其所造成的崩溃。在异步的 block 或者操作中一致使用 <code>__weak</code>，并且不去直接访问局部变量会对避开这类问题有所帮助。</p>\n<h4 id=\"集合类\"><a href=\"#集合类\" class=\"headerlink\" title=\"集合类\"></a>集合类</h4><p>Apple 有一个<a href=\"https://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-SW1\" target=\"_blank\" rel=\"noopener\">针对 iOS 和 Mac 的很好的总览性文档</a>，为大多数基本的 foundation 类列举了其线程安全特性。<br>总的来说，比如 <code>NSArry</code> 这样不可变类是线程安全的。然而它们的可变版本，比如 <code>NSMutableArray</code> 是线程不安全的。<br>事实上，如果是在一个队列中串行地进行访问的话，在不同线程中使用它们也是没有问题的。要记住的是即使你申明了返回类型是不可变的，方法里还是有可能返回的其实是一个可变版本的集合类。<br>一个好习惯是写类似于 <code>return [array copy]</code> 这样的代码来确保返回的对象事实上是不可变对象。</p>\n<p>与和<a href=\"\">Java</a>这样的语言不一样，Foundation 框架并不提供直接可用的集合类，这是有其道理的，因为大多数情况下，你想要的是在更高层级上的锁，以避免太多的加解锁操作。但缓存是一个值得注意的例外，iOS 4 中 Apple 添加的 <code>NSCache</code> 使用一个可变的字典来存储不可变数据，它不仅会对访问加锁，更甚至在低内存情况下会清空自己的内容。</p>\n<p>也就是说，在你的应用中存在可变的且线程安全的字典是可以做到的。借助于 class cluster 的方式，我们也很容易<a href=\"https://gist.github.com/steipete/5928916\" target=\"_blank\" rel=\"noopener\">写出这样的代码</a>。</p>\n<h3 id=\"原子属性-Atomic-Properties\"><a href=\"#原子属性-Atomic-Properties\" class=\"headerlink\" title=\"原子属性 (Atomic Properties)\"></a>原子属性 (Atomic Properties)</h3><p>你曾经好奇过 Apple 是怎么处理 atomic 的设置/读取属性的么？至今为止，你可能听说过自旋锁 (spinlocks)，信标 (semaphores)，锁 (locks)，@synchronized 等，Apple 用的是什么呢？因为 <a href=\"http://www.opensource.apple.com/source/objc4/\" target=\"_blank\" rel=\"noopener\">Objctive-C 的 runtime 是开源</a>的，所以我们可以一探究竟。</p>\n<p>一个非原子的 setter 看起来是这个样子的：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setUserName:(<span class=\"built_in\">NSString</span> *)userName &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (userName != _userName) &#123;</span><br><span class=\"line\">        [userName <span class=\"keyword\">retain</span>];</span><br><span class=\"line\">        [_userName release];</span><br><span class=\"line\">        _userName = userName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这是一个手动 retain/release 的版本，ARC 生成的代码和这个看起来也是类似的。当我们看这段代码时，显而易见要是 <code>setUserName:</code> 被并发调用的话会造成麻烦。我们可能会释放 <code>_userName</code> 两次，这回使内存错误，并且导致难以发现的 bug。</p>\n<p>对于任何没有手动实现的属性，编译器都会生成一个 <a href=\"https://github.com/opensource-apple/objc4/blob/master/runtime/Accessors.subproj/objc-accessors.mm#L127\" target=\"_blank\" rel=\"noopener\"><code>objc_setProperty_non_gc(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy)</code></a> 的调用。在我们的例子中，这个调用的参数是这样的：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_setProperty_non_gc(<span class=\"keyword\">self</span>, _cmd,</span><br><span class=\"line\">(ptrdiff_t)(&amp;_userName) - (ptrdiff_t)(<span class=\"keyword\">self</span>), userName, <span class=\"literal\">NO</span>, <span class=\"literal\">NO</span>);`</span><br></pre></td></tr></table></figure></p>\n<p><code>ptrdiff_t</code> 可能会吓到你，但是实际上这就是一个简单的指针算术，因为其实 Objective-C 的类仅仅只是 C 结构体而已。</p>\n<p><code>objc_setProperty</code> 调用的是如下方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static inline void reallySetProperty(id self, SEL _cmd, id newValue,</span><br><span class=\"line\">ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    id oldValue;</span><br><span class=\"line\">    id *slot = (id*) ((char*)self + offset);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (copy) &#123;</span><br><span class=\"line\">        newValue = [newValue copyWithZone:NULL];</span><br><span class=\"line\">    &#125; else if (mutableCopy) &#123;</span><br><span class=\"line\">        newValue = [newValue mutableCopyWithZone:NULL];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        if (*slot == newValue) return;</span><br><span class=\"line\">        newValue = objc_retain(newValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!atomic) &#123;</span><br><span class=\"line\">        oldValue = *slot;</span><br><span class=\"line\">        *slot = newValue;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        spin_lock_t *slotlock = &amp;PropertyLocks[GOODHASH(slot)];</span><br><span class=\"line\">        _spin_lock(slotlock);</span><br><span class=\"line\">        oldValue = *slot;</span><br><span class=\"line\">        *slot = newValue;</span><br><span class=\"line\">        _spin_unlock(slotlock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    objc_release(oldValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>除开方法名字很有趣以外，其实方法实际做的事情非常直接，它使用了在 <code>PropertyLocks</code> 中的 128 个自旋锁中的 1 个来给操作上锁。这是一种务实和快速的方式，最糟糕的情况下，如果遇到了哈希碰撞，那么 setter 需要等待另一个和它无关的 setter 完成之后再进行工作。</p>\n<p>虽然这些方法没有定义在任何公开的头文件中，但我们还是可用手动调用他们。我不是说这是一个好的做法，但是知道这个还是蛮有趣的，而且如果你想要同时实现原子属性<strong>和</strong>自定义的 setter 的话，这个技巧就非常有用了。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 手动声明运行时的方法</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> objc_setProperty(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, ptrdiff_t offset,</span><br><span class=\"line\"><span class=\"keyword\">id</span> newValue, <span class=\"built_in\">BOOL</span> atomic, <span class=\"built_in\">BOOL</span> shouldCopy);</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">id</span> objc_getProperty(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, ptrdiff_t offset,</span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> atomic);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#define PSTAtomicRetainedSet(dest, src) objc_setProperty(self, _cmd,</span></span><br><span class=\"line\">(ptrdiff_t)(&amp;dest) - (ptrdiff_t)(<span class=\"keyword\">self</span>), src, <span class=\"literal\">YES</span>, <span class=\"literal\">NO</span>)</span><br><span class=\"line\"><span class=\"meta\">#define PSTAtomicAutoreleasedGet(src) objc_getProperty(self, _cmd,</span></span><br><span class=\"line\">(ptrdiff_t)(&amp;src) - (ptrdiff_t)(<span class=\"keyword\">self</span>), <span class=\"literal\">YES</span>)</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://gist.github.com/steipete/5928690\" target=\"_blank\" rel=\"noopener\">参考这个 gist</a> 来获取包含处理结构体的完整的代码，但是我们其实并不推荐使用它。</p>\n<h4 id=\"为何不用-synchronized-？\"><a href=\"#为何不用-synchronized-？\" class=\"headerlink\" title=\"为何不用 @synchronized ？\"></a>为何不用 @synchronized ？</h4><p>你也许会想问为什么苹果不用 <code>@synchronized(self)</code> 这样一个已经存在的运行时特性来锁定属？？你可以看看<a href=\"https://github.com/opensource-apple/objc4/blob/master/runtime/objc-sync.mm#L291\" target=\"_blank\" rel=\"noopener\">这里的源码</a>，就会发现其实发生了很多的事情。Apple 使用了<a href=\"http://googlemac.blogspot.co.at/2006/10/synchronized-swimming.html\" target=\"_blank\" rel=\"noopener\">最多三个加/解锁序列</a>，还有一部分原因是他们也添加了<a href=\"https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW3\" target=\"_blank\" rel=\"noopener\">异常开解(exception unwinding)</a>机制。相比于更快的自旋锁方式，这种实现要慢得多。由于设置某个属性一般来说会相当快，因此自旋锁更适合用来完成这项工作。<code>@synchonized(self)</code> 更适合使用在你需要确保在发生错误时代码不会死锁，而是抛出异常的时候。</p>\n<h3 id=\"你自己的类\"><a href=\"#你自己的类\" class=\"headerlink\" title=\"你自己的类\"></a>你自己的类</h3><p>单独使用原子属性并不会使你的类变成线程安全。它不能保护你应用的逻辑，只能保护你免于在 setter 中遭遇到<a href=\"http://objccn.io/issue-3-1\" target=\"_blank\" rel=\"noopener\">竞态条件</a>的困扰。看看下面的代码片段：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.contents) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFAttributedStringRef</span> stringRef = <span class=\"built_in\">CFAttributedStringCreate</span>(<span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    (__bridge <span class=\"built_in\">CFStringRef</span>)<span class=\"keyword\">self</span>.contents, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 渲染字符串</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我之前在 <a href=\"http://pspdfkit.com\" target=\"_blank\" rel=\"noopener\">PSPDFKit</a> 中就犯了这个错误。时不时地应用就会因为 <code>contents</code> 属性在通过检查之后却又被设成了 nil 而导致 EXC_BAD_ACCESS 崩溃。捕获这个变量就可以简单修复这个问题；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSString *contents = self.contents;</span><br><span class=\"line\">if (contents) &#123;</span><br><span class=\"line\">    CFAttributedStringRef stringRef = CFAttributedStringCreate(NULL,</span><br><span class=\"line\">    (__bridge CFStringRef)contents, NULL);</span><br><span class=\"line\">    // 渲染字符串</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这里这样就能解决问题，但是大多数情况下不会这么简单。<br>想象一下我们还有一个 <code>textColor</code> 的属性，我们在一个线程中将两个属性都做了改变。我们的渲染线程有可能使用了新的内容，但是依旧保持了旧的颜色，于是我们得到了一组奇怪的组合。这其实也是为什么 Core Data 要将 model 对象都绑定在一个线程或者队列中的原因。</p>\n<p>对于这个问题，其实没有万用解法。使用 <a href=\"http://www.cocoawithlove.com/2008/04/value-of-immutable-values.html\" target=\"_blank\" rel=\"noopener\">不可变模型</a>是一个可能的方案，但是它也有自己的问题。另一种途径是限制对存在在主线程或者某个特定队列中的既存对象的改变，而是先进行一次拷贝之后再在工作线程中使用。对于这个问题的更多对应方法，我推荐阅读 Jonathan Sterling 的关于 <a href=\"http://www.jonmsterling.com/posts/2012-12-27-a-pattern-for-immutability.html\" target=\"_blank\" rel=\"noopener\">Objective-C 中轻量化不可变对象</a>的文章。</p>\n<p>一个简单的解决办法是使用 <code>@synchronize</code>。其他的方式都非常非常可能使你误入歧途，已经有太多聪明人在这种尝试上一次又一次地以失败告终。</p>\n<h4 id=\"可行的线程安全设计\"><a href=\"#可行的线程安全设计\" class=\"headerlink\" title=\"可行的线程安全设计\"></a>可行的线程安全设计</h4><p>在尝试写一些线程安全的东西之前，应该先想清楚是不是真的需要。确保你要做的事情不会是过早优化。如果要写的东西是一个类似配置类 (configuration class) 的话，去考虑线程安全这种事情就毫无意义了。更正确的做法是扔一个断言上去，以保证它被正确地使用：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> PSPDFAssertIfNotMainThread(<span class=\"keyword\">void</span>) &#123;</span><br><span class=\"line\"><span class=\"built_in\">NSAssert</span>(<span class=\"built_in\">NSThread</span>.isMainThread,</span><br><span class=\"line\"><span class=\"string\">@\"Error: Method needs to be called on the main thread. %@\"</span>,</span><br><span class=\"line\">[<span class=\"built_in\">NSThread</span> callStackSymbols]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对于那些肯定应该线程安全的代码（一个好例子是负责缓存的类）来说，一个不错的设计是使用并发的 <code>dispatch_queue</code> 作为读/写锁，并且确保只锁着那些真的需要被锁住的部分，以此来最大化性能。一旦你使用多个队列来给不同的部分上锁的话，整件事情很快就会变得难以控制了。</p>\n<p>于是你也可以重新组织你的代码，这样某些特定的锁就不再需要了。看看下面这段实现了一种多委托的代码（其实在大多数情况下，用 NSNotifications 会更好，但是其实也还是有<a href=\"https://code.google.com/r/riky-adsfasfasf/source/browse/Utilities/GCDMulticastDelegate.h\" target=\"_blank\" rel=\"noopener\">多委托的实用例子</a>）的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 头文件</span><br><span class=\"line\">@property (nonatomic, strong) NSMutableSet *delegates;</span><br><span class=\"line\"></span><br><span class=\"line\">// init方法中</span><br><span class=\"line\">_delegateQueue = dispatch_queue_create(&quot;com.PSPDFKit.cacheDelegateQueue&quot;,</span><br><span class=\"line\">DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)addDelegate:(id&lt;PSPDFCacheDelegate&gt;)delegate &#123;</span><br><span class=\"line\">    dispatch_barrier_async(_delegateQueue, ^&#123;</span><br><span class=\"line\">        [self.delegates addObject:delegate];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)removeAllDelegates &#123;</span><br><span class=\"line\">    dispatch_barrier_async(_delegateQueue, ^&#123;</span><br><span class=\"line\">        self.delegates removeAllObjects];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)callDelegateForX &#123;</span><br><span class=\"line\">    dispatch_sync(_delegateQueue, ^&#123;</span><br><span class=\"line\">        [self.delegates enumerateObjectsUsingBlock:^(id&lt;PSPDFCacheDelegate&gt; delegate, NSUInteger idx, BOOL *stop) &#123;</span><br><span class=\"line\">            // 调用delegate</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>除非 <code>addDelegate:</code> 或者 <code>removeDelegate:</code> 每秒要被调用上千次，否则我们可以使用一个相对简洁的实现方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 头文件</span><br><span class=\"line\">@property (atomic, copy) NSSet *delegates;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)addDelegate:(id&lt;PSPDFCacheDelegate&gt;)delegate &#123;</span><br><span class=\"line\">    @synchronized(self) &#123;</span><br><span class=\"line\">        self.delegates = [self.delegates setByAddingObject:delegate];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)removeAllDelegates &#123;</span><br><span class=\"line\">    @synchronized(self) &#123;</span><br><span class=\"line\">        self.delegates = nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)callDelegateForX &#123;</span><br><span class=\"line\">    [self.delegates enumerateObjectsUsingBlock:^(id&lt;PSPDFCacheDelegate&gt; delegate, NSUInteger idx, BOOL *stop) &#123;</span><br><span class=\"line\">        // 调用delegate</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>就算这样，这个例子还是有点理想化，因为其他人可以把变更限制在主线程中。但是对于很多数据结构，可以在可变更操作的方法中创建不可变的拷贝，这样整体的代码逻辑上就不再需要处理过多的锁了。</p>\n<h2 id=\"GCD-的陷阱\"><a href=\"#GCD-的陷阱\" class=\"headerlink\" title=\"GCD 的陷阱\"></a>GCD 的陷阱</h2><p>对于大多数上锁的需求来说，GCD 就足够好了。它简单迅速，并且基于 block 的 API 使得粗心大意造成非平衡锁操作的概率下降了不少。然后，GCD 中还是有不少陷阱，我们在这里探索一下其中的一些。</p>\n<h3 id=\"将-GCD-当作递归锁使用\"><a href=\"#将-GCD-当作递归锁使用\" class=\"headerlink\" title=\"将 GCD 当作递归锁使用\"></a>将 GCD 当作递归锁使用</h3><p>GCD 是一个对共享资源的访问进行串行化的队列。这个特性可以被当作锁来使用，但实际上它和 <code>@synchronized</code> 有很大区别。 GCD队列并非是<a href=\"http://zh.wikipedia.org/w/index.php?title=可重入&amp;variant=zh-cn\" target=\"_blank\" rel=\"noopener\">可重入</a>的，因为这将破坏队列的特性。很多有试图使用 <code>dispatch_get_current_queue()</code> 来绕开这个限制，但是这是一个<a href=\"https://gist.github.com/steipete/3713233\" target=\"_blank\" rel=\"noopener\">糟糕的做法</a>，Apple 在 iOS6 中将这个方法标记为废弃，自然也是有自己的理由。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This is a bad idea.</span><br><span class=\"line\">inline void pst_dispatch_sync_reentrant(dispatch_queue_t queue,</span><br><span class=\"line\">dispatch_block_t block)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dispatch_get_current_queue() == queue ? block() : dispatch_sync(queue, block);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对当前的队列进行测试也许在简单情况下可以行得通，但是一旦你的代码变得复杂一些，并且你可能有多个队列在同时被锁住的情况下，这种方法很快就悲剧了。一旦这种情况发生，几乎可以肯定的是你会遇到<a href=\"http://objccn.io/issue-2-1/#dead_locks\" target=\"_blank\" rel=\"noopener\">死锁</a>。当然，你可以使用 <code>dispatch_get_specific()</code>，这将截断整个队列结构，从而对某个特定的队列进行测试。要这么做的话，你还得为了在队列中附加标志队列的元数据，而去写自定义的队列构造函数。嘛，最好别这么做。其实在实用中，使用 <code>NSRecursiveLock</code> 会是一个更好的选择。</p>\n<h3 id=\"用-dispatch-async-修复时序问题\"><a href=\"#用-dispatch-async-修复时序问题\" class=\"headerlink\" title=\"用 dispatch_async 修复时序问题\"></a>用 dispatch_async 修复时序问题</h3><p>在使用 UIKit 的时候遇到了一些时序上的麻烦？很多时候，这样进行“修正”看来非常完美：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Some UIKit call that had timing issues but works fine</span></span><br><span class=\"line\">    <span class=\"comment\">// in the next runloop.</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> updatePopoverSize];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>千万别这么做！相信我，这种做法将会在之后你的 app 规模大一些的时候让你找不着北。这种代码非常难以调试，并且你很快就会陷入用更多的 dispatch 来修复所谓的莫名其妙的”时序问题”。审视你的代码，并且找到合适的地方来进行调用（比如在 viewWillAppear 里调用，而不是 viewDidLoad 之类的）才是解决这个问题的正确做法。我在自己的代码中也还留有一些这样的 hack，但是我为它们基本都做了正确的文档工作，并且对应的 issue 也被一一记录过。</p>\n<p>记住这不是真正的 GCD 特性，而只是一个在 GCD 下很容易实现的常见反面模式。事实上你可以使用 <code>performSelector:afterDelay:</code> 方法来实现同样的操作，其中 delay 是在对应时间后的 runloop。</p>\n<h3 id=\"在性能关键的代码中混用-dispatch-sync-和-dispatch-async\"><a href=\"#在性能关键的代码中混用-dispatch-sync-和-dispatch-async\" class=\"headerlink\" title=\"在性能关键的代码中混用 dispatch_sync 和 dispatch_async\"></a>在性能关键的代码中混用 dispatch_sync 和 dispatch_async</h3><p>这个问题我花了好久来研究。在 <a href=\"http://pspdfkit.com\" target=\"_blank\" rel=\"noopener\">PSPDFKit</a> 中有一个使用了 LRU（最久未使用）算法列表的缓存类来记录对图片的访问。当你在页面中滚动时，这个方法将被调用<strong>非常多次</strong>。最初的实现使用了 <code>dispatch_sync</code> 来进行实际有效的访问，使用 <code>dispatch_async</code> 来更新 LRU 列表的位置。这导致了帧数远低于原来的 60 帧的目标。</p>\n<p>当你的 app 中的其他运行的代码阻挡了 GCD 线程的时候，dispatch manager 需要花时间去寻找能够执行 dispatch_async 代码的线程，这有时候会花费一点时间。在找到合适的执行线程之前，你的同步调用就会被 block 住了。其实在这个例子中，异步情况的执行顺序并不是很重要，但没有能将这件事情告诉 GCD 的好办法。读/写锁这里并不能起到什么作用，因为在异步操作中基本上一定会需要进行顺序写入，而在此过程中读操作将被阻塞住。如果误用了 <code>dispatch_async</code> 代价将会是非常惨重的。在将它用作锁的时候，一定要非常小心。</p>\n<h3 id=\"使用-dispatch-async-来派发内存敏感的操作\"><a href=\"#使用-dispatch-async-来派发内存敏感的操作\" class=\"headerlink\" title=\"使用 dispatch_async 来派发内存敏感的操作\"></a>使用 dispatch_async 来派发内存敏感的操作</h3><p>我们已经谈论了很多关于 NSOperations 的话题了，一般情况下，使用这个更高层级的 API 会是一个好主意。当你要处理一段内存敏感的操作的代码块时，这个优势尤为突出、</p>\n<p>在 PSPDFKit 的老版本中，我用了 GCD 队列来将已缓存的 JPG 图片写到磁盘中。当 retina 的 iPad 问世之后，这个操作出现了问题。ß因为分辨率翻倍了，相比渲染这张图片，将它编码花费的时间要长得多。所以，操作堆积在了队列中，当系统繁忙时，甚至有可能因为内存耗尽而崩溃。</p>\n<p>我们没有办法追踪有多少个操作在队列中等待运行（除非你手动添加了追踪这个的代码），我们也没有现成的方法来在接收到低内存通告的时候来取消操作、这时候，切换到 NSOperations 可以使代码变得容易调试得多，并且允许我们在不添加手动管理的代码的情况下，做到对操作的追踪和取消。</p>\n<p>当然也有一些不好的地方，比如你不能在你的 <code>NSOperationQueue</code> 中设置目标队列（就像 <code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code> 之于 缓速 I/O 那样）。但这只是为了可调试性的一点小代价，而事实上这也帮助你避免遇到<a href=\"http://objccn.io/issue-2-1/#priority_inversion\" target=\"_blank\" rel=\"noopener\">优先级反转</a>的问题。我甚至不推荐直接使用已经包装好的 <code>NSBlockOperation</code> 的 API，而是建议使用一个 NSOperation 的真正的子类，包括实现其 description。诚然，这样做工作量会大一些，但是能输出所有运行中/准备运行的操作是及其有用的。</p>\n<hr>\n<p><a href=\"http://objccn.io/issue-2\" target=\"_blank\" rel=\"noopener\">话题 #2 下的更多文章</a></p>\n<p>原文 <a href=\"http://www.objc.io/issue-2/thread-safe-class-design.html\" target=\"_blank\" rel=\"noopener\">Thread-Safe Class Design</a></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"设计","path":"api/categories/设计.json"}],"tags":[]},{"title":"GCD底层并发API","slug":"iOS/GCD底层并发API","date":"2017-09-24T18:21:38.000Z","updated":"2017-09-24T18:21:38.000Z","comments":true,"path":"api/articles/iOS/GCD底层并发API.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>这篇文章里，我们将会讨论一些 iOS 和 OS X 都可以使用的底层 API。除了 <code>dispatch_once</code> ，我们一般不鼓励使用其中的任何一种技术。</p>\n<p>但是我们想要揭示出表面之下深层次的一些可利用的方面。这些底层的 API 提供了大量的灵活性，随之而来的是大量的复杂度和更多的责任。在我们的文章<a href=\"http://objccn.io/issue-2-2/\" target=\"_blank\" rel=\"noopener\">常见的后台实践</a>中提到的高层的 API 和模式能够让你专注于手头的任务并且免于大量的问题。通常来说，高层的 API 会提供更好的性能，除非你能承受起使用底层 API 带来的纠结于调试代码的时间和努力。</p>\n<p>尽管如此，了解深层次下的软件堆栈工作原理还是有很有帮助的。我们希望这篇文章能够让你更好的了解这个平台，同时，让你更加感谢这些高层的 API。</p>\n<p>首先，我们将会分析大多数组成 <em>Grand Central Dispatch</em> 的部分。它已经存在了好几年，并且苹果公司持续添加功能并且改善它。现在苹果已经将其开源，这意味着它对其他平台也是可用的了。最后，我们将会看一下<a href=\"#atomic_operations\">原子操作</a>——另外的一种底层代码块的集合。</p>\n<p>或许关于并发编程最好的书是 <em>M. Ben-Ari</em> 写的《Principles of Concurrent Programming》,<a href=\"https://en.wikipedia.org/wiki/Special:BookSources/0-13-701078-8\" target=\"_blank\" rel=\"noopener\">ISBN 0-13-701078-8</a>。如果你正在做任何与并发编程有关的事情，你需要读一下这本书。这本书已经30多年了，仍然非常卓越。书中简洁的写法，优秀的例子和练习，带你领略并发编程中代码块的基本原理。这本书现在已经绝版了，但是它的一些复印版依然广为流传。有一个新版书，名字叫《Principles of Concurrent and Distributed Programming》,<a href=\"https://en.wikipedia.org/wiki/Special:BookSources/0-321-31283-X\" target=\"_blank\" rel=\"noopener\">ISBN 0-321-31283-X</a>,好像有很多相同的地方，不过我还没有读过。</p>\n<h2 id=\"常用的GCD\"><a href=\"#常用的GCD\" class=\"headerlink\" title=\"常用的GCD\"></a>常用的GCD</h2><h3 id=\"单例：dispatch-once\"><a href=\"#单例：dispatch-once\" class=\"headerlink\" title=\"单例：dispatch_once\"></a>单例：dispatch_once</h3><p>或许GCD中使用最多并且被滥用功能的就是 <code>dispatch_once</code> 了。正确的用法看起来是这样的：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">UIColor</span> *)boringColor;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">UIColor</span> *color;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        color = [<span class=\"built_in\">UIColor</span> colorWithRed:<span class=\"number\">0.380</span>f green:<span class=\"number\">0.376</span>f blue:<span class=\"number\">0.376</span>f alpha:<span class=\"number\">1.000</span>f];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> color;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的 block 只会运行一次。并且在连续的调用中，这种检查是很高效的。你能使用它来初始化全局数据比如单例。要注意的是，使用 <code>dispatch_once_t</code> 会使得测试变得非常困难（单例和测试不是很好配合）。</p>\n<p>要确保 <code>onceToken</code> 被声明为 <code>static</code> ，或者有全局作用域。任何其他的情况都会导致无法预知的行为。换句话说，<strong>不要</strong>把 <code>dispatch_once_t</code> 作为一个对象的成员变量，或者类似的情形。</p>\n<p>退回到远古时代（其实也就是几年前），人们会使用 <code>pthread_once</code> ，因为 <code>dispatch_once_t</code> 更容易使用并且不易出错，所以你永远都不会再用到 <code>pthread_once</code> 了。</p>\n<h3 id=\"延后执行：dispatch-after\"><a href=\"#延后执行：dispatch-after\" class=\"headerlink\" title=\"延后执行：dispatch_after\"></a>延后执行：dispatch_after</h3><p>它能使工作延后执行。它是很强大的，但是要注意：你很容易就陷入到一堆麻烦中。一般用法是这样的：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)foo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">double</span> delayInSeconds = <span class=\"number\">2.0</span>;</span><br><span class=\"line\">dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * <span class=\"built_in\">NSEC_PER_SEC</span>));</span><br><span class=\"line\">dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class=\"keyword\">void</span>)&#123;</span><br><span class=\"line\">[<span class=\"keyword\">self</span> bar];</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第一眼看上去这段代码是极好的。但是这里存在一些缺点。我们不能（直接）取消我们已经提交到 <code>dispatch_after</code> 的代码，它将会运行。</p>\n<h4 id=\"时序性bug\"><a href=\"#时序性bug\" class=\"headerlink\" title=\"时序性bug\"></a>时序性bug</h4><p>当人们使用 <code>dispatch_after</code> 去处理他们代码中存在的时序 bug 时，会存在一些有问题的倾向。一些代码执行的过早而你很可能不知道为什么会这样，所以你把这段代码放到了 <code>dispatch_after</code> 中，现在一切运行正常了。但是几周以后，之前的工作不起作用了。由于你并不十分清楚你自己代码的执行次序，调试代码就变成了一场噩梦。所以不要像上面这样做。</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>大多数的情况下，你最好把代码放到正确的位置。如果代码放到 <code>-viewWillAppear</code> 太早，那么或许 <code>-viewDidAppear</code> 就是正确的地方。<br>通过在自己代码中建立直接调用（类似 <code>-viewDidAppear</code> ）而不是依赖于  <code>dispatch_after</code> ，你会为自己省去很多麻烦。</p>\n<h4 id=\"推荐场景\"><a href=\"#推荐场景\" class=\"headerlink\" title=\"推荐场景\"></a>推荐场景</h4><p>如果你需要一些事情在某个特定的时刻运行，那么 <code>dispatch_after</code> 或许会是个好的选择。确保同时考虑了 <code>NSTimer</code>，这个API虽然有点笨重，但是它允许你取消定时器的触发。</p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>GCD是一个很大抽象层级用户 API，提供管理线程池队列的管理。<br>当使用 GCD 来完成并发的工作时，你不必考虑线程方面的问题，只需考虑队列和功能点（提交给队列的 block）。虽然往下深究，依然都是线程，但是 GCD 的抽象层级为你惯用的编码提供了更好的方式。<br>隔离队列：默认情况下，它们是串行的，也就是说，任何给定的时间内，只能有一个单独的 block 运行。<br>并行队列：同一时间内允许多个 block 一起执行。<br>GCD 中一个基本的代码块就是队列。下面我们会给出一些如何使用它的例子。当使用队列的时候，给它们一个明显的标签会帮自己不少忙。在调试时，这个标签会在 Xcode (和 lldb)中显示，这会帮助你了解你的 app 是由什么决定的：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)init;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> != <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> *label = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@.isolation.%p\"</span>, [<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], <span class=\"keyword\">self</span>];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.isolationQueue = dispatch_queue_create([label UTF8String], <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        label = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@.work.%p\"</span>, [<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], <span class=\"keyword\">self</span>];</span><br><span class=\"line\">        <span class=\"comment\">//创建一个队列</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.workQueue = dispatch_queue_create([label UTF8String], <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"解决扇出问题\"><a href=\"#解决扇出问题\" class=\"headerlink\" title=\"解决扇出问题\"></a>解决扇出问题</h4><p>队列和功能点同时解决了一个连续不断的扇出的问题：如果我们直接使用线程，并且想要做一些并发的事情，我们很可能将我们的工作分成 100 个小的功能点，然后基于可用的 CPU 内核数量来创建线程，假设是 8。我们把这些功能点送到这 8 个线程中。当我们处理这些功能点时，可能会调用一些函数作为功能的一部分。写那个函数的人也想要使用并发，因此当你调用这个函数的时候，这个函数也会创建 8 个线程。现在，你有了 8 × 8 = 64 个线程，尽管你只有 8 个CPU内核——也就是说任何时候只有12%的线程实际在运行而另外88%的线程什么事情都没做。使用 GCD 你就不会遇到这种问题，当系统关闭 CPU 内核以省电时，GCD 甚至能够相应地调整线程数量。</p>\n<h4 id=\"GCD中创建线程\"><a href=\"#GCD中创建线程\" class=\"headerlink\" title=\"GCD中创建线程\"></a>GCD中创建线程</h4><p>GCD 通过创建所谓的<a href=\"http://en.wikipedia.org/wiki/Thread_pool_pattern\" target=\"_blank\" rel=\"noopener\">线程池</a>来大致匹配 CPU 内核数量。要记住，线程的创建并不是无代价的。每个线程都需要占用内存和内核资源。这里也有一个问题：如果你提交了一个 block 给 GCD，但是这段代码阻塞了这个线程，那么这个线程在这段时间内就不能用来完成其他工作——它被阻塞了。为了确保功能点在队列上一直是执行的，GCD 不得不创建一个新的线程，并把它添加到线程池。</p>\n<h4 id=\"线程阻塞问题\"><a href=\"#线程阻塞问题\" class=\"headerlink\" title=\"线程阻塞问题\"></a>线程阻塞问题</h4><p>如果你的代码阻塞了许多线程，这会带来很大的问题。首先，线程消耗资源，此外，创建线程会变得代价高昂。创建过程需要一些时间。并且在这段时间中，GCD 无法以全速来完成功能点。有不少能够导致线程阻塞的情况，但是最常见的情况与 I/O 有关，也就是从文件或者网络中读写数据。正是因为这些原因，你不应该在GCD队列中以阻塞的方式来做这些操作。看一下下面的<a href=\"#input_output\">输入输出</a>段落去了解一些关于如何以 GCD 运行良好的方式来做 I/O 操作的信息。</p>\n<h3 id=\"目标队列\"><a href=\"#目标队列\" class=\"headerlink\" title=\"目标队列\"></a>目标队列</h3><p>目标队列可以设置队列的名字，这让调试变得轻松许多—— Xcode 可以让你在 Debug Navigator 中看到所有的队列名字，如果你直接使用 <code>lldb</code>。<code>(lldb) thread list</code> 命令将会在控制台打印出所有队列的名字。一旦你使用大量的异步内容，这会是非常有用的帮助。<br>如果一个队列的目标队列是串行的（也就是非并发），那么实际上这个队列也会转换为一个串行队列。<br>你能够为你创建的任何一个队列设置一个<strong>目标队列</strong>。这会是很强大的，并且有助于调试。</p>\n<p>使用私有队列同样强调封装性。这时你自己的队列，你要自己决定如何使用它。</p>\n<h4 id=\"队列转发控制\"><a href=\"#队列转发控制\" class=\"headerlink\" title=\"队列转发控制\"></a>队列转发控制</h4><p>默认情况下，一个新创建的队列转发到默认优先级的全局队列中。我们就将会讨论一些有关优先级的东西。</p>\n<p>你可以改变你队列转发到的队列——你可以设置自己队列的目标队列。以这种方式，你可以将不同队列链接在一起。你的 <code>Foo</code> 类有一个队列，该队列转发到 <code>Bar</code> 类的队列，<code>Bar</code> 类的队列又转发到全局队列。</p>\n<p>当你为了隔离目的而使用一个队列时，这会非常有用。<code>Foo</code> 有一个隔离队列，并且转发到 <code>Bar</code> 的隔离队列，与 <code>Bar</code> 的隔离队列所保护的有关的资源，会自动成为线程安全的。</p>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><p>你可以通过设置目标队列为一个全局队列来改变自己队列的优先级，但是你应该克制这么做的冲动。</p>\n<p>在大多数情况下，改变优先级不会使事情照你预想的方向运行。一些看起简单的事情实际上是一个非常复杂的问题。你很容易会碰到一个叫做<a href=\"http://en.wikipedia.org/wiki/Priority_inversion\" target=\"_blank\" rel=\"noopener\">优先级反转</a>的情况。我们的文章<a href=\"http://objccn.io/issue-2-1/#priority_inversion\" target=\"_blank\" rel=\"noopener\">《并发编程：API 及挑战》</a>有更多关于这个问题的信息，这个问题几乎导致了NASA的探路者火星漫游器变成砖头。</p>\n<p>此外，使用 <code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code> 队列时，你需要格外小心。除非你理解了 <em>throttled I/O</em> 和 <em>background status as per setpriority(2)</em> 的意义，否则不要使用它。不然，系统可能会以难以忍受的方式终止你的 app 的运行。打算以不干扰系统其他正在做 I/O 操作的方式去做 I/O 操作时，一旦和优先级反转情况结合起来，这会变成一种危险的情况。</p>\n<h2 id=\"隔离\"><a href=\"#隔离\" class=\"headerlink\" title=\"隔离\"></a>隔离</h2><p>隔离队列是 GCD 队列使用中非常普遍的一种模式。这里有两个变种。</p>\n<h3 id=\"资源保护\"><a href=\"#资源保护\" class=\"headerlink\" title=\"资源保护\"></a>资源保护</h3><p>多线程编程中，最常见的情形是你有一个资源，每次只有一个线程被允许访问这个资源。</p>\n<p>我们在<a href=\"http://objccn.io/issue-2-1/#shared_resources\" target=\"_blank\" rel=\"noopener\">有关多线程技术的文章</a>中讨论了<em>资源</em>在并发编程中意味着什么，它通常就是一块内存或者一个对象，每次只有一个线程可以访问它。</p>\n<h4 id=\"串行队列读写共享资源\"><a href=\"#串行队列读写共享资源\" class=\"headerlink\" title=\"串行队列读写共享资源\"></a>串行队列读写共享资源</h4><p>举例来说，我们需要以多线程（或者多个队列）方式访问 <code>NSMutableDictionary</code> 。我们可能会照下面的代码来做：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setCount:(<span class=\"built_in\">NSUInteger</span>)count forKey:(<span class=\"built_in\">NSString</span> *)key</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    key = [key <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(<span class=\"keyword\">self</span>.isolationQueue, ^()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span>.counts removeObjectForKey:key];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.counts[key] = @(count);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSUInteger</span>)countForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __block <span class=\"built_in\">NSUInteger</span> count;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(<span class=\"keyword\">self</span>.isolationQueue, ^()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSNumber</span> *n = <span class=\"keyword\">self</span>.counts[key];</span><br><span class=\"line\">        count = [n unsignedIntegerValue];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过以上代码，只有一个线程可以访问 <code>NSMutableDictionary</code> 的实例。</p>\n<p>注意以下四点：</p>\n<ol>\n<li>不要使用上面的代码，请先阅读<a href=\"#multiple_readers_single_writer\">多读单写</a>和<a href=\"#contention\">锁竞争</a></li>\n<li>我们使用 <code>async</code> 方式来保存值，这很重要。我们不想也不必阻塞当前线程只是为了等待<em>写操作</em>完成。当读操作时，我们使用 <code>sync</code> 因为我们需要返回值。</li>\n<li>从函数接口可以看出，<code>-setCount:forKey:</code> 需要一个 <code>NSString</code> 参数，用来传递给 <code>dispatch_async</code>。函数调用者可以自由传递一个 <code>NSMutableString</code> 值并且能够在函数返回后修改它。因此我们<em>必须</em>对传入的字符串使用 <em>copy</em> 操作以确保函数能够正确地工作。如果传入的字符串不是可变的（也就是正常的 <code>NSString</code> 类型），调用<em>copy</em>基本上是个空操作。</li>\n<li><code>isolationQueue</code> 创建时，参数 <code>dispatch_queue_attr_t</code> 的值必须是<em>DISPATCH_QUEUE_SERIAL</em>（或者0）。</li>\n</ol>\n<p><a id=\"multiple_readers_single_writer\" name=\"multiple_readers_single_writer\"> </a></p>\n<h4 id=\"barrier分发block实现并行队列多读单写\"><a href=\"#barrier分发block实现并行队列多读单写\" class=\"headerlink\" title=\"barrier分发block实现并行队列多读单写\"></a><strong>barrier</strong>分发block实现并行队列多读单写</h4><p>我们能够改善上面的那个例子。GCD 有可以让多线程运行的并发队列。我们能够安全地使用多线程来从 <code>NSMutableDictionary</code> 中读取只要我们不同时修改它。<br>我们使用 <em>barrier</em> 来分发一个block实现对字典的多读单写操作。这样的一个 block 的运行时机是，<strong>在它之前所有计划好的 block 完成之后，并且在所有它后面的 block 运行之前</strong>。</p>\n<p>以如下方式创建队列：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.isolationQueue = dispatch_queue_create([label UTF8String], DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure></p>\n<p>并且用以下代码来改变setter函数：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setCount:(<span class=\"built_in\">NSUInteger</span>)count forKey:(<span class=\"built_in\">NSString</span> *)key</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    key = [key <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">    dispatch_barrier_async(<span class=\"keyword\">self</span>.isolationQueue, ^()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.counts removeObjectForKey:key];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.counts[key] = @(count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当使用并发队列时，要确保所有的 <em>barrier</em> 调用都是 <em>async</em> 的。如果你使用 <code>dispatch_barrier_sync</code> ，那么你很可能会使你自己（更确切的说是，你的代码）产生死锁。写操作<em>需要</em>  barrier，并且<em>可以</em>是 async 的。</p>\n<p><a id=\"contention\" name=\"contention\"> </a></p>\n<h3 id=\"锁竞争\"><a href=\"#锁竞争\" class=\"headerlink\" title=\"锁竞争\"></a>锁竞争</h3><p>首先，这里有一个警告：上面这个例子中我们保护的资源是一个  <code>NSMutableDictionary</code>，出于这样的目的，这段代码运行地相当不错。但是在真实的代码中，把隔离放到正确的复杂度层级下是很重要的。</p>\n<p>如果你对 <code>NSMutableDictionary</code> 的访问操作变得非常频繁，你会碰到一个已知的叫做锁竞争的问题。锁竞争并不是只是在 GCD 和队列下才变得特殊，任何使用了锁机制的程序都会碰到同样的问题——只不过不同的锁机制会以不同的方式碰到。</p>\n<h4 id=\"时序性避免使用锁\"><a href=\"#时序性避免使用锁\" class=\"headerlink\" title=\"时序性避免使用锁\"></a>时序性避免使用锁</h4><p>所有对  <code>dispatch_async</code>，<code>dispatch_sync</code> 等等的调用都需要完成某种形式的锁——以确保仅有一个线程或者特定的线程运行指定的代码。GCD 某些程序上可以使用时序(译注：原词为 scheduling)来避免使用锁，但在最后，问题只是稍有变化。<br>根本问题仍然存在：如果你有<strong>大量</strong>的线程在相同时间去访问同一个锁或者队列，你就会看到性能的变化。性能会严重下降。</p>\n<h4 id=\"平衡两个开销\"><a href=\"#平衡两个开销\" class=\"headerlink\" title=\"平衡两个开销\"></a>平衡两个开销</h4><p>你应该直接从复杂层次中隔离开。当你发现了性能下降，这明显表明代码中存在设计问题。这里有两个开销需要你来平衡：<br>第一个是独占临界区资源太久的开销，以至于别的线程都因为进入临界区的操作而阻塞。例如：一个在隔离队列中运行 block，它可能潜在的阻塞了其他将要在这个隔离队列中运行的代码。<br>第二个是太频繁出入临界区的开销。例如频繁调用 <code>dispatch_async</code> 和 <code>dispatch_sync</code> 。<br><strong>无论再怎么优化，这两个操作都不是无代价的。</strong><br>令人忧伤的，不存在通用的标准来指导如何正确的平衡，你需要自己评测和调整。启动 Instruments 观察你的 app 忙于什么操作。</p>\n<h4 id=\"设计层保护隔离队列\"><a href=\"#设计层保护隔离队列\" class=\"headerlink\" title=\"设计层保护隔离队列\"></a>设计层保护隔离队列</h4><p>在你自己的代码中，要考虑自己是否在更高的层次保护了隔离队列。<br>举个例子：<br>类 <code>Foo</code> 有一个隔离队列并且它本身保护着对 <code>NSMutableDictionary</code> 的访问，代替的，可以有一个用到了 <code>Foo</code> 类的 <code>Bar</code> 类有一个隔离队列保护所有对类 <code>Foo</code> 的使用。<br>换句话说，你可以把类 <code>Foo</code> 变为非线程安全的（没有隔离队列），并在 <code>Bar</code> 中，使用一个隔离队列来确保任何时刻只能有一个线程使用 <code>Foo</code> 。</p>\n<p><a name=\"async\" id=\"async\"> </a></p>\n<h3 id=\"死锁问题\"><a href=\"#死锁问题\" class=\"headerlink\" title=\"死锁问题\"></a>死锁问题</h3><p>全都使用异步分发</p>\n<h4 id=\"同步分发死锁\"><a href=\"#同步分发死锁\" class=\"headerlink\" title=\"同步分发死锁\"></a>同步分发死锁</h4><ol>\n<li>在 GCD 中，同步和异步地分发一个  block，一个工作单元。以同步分发的方式非常容易出现<a href=\"http://zh.wikipedia.org/wiki/死锁\" target=\"_blank\" rel=\"noopener\">死锁</a>。见下面的代码：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queueA; <span class=\"comment\">// assume we have this</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_sync</span>(queueA, ^()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(queueA, ^()&#123;</span><br><span class=\"line\">        foo();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>一旦我们进入到第二个 <code>dispatch_sync</code> 就会发生死锁。我们不能分发到queueA，因为有人（当前线程）正在队列中并且永远不会离开。</p>\n<ol>\n<li>更隐晦的产生死锁方式：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queueA; <span class=\"comment\">// assume we have this</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queueB; <span class=\"comment\">// assume we have this</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">dispatch_sync</span>(queueA, ^()&#123;</span><br><span class=\"line\">    foo();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> foo(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(queueB, ^()&#123;</span><br><span class=\"line\">        bar();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> bar(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(queueA, ^()&#123;</span><br><span class=\"line\">        baz();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>单独的每次调用 <code>dispatch_sync()</code> 看起来都没有问题，但是一旦组合起来，就会发生死锁。</p>\n<h4 id=\"解决：异步调用不会产生死锁\"><a href=\"#解决：异步调用不会产生死锁\" class=\"headerlink\" title=\"解决：异步调用不会产生死锁\"></a>解决：异步调用不会产生死锁</h4><p>这是使用同步分发存在的固有问题，如果我们使用异步分发，比如：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queueA; <span class=\"comment\">// assume we have this</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queueA, ^()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(queueA, ^()&#123;</span><br><span class=\"line\">        foo();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>一切运行正常。<em>异步调用不会产生死锁</em>。因此值得我们在任何可能的时候都使用异步分发。我们使用一个异步调用结果 block 的函数，来代替编写一个返回值（必须要用同步）的方法或者函数。这种方式，我们会有更少发生死锁的可能性。</p>\n<p>异步调用的副作用就是它们很难调试。当我们在调试器里中止代码运行，回溯并查看已经变得没有意义了。</p>\n<p>要牢记这些。死锁通常是最难处理的问题。</p>\n<h3 id=\"如何设计健壮的异步-API\"><a href=\"#如何设计健壮的异步-API\" class=\"headerlink\" title=\"如何设计健壮的异步 API\"></a>如何设计健壮的异步 API</h3><p>记住几种好的实践：</p>\n<ol>\n<li>需要倾向于异步 API。<br>当你创建一个 API，它会在你的控制之外以各种方式调用，如果你的代码能产生死锁，那么死锁就会发生。</li>\n<li>主动在自己的函数或者方法中调用异步分发<code>dispatch_async()</code>。<br>不要让你的函数调用者来这么做，这个调用应该在你的方法或者函数中来做。</li>\n<li>返回值传递，异步地将方法或函数的返回值传递给回调处理程序。<br>这个API（方法或函数）应该同时持有一个<code>结果 block</code> 和一个<code>将结果传递过去的队列</code>。不需要API调用者自己来做分发。<br>这么做的原因很简单：几乎所有事件，函数调用都应该在一个适当的队列中，而且以这种方式编写的代码是很容易阅读的。总之，你的函数将会（必须）调用 <code>dispatch_async()</code> 去运行回调处理程序，所以它同时也可能在需要调用的队列上做这些工作。</li>\n</ol>\n<p>如果你写一个类，让你类的使用者设置一个回调处理队列或许会是一个好的选择。你的代码可能像这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)processImage:(UIImage *)image completionHandler:(void(^)(BOOL success))handler;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dispatch_async(self.isolationQueue, ^(void)&#123;</span><br><span class=\"line\">        // do actual processing here</span><br><span class=\"line\">        dispatch_async(self.resultQueue, ^(void)&#123;</span><br><span class=\"line\">            handler(YES);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果你以这种方式来写你的类，让类之间协同工作就会变得容易。如果类 A 使用了类 B，它会把自己的隔离队列设置为 B 的回调队列。</p>\n<h2 id=\"迭代执行\"><a href=\"#迭代执行\" class=\"headerlink\" title=\"迭代执行\"></a>迭代执行</h2><p>如果你正在倒弄一些数字，并且手头上的问题可以拆分出同样性质的部分，那么 <code>dispatch_apply</code> 会很有用。</p>\n<p>如果你的代码看起来是这样的：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (size_t y = <span class=\"number\">0</span>; y &lt; height; ++y) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (size_t x = <span class=\"number\">0</span>; x &lt; width; ++x) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Do something with x and y here</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>小小的改动或许就可以让它运行的更快：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_apply(height, dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>), ^(size_t y) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (size_t x = <span class=\"number\">0</span>; x &lt; width; x += <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Do something with x and y here</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>代码运行良好的程度取决于你在循环内部做的操作。</p>\n<p>block 中运行的工作必须是非常重要的，否则这个头部信息就显得过于繁重了。除非代码受到计算带宽的约束，每个工作单元为了很好适应缓存大小而读写的内存都是临界的。这会对性能会带来显著的影响。受到临界区约束的代码可能不会很好地运行。详细讨论这些问题已经超出了这篇文章的范围。使用 <code>dispatch_apply</code> 可能会对性能提升有所帮助，但是性能优化本身就是个很复杂的主题。维基百科上有一篇关于 <a href=\"https://en.wikipedia.org/wiki/Memory_bound\" target=\"_blank\" rel=\"noopener\">Memory-bound function</a> 的文章。内存访问速度在 L2，L3 和主存上变化很显著。当你的数据访问模式与缓存大小不匹配时，10倍性能下降的情况并不少见。</p>\n<h2 id=\"组\"><a href=\"#组\" class=\"headerlink\" title=\"组\"></a>组</h2><p>很多时候，你发现需要将异步的 block 组合起来去完成一个给定的任务。这些任务中甚至有些是并行的。<br>现在，如果你想要在这些任务都执行完成后运行一些代码，”groups” 可以完成这项任务。看这里的例子：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_group_t group = dispatch_group_create();</span><br><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">dispatch_group_async(group, queue, ^()&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Do something that takes a while</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> doSomeFoo];</span><br><span class=\"line\">    dispatch_group_async(group, dispatch_get_main_queue(), ^()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.foo = <span class=\"number\">42</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_async(group, queue, ^()&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Do something else that takes a while</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> doSomeBar];</span><br><span class=\"line\">    dispatch_group_async(group, dispatch_get_main_queue(), ^()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.bar = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This block will run once everything above is done:</span></span><br><span class=\"line\">dispatch_group_notify(group, dispatch_get_main_queue(), ^()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"foo: %d\"</span>, <span class=\"keyword\">self</span>.foo);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"bar: %d\"</span>, <span class=\"keyword\">self</span>.bar);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的重要事情是，所有的这些都是非阻塞的。我们从未让当前的线程一直等待直到别的任务做完。恰恰相反，我们只是简单的将多个 block 放入队列。由于代码不会阻塞，所以就不会产生死锁。</p>\n<p>同时需要注意的是，在这个小并且简单的例子中，我们是怎么在不同的队列间进切换的。</p>\n<h3 id=\"对现有API使用-dispatch-group-t\"><a href=\"#对现有API使用-dispatch-group-t\" class=\"headerlink\" title=\"对现有API使用 dispatch_group_t\"></a>对现有API使用 dispatch_group_t</h3><p>一旦你将  groups 作为你的工具箱中的一部分，你可能会怀疑为什么大多数的异步API不把 <code>dispatch_group_t</code> 作为一个可选参数。这没有什么无法接受的理由，仅仅是因为自己添加这个功能太简单了，但是你还是要小心以确保自己使用 groups 的代码是成对出现的。</p>\n<p>举例来说，我们可以给 Core Data 的 <code>-performBlock:</code> API 函数添加上 groups，就像这样：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)withGroup:(dispatch_group_t)group performBlock:(dispatch_block_t)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (group == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">[<span class=\"keyword\">self</span> performBlock:block];</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">dispatch_group_enter(group);</span><br><span class=\"line\">[<span class=\"keyword\">self</span> performBlock:^()&#123;</span><br><span class=\"line\">block();</span><br><span class=\"line\">dispatch_group_leave(group);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当 Core Data 上的一系列操作(很可能和其他的代码组合起来)完成以后，我们可以使用 <code>dispatch_group_notify</code> 来运行一个 block 。</p>\n<p>很明显，我们可以给 <code>NSURLConnection</code> 做同样的事情：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">void</span>)withGroup:(dispatch_group_t)group</span><br><span class=\"line\">sendAsynchronousRequest:(<span class=\"built_in\">NSURLRequest</span> *)request</span><br><span class=\"line\">queue:(<span class=\"built_in\">NSOperationQueue</span> *)queue</span><br><span class=\"line\">completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSURLResponse</span>*, <span class=\"built_in\">NSData</span>*, <span class=\"built_in\">NSError</span>*))handler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (group == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> sendAsynchronousRequest:request</span><br><span class=\"line\">                            queue:queue</span><br><span class=\"line\">                completionHandler:handler];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        dispatch_group_enter(group);</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> sendAsynchronousRequest:request</span><br><span class=\"line\">                                queue:queue</span><br><span class=\"line\">                    completionHandler:^(<span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSData</span> *data, <span class=\"built_in\">NSError</span> *error)&#123;</span><br><span class=\"line\">            handler(response, data, error);</span><br><span class=\"line\">            dispatch_group_leave(group);</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为了能正常工作，你需要确保:</p>\n<ul>\n<li><code>dispatch_group_enter()</code> 必须要在 <code>dispatch_group_leave()</code>之前运行。</li>\n<li><code>dispatch_group_enter()</code> 和 <code>dispatch_group_leave()</code> 一直是成对出现的（就算有错误产生时）。</li>\n</ul>\n<h2 id=\"事件源\"><a href=\"#事件源\" class=\"headerlink\" title=\"事件源\"></a>事件源</h2><p>GCD 有一个较少人知道的特性：事件源 <code>dispatch_source_t</code>。</p>\n<p>跟 GCD 一样，它也是很底层的东西。当你需要用到它时，它会变得极其有用。它的一些使用是秘传招数，我们将会接触到一部分的使用。但是大部分事件源在 iOS 平台不是很有用，因为在 iOS 平台有诸多限制，你无法启动进程（因此就没有必要监视进程），也不能在你的 app bundle 之外写数据（因此也就没有必要去监视文件）等等。</p>\n<p>GCD 事件源是以极其资源高效的方式实现的。</p>\n<h3 id=\"监视进程\"><a href=\"#监视进程\" class=\"headerlink\" title=\"监视进程\"></a>监视进程</h3><p>如果一些进程正在运行而你想知道他们什么时候存在，GCD 能够做到这些。你也可以使用 GCD 来检测进程什么时候分叉，也就是产生子进程或者传送给了进程的一个信号（比如 <code>SIGTERM</code>）。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSRunningApplication</span> *mail = [<span class=\"built_in\">NSRunningApplication</span></span><br><span class=\"line\">runningApplicationsWithBundleIdentifier:<span class=\"string\">@\"com.apple.mail\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mail == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">pid_t <span class=\"keyword\">const</span> pid = mail.processIdentifier;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, pid,</span><br><span class=\"line\">DISPATCH_PROC_EXIT, DISPATCH_TARGET_QUEUE_DEFAULT);</span><br><span class=\"line\">dispatch_source_set_event_handler(<span class=\"keyword\">self</span>.source, ^()&#123;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Mail quit.\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_resume(<span class=\"keyword\">self</span>.source);</span><br></pre></td></tr></table></figure></p>\n<p>当 Mail.app 退出的时候，这个程序会打印出 <strong>Mail quit.</strong>。</p>\n<p>注意：在所有的事件源被传递到你的事件处理器之前，必须调用 <code>dispatch_resume()</code>。</p>\n<p><a name=\"watching_files\" id=\"watching_files\"> </a></p>\n<h3 id=\"监视文件\"><a href=\"#监视文件\" class=\"headerlink\" title=\"监视文件\"></a>监视文件</h3><p>这种可能性是无穷的。你能直接监视一个文件的改变，并且当改变发生时事件源的事件处理将会被调用。</p>\n<p>你也可以使用它来监视文件夹，比如创建一个 <em>watch folder</em>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSURL *directoryURL; // assume this is set to a directory</span><br><span class=\"line\">int const fd = open([[directoryURL path] fileSystemRepresentation], O_EVTONLY);</span><br><span class=\"line\">if (fd &lt; 0) &#123;</span><br><span class=\"line\">char buffer[80];</span><br><span class=\"line\">strerror_r(errno, buffer, sizeof(buffer));</span><br><span class=\"line\">NSLog(@&quot;Unable to open \\&quot;%@\\&quot;: %s (%d)&quot;, [directoryURL path], buffer, errno);</span><br><span class=\"line\">return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd,</span><br><span class=\"line\">DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE, DISPATCH_TARGET_QUEUE_DEFAULT);</span><br><span class=\"line\">dispatch_source_set_event_handler(source, ^()&#123;</span><br><span class=\"line\">unsigned long const data = dispatch_source_get_data(source);</span><br><span class=\"line\">if (data &amp; DISPATCH_VNODE_WRITE) &#123;</span><br><span class=\"line\">NSLog(@&quot;The directory changed.&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (data &amp; DISPATCH_VNODE_DELETE) &#123;</span><br><span class=\"line\">NSLog(@&quot;The directory has been deleted.&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_source_set_cancel_handler(source, ^()&#123;</span><br><span class=\"line\">close(fd);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">self.source = source;</span><br><span class=\"line\">dispatch_resume(self.source);</span><br></pre></td></tr></table></figure></p>\n<p>你应该总是添加 <code>DISPATCH_VNODE_DELETE</code> 去检测文件或者文件夹是否已经被删除——然后就停止监听。</p>\n<h3 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h3><p>大多数情况下，对于定时事件你会选择 <code>NSTimer</code>。定时器的GCD版本是底层的，它会给你更多控制权——但要小心使用。</p>\n<p>需要特别重点指出的是，为了让 OS 节省电量，需要为 GCD 的定时器接口指定一个低的余地值(译注：原文leeway value)。如果你不必要的指定了一个低余地值，将会浪费更多的电量。</p>\n<p>这里我们设定了一个5秒的定时器，并允许有十分之一秒的余地值：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,</span><br><span class=\"line\"><span class=\"number\">0</span>, <span class=\"number\">0</span>, DISPATCH_TARGET_QUEUE_DEFAULT);</span><br><span class=\"line\">dispatch_source_set_event_handler(source, ^()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Time flies.\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_time_t start</span><br><span class=\"line\">dispatch_source_set_timer(source, DISPATCH_TIME_NOW, <span class=\"number\">5</span>ull * <span class=\"built_in\">NSEC_PER_SEC</span>,</span><br><span class=\"line\"><span class=\"number\">100</span>ull * <span class=\"built_in\">NSEC_PER_MSEC</span>);</span><br><span class=\"line\"><span class=\"keyword\">self</span>.source = source;</span><br><span class=\"line\">dispatch_resume(<span class=\"keyword\">self</span>.source);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"取消\"><a href=\"#取消\" class=\"headerlink\" title=\"取消\"></a>取消</h3><p>所有的事件源都允许你添加一个 <em>cancel handler</em> 。这对清理你为事件源创建的任何资源都是很有帮助的，比如关闭文件描述符。GCD 保证在 <em>cancel handle</em>  调用前，所有的事件处理都已经完成调用。</p>\n<p>参考上面的<a href=\"#watching_files\">监视文件例子</a>中对 <code>dispatch_source_set_cancel_handler()</code> 的使用。</p>\n<p><a id=\"input_output\" name=\"input_output\"> </a></p>\n<h2 id=\"输入输出\"><a href=\"#输入输出\" class=\"headerlink\" title=\"输入输出\"></a>输入输出</h2><p>写出能够在繁重的 I/O 处理情况下运行良好的代码是一件非常棘手的事情。GCD 有一些能够帮上忙的地方。不会涉及太多的细节，我们只简单的分析下问题是什么，GCD 是怎么处理的。</p>\n<p>习惯上，当你从一个网络套接字中读取数据时，你要么做一个阻塞的读操作，也就是让你个线程一直等待直到数据变得可用，或者是做反复的轮询。这两种方法都是很浪费资源并且无法度量。然而，<code>kqueue</code> 通过当数据变得可用时传递一个事件解决了轮询的问题，GCD 也采用了同样的方法，但是更加优雅。当向套接字写数据时，同样的问题也存在，这时你要么做阻塞的写操作，要么等待套接字直到能够接收数据。</p>\n<p>在处理 I/O 时，还有一个问题就是数据是以数据块的形式到达的。当从网络中读取数据时，依据 MTU(<a href=\"https://en.wikipedia.org/wiki/Maximum_transmission_unit\" target=\"_blank\" rel=\"noopener\">]最大传输单元</a>)，数据块典型的大小是在1.5K字节左右。这使得数据块内可以是任何内容。一旦数据到达，你通常只是对跨多个数据块的内容感兴趣。而且通常你会在一个大的缓冲区里将数据组合起来然后再进行处理。假设（人为例子）你收到了这样8个数据块：</p>\n<p>0: HTTP/1.1 200 OK\\r\\nDate: Mon, 23 May 2005 22:38<br>1: :34 GMT\\r\\nServer: Apache/1.3.3.7 (Unix) (Red-H<br>2: at/Linux)\\r\\nLast-Modified: Wed, 08 Jan 2003 23<br>3: :11:55 GMT\\r\\nEtag: “3f80f-1b6-3e1cb03b”\\r\\nCon<br>4: tent-Type: text/html; charset=UTF-8\\r\\nContent-<br>5: Length: 131\\r\\nConnection: close\\r\\n\\r\\n<html>\\r<br>6: \\n<head>\\r\\n  <title>An Example Page</title>\\r\\n<br>7: </head>\\r\\n<body>\\r\\n  Hello World, this is a ve</body></html></p>\n<p>如果你是在寻找 HTTP 的头部，将所有数据块组合成一个大的缓冲区并且从中查找 <code>\\r\\n\\r\\n</code> 是非常简单的。但是这样做，你会大量地复制这些数据。大量 <em>旧的</em> C 语言 API 存在的另一个问题就是，缓冲区没有所有权的概念，所以函数不得不将数据再次拷贝到自己的缓冲区中——又一次的拷贝。拷贝数据操作看起来是无关紧要的，但是当你正在做大量的 I/O 操作的时候，你会在 profiling tool(Instruments) 中看到这些拷贝操作大量出现。即使你仅仅每个内存区域拷贝一次，你还是使用了两倍的存储带宽并且占用了两倍的内存缓存。</p>\n<h3 id=\"GCD-和缓冲区\"><a href=\"#GCD-和缓冲区\" class=\"headerlink\" title=\"GCD 和缓冲区\"></a>GCD 和缓冲区</h3><p>最直接了当的方法是使用数据缓冲区。GCD 有一个 <code>dispatch_data_t</code> 类型，在某种程度上和 Objective-C 的 <code>NSData</code> 类型很相似。但是它能做别的事情，而且更通用。</p>\n<p>注意，<code>dispatch_data_t</code> 可以被 retained 和 releaseed ，并且 <code>dispatch_data_t</code> <em>拥有</em>它持有的对象。</p>\n<p>这看起来无关紧要，但是我们必须记住 GCD 只是纯 C 的 API，并且不能使用Objective-C。通常的做法是创建一个缓冲区，这个缓冲区要么是基于栈的，要么是  <code>malloc</code> 操作分配的内存区域 —— 这些都没有所有权。</p>\n<p><code>dispatch_data_t</code> 的一个相当独特的属性是它可以基于零碎的内存区域。这解决了我们刚提到的组合内存的问题。当你要将两个数据对象连接起来时：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_data_t a; <span class=\"comment\">// Assume this hold some valid data</span></span><br><span class=\"line\">dispatch_data_t b; <span class=\"comment\">// Assume this hold some valid data</span></span><br><span class=\"line\">dispatch_data_t c = dispatch_data_create_concat(a, b);</span><br></pre></td></tr></table></figure></p>\n<p>数据对象 c 并不会将 a 和 b 拷贝到一个单独的，更大的内存区域里去。相反，它只是简单地 retain 了 a 和 b。你可以使用 <code>dispatch_data_apply</code> 来遍历对象 c 持有的内存区域：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_data_apply(c, ^<span class=\"keyword\">bool</span>(dispatch_data_t region, size_t offset, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buffer, size_t size) &#123;</span><br><span class=\"line\">fprintf(stderr, <span class=\"string\">\"region with offset %zu, size %zu\\n\"</span>, offset, size);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>类似的，你可以使用 <code>dispatch_data_create_subrange</code> 来创建一个不做任何拷贝操作的子区域。</p>\n<h3 id=\"读和写\"><a href=\"#读和写\" class=\"headerlink\" title=\"读和写\"></a>读和写</h3><p>在 GCD 的核心里，<em>调度 I/O</em>（译注：原文为 Dispatch I/O） 与所谓的<em>通道</em>有关。调度 I/O 通道提供了一种与从文件描述符中读写不同的方式。创建这样一个通道最基本的方式就是调用：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_io_t dispatch_io_create(dispatch_io_type_t type, dispatch_fd_t fd,</span><br><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue, <span class=\"keyword\">void</span> (^cleanup_handler)(<span class=\"keyword\">int</span> error));</span><br></pre></td></tr></table></figure></p>\n<p>这将返回一个持有文件描述符的创建好的通道。在你通过它创建了通道之后，你不准以任何方式修改这个文件描述符。</p>\n<p>有两种从根本上不同类型的通道：流和随机存取。如果你打开了硬盘上的一个文件，你可以使用它来创建一个随机存取的通道（因为这样的文件描述符是可寻址的）。如果你打开了一个套接字，你可以创建一个流通道。</p>\n<p>如果你想要为一个文件创建一个通道，你最好使用需要一个路径参数的 <code>dispatch_io_create_with_path</code> ，并且让 GCD 来打开这个文件。这是有益的，因为GCD会延迟打开这个文件以限制相同时间内同时打开的文件数量。</p>\n<p>类似通常的 read(2)，write(2) 和 close(2) 的操作，GCD 提供了 <code>dispatch_io_read</code>，<code>dispatch_io_write</code> 和 <code>dispatch_io_close</code>。无论何时数据读完或者写完，读写操作调用一个回调 block 来结束。这些都是以非阻塞，异步 I/O 的形式高效实现的。</p>\n<p>在这你得不到所有的细节，但是这里会提供一个创建TCP服务端的例子：</p>\n<p>首先我们创建一个监听套接字，并且设置一个接受连接的事件源：</p>\n<p>_isolation = dispatch_queue_create([[self description] UTF8String], 0);<br>_nativeSocket = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP);<br>struct sockaddr_in sin = {};<br>sin.sin_len = sizeof(sin);<br>sin.sin_family = AF_INET6;<br>sin.sin_port = htons(port);<br>sin.sin_addr.s_addr= INADDR_ANY;<br>int err = bind(result.nativeSocket, (struct sockaddr *) &amp;sin, sizeof(sin));<br>NSCAssert(0 &lt;= err, @””);</p>\n<p>_eventSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, _nativeSocket, 0, _isolation);<br>dispatch_source_set_event_handler(result.eventSource, ^{<br>acceptConnection(_nativeSocket);<br>});</p>\n<p>当接受了连接，我们创建一个I/O通道：</p>\n<p>typedef union socketAddress {<br>struct sockaddr sa;<br>struct sockaddr_in sin;<br>struct sockaddr_in6 sin6;<br>} socketAddressUnion;</p>\n<p>socketAddressUnion rsa; // remote socket address<br>socklen_t len = sizeof(rsa);<br>int native = accept(nativeSocket, &amp;rsa.sa, &amp;len);<br>if (native == -1) {<br>// Error. Ignore.<br>return nil;<br>}</p>\n<p>_remoteAddress = rsa;<br>_isolation = dispatch_queue_create([[self description] UTF8String], 0);<br>_channel = dispatch_io_create(DISPATCH_IO_STREAM, native, _isolation, ^(int error) {<br>NSLog(@”An error occured while listening on socket: %d”, error);<br>});</p>\n<p>//dispatch_io_set_high_water(_channel, 8 <em> 1024);<br>dispatch_io_set_low_water(_channel, 1);<br>dispatch_io_set_interval(_channel, NSEC_PER_MSEC </em> 10, DISPATCH_IO_STRICT_INTERVAL);</p>\n<p>socketAddressUnion lsa; // remote socket address<br>socklen_t len = sizeof(rsa);<br>getsockname(native, &amp;lsa.sa, &amp;len);<br>_localAddress = lsa;</p>\n<p>如果我们想要设置 <code>SO_KEEPALIVE</code>（如果使用了HTTP的keep-alive），我们需要在调用 <code>dispatch_io_create</code> 前这么做。</p>\n<p>创建好 I/O 通道后，我们可以设置读取处理程序：</p>\n<p>dispatch_io_read(_channel, 0, SIZE_MAX, _isolation, ^(bool done, dispatch_data_t data, int error){<br>if (data != NULL) {<br>if (_data == NULL) {<br>_data = data;<br>} else {<br>_data = dispatch_data_create_concat(_data, data);<br>}<br>[self processData];<br>}<br>});</p>\n<p>如果所有你想做的只是读取或者写入一个文件，GCD 提供了两个方便的封装： <code>dispatch_read</code> 和 <code>dispatch_write</code> 。你需要传递给 <code>dispatch_read</code> 一个文件路径和一个在所有数据块读取后调用的 block。类似的，<code>dispatch_write</code> 需要一个文件路径和一个被写入的 <code>dispatch_data_t</code> 对象。</p>\n<h2 id=\"基准测试\"><a href=\"#基准测试\" class=\"headerlink\" title=\"基准测试\"></a>基准测试</h2><p>在 GCD 的一个不起眼的角落，你会发现一个适合优化代码的灵巧小工具：</p>\n<p>uint64_t dispatch_benchmark(size_t count, void (^block)(void));</p>\n<p>把这个声明放到你的代码中，你就能够测量给定的代码执行的平均的纳秒数。例子如下：</p>\n<p>size_t const objectCount = 1000;<br>uint64_t n = dispatch_benchmark(10000, ^{<br>@autoreleasepool {<br>id obj = @42;<br>NSMutableArray *array = [NSMutableArray array];<br>for (size_t i = 0; i &lt; objectCount; ++i) {<br>[array addObject:obj];<br>}<br>}<br>});<br>NSLog(@”-[NSMutableArray addObject:] : %llu ns”, n);</p>\n<p>在我的机器上输出了：</p>\n<p>-[NSMutableArray addObject:] : 31803 ns</p>\n<p>也就是说添加1000个对象到 NSMutableArray 总共消耗了31803纳秒，或者说平均一个对象消耗32纳秒。</p>\n<p>正如 <code>dispatch_benchmark</code> 的<a href=\"http://opensource.apple.com/source/libdispatch/libdispatch-84.5/man/dispatch_benchmark.3\" target=\"_blank\" rel=\"noopener\">帮助页面</a>指出的，测量性能并非如看起来那样不重要。尤其是当比较并发代码和非并发代码时，你需要注意特定硬件上运行的特定计算带宽和内存带宽。不同的机器会很不一样。如果代码的性能与访问临界区有关，那么我们上面提到的锁竞争问题就会有所影响。</p>\n<p>不要把它放到发布代码中，事实上，这是无意义的，它是私有API。它只是在调试和性能分析上起作用。</p>\n<p>访问帮助界面：</p>\n<p>curl “<a href=\"http://opensource.apple.com/source/libdispatch/libdispatch-84.5/man/dispatch_benchmark.3?txt\" target=\"_blank\" rel=\"noopener\">http://opensource.apple.com/source/libdispatch/libdispatch-84.5/man/dispatch_benchmark.3?txt</a>“<br>| /usr/bin/groffer –tty -T utf8</p>\n<p><a id=\"atomic_operations\" name=\"atomic_operations\"> </a></p>\n<h2 id=\"原子操作\"><a href=\"#原子操作\" class=\"headerlink\" title=\"原子操作\"></a>原子操作</h2><p>头文件 <code>libkern/OSAtomic.h</code> 里有许多强大的函数，专门用来底层多线程编程。尽管它是内核头文件的一部分，它也能够在内核之外来帮助编程。</p>\n<p>这些函数都是很底层的，并且你需要知道一些额外的事情。就算你已经这样做了，你还可能会发现一两件你不能做，或者不易做的事情。当你正在为编写高性能代码或者正在实现无锁的和无等待的算法工作时，这些函数会吸引你。</p>\n<p>这些函数在 <code>atomic(3)</code> 的帮助页里全部有概述——运行 <code>man 3 atomic</code> 命令以得到完整的文档。你会发现里面讨论到了内存屏障。查看维基百科中关于<a href=\"https://en.wikipedia.org/wiki/Memory_barrier\" target=\"_blank\" rel=\"noopener\">内存屏障</a>的文章。如果你还存在疑问，那么你很可能需要它。</p>\n<h3 id=\"计数器\"><a href=\"#计数器\" class=\"headerlink\" title=\"计数器\"></a>计数器</h3><p><code>OSAtomicIncrement</code> 和 <code>OSAtomicDecrement</code> 有一个很长的函数列表允许你以原子操作的方式去增加和减少一个整数值 —— 不必使用锁（或者队列）同时也是线程安全的。如果你需要让一个全局的计数器值增加，而这个计数器为了统计目的而由多个线程操作，使用原子操作是很有帮助的。如果你要做的仅仅是增加一个全局计数器，那么无屏障版本的 <code>OSAtomicIncrement</code> 是很合适的，并且当没有锁竞争时，调用它们的代价很小。</p>\n<p>类似的，<code>OSAtomicOr</code> ，<code>OSAtomicAnd</code>，<code>OSAtomicXor</code> 的函数能用来进行逻辑运算，而 <code>OSAtomicTest</code> 可以用来设置和清除位。</p>\n<h4 id=\"10-2、比较和交换\"><a href=\"#10-2、比较和交换\" class=\"headerlink\" title=\"10.2、比较和交换\"></a>10.2、比较和交换</h4><p><code>OSAtomicCompareAndSwap</code> 能用来做无锁的惰性初始化，如下：</p>\n<p>void <em> sharedBuffer(void)<br>{<br>static void </em> buffer;<br>if (buffer == NULL) {<br>void * newBuffer = calloc(1, 1024);<br>if (!OSAtomicCompareAndSwapPtrBarrier(NULL, newBuffer, &amp;buffer)) {<br>free(newBuffer);<br>}<br>}<br>return buffer;<br>}</p>\n<p>如果没有 buffer，我们会创建一个，然后原子地将其写到 <code>buffer</code> 中如果 <code>buffer</code> 为NULL。在极少的情况下，其他人在当前线程同时设置了 <code>buffer</code> ，我们简单地将其释放掉。因为比较和交换方法是原子的，所以它是一个线程安全的方式去惰性初始化值。NULL的检测和设置 <code>buffer</code> 都是以原子方式完成的。</p>\n<p>明显的，使用 <code>dispatch_once()</code> 我们也可以完成类似的事情。</p>\n<h3 id=\"原子队列\"><a href=\"#原子队列\" class=\"headerlink\" title=\"原子队列\"></a>原子队列</h3><p><code>OSAtomicEnqueue()</code> 和 <code>OSAtomicDequeue()</code> 可以让你以线程安全，无锁的方式实现一个LIFO队列(常见的就是栈)。对有潜在精确要求的代码来说，这会是强大的代码。</p>\n<p>还有  <code>OSAtomicFifoEnqueue()</code> 和 <code>OSAtomicFifoDequeue()</code> 函数是为了操作FIFO队列，但这些只有在头文件中才有文档 —— 阅读他们的时候要小心。</p>\n<h3 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h3><p>最后，<code>OSAtomic.h</code> 头文件定义了使用自旋锁的函数：<code>OSSpinLock</code>。同样的，维基百科有深入的有关<a href=\"https://en.wikipedia.org/wiki/Spinlock\" target=\"_blank\" rel=\"noopener\">自旋锁</a>的信息。使用命令 <code>man 3 spinlock</code> 查看帮助页的 <code>spinlock(3)</code> 。当没有锁竞争时使用自旋锁代价很小。</p>\n<p>在合适的情况下，使用自旋锁对性能优化是很有帮助的。一如既往：先测量，然后优化。不要做乐观的优化。</p>\n<p>下面是 OSSpinLock 的一个例子：</p>\n<p>@interface MyTableViewCell : UITableViewCell</p>\n<p>@property (readonly, nonatomic, copy) NSDictionary *amountAttributes;</p>\n<p>@end</p>\n<p>@implementation MyTableViewCell<br>{<br>NSDictionary *_amountAttributes;<br>}</p>\n<ul>\n<li>(NSDictionary <em>)amountAttributes;<br>{<br>if (_amountAttributes == nil) {<br>static __weak NSDictionary </em>cachedAttributes = nil;<br>static OSSpinLock lock = OS_SPINLOCK_INIT;<br>OSSpinLockLock(&amp;lock);<br>_amountAttributes = cachedAttributes;<br>if (_amountAttributes == nil) {<br>NSMutableDictionary *attributes = [[self subtitleAttributes] mutableCopy];<br>attributes[NSFontAttributeName] = [UIFont fontWithName:@”ComicSans” size:36];<br>attributes[NSParagraphStyleAttributeName] = [NSParagraphStyle defaultParagraphStyle];<br>_amountAttributes = [attributes copy];<br>cachedAttributes = _amountAttributes;<br>}<br>OSSpinLockUnlock(&amp;lock);<br>}<br>return _amountAttributes;<br>}</li>\n</ul>\n<p>就上面的例子而言，或许用不着这么麻烦，但它演示了一种理念。我们使用了ARC的 <code>__weak</code> 来确保一旦 <code>MyTableViewCell</code> 所有的实例都不存在， <code>amountAttributes</code> 会调用 <code>dealloc</code> 。因此在所有的实例中，我们可以持有字典的一个单独实例。</p>\n<p>这段代码运行良好的原因是我们不太可能访问到方法最里面的部分。这是很深奥的——除非你真正需要，不然不要在你的 App 中使用它。</p>\n<hr>\n<p><a href=\"http://objccn.io/issue-2\" target=\"_blank\" rel=\"noopener\">话题 #2 下的更多文章</a></p>\n<p>原文 <a href=\"http://www.objc.io/issue-2/low-level-concurrency-apis.html\" target=\"_blank\" rel=\"noopener\">Low-Level Concurrency APIs</a></p>\n<p>译文 <a href=\"http://webfrogs.me/2013/07/18/low-level_concurrency_apis/\" target=\"_blank\" rel=\"noopener\">Objc的底层并发API - webfrogs</a></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"API","path":"api/categories/API.json"}],"tags":[]},{"title":"常见的后台实现","slug":"iOS/常见的后台实现","date":"2017-09-24T11:03:35.000Z","updated":"2017-09-24T11:03:35.000Z","comments":true,"path":"api/articles/iOS/常见的后台实现.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h2><p>本文主要探讨一些常用后台任务的最佳实践：</p>\n<ol>\n<li>如何做异步网络请求</li>\n<li>如何异步处理大型文件，以保持较低的内存占用</li>\n</ol>\n<h3 id=\"操作队列-Operation-Queues-还是-GCD\"><a href=\"#操作队列-Operation-Queues-还是-GCD\" class=\"headerlink\" title=\"操作队列 (Operation Queues) 还是 GCD ?\"></a>操作队列 (Operation Queues) 还是 GCD ?</h3><p>操作队列提供了在 GCD 中不那么容易复制的有用特性。其中最重要的一个就是可以取消在任务处理队列中的任务，而且操作队列在管理操作间的依赖关系方面也容易一些。<br>GCD 给予你更多的控制权力以及操作队列中所不能使用的底层函数。详细介绍可以参考<a href=\"http://www.objccn.io/issue-2-3/\" target=\"_blank\" rel=\"noopener\">底层并发 API</a> 这篇文章。</p>\n<h2 id=\"后台-UI-代码\"><a href=\"#后台-UI-代码\" class=\"headerlink\" title=\"后台 UI 代码\"></a>后台 UI 代码</h2><p>首先要强调：UIKit 只能在主线程上运行。而那部分不与 UIKit 直接相关，却会消耗大量时间的 UI 代码可以被移动到后台去处理，以避免其将主线程阻塞太久。</p>\n<h3 id=\"后台获取UI数据\"><a href=\"#后台获取UI数据\" class=\"headerlink\" title=\"后台获取UI数据\"></a>后台获取UI数据</h3><p>例如使用操作队列隔离以下昂贵操作：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">id</span> weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.operationQueue addOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSNumber</span>* result = findLargestMersennePrime();</span><br><span class=\"line\">    [[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class=\"line\">        MyClass* strongSelf = weakSelf;</span><br><span class=\"line\">        strongSelf.textLabel.text = [result stringValue];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></p>\n<p>如你所见，这些代码其实一点也不直接明了。我们首先声明了一个 weak 引用来参照 self，否则会形成循环引用（ block 持有了 self，私有的 <code>operationQueue</code> retain 了 block，而 self 又 retain 了 <code>operationQueue</code> ）。为了避免在运行 block 时访问到已被释放的对象，在 block 中我们又需要将其转回 strong 引用。</p>\n<blockquote>\n<p>这在 ARC 和 block 主导的编程范式中是解决 retain cycle 的一种常见也是最标准的方法。</p>\n</blockquote>\n<h3 id=\"后台绘制UI\"><a href=\"#后台绘制UI\" class=\"headerlink\" title=\"后台绘制UI\"></a>后台绘制UI</h3><p>如果你确定 <code>drawRect:</code> 是你的应用的性能瓶颈，那么你可以将这些绘制代码放到后台去做。但是在你这样做之前，检查下看看是不是有其他方法来解决，比如、考虑使用 core animation layers 或者预先渲染图片而不去做 Core Graphics 绘制。</p>\n<p>如果你确实认为在后台执行绘制代码会是你的最好选择时再这么做。其实解决起来也很简单，把 <code>drawRect:</code> 中的代码放到一个后台操作中去做就可以了。然后将原本打算绘制的视图用一个 image view 来替换，等到操作执行完后再去更新。在绘制的方法中，使用 <code>UIGraphicsBeginImageContextWithOptions</code> 来取代 <code>UIGraphicsGetCurrentContext</code> ：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIGraphicsBeginImageContextWithOptions</span>(size, <span class=\"literal\">NO</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// drawing code here</span></span><br><span class=\"line\"><span class=\"built_in\">UIImage</span> *i = <span class=\"built_in\">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class=\"line\"><span class=\"built_in\">UIGraphicsEndImageContext</span>();</span><br><span class=\"line\"><span class=\"keyword\">return</span> i;</span><br></pre></td></tr></table></figure></p>\n<p>通过在第三个参数中传入 0 ，设备的主屏幕的 scale 将被自动传入，这将使图片在普通设备和 retina 屏幕上都有良好的表现。</p>\n<h4 id=\"cell在操作队列中异步绘制\"><a href=\"#cell在操作队列中异步绘制\" class=\"headerlink\" title=\"cell在操作队列中异步绘制\"></a>cell在操作队列中异步绘制</h4><p>如果你在 table view 或者是 collection view 的 cell 上做了自定义绘制的话，最好将它们放入 operation 的子类中去。你可以将它们添加到后台操作队列，也可以在用户将 cell 滚动出边界时的 <code>didEndDisplayingCell</code> 委托方法中进行取消。这些技巧都在 2012 年的WWDC <a href=\"https://developer.apple.com/videos/wwdc/2012/\" target=\"_blank\" rel=\"noopener\">Session 211 – Building Concurrent User Interfaces on iOS</a>中有详细阐述。</p>\n<h4 id=\"其他方案\"><a href=\"#其他方案\" class=\"headerlink\" title=\"其他方案\"></a>其他方案</h4><p>除了在后台自己调度绘制代码，以也可以试试看使用 <code>CALayer</code> 的 <code>drawsAsynchronously</code> 属性。然而你需要精心衡量这样做的效果，因为有时候它能使绘制加速，有时候却适得其反。</p>\n<h2 id=\"异步网络请求处理\"><a href=\"#异步网络请求处理\" class=\"headerlink\" title=\"异步网络请求处理\"></a>异步网络请求处理</h2><p>你的所有网络请求都应该采取异步的方式完成。</p>\n<p>然而，在 GCD 下，有时候你可能会看到这样的代码<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 警告：不要使用这些代码。</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(backgroundQueue, ^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSData</span>* contents = [<span class=\"built_in\">NSData</span> dataWithContentsOfURL:url]</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理取到的日期</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>乍看起来没什么问题，但是这段代码却有致命缺陷。你没有办法去取消这个同步的网络请求。它将阻塞主线程直到它完成。如果请求一直没结果，那就只能干等到超时（比如 <code>dataWithContentsOfURL:</code> 的超时时间是 30 秒）。</p>\n<h3 id=\"分析状况\"><a href=\"#分析状况\" class=\"headerlink\" title=\"分析状况\"></a>分析状况</h3><ol>\n<li>当队列是串行执行时，它将一直被阻塞住。</li>\n<li>当队列是并行执行时，GCD 需要重开一个线程来补凑你阻塞住的线程。</li>\n</ol>\n<p>两种结果都不太妙，所以最好还是不要阻塞线程。</p>\n<h3 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h3><p>要解决上面的困境，我们可以使用 <code>NSURLConnection</code> 的异步方法，并且把所有操作转化为 operation 来执行。通过这种方法，我们可以从操作队列的强大功能和便利中获益良多：我们能轻易地控制并发操作的数量，添加依赖，以及取消操作。<br>例如：在<code>NSOperation</code>子类<code>DownloadOperation</code>中重写<code>start</code>方法，并实现<code>NSURLConnectionDelegate</code>代理方法。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">DownloadOperation</span> : <span class=\"title\">NSOperation</span>&lt;<span class=\"title\">NSURLConnectionDelegate</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)start</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequest</span>* request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:<span class=\"keyword\">self</span>.url];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.isExecuting = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.isConcurrent = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.isFinished = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    [[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.connection = [<span class=\"built_in\">NSURLConnection</span> connectionWithRequest:request delegate:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然而，在这里还有一些事情值得注意： <code>NSURLConnection</code> 是通过 run loop 来发送事件的。因为发送事件不会花多少时间，因此最简单的是就只使用 main run loop 来做这个。然后，我们就可以用后台线程来处理输入的数据了。</p>\n<h3 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h3><p>另一种可能的方式是使用像 <a href=\"http://afnetworking.com\" target=\"_blank\" rel=\"noopener\">AFNetworking</a> 这样的框架：建立一个独立的线程，为建立的线程设置自己的 run loop，然后在其中调度 URL 连接。但是并不推荐你自己去实现这些事情。</p>\n<p>要处理URL 连接，我们重写自定义的 operation 子类中的 <code>start</code> 方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)start</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequest</span>* request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:<span class=\"keyword\">self</span>.url];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.isExecuting = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.isFinished = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    [[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.connection = [<span class=\"built_in\">NSURLConnectionconnectionWithRequest</span>:request</span><br><span class=\"line\">        delegate:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于重写的是 <code>start</code> 方法，所以我们需要自己要管理操作的 <code>isExecuting</code> 和 <code>isFinished</code> 状态。要取消一个操作，我们需要取消 connection ，并且设定合适的标记，这样操作队列才知道操作已经完成。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)cancel</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> cancel];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.connection cancel];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.isFinished = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.isExecuting = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当连接完成加载后，它向代理发送回调：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)connectionDidFinishLoading:(<span class=\"built_in\">NSURLConnection</span> *)connection</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.data = <span class=\"keyword\">self</span>.buffer;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.buffer = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.isExecuting = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.isFinished = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>就这么多了。完整的代码可以参见<a href=\"https://github.com/objcio/issue-2-background-networking\" target=\"_blank\" rel=\"noopener\">GitHub上的示例工程</a>。</p>\n<p>总结来说，我们建议要么你花时间来把事情做对做好，要么就直接使用像 <a href=\"http://afnetworking.com/\" target=\"_blank\" rel=\"noopener\">AFNetworking</a> 这样的框架。其实 <a href=\"http://afnetworking.com/\" target=\"_blank\" rel=\"noopener\">AFNetworking</a> 还提供了不少好用的小工具，比如有个 <code>UIImageView</code> 的 category，来负责异步地从一个 URL 加载图片。在你的 table view 里使用的话，还能自动帮你处理取消加载操作，非常方便。</p>\n<p>扩展阅读：</p>\n<ul>\n<li><a href=\"http://developer.apple.com/library/ios/#documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091-CH1-SW1\" target=\"_blank\" rel=\"noopener\">Concurrency Programming Guide</a></li>\n<li><a href=\"http://developer.apple.com/library/ios/#documentation/Cocoa/Reference/NSOperation_class/Reference/Reference.html%23http://developer.apple.com/library/ios/#documentation/Cocoa/Reference/NSOperation_class/Reference/Reference.html%23//apple_ref/doc/uid/TP40004591-RH2-SW15\" target=\"_blank\" rel=\"noopener\">NSOperation Class Reference: Concurrent vs. Non-Concurrent Operations</a></li>\n<li><a href=\"http://www.cocoaintheshell.com/2011/04/nsurlconnection-synchronous-asynchronous/\" target=\"_blank\" rel=\"noopener\">Blog: synchronous vs. asynchronous NSURLConnection</a></li>\n<li><a href=\"https://github.com/rs/SDWebImage/blob/master/SDWebImage/SDWebImageDownloaderOperation.m\" target=\"_blank\" rel=\"noopener\">GitHub: <code>SDWebImageDownloaderOperation.m</code></a></li>\n<li><a href=\"http://www.cocoaintheshell.com/2011/05/progressive-images-download-imageio/\" target=\"_blank\" rel=\"noopener\">Blog: Progressive image download with ImageIO</a></li>\n<li><a href=\"https://developer.apple.com/videos/wwdc/2012/\" target=\"_blank\" rel=\"noopener\">WWDC 2012 Session 211: Building Concurrent User Interfaces on iOS</a></li>\n</ul>\n<h2 id=\"进阶：后台文件-I-O\"><a href=\"#进阶：后台文件-I-O\" class=\"headerlink\" title=\"进阶：后台文件 I/O\"></a>进阶：后台文件 I/O</h2><p>构建一个类，负责一行一行读取文件而不是一次将整个文件读入内存，另外要在后台队列处理文件，以保持应用相应用户的操作。<br>为了达到这个目的，我们使用能让我们异步处理文件的 <code>NSInputStream</code> 。根据<a href=\"http://developer.apple.com/library/ios/#documentation/FileManagement/Conceptual/FileSystemProgrammingGUide/TechniquesforReadingandWritingCustomFiles/TechniquesforReadingandWritingCustomFiles.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>的描述：</p>\n<blockquote>\n<p>如果你总是需要从头到尾来读/写文件的话，streams 提供了一个简单的接口来异步完成这个操作</p>\n</blockquote>\n<p>不管你是否使用 streams，大体上逐行读取一个文件的模式是这样的：</p>\n<ol>\n<li>建立一个中间缓冲层以提供，当没有找到换行符号的时候可以向其中添加数据</li>\n<li>从 stream 中读取一块数据</li>\n<li>对于这块数据中发现的每一个换行符，取中间缓冲层，向其中添加数据，直到（并包括）这个换行符，并将其输出</li>\n<li>将剩余的字节添加到中间缓冲层去</li>\n<li>回到 2，直到 stream 关闭</li>\n</ol>\n<p>为了将其运用到实践中，我们又建立了一个<a href=\"https://github.com/objcio/issue-2-background-file-io\" target=\"_blank\" rel=\"noopener\">示例应用</a>，里面有一个 <code>Reader</code> 类完成了这件事情，它的接口十分简单<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Reader</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)enumerateLines:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSString</span>*))block completion:(<span class=\"keyword\">void</span> (^)())completion;</span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)initWithFileAtPath:(<span class=\"built_in\">NSString</span>*)path;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"runloop分发NSInputStream事件\"><a href=\"#runloop分发NSInputStream事件\" class=\"headerlink\" title=\"runloop分发NSInputStream事件\"></a>runloop分发NSInputStream事件</h4><p>注意，这个类不是 NSOperation 的子类。与 URL connections 类似，输入的 streams 通过 run loop 来传递它的事件。这里，我们仍然采用 main run loop 来分发事件，然后将数据处理过程派发至后台操作线程里去处理。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)enumerateLines:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSString</span>*))block</span><br><span class=\"line\">completion:(<span class=\"keyword\">void</span> (^)())completion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.queue == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.queue.maxConcurrentOperationCount = <span class=\"number\">1</span>;  <span class=\"comment\">//串行队列</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.callback = block;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.completion = completion;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.inputStream = [<span class=\"built_in\">NSInputStream</span> inputStreamWithURL:<span class=\"keyword\">self</span>.fileURL];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.inputStream.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    <span class=\"comment\">//分发NSInputStream事件</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.inputStream scheduleInRunLoop:[<span class=\"built_in\">NSRunLoop</span> currentRunLoop]</span><br><span class=\"line\">                                forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.inputStream open];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用时的代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)import:(<span class=\"keyword\">id</span>)sender</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *fileURL = [[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"Clarissa Harlowe\"</span> withExtension:<span class=\"string\">@\"txt\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSAssert</span>([[<span class=\"built_in\">NSFileManager</span> defaultManager] fileExistsAtPath:[fileURL path]], <span class=\"string\">@\"Please download the sample data\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.reader = [[Reader alloc] initWithFileAtURL:fileURL];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.reader enumerateLinesWithBlock:^(<span class=\"built_in\">NSUInteger</span> i, <span class=\"built_in\">NSString</span> *line)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((i % <span class=\"number\">2000</span>ull) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"i: %d\"</span>, i);</span><br><span class=\"line\">        [[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span>.button setTitle:line forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; completionHandler:^(<span class=\"built_in\">NSUInteger</span> numberOfLines)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"lines: %d\"</span>, numberOfLines);</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.button setTitle:<span class=\"string\">@\"Done\"</span> forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"NSInputStream代理方法\"><a href=\"#NSInputStream代理方法\" class=\"headerlink\" title=\"NSInputStream代理方法\"></a>NSInputStream代理方法</h4><p>现在，input stream 将（在主线程）向我们发送代理消息，然后我们可以在操作队列中加入一个 block 操作来执行处理了：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)stream:(<span class=\"built_in\">NSStream</span>*)stream handleEvent:(<span class=\"built_in\">NSStreamEvent</span>)eventCode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (eventCode) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"built_in\">NSStreamEventHasBytesAvailable</span>: &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSMutableData</span> *buffer = [<span class=\"built_in\">NSMutableData</span> dataWithLength:<span class=\"number\">4</span> * <span class=\"number\">1024</span>];</span><br><span class=\"line\">            <span class=\"built_in\">NSUInteger</span> length = [<span class=\"keyword\">self</span>.inputStream read:[buffer mutableBytes]</span><br><span class=\"line\">                                             maxLength:[buffer length]];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"number\">0</span> &lt; length) &#123;</span><br><span class=\"line\">                [buffer setLength:length];</span><br><span class=\"line\">                __<span class=\"keyword\">weak</span> <span class=\"keyword\">id</span> weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">                [<span class=\"keyword\">self</span>.queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//在后台串行队列的线程池中逐行处理缓冲区</span></span><br><span class=\"line\">                    [weakSelf processDataChunk:buffer];</span><br><span class=\"line\">                &#125;];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"缓冲区处理\"><a href=\"#缓冲区处理\" class=\"headerlink\" title=\"缓冲区处理\"></a>缓冲区处理</h4><p>处理数据块的过程是先查看当前已缓冲的数据，并将新加入的数据附加上去。接下来它将按照换行符分解成小的部分，并逐行处理。<br>数据处理过程中会不断的从buffer中获取已读入的数据。然后把这些新读入的数据按行分开并存储。剩余的数据被再次存储到缓冲区中：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)processDataChunk:(<span class=\"built_in\">NSMutableData</span> *)buffer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.remainder != <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.remainder appendData:buffer];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.remainder = buffer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.remainder obj_enumerateComponentsSeparatedBy:<span class=\"keyword\">self</span>.delimiter</span><br><span class=\"line\">                            usingBlock:^(<span class=\"built_in\">NSData</span>* component, <span class=\"built_in\">BOOL</span> last) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!last) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span> emitLineWithData:component];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"number\">0</span> &lt; [component length]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.remainder = [component mutableCopy];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.remainder = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)emitLineWithData:(<span class=\"built_in\">NSData</span> *)data;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSUInteger</span> lineNumber = <span class=\"keyword\">self</span>.lineNumber;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.lineNumber = lineNumber + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">0</span> &lt; data.length) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> *line = [[<span class=\"built_in\">NSString</span> alloc] initWithData:data encoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.callback(lineNumber, line);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在你运行示例应用的话，会发现它在响应事件时非常迅速，内存的开销也保持很低（在我们测试时，不论读入的文件有多大，堆所占用的内存量始终低于 800KB）。绝大部分时候，使用逐块读入的方式来处理大文件，是非常有用的技术。</p>\n<p>延伸阅读：</p>\n<ul>\n<li><a href=\"http://developer.apple.com/library/ios/#documentation/FileManagement/Conceptual/FileSystemProgrammingGUide/TechniquesforReadingandWritingCustomFiles/TechniquesforReadingandWritingCustomFiles.html\" target=\"_blank\" rel=\"noopener\">File System Programming Guide: Techniques for Reading and Writing Files Without File Coordinators</a></li>\n<li><a href=\"http://stackoverflow.com/questions/3707427/how-to-read-data-from-nsfilehandle-line-by-line\" target=\"_blank\" rel=\"noopener\">StackOverflow: How to read data from NSFileHandle line by line?</a></li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过我们所列举的几个示例，我们展示了如何异步地在后台执行一些常见任务。在所有的解决方案中，我们尽力保持了代码的简单，这是因为在并发编程中，稍不留神就会捅出篓子来。</p>\n<p>很多时候为了避免麻烦，你可能更愿意在主线程中完成你的工作，在你能这么做事，这确实让你的工作轻松不少，但是当你发现性能瓶颈时，你可以尝试尽可能用最简单的策略将那些繁重任务放到后台去做。</p>\n<p>我们在上面例子中所展示的方法对于其他任务来说也是安全的选择。在主队列中接收事件或者数据，然后用后台操作队列来执行实际操作，然后回到主队列去传递结果，遵循这样的原则来编写尽量简单的并行代码，将是保证高效正确的不二法则。</p>\n<hr>\n<p><a href=\"http://objccn.io/issue-2\" target=\"_blank\" rel=\"noopener\">话题 #2 下的更多文章</a></p>\n<p>原文 <a href=\"http://www.objc.io/issue-2/common-background-practices.html\" target=\"_blank\" rel=\"noopener\">Common Background Practices</a></p>\n<p>译文 <a href=\"http://onevcat.com/2014/03/common-background-practices/\" target=\"_blank\" rel=\"noopener\">常见的后台实践</a></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"API","path":"api/categories/API.json"}],"tags":[]},{"title":"iOS多线程API介绍","slug":"iOS/iOS多线程API介绍","date":"2017-09-24T09:18:49.000Z","updated":"2017-09-24T09:18:49.000Z","comments":true,"path":"api/articles/iOS/iOS多线程API介绍.json","excerpt":null,"keywords":null,"cover":"https://www.objccn.io/images/issues/issue-2/gcd-queues.png","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><a href=\"http://en.wikipedia.org/wiki/Concurrency_%28computer_science%29\" target=\"_blank\" rel=\"noopener\">并发</a>所描述的概念就是同时运行多个任务。这些任务可能是以在单核 CPU 上<a href=\"http://en.wikipedia.org/wiki/Preemption_%28computing%29\" target=\"_blank\" rel=\"noopener\">分时（时间共享）</a>的形式同时运行，也可能是在多核 CPU 上以真正的并行方式来运行。</p>\n<p>OS X 和 iOS 提供了几种不同的 API 来支持并发编程。每一个 API 都具有不同的功能和使用限制，这使它们适合不同的任务。同时，这些 API 处在不同的抽象层级上。我们有可能用其进行非常深入底层的操作，但是这也意味着背负起将任务进行良好处理的巨大责任。</p>\n<p>实际上，并发编程是一个很有挑战的主题，它有许多错综复杂的问题和陷阱。当开发者在使用类似 <code>Grand Central Dispatch</code>（GCD）或 <code>NSOperationQueue</code> 的 API 时，很容易遗忘这些问题和陷阱。本文首先对 OS X 和 iOS 中不同的并发编程 API 进行一些介绍，然后再深入了解并发编程中独立于与你所使用的特定 API 的一些内在挑战。</p>\n<h2 id=\"OS-X-和-iOS-中的并发编程\"><a href=\"#OS-X-和-iOS-中的并发编程\" class=\"headerlink\" title=\"OS X 和 iOS 中的并发编程\"></a>OS X 和 iOS 中的并发编程</h2><p>OS X 和 iOS 提供了相同的并发编程API。 本文会介绍 <code>pthread</code> 、 <code>NSThread</code> 、<code>GCD</code> 、<code>NSOperationQueue</code>，以及 <code>NSRunLoop</code>（并非并发）。</p>\n<p>由于高层 API 是基于底层 API 构建的，所以我们首先将从底层的 API 开始介绍，然后逐步扩展到高层 API。不过在具体编程中，选择 API 的顺序刚好相反：因为大多数情况下，选择高层的 API 不仅可以完成底层 API 能完成的任务，而且能够让并发模型变得简单。</p>\n<p>如果你对我们为何坚持推荐使用高抽象层级以及简单的并行代码有所疑问的话，那么你可以看看这篇文章的第二部分<a href=\"#challenges\">并发编程中面临的挑战</a>，以及 Peter Steinberger 写的关于<a href=\"http://objccn.io/issue-2-4/\" target=\"_blank\" rel=\"noopener\">线程安全</a>的文章。</p>\n<h3 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h3><p><a href=\"http://zh.wikipedia.org/wiki/线程\" target=\"_blank\" rel=\"noopener\">线程</a>（thread）是组成进程的子单元，操作系统的调度器可以对线程进行单独的调度。实际上，所有的并发编程 API 都是构建于线程之上的 —— 包括 GCD 和操作队列（operation queues）。</p>\n<p>多线程可以在单核 CPU 上同时（或者至少看作同时）运行。操作系统将小的时间片分配给每一个线程，这样就能够让用户感觉到有多个任务在同时进行。如果 CPU 是多核的，那么线程就可以真正的以并发方式被执行，从而减少了完成某项操作所需要的总时间。</p>\n<p>你可以使用 Instruments 中的 <a href=\"http://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/AnalysingCPUUsageinYourOSXApp/AnalysingCPUUsageinYourOSXApp.html\" target=\"_blank\" rel=\"noopener\">CPU strategy view</a> 来得知你的代码或者你在使用的框架代码是如何在多核 CPU 中调度执行的。</p>\n<p>需要重点关注的是，你无法控制你的代码在什么地方以及什么时候被调度，以及无法控制执行多长时间后将被暂停，以便轮换执行别的任务。这种线程调度是非常强大的一种技术，但是也非常复杂，我们稍后研究。</p>\n<p>先把线程调度的复杂情况放一边，开发者可以使用 <a href=\"http://en.wikipedia.org/wiki/POSIX_Threads\" target=\"_blank\" rel=\"noopener\">POSIX 线程</a> API，或者 Objective-C 中提供的对该 API 的封装 <code>NSThread</code>，来创建自己的线程。</p>\n<h4 id=\"线程实例\"><a href=\"#线程实例\" class=\"headerlink\" title=\"线程实例\"></a>线程实例</h4><p><strong>在一百万个数字中查找最小值和最大值</strong>。</p>\n<h5 id=\"pthread-方式实现\"><a href=\"#pthread-方式实现\" class=\"headerlink\" title=\"pthread 方式实现\"></a><code>pthread</code> 方式实现</h5><p>下面这个小示例利用 <code>pthread</code> 来<strong>在一百万个数字中查找最小值和最大值</strong>。其中并发执行了 4 个线程。从该示例复杂的代码中，应该可以看出为什么你不会希望直接使用 pthread 。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">threadInfo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> * inputValues;</span><br><span class=\"line\"><span class=\"keyword\">size_t</span> count;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">threadResult</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> min;</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> max;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> * <span class=\"title\">findMinAndMax</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">threadInfo</span> <span class=\"title\">const</span> * <span class=\"title\">const</span> <span class=\"title\">info</span> = (<span class=\"title\">struct</span> <span class=\"title\">threadInfo</span> *) <span class=\"title\">arg</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> min = UINT32_MAX;</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; info-&gt;count; ++i) &#123;</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> v = info-&gt;inputValues[i];</span><br><span class=\"line\">min = MIN(min, v);</span><br><span class=\"line\">max = MAX(max, v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">free</span>(arg);</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">threadResult</span> * <span class=\"title\">const</span> <span class=\"title\">result</span> = (<span class=\"title\">struct</span> <span class=\"title\">threadResult</span> *) <span class=\"title\">malloc</span>(<span class=\"title\">sizeof</span>(*<span class=\"title\">result</span>));</span></span><br><span class=\"line\">result-&gt;min = min;</span><br><span class=\"line\">result-&gt;max = max;</span><br><span class=\"line\"><span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">size_t</span> <span class=\"keyword\">const</span> count = <span class=\"number\">1000000</span>;</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> inputValues[count];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用随机数字填充 inputValues</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; count; ++i) &#123;</span><br><span class=\"line\">inputValues[i] = arc4random();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开始4个寻找最小值和最大值的线程</span></span><br><span class=\"line\"><span class=\"keyword\">size_t</span> <span class=\"keyword\">const</span> threadCount = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">pthread_t</span> tid[threadCount];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; threadCount; ++i) &#123;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">threadInfo</span> * <span class=\"title\">const</span> <span class=\"title\">info</span> = (<span class=\"title\">struct</span> <span class=\"title\">threadInfo</span> *) <span class=\"title\">malloc</span>(<span class=\"title\">sizeof</span>(*<span class=\"title\">info</span>));</span></span><br><span class=\"line\"><span class=\"keyword\">size_t</span> offset = (count / threadCount) * i;</span><br><span class=\"line\">info-&gt;inputValues = inputValues + offset;</span><br><span class=\"line\">info-&gt;count = MIN(count - offset, count / threadCount);</span><br><span class=\"line\"><span class=\"keyword\">int</span> err = pthread_create(tid + i, <span class=\"literal\">NULL</span>, &amp;findMinAndMax, info);</span><br><span class=\"line\">NSCAssert(err == <span class=\"number\">0</span>, @<span class=\"string\">\"pthread_create() failed: %d\"</span>, err);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 等待线程退出</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">threadResult</span> * <span class=\"title\">results</span>[<span class=\"title\">threadCount</span>];</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; threadCount; ++i) &#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> err = pthread_join(tid[i], (<span class=\"keyword\">void</span> **) &amp;(results[i]));</span><br><span class=\"line\">NSCAssert(err == <span class=\"number\">0</span>, @<span class=\"string\">\"pthread_join() failed: %d\"</span>, err);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 寻找 min 和 max</span></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> min = UINT32_MAX;</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; threadCount; ++i) &#123;</span><br><span class=\"line\">min = MIN(min, results[i]-&gt;min);</span><br><span class=\"line\">max = MAX(max, results[i]-&gt;max);</span><br><span class=\"line\"><span class=\"built_in\">free</span>(results[i]);</span><br><span class=\"line\">results[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@<span class=\"string\">\"min = %u\"</span>, min);</span><br><span class=\"line\">NSLog(@<span class=\"string\">\"max = %u\"</span>, max);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"NSThread方式实现\"><a href=\"#NSThread方式实现\" class=\"headerlink\" title=\"NSThread方式实现\"></a>NSThread方式实现</h5><p><code>NSThread</code> 是 Objective-C 对 pthread 的一个封装。通过封装，在 Cocoa 环境中，可以让代码看起来更加亲切。例如，<strong>开发者可以利用 NSThread 的一个子类来定义一个线程，在这个子类的中封装需要在后台线程运行的代码</strong>。针对上面的那个例子，我们可以定义一个这样的 <code>NSThread</code> 子类：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">FindMinMaxThread</span> : <span class=\"title\">NSThread</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span> min;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span> max;</span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithNumbers:(<span class=\"built_in\">NSArray</span> *)numbers;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">FindMinMaxThread</span> </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *_numbers;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithNumbers:(<span class=\"built_in\">NSArray</span> *)numbers</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">_numbers = numbers;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"built_in\">NSUInteger</span> min;</span><br><span class=\"line\"><span class=\"built_in\">NSUInteger</span> max;</span><br><span class=\"line\"><span class=\"comment\">// 进行相关数据的处理</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.min = min;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.max = max;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>要想启动一个新的线程，需要创建一个线程对象，然后调用它的 <code>start</code> 方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableSet</span> *threads = [<span class=\"built_in\">NSMutableSet</span> set];</span><br><span class=\"line\"><span class=\"built_in\">NSUInteger</span> numberCount = <span class=\"keyword\">self</span>.numbers.count;</span><br><span class=\"line\"><span class=\"built_in\">NSUInteger</span> threadCount = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSUInteger</span> i = <span class=\"number\">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class=\"line\"><span class=\"built_in\">NSUInteger</span> offset = (count / threadCount) * i;</span><br><span class=\"line\"><span class=\"built_in\">NSUInteger</span> count = MIN(numberCount - offset, numberCount / threadCount);</span><br><span class=\"line\"><span class=\"built_in\">NSRange</span> range = <span class=\"built_in\">NSMakeRange</span>(offset, count);</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *subset = [<span class=\"keyword\">self</span>.numbers subarrayWithRange:range];</span><br><span class=\"line\">FindMinMaxThread *thread = [[FindMinMaxThread alloc] initWithNumbers:subset];</span><br><span class=\"line\">[threads addObject:thread];</span><br><span class=\"line\">[thread start];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，我们可以<strong>通过检测到线程的 <code>isFinished</code> 属性来检测新生成的线程是否已经结束，并获取结果</strong>。</p>\n<h4 id=\"线程问题\"><a href=\"#线程问题\" class=\"headerlink\" title=\"线程问题\"></a>线程问题</h4><p>直接使用线程可能会引发的一个问题是，如果你的代码和所基于的框架代码都创建自己的线程时，那么活动的线程数量有可能以指数级增长。这在大型工程中是一个常见问题。例如，在 8 核 CPU 中，你创建了 8 个线程来完全发挥 CPU 性能。然而在这些线程中你的代码所调用的框架代码也做了同样事情（因为它并不知道你已经创建的这些线程），这样会很快产生成成百上千的线程。代码的每个部分自身都没有问题，然而最后却还是导致了问题。使用线程并不是没有代价的，每个线程都会消耗一些内存和内核资源。</p>\n<p>接下来，我们将介绍两个基于队列的并发编程 API ：GCD 和 operation queue 。它们通过集中管理一个被大家协同使用的<a href=\"http://en.wikipedia.org/wiki/Thread_pool_pattern\" target=\"_blank\" rel=\"noopener\">线程池</a>，来解决上面遇到的问题。</p>\n<h3 id=\"Grand-Central-Dispatch\"><a href=\"#Grand-Central-Dispatch\" class=\"headerlink\" title=\"Grand Central Dispatch\"></a>Grand Central Dispatch</h3><p>为了让开发者更加容易的使用设备上的多核CPU，苹果在 OS X 10.6 和 iOS 4 中引入了 Grand Central Dispatch（GCD）。在下一篇关于<a href=\"http://objccn.io/issue-2-3/\" target=\"_blank\" rel=\"noopener\">底层并发 API</a> 的文章中，我们将更深入地介绍 GCD。</p>\n<p>通过 GCD，开发者不用再直接跟线程打交道了，只需要向队列中添加代码块即可，GCD 在后端管理着一个<a href=\"http://en.wikipedia.org/wiki/Thread_pool_pattern\" target=\"_blank\" rel=\"noopener\">线程池</a>。GCD 不仅决定着你的代码块将在哪个线程被执行，它还根据可用的系统资源对这些线程进行管理。这样可以将开发者从线程管理的工作中解放出来，通过集中的管理线程，来缓解大量线程被创建的问题。</p>\n<p>GCD 带来的另一个重要改变是，作为开发者可以将工作考虑为一个队列，而不是一堆线程，这种并行的抽象模型更容易掌握和使用。</p>\n<p>GCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）。<br>另外，开发者可以创建自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有 block 最终都将被放入到系统的全局队列中和线程池中。</p>\n<p><img src=\"https://www.objccn.io/images/issues/issue-2/gcd-queues.png\" alt=\"GCD queues\"></p>\n<p>使用不同优先级的若干个队列乍听起来非常直接，不过，我们强烈建议，在绝大多数情况下使用默认的优先级队列就可以了。如果执行的任务需要访问一些共享的资源，那么在不同优先级的队列中调度这些任务很快就会造成不可预期的行为。这样可能会引起程序的完全挂起，因为低优先级的任务阻塞了高优先级任务，使它不能被执行。更多相关内容，在本文的<a href=\"#Priority-Inversion\">优先级反转</a>部分中会有介绍。</p>\n<p>虽然 GCD 是一个低层级的 C API ，但是它使用起来非常的直接。不过这也容易使开发者忘记并发编程中的许多注意事项和陷阱。读者可以阅读本文后面的<a href=\"#challenges\">并发编程中面临的挑战</a>，这样可以注意到一些潜在的问题。本期的另外一篇优秀文章：<a href=\"http://objccn.io/issue-2-3/\" target=\"_blank\" rel=\"noopener\">底层并发 API</a> 中，包含了很多深入的解释和一些有价值的提示。</p>\n<h3 id=\"Operation-Queues\"><a href=\"#Operation-Queues\" class=\"headerlink\" title=\"Operation Queues\"></a>Operation Queues</h3><p>操作队列（operation queue）是由 GCD 提供的一个队列模型的 Cocoa 抽象。GCD 提供了更加底层的控制，而操作队列则在 GCD 之上实现了一些方便的功能，这些功能对于 app 的开发者来说通常是最好最安全的选择。</p>\n<h4 id=\"操作队列成员\"><a href=\"#操作队列成员\" class=\"headerlink\" title=\"操作队列成员\"></a>操作队列成员</h4><ol>\n<li>主队列：在主线程上运行</li>\n<li>自定义队列：在后台子线程上执行</li>\n<li>操作任务：<code>NSOperation</code> 的子类，即在前两种队列中所要执行的任务代码</li>\n</ol>\n<h4 id=\"实现操作任务\"><a href=\"#实现操作任务\" class=\"headerlink\" title=\"实现操作任务\"></a>实现操作任务</h4><p>你可以通过重写 <code>main</code> 或者 <code>start</code> 方法 来定义自己的 <code>operations</code> 。</p>\n<h5 id=\"重写-main方法\"><a href=\"#重写-main方法\" class=\"headerlink\" title=\"重写 main方法\"></a>重写 <code>main</code>方法</h5><p>当 <code>main</code> 方法返回的时候，这个 operation 就结束了。无法控制操作状态属性（例如 <code>isExecuting</code> 和 <code>isFinished</code>）。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YourOperation</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">// 进行处理 ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"重写-start方法\"><a href=\"#重写-start方法\" class=\"headerlink\" title=\"重写 start方法\"></a>重写 <code>start</code>方法</h5><p>这种方式可以拥有更多的控制权，以及在一个操作中可以执行异步任务，重写 <code>start</code> 方法必须手动管理操作的状态（例如 <code>isExecuting</code> 和 <code>isFinished</code>）。</p>\n<ol>\n<li><p>重写实现：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YourOperation</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)start</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.isExecuting = <span class=\"literal\">YES</span>;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.isFinished = <span class=\"literal\">NO</span>;</span><br><span class=\"line\"><span class=\"comment\">// 开始处理，在结束时应该调用 finished ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)finished</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.isExecuting = <span class=\"literal\">NO</span>;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.isFinished = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p> 注意：这种情况下，你必须手动管理操作的状态。 为了让操作队列能够捕获到操作的改变，需要将状态的属性以配合 KVO 的方式进行实现。如果你不使用它们默认的 setter 来进行设置的话，你就需要在合适的时候发送合适的 KVO 消息。</p>\n</li>\n<li><p>取消功能的实现<br>为了能使用操作队列所提供的取消功能，你需要在长时间操作中时不时地检查 <code>isCancelled</code> 属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (notDone &amp;&amp; !<span class=\"keyword\">self</span>.isCancelled) &#123;</span><br><span class=\"line\"><span class=\"comment\">// 进行处理</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重写 operation 的<code>description</code> 方法<br>这样就可以很容易的标示出在某个队列中当前被调度的所有操作 。</p>\n<h4 id=\"操作队列管理\"><a href=\"#操作队列管理\" class=\"headerlink\" title=\"操作队列管理\"></a>操作队列管理</h4><h5 id=\"添加操作任务\"><a href=\"#添加操作任务\" class=\"headerlink\" title=\"添加操作任务\"></a>添加操作任务</h5><p>当你定义好 operation 类之后，就可以很容易的将一个 operation 添加到队列中：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span> *queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\">YourOperation *operation = [[YourOperation alloc] init];</span><br><span class=\"line\">[queue addOperation:operation];</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"添加一次性任务\"><a href=\"#添加一次性任务\" class=\"headerlink\" title=\"添加一次性任务\"></a>添加一次性任务</h5><p>另外，你也可以将 block 添加到操作队列中。这有时候会非常的方便，比如你希望在主队列中调度一个一次性任务：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class=\"line\"><span class=\"comment\">// 代码...</span></span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"操作队列的任务个数\"><a href=\"#操作队列的任务个数\" class=\"headerlink\" title=\"操作队列的任务个数\"></a>操作队列的任务个数</h5><p>除了提供基本的调度操作或 block 外，操作队列还提供了在 GCD 中不太容易处理好的特性的功能。例如，你可以通过 <code>maxConcurrentOperationCount</code> 属性来控制一个特定队列中可以有多少个操作参与并发执行。将其设置为 1 的话，你将得到一个串行队列，这在以隔离为目的的时候会很有用。</p>\n<h5 id=\"操作优先级\"><a href=\"#操作优先级\" class=\"headerlink\" title=\"操作优先级\"></a>操作优先级</h5><p>另外还有一个方便的功能就是根据队列中 <code>operation</code> 的优先级对其进行排序，这不同于 GCD 的队列优先级，它只影响当前队列中所有被调度的 operation 的执行先后。</p>\n<h5 id=\"操作依赖\"><a href=\"#操作依赖\" class=\"headerlink\" title=\"操作依赖\"></a>操作依赖</h5><p>如果你需要进一步在除了 5 个标准的优先级以外对 operation 的执行顺序进行控制的话，还可以在 operation 之间指定依赖关系。<br>使用<code>NSOperation</code>类的实例方法<code>addDependency:</code>实现操作之间的依赖关系。<br>对于需要明确的执行顺序时，操作依赖是非常强大的一个机制。它可以让你创建一些操作组，并确保这些操作组在依赖它们的操作被执行之前执行，或者在并发队列中以串行的方式执行操作。<br>如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[intermediateOperation addDependency:operation1];</span><br><span class=\"line\">[intermediateOperation addDependency:operation2];</span><br><span class=\"line\">[finishedOperation addDependency:intermediateOperation];</span><br></pre></td></tr></table></figure></p>\n<p>这些简单的代码可以确保 <code>operation1</code> 和 <code>operation2</code> 在 <code>intermediateOperation</code> 之前执行，当然，也会在 <code>finishOperation</code> 之前被执行。</p>\n<p>从本质上来看，操作队列的性能比 GCD 要低那么一点，不过，大多数情况下这点负面影响可以忽略不计，操作队列是并发编程的首选工具。</p>\n<h3 id=\"Run-Loops\"><a href=\"#Run-Loops\" class=\"headerlink\" title=\"Run Loops\"></a>Run Loops</h3><p>实际上，Run loop并不像 GCD 或者操作队列那样是一种并发机制，因为它并不能并行执行任务。不过在主 dispatch/operation 队列中， run loop 将直接配合任务的执行，它提供了一种异步执行代码的机制。</p>\n<p>Run loop 比起操作队列或者 GCD 来说容易使用得多，因为通过 run loop ，你不必处理并发中的复杂情况，就能异步地执行任务。</p>\n<h4 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h4><p>一个 run loop 总是绑定到某个特定的线程中。main run loop 是与主线程相关的，在每一个 Cocoa 和 CocoaTouch 程序中，这个 main run loop 都扮演了一个核心角色，它负责处理 UI 事件、计时器，以及其它内核相关事件。无论你什么时候设置计时器、使用 <code>NSURLConnection</code> 或者调用 <code>performSelector:withObject:afterDelay:</code>，其实背后都是 run loop 在处理这些异步任务。</p>\n<h4 id=\"runloop运行模式\"><a href=\"#runloop运行模式\" class=\"headerlink\" title=\"runloop运行模式\"></a>runloop运行模式</h4><p>无论何时你使用 run loop 来执行一个方法的时候，都需要记住一点：run loop 可以运行在不同的模式中，每种模式都定义了一组事件，供 run loop 做出响应。这在对应 main run loop 中暂时性的将某个任务优先执行这种任务上是一种聪明的做法。</p>\n<p>关于这点，在 iOS 中非常典型的一个示例就是滚动。在进行滚动时，run loop 并不是运行在默认模式中的，因此， run loop 此时并不会响应比如滚动前设置的计时器。一旦滚动停止了，run loop 会回到默认模式，并执行添加到队列中的相关事件。如果在滚动时，希望计时器能被触发，需要将其设为 <code>NSRunLoopCommonModes</code> 的模式，并添加到 run loop 中。</p>\n<h4 id=\"子线程中使用runloop\"><a href=\"#子线程中使用runloop\" class=\"headerlink\" title=\"子线程中使用runloop\"></a>子线程中使用runloop</h4><p>主线程一般来说都已经配置好了 main run loop。然而其他线程默认情况下都没有设置 run loop。你也可以自行为其他线程设置 run loop ，但是一般来说我们很少需要这么做。大多数时间使用 main run loop 会容易得多。如果你需要处理一些很重的工作，但是又不想在主线程里做，你仍然可以在你的代码在 main run loop 中被调用后将工作分配给其他队列。Chris 在他关于<a href=\"http://objccn.io/issue-2-2/\" target=\"_blank\" rel=\"noopener\">常见的后台实践</a>的文章里阐述了一些关于这种模式的很好的例子。</p>\n<p>如果你真需要在别的线程中添加一个 run loop ，那么不要忘记在 run loop 中至少添加一个 input source 。如果 run loop 中没有设置好的 input source，那么每次运行这个 run loop ，它都会立即退出。</p>\n<p><a name=\"challenges\" id=\"challenges\"> </a></p>\n<h2 id=\"并发编程中面临的挑战\"><a href=\"#并发编程中面临的挑战\" class=\"headerlink\" title=\"并发编程中面临的挑战\"></a>并发编程中面临的挑战</h2><p>使用并发编程会带来许多陷阱。只要一旦你做的事情超过了最基本的情况，对于并发执行的多任务之间的相互影响的不同状态的监视就会变得异常困难。 问题往往发生在一些不确定性（不可预见性）的地方，这使得在调试相关并发代码时更加困难。</p>\n<p>关于并发编程的不可预见性有一个非常有名的例子：在1995年， NASA (美国宇航局)发送了开拓者号火星探测器，但是当探测器成功着陆在我们红色的邻居星球后不久，任务<a href=\"http://research.microsoft.com/en-us/um/people/mbj/Mars_Pathfinder/Mars_Pathfinder.html\" target=\"_blank\" rel=\"noopener\">嘎然而止</a>，火星探测器莫名其妙的不停重启，在计算机领域内，遇到的这种现象被定为为<a href=\"#priority_inversion\">优先级反转</a>，也就是说低优先级的线程一直阻塞着高优先级的线程。稍后我们会看到关于这个问题的更多细节。在这里我们想说明的是，即使拥有丰富的资源和大量优秀工程师的智慧，并发也还是会在不少情况下反咬你一口。</p>\n<p><a name=\"shared_resources\" id=\"shared_resources\"> </a></p>\n<h3 id=\"资源共享\"><a href=\"#资源共享\" class=\"headerlink\" title=\"资源共享\"></a>资源共享</h3><p>并发编程中许多问题的根源就是在多线程中访问共享资源。资源可以是一个属性、一个对象，通用的内存、网络设备或者一个文件等等。在多线程中任何一个共享的资源都可能是一个潜在的冲突点，你必须精心设计以防止这种冲突的发生。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p>为了演示这类问题，我们举一个关于资源的简单示例：<br>描述：比如仅仅用一个整型值来做计数器。在程序运行过程中，我们有两个并行线程 A 和 B，这两个线程都尝试着同时增加计数器的值。<br>问题：你通过 C 语言或 Objective-C 写的代码大多数情况下对于 CPU 来说不会仅仅是一条机器指令。要想增加计数器的值，当前的必须被从内存中读出，然后增加计数器的值，最后还需要将这个增加后的值写回内存中。</p>\n<p>我们可以试着想一下，如果两个线程同时做上面涉及到的操作，会发生怎样的偶然。例如，线程 A 和 B 都从内存中读取出了计数器的值，假设为 <code>17</code> ，然后线程A将计数器的值加1，并将结果 <code>18</code> 写回到内存中。同时，线程B也将计数器的值加 1 ，并将结果 <code>18</code> 写回到内存中。实际上，此时计数器的值已经被破坏掉了，因为计数器的值 <code>17</code> 被加 1 了两次，而它的值却是 <code>18</code>。</p>\n<p><img src=\"https://www.objccn.io/images/issue-2/race-condition.png\" alt=\"竞态条件\"></p>\n<p>这个问题被叫做<a href=\"http://en.wikipedia.org/wiki/Race_conditions#Software\" target=\"_blank\" rel=\"noopener\">竞态条件</a>，<strong>在多线程里面访问一个共享的资源，如果没有一种机制来确保在线程 A 结束访问一个共享资源之前，线程 B 就不会开始访问该共享资源的话，资源竞争的问题就总是会发生</strong>。如果你所写入内存的并不是一个简单的整数，而是一个更复杂的数据结构，可能会发生这样的现象：当第一个线程正在写入这个数据结构时，第二个线程却尝试读取这个数据结构，那么获取到的数据可能是新旧参半或者没有初始化。为了防止出现这样的问题，多线程需要一种互斥的机制来访问共享资源。</p>\n<p>在实际的开发中，情况甚至要比上面介绍的更加复杂，因为现代 CPU 为了优化目的，往往会改变向内存读写数据的顺序（<a href=\"http://en.wikipedia.org/wiki/Out-of-order_execution\" target=\"_blank\" rel=\"noopener\">乱序执行</a>）。</p>\n<h3 id=\"互斥锁\"><a href=\"#互斥锁\" class=\"headerlink\" title=\"互斥锁\"></a>互斥锁</h3><p><a href=\"http://en.wikipedia.org/wiki/Mutex\" target=\"_blank\" rel=\"noopener\">互斥</a>访问的意思就是同一时刻，只允许一个线程访问某个特定资源。为了保证这一点，每个希望访问共享资源的线程，首先需要获得一个共享资源的<a href=\"http://en.wikipedia.org/wiki/Lock_%28computer_science%29\" target=\"_blank\" rel=\"noopener\">互斥锁</a>，一旦某个线程对资源完成了操作，就释放掉这个互斥锁，这样别的线程就有机会访问该共享资源了。</p>\n<p><img src=\"https://www.objccn.io/images/issue-2/locking.png\" alt=\"互斥锁\"></p>\n<p>除了确保互斥访问，还需要解决代码无序执行所带来的问题。如果不能确保 CPU 访问内存的顺序跟编程时的代码指令一样，那么仅仅依靠互斥访问是不够的。为了解决由 CPU 的优化策略引起的副作用，还需要引入<a href=\"http://en.wikipedia.org/wiki/Memory_barrier\" target=\"_blank\" rel=\"noopener\">内存屏障</a>。通过设置内存屏障，来确保没有无序执行的指令能跨过屏障而执行。</p>\n<p>当然，互斥锁自身的实现是需要没有竞争条件的。这实际上是非常重要的一个保证，并且需要在现代 CPU 上使用特殊的指令。更多关于原子操作（atomic operation）的信息，请阅读 Daniel 写的文章：<a href=\"http://objccn.io/issue-2-3/\" target=\"_blank\" rel=\"noopener\">底层并发技术</a>。</p>\n<h4 id=\"解决方案：原子声明属性\"><a href=\"#解决方案：原子声明属性\" class=\"headerlink\" title=\"解决方案：原子声明属性\"></a>解决方案：原子声明属性</h4><p>从语言层面来说，在 Objective-C 中将属性以 atomic 的形式来声明，就能支持互斥锁了。事实上在默认情况下，属性就是 atomic 的。将一个属性声明为 atomic 表示每次访问该属性都会进行隐式的加锁和解锁操作。虽然最把稳的做法就是将所有的属性都声明为 atomic，但是加解锁这也会付出一定的代价。</p>\n<h4 id=\"性能开销及锁的竞争\"><a href=\"#性能开销及锁的竞争\" class=\"headerlink\" title=\"性能开销及锁的竞争\"></a>性能开销及锁的竞争</h4><p>在资源上的加锁会引发一定的性能代价。获取锁和释放锁的操作本身也需要没有竞态条件，这在多核系统中是很重要的。另外，在获取锁的时候，线程有时候需要等待，因为可能其它的线程已经获取过资源的锁了。这种情况下，线程会进入休眠状态。当其它线程释放掉相关资源的锁时，休眠的线程会得到通知。所有这些相关操作都是非常昂贵且复杂的。<br>在这里有一个东西需要进行权衡：获取和释放锁所是要带来开销的，因此你需要确保你不会频繁地进入和退出<a href=\"http://en.wikipedia.org/wiki/Critical_section\" target=\"_blank\" rel=\"noopener\">临界区段</a>（比如获取和释放锁）。同时，如果你获取锁之后要执行一大段代码，这将带来锁竞争的风险：其它线程可能必须等待获取资源锁而无法工作。这并不是一项容易解决的任务。</p>\n<h4 id=\"不同类型的锁\"><a href=\"#不同类型的锁\" class=\"headerlink\" title=\"不同类型的锁\"></a>不同类型的锁</h4><p>锁也有不同的类型。当没有竞争时，有些锁在没有锁竞争的情况下性能很好，但是在有锁的竞争情况下，性能就会大打折扣。另外一些锁则在基本层面上就比较耗费资源，但是在竞争情况下，性能的恶化会没那么厉害。(<a href=\"http://en.wikipedia.org/wiki/Lock_%28computer_science%29#Granularity\" target=\"_blank\" rel=\"noopener\">锁的竞争</a>是这样产生的：当一个或者多个线程尝试获取一个已经被别的线程获取过了的锁)。</p>\n<p>我们经常能看到本来计划并行运行的代码，但实际上由于共享资源中配置了相关的锁，所以同一时间只有一个线程是处于激活状态的。对于你的代码会如何在多核上运行的预测往往十分重要，你可以使用 Instrument 的 <a href=\"http://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/AnalysingCPUUsageinYourOSXApp/AnalysingCPUUsageinYourOSXApp.html\" target=\"_blank\" rel=\"noopener\">CPU strategy view</a> 来检查是否有效的利用了 CPU 的可用核数，进而得出更好的想法，以此来优化代码。</p>\n<p><a name=\"dead_locks\" id=\"dead_locks\"> </a></p>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><p>互斥锁解决了竞态条件的问题，但很不幸同时这也引入了一些<a href=\"http://en.wikipedia.org/wiki/Lock_%28computer_science%29#The_problems_with_locks\" target=\"_blank\" rel=\"noopener\">其他问题</a>，其中一个就是<a href=\"http://en.wikipedia.org/wiki/Deadlock\" target=\"_blank\" rel=\"noopener\">死锁</a>。当多个线程在相互等待着对方的结束时，就会发生死锁，这时程序可能会被卡住。</p>\n<p><img src=\"https://www.objccn.io/images/issue-2/dead-lock.png\" alt=\"死锁\"></p>\n<p>看看下面的代码，它交换两个变量的值：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(A, B)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">lock(lockA);</span><br><span class=\"line\">lock(lockB);</span><br><span class=\"line\"><span class=\"keyword\">int</span> a = A;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = B;</span><br><span class=\"line\">A = b;</span><br><span class=\"line\">B = a;</span><br><span class=\"line\">unlock(lockB);</span><br><span class=\"line\">unlock(lockA);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>大多数时候，这能够正常运行。但是当两个线程使用相反的值来同时调用上面这个方法时：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swap(X, Y); <span class=\"comment\">// 线程 1</span></span><br><span class=\"line\">swap(Y, X); <span class=\"comment\">// 线程 2</span></span><br></pre></td></tr></table></figure></p>\n<p>此时程序可能会由于死锁而被终止。线程 1 获得了 X 的一个锁，线程 2 获得了 Y 的一个锁。 接着它们会同时等待另外一把锁，但是永远都不会获得。</p>\n<p>再说一次，你在线程之间共享的资源越多，你使用的锁也就越多，同时程序被死锁的概率也会变大。这也是为什么我们需要尽量减少线程间资源共享，并确保共享的资源尽量简单的原因之一。</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>建议阅读一下<a href=\"http://objccn.io/issue-2-3/\" target=\"_blank\" rel=\"noopener\">底层并发编程 API</a> 中的<a href=\"http://objccn.io/issue-2-3/#async\" target=\"_blank\" rel=\"noopener\">全部使用异步分发</a>一节。</p>\n<h3 id=\"资源饥饿（Starvation）\"><a href=\"#资源饥饿（Starvation）\" class=\"headerlink\" title=\"资源饥饿（Starvation）\"></a>资源饥饿（Starvation）</h3><p>当你认为已经足够了解并发编程面临的问题时，又出现了一个新的问题。锁定的共享资源会引起<a href=\"http://en.wikipedia.org/wiki/Readers-writers_problem\" target=\"_blank\" rel=\"noopener\">读写问题</a>。大多数情况下，限制资源一次只能有一个线程进行读取访问其实是非常浪费的。因此，在资源上没有写入锁的时候，持有一个读取锁是被允许的。这种情况下，如果一个持有读取锁的线程在等待获取写入锁的时候，其他希望读取资源的线程则因为无法获得这个读取锁而导致<a href=\"http://en.wikipedia.org/wiki/Resource_starvation\" target=\"_blank\" rel=\"noopener\">资源饥饿</a>的发生。</p>\n<h4 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>为了解决这个问题，我们需要使用一个比简单的读/写锁更聪明的方法，例如给定一个 <a href=\"http://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock\" target=\"_blank\" rel=\"noopener\">writer preference</a>，或者使用 <a href=\"http://en.wikipedia.org/wiki/Read-copy-update\" target=\"_blank\" rel=\"noopener\">read-copy-update</a> 算法。Daniel 在<a href=\"http://objccn.io/issue-2-3/#multiple-readers-single-writer\" target=\"_blank\" rel=\"noopener\">底层并发编程 API </a>中有介绍了如何用 GCD 实现一个多读取单写入的模式，这样就不会被写入资源饥饿的问题困扰了。</p>\n<p><a name=\"priority_inversion\" id=\"priority_inversion\"> </a></p>\n<h2 id=\"优先级反转\"><a href=\"#优先级反转\" class=\"headerlink\" title=\"优先级反转\"></a>优先级反转</h2><p>本节开头介绍了美国宇航局发射的开拓者号火星探测器在火星上遇到的并发问题。现在我们就来看看为什么开拓者号几近失败，以及为什么有时候我们的程序也会遇到相同的问题，该死的<a href=\"http://en.wikipedia.org/wiki/Priority_inversion\" target=\"_blank\" rel=\"noopener\">优先级反转</a>。</p>\n<p>优先级反转是指程序在运行时低优先级的任务阻塞了高优先级的任务，有效的反转了任务的优先级。由于 GCD 提供了拥有不同优先级的后台队列，甚至包括一个 I/O 队列，所以我们最好了解一下优先级反转的可能性。</p>\n<p>高优先级和低优先级的任务之间共享资源时，就可能发生优先级反转。当低优先级的任务获得了共享资源的锁时，该任务应该迅速完成，并释放掉锁，这样高优先级的任务就可以在没有明显延时的情况下继续执行。然而高优先级任务会在低优先级的任务持有锁的期间被阻塞。如果这时候有一个中优先级的任务(该任务不需要那个共享资源)，那么它就有可能会抢占低优先级任务而被执行，因为此时高优先级任务是被阻塞的，所以中优先级任务是目前所有可运行任务中优先级最高的。此时，中优先级任务就会阻塞着低优先级任务，导致低优先级任务不能释放掉锁，这也就会引起高优先级任务一直在等待锁的释放。</p>\n<p><img src=\"https://www.objccn.io/images/issue-2/priority-inversion.png\" alt=\"优先级反转\"></p>\n<p>在你的实际代码中，可能不会像发生在火星的事情那样戏剧性地不停重启。遇到优先级反转时，一般没那么严重。</p>\n<p>解决这个问题的方法，通常就是不要使用不同的优先级。通常最后你都会以让高优先级的代码等待低优先级的代码来解决问题。当你使用 GCD 时，总是使用默认的优先级队列（直接使用，或者作为目标队列）。如果你使用不同的优先级，很可能实际情况会让事情变得更糟糕。</p>\n<p>从中得到的教训是，使用不同优先级的多个队列听起来虽然不错，但毕竟是纸上谈兵。它将让本来就复杂的并行编程变得更加复杂和不可预见。如果你在编程中，遇到高优先级的任务突然没理由地卡住了，可能你会想起本文，以及那个美国宇航局的工程师也遇到过的被称为优先级反转的问题。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>我们希望通过本文你能够了解到并发编程带来的复杂性和相关问题。并发编程中，无论是看起来多么简单的 API ，它们所能产生的问题会变得非常的难以观测，而且要想调试这类问题往往也都是非常困难的。</p>\n<p>但另一方面，并发实际上是一个非常棒的工具。它充分利用了现代多核 CPU 的强大计算能力。在开发中，关键的一点就是尽量让并发模型保持简单，这样可以限制所需要的锁的数量。</p>\n<p>我们建议采纳的安全模式是这样的：从主线程中提取出要使用到的数据，并利用一个操作队列在后台处理相关的数据，最后回到主队列中来发送你在后台队列中得到的结果。使用这种方式，你不需要自己做任何锁操作，这也就大大减少了犯错误的几率。</p>\n<hr>\n<p><a href=\"http://objccn.io/issue-2\" target=\"_blank\" rel=\"noopener\">话题 #2 下的更多文章</a></p>\n<p>原文 <a href=\"http://www.objc.io/issue-2/concurrency-apis-and-pitfalls.html\" target=\"_blank\" rel=\"noopener\">Concurrent Programming: APIs and Challenges</a></p>\n<p>精细校对 <a href=\"http://im.onevcat.com\" target=\"_blank\" rel=\"noopener\">@onevcat</a></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"API","path":"api/categories/API.json"}],"tags":[]},{"title":"iOS视图渲染","slug":"iOS/iOS视图渲染","date":"2017-09-23T14:51:07.000Z","updated":"2017-09-23T17:28:45.000Z","comments":true,"path":"api/articles/iOS/iOS视图渲染.json","excerpt":null,"keywords":null,"cover":"https://objccn.io/images/issue-3/pixels-software-stack.png","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"图形堆栈\"><a href=\"#图形堆栈\" class=\"headerlink\" title=\"图形堆栈\"></a>图形堆栈</h2><p>当像素映射到屏幕上的时候，后台发生了很多事情。但一旦他们显示到屏幕上，每一个像素均由三个颜色组件构成：红，绿，蓝。三个独立的颜色单元会根据给定的颜色显示到一个像素上。在 iPhone5 的<a href=\"https://zh.wikipedia.org/wiki/%E6%A9%AB%E5%90%91%E9%9B%BB%E5%A0%B4%E6%95%88%E6%87%89%E9%A1%AF%E7%A4%BA%E6%8A%80%E8%A1%93\" target=\"_blank\" rel=\"noopener\">液晶显示器</a>上有1,136×640=727,040个像素，因此有2,181,120个颜色单元。在15寸视网膜屏的 MacBook Pro 上，这一数字达到15.5百万以上。所有的图形堆栈一起工作以确保每次正确的显示。当你滚动整个屏幕的时候，数以百万计的颜色单元必须以每秒60次的速度刷新，这是一个很大的工作量。</p>\n<h3 id=\"软件堆栈组成\"><a href=\"#软件堆栈组成\" class=\"headerlink\" title=\"软件堆栈组成\"></a>软件堆栈组成</h3><p>从简单的角度来看，软件堆栈看起来有点像这样：</p>\n<p><img src=\"https://objccn.io/images/issue-3/pixels-software-stack.png\" alt=\"软件堆栈\"></p>\n<h4 id=\"GPU强大的图形硬件\"><a href=\"#GPU强大的图形硬件\" class=\"headerlink\" title=\"GPU强大的图形硬件\"></a>GPU强大的图形硬件</h4><p><code>Display</code>的上一层便是图形处理单元 GPU，<code>GPU</code> 是一个专门为图形高并发计算而量身定做的处理单元。这也是为什么它能同时更新所有的像素，并呈现到显示器上。它并发的本性让它能高效的将不同纹理合成起来。我们将有一小块内容来更详细的讨论图形合成。关键的是，GPU 是非常专业的，因此在某些工作上非常高效。比如，GPU 非常快，并且比 CPU 使用更少的电来完成工作。通常 CPU 都有一个普遍的目的，它可以做很多不同的事情，但是合成图像在 CPU 上却显得比较慢。</p>\n<p>GPU 是一个非常强大的图形硬件，并且在显示像素方面起着核心作用。它连接到 CPU。从硬件上讲两者之间存在某种类型的<a href=\"https://zh.wikipedia.org/wiki/I/O%E6%80%BB%E7%BA%BF\" target=\"_blank\" rel=\"noopener\">总线</a>，并且有像 OpenGL，Core Animation 和 Core Graphics 这样的框架来在 GPU 和 CPU 之间精心安排数据的传输。为了将像素显示到屏幕上，一些处理将在 CPU 上进行。然后数据将会传送到 GPU，这也需要做一些相应的操作，最终像素显示到屏幕上。</p>\n<p><code>GPU Driver</code>是直接和 GPU 交流的代码块。不同的GPU是不同的性能怪兽，但是驱动使他们在下一个层级上显示的更为统一，典型的下一层级有 OpenGL/OpenGL ES.</p>\n<h4 id=\"OpenGL的扩展API\"><a href=\"#OpenGL的扩展API\" class=\"headerlink\" title=\"OpenGL的扩展API\"></a>OpenGL的扩展API</h4><p>OpenGL(<a href=\"http://zh.wikipedia.org/wiki/OpenGL\" target=\"_blank\" rel=\"noopener\">Open Graphics Library</a>) 是一个提供了 2D 和 3D 图形渲染的 API。GPU 是一块非常特殊的硬件，OpenGL  和 GPU 密切的工作以提高GPU的能力，并实现硬件加速渲染。</p>\n<p>在 iOS 上，几乎所有的东西都是通过 Core Animation 绘制出来，因为 Core Animation 使用 Core Graphics 来做一些渲染。像 AVFoundation，Core Image 框架，和其他一些混合的入口。<br>在OS X 上，绕过 Core Animation 直接使用 Core Graphics 绘制的情况并不少见。对于一些专门的应用，尤其是游戏，程序可能直接和 OpenGL/OpenGL ES 交流。</p>\n<h2 id=\"GPU纹理合成渲染流程\"><a href=\"#GPU纹理合成渲染流程\" class=\"headerlink\" title=\"GPU纹理合成渲染流程\"></a>GPU纹理合成渲染流程</h2><p><img src=\"https://objccn.io/images/issue-3/pixels%2C%20hardware.png\" alt=\"挑战\"></p>\n<p>合成挑战：GPU 需要将每一个 frame 的纹理(位图)合成在一起(一秒60次)。每一个纹理会占用 VRAM(video RAM)，所以需要给 GPU 同时保持纹理的数量做一个限制。GPU 在合成方面非常高效，但是某些合成任务却比其他更复杂，并且 GPU在 16.7ms(1/60s)内能做的工作也是有限的。</p>\n<p>耗时挑战：下一个挑战就是将数据传输到 GPU 上。为了让 GPU 访问数据，需要将数据从 RAM 移动到 VRAM 上。这就是提及到的上传数据到 GPU。这看起来貌似微不足道，但是一些大型的纹理却会非常耗时。</p>\n<p>最终，CPU 开始运行你的程序。你可能会让 CPU 从 bundle 加载一张 PNG 的图片并且解压它。这所有的事情都在 CPU 上进行。然后当你需要显示解压缩后的图片时，它需要以某种方式上传到 GPU。一些看似平凡的，比如显示文本，对 CPU 来说却是一件非常复杂的事情，这会促使 Core Text 和 Core Graphics 框架更紧密的集成来根据文本生成一个位图。一旦准备好，它将会被作为一个纹理上传到 GPU 并准备显示出来。当你滚动或者在屏幕上移动文本时，不管怎么样，同样的纹理能够被复用，CPU 只需简单的告诉 GPU 新的位置就行了,所以 GPU 就可以重用存在的纹理了。CPU 并不需要重新渲染文本，并且位图也不需要重新上传到 GPU。</p>\n<p>这张图涉及到一些错综复杂的方面，我们将会把这些方面提取出来并深一步了解。</p>\n<h3 id=\"合成-纹理概念\"><a href=\"#合成-纹理概念\" class=\"headerlink\" title=\"合成/纹理概念\"></a>合成/纹理概念</h3><p>合成：在图形世界中，合成是一个描述不同位图如何放到一起来创建你最终在屏幕上看到图像的过程。</p>\n<p>纹理：屏幕上一切事物皆纹理。一个纹理就是一个包含 RGBA 值的长方形，比如，每一个像素里面都包含红、绿、蓝和透明度的值。在 Core Animation 世界中的纹理就是 CALayer。</p>\n<p>纹理合成：在这个简化的设置中，每一个 layer 是一个纹理，所有的纹理都以某种方式堆叠在彼此的顶部。对于屏幕上的每一个像素，GPU 需要算出怎么混合这些纹理来得到像素 RGB 的值。</p>\n<h3 id=\"纹理合成像素的计算公式\"><a href=\"#纹理合成像素的计算公式\" class=\"headerlink\" title=\"纹理合成像素的计算公式\"></a>纹理合成像素的计算公式</h3><p>如果我们所拥有的是一个和屏幕大小一样并且和屏幕像素对齐的单一纹理，那么屏幕上每一个像素相当于纹理中的一个像素，纹理的最后一个像素也就是屏幕的最后一个像素。</p>\n<p>如果我们有第二个纹理放在第一个纹理之上，然后GPU将会把第二个纹理合成到第一个纹理中。有很多种不同的合成方法，但是如果我们假定两个纹理的像素对齐，并且使用正常的混合模式，我们便可以用下面这个公式来计算每一个像素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R = S + D * ( 1 – Sa )</span><br></pre></td></tr></table></figure></p>\n<p>结果的颜色是源色彩(顶端纹理)+目标颜色(低一层的纹理)*(1-源颜色的透明度)。在这个公式中所有的颜色都假定已经预先乘以了他们的透明度。</p>\n<p>显然相当多的事情在这发生了。让我们进行第二个假定，两个纹理都完全不透明，比如 alpha=1.如果目标纹理(低一层的纹理)是蓝色(RGB=0,0,1)，并且源纹理(顶层的纹理)颜色是红色(RGB=1,0,0)，因为 Sa 为1，所以结果为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R = S</span><br></pre></td></tr></table></figure></p>\n<p>结果是源颜色的红色。这正是我们所期待的(红色覆盖了蓝色)。</p>\n<p>如果源颜色层为50%的透明，比如 alpha=0.5，既然 alpha 组成部分需要预先乘进 RGB 的值中，那么 S 的 RGB 值为(0.5, 0, 0)，公式看起来便会像这样:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0.5   0               0.5</span><br><span class=\"line\">R = S + D * (1 - Sa) = 0   + 0 * (1 - 0.5) = 0</span><br><span class=\"line\">0     1               0.5</span><br></pre></td></tr></table></figure></p>\n<p>我们最终得到RGB值为(0.5, 0, 0.5),是一个紫色。这正是我们所期望将透明红色合成到蓝色背景上所得到的。</p>\n<p>记住我们刚刚只是将纹理中的一个像素合成到另一个纹理的像素上。当两个纹理覆盖在一起的时候，GPU需要为所有像素做这种操作。正如你所知道的一样，许多程序都有很多层，因此所有的纹理都需要合成到一起。尽管GPU是一块高度优化的硬件来做这种事情，但这还是会让它非常忙碌。</p>\n<h4 id=\"opaque-的属性：不透明-VS-透明\"><a href=\"#opaque-的属性：不透明-VS-透明\" class=\"headerlink\" title=\"opaque 的属性：不透明 VS 透明\"></a>opaque 的属性：不透明 VS 透明</h4><p>当源纹理是完全不透明的时候，目标像素就等于源纹理。这可以省下 GPU 很大的工作量，这样只需简单的拷贝源纹理而不需要合成所有的像素值。<br> CALayer 有一个叫做 opaque 的属性会告诉 GPU 纹理上的像素是透明还是不透明的。如果这个属性为 YES，GPU 将不会做任何合成，而是简单从这个层拷贝，不需要考虑它下方的任何东西(因为都被它遮挡住了)。这节省了 GPU 相当大的工作量。这也正是 Instruments 中 color blended layers 选项中所涉及的。(这在模拟器中的Debug菜单中也可用).它允许你看到哪一个 layers(纹理) 被标注为透明的，比如 GPU 正在为哪一个 layers 做合成。合成不透明的 layers 因为需要更少的数学计算而更廉价。<br> 所以如果你知道你的 layer 是不透明的，最好确定设置它的 opaque 为 YES。如果你加载一个没有 alpha 通道的图片，并且将它显示在 UIImageView 上，这将会自动发生。但是要记住如果一个图片没有 alpha 通道和一个图片每个地方的 alpha 都是100%，这将会产生很大的不同。在后一种情况下，Core Animation 需要假定是否存在像素的 alpha 值不为100%。在 Finder 中，你可以使用 Get Info 并且检查 More Info 部分。它将告诉你这张图片是否拥有 alpha 通道。</p>\n<h4 id=\"像素对齐-VS-不重合在一起\"><a href=\"#像素对齐-VS-不重合在一起\" class=\"headerlink\" title=\"像素对齐 VS 不重合在一起\"></a>像素对齐 VS 不重合在一起</h4><ol>\n<li>像素对齐<br>到现在我们都在考虑像素完美重合在一起的 layers。当所有的像素是对齐的时候我们得到相对简单的计算公式。每当 GPU 需要计算出屏幕上一个像素是什么颜色的时候，它只需要考虑在这个像素之上的所有 layer 中对应的单个像素，并把这些像素合并到一起。或者，如果最顶层的纹理是不透明的(即图层树的最底层)，这时候 GPU 就可以简单的拷贝它的像素到屏幕上。</li>\n<li>滚动/错位<br>当一个 layer 上所有的像素和屏幕上的像素完美的对应整齐，那这个 layer 就是像素对齐的。主要有两个原因可能会造成不对齐。<br>第一个便是滚动：当一个纹理上下滚动的时候，纹理的像素便不会和屏幕的像素排列对齐。<br>另一个原因便是：当纹理的起点不在一个像素的边界上。</li>\n</ol>\n<p>在这两种情况下，GPU 需要再做额外的计算。它需要将源纹理上多个像素混合起来，生成一个用来合成的值。当所有的像素都是对齐的时候，GPU 只剩下很少的工作要做。</p>\n<p>Core Animation 工具和模拟器有一个叫做 color misaligned images 的选项，当这些在你的 CALayer 实例中发生的时候，这个功能便可向你展示。</p>\n<h3 id=\"Masks位图蒙板\"><a href=\"#Masks位图蒙板\" class=\"headerlink\" title=\"Masks位图蒙板\"></a>Masks位图蒙板</h3><p>一个图层可以有一个和它相关联的 mask(蒙板)，mask 是一个拥有 alpha 值的位图，当像素要和蒙板下面包含的像素合并之前都会把 mask 应用到图层的像素上去，最终只有在 mask 中显示出来的(即图层中的部分)才会被渲染出来。<br>例如：当你要设置一个图层的圆角半径时，你可以有效的在图层上面设置一个 mask。但是也可以指定任意一个蒙板。比如，一个字母 A 形状的 mask。</p>\n<h3 id=\"离屏渲染-Offscreen-Rendering\"><a href=\"#离屏渲染-Offscreen-Rendering\" class=\"headerlink\" title=\"离屏渲染(Offscreen Rendering)\"></a>离屏渲染(Offscreen Rendering)</h3><p>离屏渲染：即在屏幕外对图层树的合并/渲染，此时会有一个屏幕外缓冲区缓存图层树，然后该缓冲区会被渲染到屏幕上。离屏渲染可以被 Core Animation 自动触发，或者被应用程序强制触发。</p>\n<p>离屏渲染合成计算是非常昂贵的, 但有时你也许希望强制这种操作。一种好的方法就是缓存合成的纹理/图层。如果你的渲染树非常复杂(所有的纹理，以及如何组合在一起)，你可以强制离屏渲染缓存那些图层，然后可以用缓存作为合成的结果放到屏幕上。<br>Instrument 的 Core Animation 工具有一个叫做 <em>Color Offscreen-Rendered Yellow</em> 的选项，它会将已经被渲染到屏幕外缓冲区的区域标注为黄色(这个选项在模拟器中也可以用)。同时记得检查 <em>Color Hits Green and Misses Red</em> 选项。绿色代表无论何时一个屏幕外缓冲区被复用，而红色代表当缓冲区被重新创建。</p>\n<h4 id=\"GPU离屏渲染多图层动画\"><a href=\"#GPU离屏渲染多图层动画\" class=\"headerlink\" title=\"GPU离屏渲染多图层动画\"></a>GPU离屏渲染多图层动画</h4><p>如果你的程序混合了很多图层，并且想要他们一起做动画，GPU 通常会为每一帧(1/60s)重复合成所有的图层。当使用离屏渲染时，GPU 第一次会混合所有图层到一个基于新的纹理的位图缓存上，然后使用这个纹理来绘制到屏幕上。现在，当这些图层一起移动的时候，GPU 便可以复用这个位图缓存，并且只需要做很少的工作。需要注意的是，只有当那些图层不改变时，这才可以用。如果那些图层改变了，GPU 需要重新创建位图缓存。你可以通过设置 shouldRasterize 为 YES 来触发这个行为。</p>\n<ol>\n<li>两个权衡点<br>第一，这可能会使事情变得更慢。创建额外的屏幕外缓冲区是 GPU 需要多做的一步操作，特殊情况下这个位图可能再也不需要被复用，这便是一个无用功了。<br>第二，可以被复用的位图，GPU 也有可能将它卸载了。所以你需要计算 GPU 的利用率和帧的速率来判断这个位图是否有用。</li>\n<li><p>副作用：mask蒙板渲染至缓冲区<br>离屏渲染也可能产生副作用。如果你正在直接或者间接的将mask应用到一个图层上，Core Animation 为了应用这个 mask，会强制进行屏幕外渲染。这会对 GPU 产生重负。通常情况下 mask 只能被直接渲染到帧的缓冲区中(在屏幕内)。</p>\n</li>\n<li><p>避免使用离屏渲染<br>因为直接将图层合成到帧的缓冲区中(在屏幕上)比先创建屏幕外缓冲区，然后渲染到纹理中，最后将结果渲染到帧的缓冲区中要廉价很多。这其中涉及两次昂贵的环境转换(转换环境到屏幕外缓冲区，然后转换环境到帧缓冲区)。<br>layer的几种触发离屏渲染<br>为 layer 使用蒙板或者设置圆角半径会造成屏幕外渲染，产生阴影也会如此。<br>至于 mask，圆角半径(特殊的mask)和 clipsToBounds/masksToBounds，你可以简单的为一个已经拥有 mask 的 layer 创建内容，比如，已经应用了 mask 的 layer 使用一张图片。如果你想根据 layer 的内容为其应用一个长方形 mask，你可以使用 contentsRect 来代替蒙板。<br>如果你最后设置了 shouldRasterize 为 YES，那也要记住设置 rasterizationScale 为 contentsScale。<br>所以当你打开 <em>Color Offscreen-Rendered Yellow</em> 后看到黄色，这便是一个警告，但这不一定是不好的。如果 Core Animation 能够复用屏幕外渲染的结果，这便能够提升性能。</p>\n</li>\n<li>离屏渲染空间限制<br>同时还要注意，rasterized layer 的空间是有限的。苹果暗示大概有屏幕大小两倍的空间来存储 rasterized layer/屏幕外缓冲区。</li>\n</ol>\n<h2 id=\"更多的关于合成\"><a href=\"#更多的关于合成\" class=\"headerlink\" title=\"更多的关于合成\"></a>更多的关于合成</h2><p>像往常一样，维基百科上有更多关于<a href=\"https://en.wikipedia.org/wiki/Alpha_compositing\" target=\"_blank\" rel=\"noopener\">透明合成</a>的基础公式。当我们谈完像素后，我们将更深入一点的谈论红，绿，蓝和 alpha 是怎么在内存中表现的。</p>\n<h2 id=\"OS-X\"><a href=\"#OS-X\" class=\"headerlink\" title=\"OS X\"></a>OS X</h2><p>如果你是在 OS X 上工作，你将会发现大多数 debugging 选项在一个叫做 <em>Quartz Debug</em> 的独立程序中，而不是在 Instruments 中。Quartz Debug 是 Graphics Tools 中的一部分，这可以在苹果的 <a href=\"https://developer.apple.com/downloads/\" target=\"_blank\" rel=\"noopener\">developer portal</a> 中下载到。</p>\n<h2 id=\"Core-Animation-OpenGL-ES\"><a href=\"#Core-Animation-OpenGL-ES\" class=\"headerlink\" title=\"Core Animation  OpenGL ES\"></a>Core Animation  OpenGL ES</h2><p>正如名字所建议的那样，Core Animation 让你在屏幕上实现动画。我们将跳过动画部分，而集中在绘图上。需要注意的是，Core Animation 允许你做非常高效的渲染。这也是为什么当你使用 Core Animation 时可以实现每秒 60 帧的动画。</p>\n<p>Core Animation 的核心是 OpenGL ES 的一个抽象物，简而言之，它让你直接使用 OpenGL ES 的功能，却不需要处理 OpenGL ES 做的复杂的事情。当我们上面谈论合成的时候，我们把 layer 和 texture 当做等价的，但是他们不是同一物体，可又是如此的类似。</p>\n<p>Core Animation 的 layer 可以有子 layer，所以最终你得到的是一个图层树。Core Animation 所需要做的最繁重的任务便是判断出哪些图层需要被(重新)绘制，而 OpenGL ES 需要做的便是将图层合并、显示到屏幕上。</p>\n<p>举个例子，当你设置一个 layer 的内容为 CGImageRef 时，Core Animation 会创建一个 OpenGL 纹理，并确保在这个图层中的位图被上传到对应的纹理中。以及当你重写 <code>-drawInContext</code> 方法时，Core Animation 会请求分配一个纹理，同时确保 Core Graphics 会将你所做的(即你在<code>drawInContext</code>中绘制的东西)放入到纹理的位图数据中。一个图层的性质和 CALayer 的子类会影响到 OpenGL 的渲染结果，许多低等级的 OpenGL ES 行为被简单易懂地封装到 CALayer 概念中。</p>\n<p>Core Animation 通过 Core Graphics 的一端和 OpenGL ES 的另一端，精心策划基于 CPU 的位图绘制。因为 Core Animation 处在渲染过程中的重要位置上，所以你如何使用 Core Animation 将会对性能产生极大的影响。</p>\n<h2 id=\"CPU限制-VS-GPU限制\"><a href=\"#CPU限制-VS-GPU限制\" class=\"headerlink\" title=\"CPU限制 VS GPU限制\"></a>CPU限制 VS GPU限制</h2><p>当你在屏幕上显示东西的时候，有许多组件参与了其中的工作。其中，CPU 和 GPU 在硬件中扮演了重要的角色。在他们命名中 P 和 U 分别代表了”处理”和”单元”，当需要在屏幕上进行绘制时，他们都需要做处理，同时他们都有资源限制(即 CPU 和 GPU 的硬件资源)。</p>\n<p>为了每秒达到 60 帧，你需要确定 CPU 和 GPU 不能过载。此外，即使你当前能达到 60fps(frame per second),你还是要把尽可能多的绘制工作交给 GPU 做，而让 CPU 尽可能的来执行应用程序。通常，GPU 的渲染性能要比 CPU 高效很多，同时对系统的负载和消耗也更低一些。</p>\n<p>既然绘图性能是基于 CPU 和 GPU 的，那么你需要找出是哪一个限制你绘图性能的。如果你用尽了 GPU 所有的资源，也就是说，是 GPU 限制了你的性能，同样的，如果你用尽了 CPU，那就是 CPU 限制了你的性能。</p>\n<p>要告诉你，如果是 GPU 限制了你的性能，你可以使用 OpenGL ES Driver instrument。点击上面那个小的 i 按钮，配置一下，同时注意勾选 Device Utilization %。现在，当你运行你的 app 时，你可以看到你 GPU 的负荷。如果这个值靠近 100%，那么你就需要把你工作的重心放在GPU方面了。</p>\n<h2 id=\"Core-Graphics-Quartz-2D\"><a href=\"#Core-Graphics-Quartz-2D\" class=\"headerlink\" title=\"Core Graphics / Quartz 2D\"></a>Core Graphics / Quartz 2D</h2><p>通过 Core Graphics 这个框架，Quartz 2D 被更为广泛的知道。</p>\n<p>Quartz 2D 拥有比我们这里谈到更多的装饰。我们这里不会过多的讨论关于 PDF 的创建，渲染，解析，或者打印。只需要注意的是，PDF 的打印、创建和在屏幕上绘制位图的操作是差不多的。因为他们都是基于 Quartz 2D。</p>\n<p>让我们简单的了解一下 <a href=\"https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html\" target=\"_blank\" rel=\"noopener\">Quartz 2D</a> 主要的概念。有关详细信息可以到苹果的官方文档中了解。</p>\n<p>放心，当 Quartz 2D 涉及到 2D 绘制的时候，它是非常强大的。有基于路径的绘制，反锯齿渲染，透明图层，分辨率，并且设备独立，可以说出很多特色。这可能会让人产生畏惧，主要因为这是一个低级并且基于 C 的 API。</p>\n<p>主要的概念相对简单，UIKit 和 AppKit 都包含了 Quartz 2D 的一些简单 API，一旦你熟练了，一些简单 C 的 API 也是很容易理解的。最终你学会了一个能实现 Photoshop 和 Illustrator 大部分功能的绘图引擎。苹果把 iOS 程序里面的<a href=\"https://developer.apple.com/videos/wwdc/2011/?id=129\" target=\"_blank\" rel=\"noopener\">股票应用</a>作为讲解 Quartz 2D 在代码中实现动态渲染的一个例子。</p>\n<p>当你的程序进行位图绘制时，不管使用哪种方式，都是基于 Quartz 2D 的。也就是说，CPU 部分实现的绘制是通过 Quartz 2D 实现的。尽管 Quartz 可以做其它的事情，但是我们这里还是集中于位图绘制，在缓冲区(一块内存)绘制位图会包括 RGBA 数据。</p>\n<p>比方说，我们要画一个<a href=\"https://zh.wikipedia.org/wiki/%E5%85%AB%E8%BE%B9%E5%BD%A2\" target=\"_blank\" rel=\"noopener\">八角形</a>，我们通过 UIKit 能做到这一点<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIBezierPath</span> *path = [<span class=\"built_in\">UIBezierPath</span> bezierPath];</span><br><span class=\"line\">[path moveToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">16.72</span>, <span class=\"number\">7.22</span>)];</span><br><span class=\"line\">[path addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">3.29</span>, <span class=\"number\">20.83</span>)];</span><br><span class=\"line\">[path addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">0.4</span>, <span class=\"number\">18.05</span>)];</span><br><span class=\"line\">[path addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">18.8</span>, <span class=\"number\">-0.47</span>)];</span><br><span class=\"line\">[path addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">37.21</span>, <span class=\"number\">18.05</span>)];</span><br><span class=\"line\">[path addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">34.31</span>, <span class=\"number\">20.83</span>)];</span><br><span class=\"line\">[path addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">20.88</span>, <span class=\"number\">7.22</span>)];</span><br><span class=\"line\">[path addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">20.88</span>, <span class=\"number\">42.18</span>)];</span><br><span class=\"line\">[path addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">16.72</span>, <span class=\"number\">42.18</span>)];</span><br><span class=\"line\">[path addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">16.72</span>, <span class=\"number\">7.22</span>)];</span><br><span class=\"line\">[path closePath];</span><br><span class=\"line\">path.lineWidth = <span class=\"number\">1</span>;</span><br><span class=\"line\">[[<span class=\"built_in\">UIColor</span> redColor] setStroke];</span><br><span class=\"line\">[path stroke];</span><br></pre></td></tr></table></figure></p>\n<p>相对应的 Core Graphics 代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGContextBeginPath</span>(ctx);</span><br><span class=\"line\"><span class=\"built_in\">CGContextMoveToPoint</span>(ctx, <span class=\"number\">16.72</span>, <span class=\"number\">7.22</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">3.29</span>, <span class=\"number\">20.83</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">0.4</span>, <span class=\"number\">18.05</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">18.8</span>, <span class=\"number\">-0.47</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">37.21</span>, <span class=\"number\">18.05</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">34.31</span>, <span class=\"number\">20.83</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">20.88</span>, <span class=\"number\">7.22</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">20.88</span>, <span class=\"number\">42.18</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">16.72</span>, <span class=\"number\">42.18</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">16.72</span>, <span class=\"number\">7.22</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextClosePath</span>(ctx);</span><br><span class=\"line\"><span class=\"built_in\">CGContextSetLineWidth</span>(ctx, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextSetStrokeColorWithColor</span>(ctx, [<span class=\"built_in\">UIColor</span> redColor].CGColor);</span><br><span class=\"line\"><span class=\"built_in\">CGContextStrokePath</span>(ctx);</span><br></pre></td></tr></table></figure></p>\n<p>需要问的问题是:这个绘制到哪儿去了？这正好引出所谓的 CGContext 登场。我们传过去的ctx参数正是在那个上下文中。而这个上下文定义了我们需要绘制的地方。如果我们实现了 CALayer 的 <code>-drawInContext:</code> 这时已经传过来一个上下文。绘制到这个上下文中的内容将会被绘制到图层的备份区(图层的缓冲区).但是我们也可以创建我们自己的上下文，叫做基于位图的上下文，比如 <code>CGBitmapContextCreate()</code>.这个方法返回一个我们可以传给 CGContext 方法来绘制的上下文。</p>\n<p>注意 UIKit 版本的代码为何不传入一个上下文参数到方法中？这是因为当使用 UIKit 或者 AppKit 时，上下文是唯一的。UIkit 维护着一个上下文堆栈，UIKit 方法总是绘制到最顶层的上下文中。你可以使用 <code>UIGraphicsGetCurrentContext()</code> 来得到最顶层的上下文。你可以使用 <code>UIGraphicsPushContext()</code> 和 <code>UIGraphicsPopContext()</code> 在 UIKit 的堆栈中推进或取出上下文。</p>\n<p>最为突出的是，UIKit 使用 <code>UIGraphicsBeginImageContextWithOptions()</code> 和 <code>UIGraphicsEndImageContext()</code> 方便的创建类似于 <code>CGBitmapContextCreate()</code> 的位图上下文。混合调用 UIKit 和 Core Graphics 非常简单：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIGraphicsBeginImageContextWithOptions</span>(<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">45</span>, <span class=\"number\">45</span>), <span class=\"literal\">YES</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextRef</span> ctx = <span class=\"built_in\">UIGraphicsGetCurrentContext</span>();</span><br><span class=\"line\"><span class=\"built_in\">CGContextBeginPath</span>(ctx);</span><br><span class=\"line\"><span class=\"built_in\">CGContextMoveToPoint</span>(ctx, <span class=\"number\">16.72</span>, <span class=\"number\">7.22</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">3.29</span>, <span class=\"number\">20.83</span>);</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"built_in\">CGContextStrokePath</span>(ctx);</span><br><span class=\"line\"><span class=\"built_in\">UIGraphicsEndImageContext</span>();</span><br></pre></td></tr></table></figure></p>\n<p>或者另外一种方法:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGContextRef</span> ctx = <span class=\"built_in\">CGBitmapContextCreate</span>(<span class=\"literal\">NULL</span>, <span class=\"number\">90</span>, <span class=\"number\">90</span>, <span class=\"number\">8</span>, <span class=\"number\">90</span> * <span class=\"number\">4</span>, space, bitmapInfo);</span><br><span class=\"line\"><span class=\"built_in\">CGContextScaleCTM</span>(ctx, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>);</span><br><span class=\"line\"><span class=\"built_in\">UIGraphicsPushContext</span>(ctx);</span><br><span class=\"line\"><span class=\"built_in\">UIBezierPath</span> *path = [<span class=\"built_in\">UIBezierPath</span> bezierPath];</span><br><span class=\"line\">[path moveToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">16.72</span>, <span class=\"number\">7.22</span>)];</span><br><span class=\"line\">[path addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">3.29</span>, <span class=\"number\">20.83</span>)];</span><br><span class=\"line\">...</span><br><span class=\"line\">[path stroke];</span><br><span class=\"line\"><span class=\"built_in\">UIGraphicsPopContext</span>(ctx);</span><br><span class=\"line\"><span class=\"built_in\">CGContextRelease</span>(ctx);</span><br></pre></td></tr></table></figure></p>\n<p>你可以使用 Core Graphics 创建大量的非常酷的东西。一个很好的理由就是，苹果的文档有很多例子。我们不能得到所有的细节，但是 Core Graphics 有一个非常接近 <a href=\"https://zh.wikipedia.org/wiki/Adobe_Illustrator\" target=\"_blank\" rel=\"noopener\">Adobe Illustrator</a> 和 <a href=\"https://zh.wikipedia.org/wiki/Adobe_Photoshop\" target=\"_blank\" rel=\"noopener\">Adobe Photoshop</a> 如何工作的绘图模型，并且大多数工具的理念翻译成 Core Graphics 了。终究，他是起源于 <a href=\"https://zh.wikipedia.org/wiki/NEXTSTEP\" target=\"_blank\" rel=\"noopener\">NeXTSTEP</a> 。(原来也是乔老爷的作品)。</p>\n<h2 id=\"CGLayer\"><a href=\"#CGLayer\" class=\"headerlink\" title=\"CGLayer\"></a>CGLayer</h2><p>我们最初指出 CGLayer 可以用来提升重复绘制相同元素的速度。正如 <a href=\"http://iosptl.com/posts/cglayer-no-longer-recommended/\" target=\"_blank\" rel=\"noopener\">Dave Hayden指出</a>，这些<a href=\"http://iosptl.com/posts/cglayer-no-longer-recommended/\" target=\"_blank\" rel=\"noopener\">小道消息</a>不再可靠。</p>\n<h2 id=\"像素\"><a href=\"#像素\" class=\"headerlink\" title=\"像素\"></a>像素</h2><p>屏幕上的像素是由红，绿，蓝三种颜色组件构成的。因此，位图数据有时也被叫做 RGB 数据。你可能会对数据如何组织在内存中感到好奇。而事实是，有很多种不同的方式在内存中展现RGB位图数据。</p>\n<p>稍后我们将会谈到压缩数据，这又是一个完全不同的概念。现在，我们先看一下RGB位图数据，我们可以从颜色组件:红，绿，蓝中得到一个值。而大多数情况下，我们有第四个组件:透明度。最终我们从每个像素中得到四个单独的值。</p>\n<h3 id=\"默认的像素布局\"><a href=\"#默认的像素布局\" class=\"headerlink\" title=\"默认的像素布局\"></a>默认的像素布局</h3><p>在 iOS 和 OS X 上最常见的格式就是大家所熟知的 32bits-per-pixel(bpp), 8bits-per-componet(bpc),透明度会首先被乘以到像素值上(就像上文中提到的那个公式一样),在内存中，像下面这样:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A   R   G   B   A   R   G   B   A   R   G   B</span><br><span class=\"line\">| pixel 0       | pixel 1       | pixel 2</span><br><span class=\"line\">0   1   2   3   4   5   6   7   8   9   10  11 ...</span><br></pre></td></tr></table></figure></p>\n<p>这个格式经常被叫做 ARGB。每个像素占用 4 字节(32bpp),每一个颜色组件是1字节(8bpc).每个像素有一个 alpha 值，这个值总是最先得到的(在RGB值之前)，最终红、绿、蓝的值都会被预先乘以 alpha 的值。预乘的意思就是 alpha 值被烘烤到红、绿、蓝的组件中。如果我们有一个橙色，他们各自的 8bpc 就像这样: <code>240,99,24</code>.一个完全不透明的橙色像素拥有的 ARGB 值为:<code>255，240，99，24</code>，它在内存中的布局就像上面图示那样。如果我们有一个相同颜色的像素，但是 alpha 值为 33%，那么他的像素值便是:<code>84，80，33，8.</code></p>\n<p>另一个常见的格式便是 32bpp，8bpc，跳过第一个 alpha 值，看起来像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x   R   G   B   x   R   G   B   x   R   G   B</span><br><span class=\"line\">| pixel 0       | pixel 1       | pixel 2</span><br><span class=\"line\">0   1   2   3   4   5   6   7   8   9   10  11 ...</span><br></pre></td></tr></table></figure></p>\n<p>这常被叫做 xRGB。像素并没有任何 alpha 值(他们都被假定为100%不透明)，但是内存布局是一样的。你应该想知道为什么这种格式很流行，当我们每一个像素中都有一个不用字节时，我们将会省下 25% 的空间。事实证明，这种格式更容易被现代的 CPU 和绘图算法消化，因为每一个独立的像素都对齐到 32-bit 的边界。现代的 CPU 不喜欢装载(读取)不对齐的数据，特别是当将这种数据和上面没有 alpha 值格式的数据混合时，算法需要做很多挪动和蒙板操作。</p>\n<p>当处理 RGB 数据时，Core Graphics 也需要支持把alpha 值放到最后(另外还要支持跳过)。有时候也分别称为 RGBA 和 RGBx，假定是 8bpc，并且预乘了 alpha 值。</p>\n<h3 id=\"深奥的布局\"><a href=\"#深奥的布局\" class=\"headerlink\" title=\"深奥的布局\"></a>深奥的布局</h3><p>大多数时候，当处理位图数据时，我们也需要处理 Core Graphics/Quartz 2D。有一个非常详细的列表列出了他支持的混合组合。但是让我们首先看一下剩下的 RGB 格式：</p>\n<p>另一个选择是 16bpp，5bpc，不包含 alpha 值。这个格式相比之前一个仅占用 50% 的存储大小(每个像素2字节)，但将使你存储它的 RGB 数据到内存或磁盘中变得困难。既然这种格式中，每个颜色组件只有 5bits(原文中写的是每个像素是5bits，但根据上下文可知应该是每个组件)，这样图形(特别是平滑渐变的)会造成重叠在一起的假象。</p>\n<p>还有一个是 64bpp，16bpc，最终为 128bpp，32bpc，浮点数组件(有或没有 alpha 值)。它们分别使用 8 字节和 16 字节，并且允许更高的精度。当然，这会造成更多的内存使用和昂贵的计算。</p>\n<p>整件事件中，Core Graphics 也支持一些像灰度模式和 <a href=\"https://zh.wikipedia.org/wiki/%E5%8D%B0%E5%88%B7%E5%9B%9B%E5%88%86%E8%89%B2%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">CMYK</a> 格式，这些格式类似于仅有 alpha 值的格式(蒙板)。</p>\n<h3 id=\"二维数据\"><a href=\"#二维数据\" class=\"headerlink\" title=\"二维数据\"></a>二维数据</h3><p>当颜色组件(红、绿、蓝、alpha)混杂在一起的时候，大多数框架(包括 Core Graphics )使用像素数据。正是这种情况下我们称之为二维数据，或者二维组件。这个意思是：每一个颜色组件都在它自己的内存区域，也就是说它是二维的。比如 RGB 数据，我们有三个独立的内存区域，一个大的区域包含了所有像素的红颜色的值，一个包含了所有绿颜色的值，一个包含了所有蓝颜色的值。</p>\n<p>在某些情况下，一些视频框架便会使用二维数据。</p>\n<h3 id=\"YCbCr\"><a href=\"#YCbCr\" class=\"headerlink\" title=\"YCbCr\"></a>YCbCr</h3><p>当我们处理视频数据时，<a href=\"https://zh.wikipedia.org/wiki/YCbCr\" target=\"_blank\" rel=\"noopener\">YCbCr</a> 是一种常见的格式。它也是包含了三种(Y,Cb和Cr)代表颜色数据的组件。但是简单的讲，它更类似于通过人眼看到的颜色。人眼对 Cb 和 Cr 这两种组件的色彩度不太能精确的辨认出来，但是能很准确的识别出 Y 的亮度。当数据使用 YCbCr 格式时，在同等的条件下，Cb 和 Cr 组件比 Y 组件压缩的更紧密。</p>\n<p>出于同样的原因，JPEG 图像有时会将像素数据从 RGB 转换到 YCbCr。JPEG 单独的压缩每一个二维颜色。当压缩基于 YCbCr 的平面时，Cb 和 Cr 能比 Y 压缩得更完全。</p>\n<h2 id=\"图片格式\"><a href=\"#图片格式\" class=\"headerlink\" title=\"图片格式\"></a>图片格式</h2><p>当你在 iOS 或者 OS X 上处理图片时，他们大多数为 JPEG 和 PNG。让我们更进一步观察。</p>\n<h3 id=\"JPEG\"><a href=\"#JPEG\" class=\"headerlink\" title=\"JPEG\"></a>JPEG</h3><p>每个人都知道 JPEG。它是相机的产物。它代表着照片如何存储在电脑上。甚至你妈妈都听说过 JPEG。</p>\n<p>一个很好的理由，很多人都认为 JPEG 文件仅是另一种像素数据的格式，就像我们刚刚谈到的 RGB 像素布局那样。这样理解离真相真是差十万八千里了。</p>\n<p>将 JPEG 数据转换成像素数据是一个非常复杂的过程，你通过一个周末的计划都不能完成，甚至是一个非常漫长的周末(原文的意思好像就是为了表达这个过程非常复杂，不过老外的比喻总让人拎不清)。对于每一个二维颜色，JPEG 使用一种基于<a href=\"https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E4%BD%99%E5%BC%A6%E5%8F%98%E6%8D%A2\" target=\"_blank\" rel=\"noopener\">离散余弦变换</a>(简称 DCT 变换)的算法，将空间信息转变到频域.这个信息然后被量子化，排好序，并且用一种<a href=\"https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81\" target=\"_blank\" rel=\"noopener\">哈夫曼编码</a>的变种来压缩。很多时候，首先数据会被从 RGB 转换到二维 YCbCr，当解码 JPEG 的时候，这一切都将变得可逆。</p>\n<p>这也是为什么当你通过 JPEG 文件创建一个 UIImage 并且绘制到屏幕上时，将会有一个延时，因为 CPU 这时候忙于解压这个 JPEG。如果你需要为每一个 tableviewcell 解压 JPEG，那么你的滚动当然不会平滑(原来 tableviewcell 里面最要不要用 JPEG 的图片)。</p>\n<p>那究竟为什么我们还要用 JPEG 呢？答案就是 JPEG 可以非常非常好的压缩图片。一个通过 iPhone5 拍摄的，未经压缩的图片占用接近 24M。但是通过默认压缩设置，你的照片通常只会在 2-3M 左右。JPEG 压缩这么好是因为它是失真的，它去除了人眼很难察觉的信息，并且这样做可以超出像 gzip 这样压缩算法的限制。但这仅仅在图片上有效的，因为 JPEG 依赖于图片上有很多人类不能察觉出的数据。如果你从一个基本显示文本的网页上截取一张图，JPEG 将不会这么高效。压缩效率将会变得低下，你甚至能看出来图片已经压缩变形了。</p>\n<h3 id=\"PNG\"><a href=\"#PNG\" class=\"headerlink\" title=\"PNG\"></a>PNG</h3><p><a href=\"https://zh.wikipedia.org/wiki/PNG\" target=\"_blank\" rel=\"noopener\">PNG</a>读作”ping”。和 JPEG 相反，它的压缩对格式是无损的。当你将一张图片保存为 PNG，并且打开它(或解压)，所有的像素数据会和最初一模一样，因为这个限制，PNG 不能像 JPEG 一样压缩图片，但是对于像程序中的原图(如buttons，icons)，它工作的非常好。更重要的是，解码 PNG 数据比解码 JPEG 简单的多。</p>\n<p>在现实世界中，事情从来没有那么简单，目前存在了大量不同的 PNG 格式。可以通过维基百科查看详情。但是简言之，PNG 支持压缩带或不带 alpha 通道的颜色像素(RGB)，这也是为什么它在程序原图中表现良好的另一个原因。</p>\n<h3 id=\"挑选一个格式\"><a href=\"#挑选一个格式\" class=\"headerlink\" title=\"挑选一个格式\"></a>挑选一个格式</h3><p>当你在你的程序中使用图片时，你需要坚持这两种格式: JPEG 或者 PNG。读写这种格式文件的压缩和解压文件能表现出很高的性能，另外，还支持并行操作。同时 Apple 正在改进解压缩并可能出现在将来的新操作系统中，届时你将会得到持续的性能提升。如果尝试使用另一种格式，你需要注意到，这可能对你程序的性能会产生影响，同时可能会打开安全漏洞，经常，图像解压缩算法是黑客最喜欢的攻击目标。</p>\n<p>已经写了很多关于优化 PNGs，如果你想要了解更多，请到互联网上查询。非常重要的一点，注意 Xcode 优化 PNG 选项和优化其他引擎有很大的不同。</p>\n<p>当 Xcode 优化一个 PNG 文件的时候，它将 PNG 文件变成一个从技术上讲不再是<a href=\"https://developer.apple.com/library/ios/qa/qa1681/_index.html\" target=\"_blank\" rel=\"noopener\">有效的PNG文件</a>。但是 iOS 可以读取这种文件，并且这比解压缩正常的 PNG 文件更快。Xcode 改变他们，让 iOS 通过一种对正常 PNG 不起作用的算法来对他们解压缩。值得注意的重点是，这改变了像素的布局。正如我们所提到的一样，在像素之下有很多种方式来描绘 RGB 数据，如果这不是 iOS 绘制系统所需要的格式，它需要将每一个像素的数据替换，而不需要加速来做这件事。</p>\n<p>让我们再强调一遍，如果你可以，你需要为原图设置 resizable images。你的文件将变得更小，因此你只需要从文件系统装载更少的数据。</p>\n<h2 id=\"图层后备存储的渲染\"><a href=\"#图层后备存储的渲染\" class=\"headerlink\" title=\"图层后备存储的渲染\"></a>图层后备存储的渲染</h2><h3 id=\"UIKit-和-Pixels\"><a href=\"#UIKit-和-Pixels\" class=\"headerlink\" title=\"UIKit 和 Pixels\"></a>UIKit 和 Pixels</h3><p>每一个在 UIKit 中的 view 都有它自己的 CALayer。依次，这些图层都有一个叫像素位图的后备存储，有点像一个图像。这个后备存储正是被渲染到显示器上的。</p>\n<h3 id=\"With-–drawRect\"><a href=\"#With-–drawRect\" class=\"headerlink\" title=\"With –drawRect:\"></a>With –drawRect:</h3><p>如果你的视图类实现了 <code>-drawRect:</code>，他们将像这样工作:</p>\n<ol>\n<li>设置一个标示<br>当你调用 <code>-setNeedsDisplay</code>，UIKit 将会在这个视图的图层上调用 <code>-setNeedsDisplay</code>。这为图层设置了一个标识，标记为 dirty(直译是脏的意思，想不出用什么词比较贴切,污染？)，但还显示原来的内容。它实际上没做任何工作，所以多次调用 <code>-setNeedsDisplay</code>并不会造成性能损失。</li>\n<li>装备后备存储<br>当渲染系统准备好，它会调用视图图层的<code>-display</code>方法.此时，图层会装配它的后备存储。然后建立一个 Core Graphics 上下文(CGContextRef)，将后备存储对应内存中的数据恢复出来，绘图会进入对应的内存区域，并使用 CGContextRef 绘制。<br>2.1 使用 UIKit 的绘制方法<br>当你使用 UIKit 的绘制方法，例如: <code>UIRectFill()</code> 或者 <code>-[UIBezierPath fill]</code> 代替你的 <code>-drawRect:</code> 方法，他们将会使用这个上下文。<br>使用方法是，UIKit 将后备存储的 CGContextRef 推进他的 graphics context stack，也就是说，它会将那个上下文设置为当前的。因此 <code>UIGraphicsGetCurrent()</code> 将会返回那个对应的上下文。既然 UIKit 使用 <code>UIGraphicsGetCurrent()</code> 绘制方法，绘图将会进入到图层的后备存储。<br>2.2  直接使用 Core Graphics 方法<br>通过调用 <code>UIGraphicsGetCurrent()</code> 得到相同的上下文，并将这个上下文传给 Core Graphics 方法。</li>\n</ol>\n<p>从现在开始，图层的后备存储将会被不断的渲染到屏幕上。直到下次再次调用视图的 <code>-setNeedsDisplay</code> ，将会依次将图层的后备存储更新到视图上。</p>\n<h3 id=\"不使用-drawRect\"><a href=\"#不使用-drawRect\" class=\"headerlink\" title=\"不使用 -drawRect:\"></a>不使用 -drawRect:</h3><p>当你用一个 UIImageView 时，事情略有不同，这个视图仍然有一个 CALayer，但是图层却没有申请一个后备存储。取而代之的是使用一个 CGImageRef 作为他的内容，并且渲染服务将会把图片的数据绘制到帧的缓冲区，比如，绘制到显示屏。</p>\n<p>在这种情况下，将不会继续重新绘制。我们只是简单的将位图数据以图片的形式传给了 UIImageView，然后 UIImageView 传给了 Core Animation，然后轮流传给渲染服务。</p>\n<h2 id=\"实现-drawRect-还是不实现-drawRect\"><a href=\"#实现-drawRect-还是不实现-drawRect\" class=\"headerlink\" title=\"实现-drawRect: 还是不实现 -drawRect:\"></a>实现-drawRect: 还是不实现 -drawRect:</h2><p>最快的绘制就是你不要做任何绘制。<br>大多数时间，你可以不要合成你在其他视图(图层)上定制的视图(图层)，这正是我们推荐的，因为 UIKit 的视图类是非常优化的 (就是让我们不要闲着没事做,自己去合并视图或图层) 。</p>\n<p>当你需要自定义绘图代码时，Apple 在<a href=\"https://developer.apple.com/videos/wwdc/2012/?id=506\" target=\"_blank\" rel=\"noopener\">WWDC 2012’s session 506</a>:Optimizing 2D Graphics and Animation Performance 中展示了一个很好的例子:”finger painting”。</p>\n<p>另一个地方需要自定义绘图的就是 iOS 的股票软件。股票是直接用 Core Graphics 在设备上绘制的，注意，这仅仅是你需要自定义绘图，你并不需要实现 <code>-drawRect:</code> 方法。有时，通过 <code>UIGraphicsBeginImageContextWithOptions()</code> 或者 <code>CGBitmapContextCeate()</code> 创建位图会显得更有意义，从位图上面抓取图像，并设置为 <code>CALayer</code> 的内容。下面我们将给出一个例子来测试，检验。</p>\n<h3 id=\"单一颜色\"><a href=\"#单一颜色\" class=\"headerlink\" title=\"单一颜色\"></a>单一颜色</h3><p>如果我们看这个例子：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Don't do this</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)drawRect:(<span class=\"built_in\">CGRect</span>)rect</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">[[<span class=\"built_in\">UIColor</span> redColor] setFill];</span><br><span class=\"line\"><span class=\"built_in\">UIRectFill</span>([<span class=\"keyword\">self</span> bounds]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在我们知道这为什么不好:我们促使 Core Animation 来为我们创建一个后备存储，并让它使用单一颜色填充后备存储，然后上传给 GPU。</p>\n<p>我们跟本不需要实现 <code>-drawRect:</code>，并节省这些代码工作量，只需简单的设置这个视图图层的背景颜色。如果这个视图有一个 CAGradientLayer 作为图层，那么这个技术也同样适用于此（渐变图层）。</p>\n<h3 id=\"可变尺寸的图像\"><a href=\"#可变尺寸的图像\" class=\"headerlink\" title=\"可变尺寸的图像\"></a>可变尺寸的图像</h3><p>类似的，你可以使用可变尺寸的图像来降低绘图系统的压力。让我们假设你需要一个 300×50 点的按钮插图，这将是 600×100=60k 像素或者 60kx4=240kB 内存大小需要上传到 GPU，并且占用 VRAM。如果我们使用所谓的可变尺寸的图像，我们只需要一个 54×12 点的图像，这将占用低于 2.6k 的像素或者 10kB 的内存，这样就变得更快了。</p>\n<p>Core Animation 可以通过 CALayer 的 <a href=\"https://developer.apple.com/library/mac/documentation/graphicsimaging/reference/CALayer_class/Introduction/Introduction.html#//apple_ref/occ/instp/CALayer/contentsCenter\" target=\"_blank\" rel=\"noopener\"><code>contentsCenter</code></a> 属性来改变图像，大多数情况下，你可能更倾向于使用，<a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImage_Class/Reference/Reference.html#//apple_ref/occ/instm/UIImage/resizableImageWithCapInsets:resizingMode:\" target=\"_blank\" rel=\"noopener\"><code>-[UIImage resizableImageWithCapInsets:resizingMode:]</code></a>。</p>\n<p>同时注意，在第一次渲染这个按钮之前，我们并不需要从文件系统读取一个 60k 像素的 PNG 并解码，解码一个小的 PNG 将会更快。通过这种方式，你的程序在每一步的调用中都将做更少的工作，并且你的视图将会加载的更快。</p>\n<h3 id=\"并发绘图\"><a href=\"#并发绘图\" class=\"headerlink\" title=\"并发绘图\"></a>并发绘图</h3><p>上一次 <a href=\"http://objccn.io/issue-2/\" target=\"_blank\" rel=\"noopener\">objc.io</a> 的话题是关于并发的讨论。正如你所知道的一样，UIKit 的线程模型是非常简单的：你仅可以从主队列(比如主线程)中调用 UIKit 类(比如视图),那么并发绘图又是什么呢？</p>\n<p>如果你必须实现 <code>-drawRect:</code>，并且你必须绘制大量的东西，这将占用时间。由于你希望动画变得更平滑，除了在主队列中，你还希望在其他队列中做一些工作。同时发生的绘图是复杂的，但是除了几个警告，同时发生的绘图还是比较容易实现的。</p>\n<p>我们除了在主队列中可以向 CALayer 的后备存储中绘制一些东西，其他方法都将不可行。可怕的事情将会发生。我们能做的就是向一个完全断开链接的位图上下文中进行绘制。<br>为了同时绘制，我们需要做下面的操作:</p>\n<ol>\n<li>正如我们上面所提到的一样，在 Core Graphics 下，所有 Core Graphics 绘制方法都需要一个上下文参数来指定绘制到那个上下文中。UIKit 有一个当前上下文的概念(也就是绘制到哪儿去)。这个当前的上下文就是 per-thread.</li>\n<li>我们需要在另一个队列创建一个图像，一旦我们拥有了图像，我们可以切换回主队列，并且设置这个图像为 UIImageView 的图像。这个技术在 <a href=\"https://developer.apple.com/videos/wwdc/2012/?id=211\" target=\"_blank\" rel=\"noopener\">WWDC 2012 session 211</a> 中讨论过。(异步下载图片经常用到这个)</li>\n</ol>\n<p>增加一个你可以在其中绘制的新方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIImage</span> *)renderInImageOfSize:(<span class=\"built_in\">CGSize</span>)size</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIGraphicsBeginImageContextWithOptions</span>(size, <span class=\"literal\">NO</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 绘制代码块</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">UIImage</span> *result = <span class=\"built_in\">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class=\"line\">    <span class=\"built_in\">UIGraphicsEndImageContext</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法通过 <code>UIGraphicsBeginImageContextWithOptions()</code> 方法，并根据给定的大小创建一个新的 CGContextRef 位图上下文。这个方法也会将这个上下文设置为<em>当前UIKit</em>的上下文。现在你可以在这里做你想在 <code>-drawRect:</code> 中做的事了。然后通过 <code>UIGraphicsGetImageFromCurrentImageContext()</code>,获得的这个上下文位图数据作为一个 UIImage，最终移除这个上下文。</p>\n<p>很重要的一点就是，你在这个方法中所做的所有绘图的代码都是线程安全的，也就是说，当你访问属性等等，他们需要线程安全。因为你是在另一个队列中调用这个方法的。如果这个方法在你的视图类中，那就需要注意一点了。<br>另一个选择就是创建一个单独的渲染类，并设置所有需要的属性，然后通过触发来渲染图片。如果这样，你可以通过使用简单的 UIImageView 或者 UITableViewCell。</p>\n<p>要知道，所有 UIKit 的绘制 API 在使用另一个队列时，都是安全的。只需要确定是在同一个操作中调用他们的，这个操作需要以 <code>UIGraphicsBeginImageContextWithOptions()</code> 开始，以 <code>UIGraphicsEndIamgeContext()</code> 结束。</p>\n<p>你需要像下面这样触发渲染代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIImageView</span> *view; <span class=\"comment\">// assume we have this</span></span><br><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span> *renderQueue; <span class=\"comment\">// assume we have this</span></span><br><span class=\"line\"><span class=\"built_in\">CGSize</span> size = view.bounds.size;</span><br><span class=\"line\">[renderQueue addOperationWithBlock:^()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIImage</span> *image = [renderer renderInImageOfSize:size];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^()&#123;</span><br><span class=\"line\">        view.image = image;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></p>\n<p>要注意，我们是在主队列中调用 <code>view.image = image</code>.这是一个非常重要的细节。你不可以在任何其他队列中调用这个代码。</p>\n<p>像往常一样，同时绘制会伴随很多问题，你现在需要取消后台渲染。并且在渲染队列中设置合理的同时绘制的最大限度。为了支持这一切，最简单的就是在一个 NSOperation 子类内部实现 <code>-renderInImageOfSize:</code>。</p>\n<p>最终，需要指出，设置 UITableViewCell 内容为异步是非常困难的。单元格很有可能在完成异步渲染前已经被复用了。尽管单元格已经被其他地方复用，但你只需要设置内容就行了。</p>\n<h2 id=\"CALayer\"><a href=\"#CALayer\" class=\"headerlink\" title=\"CALayer\"></a>CALayer</h2><p>到现在为止，你需要知道在 GPU 内，一个 CALayer 在某种方式上和一个纹理类似。图层有一个后备存储，这便是被用来绘制到屏幕上的位图。</p>\n<p>通常，当你使用 CALayer 时，你会设置它的内容为一个图片。这到底做了什么？这样做会告诉 Core Animation 使用图片的位图数据作为纹理。如果这个图片(JPEG或PNG)被压缩了，Core Animation 将会这个图片解压缩，然后上传像素数据到 GPU。</p>\n<p>尽管还有很多其他种类的图层，如果你是用一个简单的没有设置上下文的 CALayer，并为这个 CALayer 设置一个背景颜色，Core Animation 并不会上传任何数据到 GPU，但却能够不用任何像素数据而在 GPU 上完成所有的工作，类似的，对于渐变的图层，GPU 是能创建渐变的，而且不需要 CPU 做任何工作，并且不需要上传任何数据到 GPU。</p>\n<h3 id=\"自定义绘制的图层\"><a href=\"#自定义绘制的图层\" class=\"headerlink\" title=\"自定义绘制的图层\"></a>自定义绘制的图层</h3><p>如果一个 CALayer 的子类实现了 <code>-drawInContext:</code> 或者它的代理，类似于 <code>-drawLayer:inContest:</code>, Core Animation 将会为这个图层申请一个后备存储，用来保存那些方法绘制进来的位图。那些方法内的代码将会运行在 CPU 上，结果将会被上传到 GPU。</p>\n<h3 id=\"形状和文本图层\"><a href=\"#形状和文本图层\" class=\"headerlink\" title=\"形状和文本图层\"></a>形状和文本图层</h3><p>形状和文本图层还是有些不同的。开始时，Core Animation 为这些图层申请一个后备存储来保存那些需要为上下文生成的位图数据。然后 Core Animation 会讲这些图形或文本绘制到后备存储上。这在概念上非常类似于，当你实现 <code>-drawInContext:</code> 方法，然后在方法内绘制形状或文本，他们的性能也很接近。</p>\n<p>在某种程度上，当你需要改变形状或者文本图层时，这需要更新它的后备存储，Core Animation 将会重新渲染后备存储。例如，当动态改变形状图层的大小时，Core Animation 需要为动画中的每一帧重新绘制形状。</p>\n<h3 id=\"异步绘图\"><a href=\"#异步绘图\" class=\"headerlink\" title=\"异步绘图\"></a>异步绘图</h3><p>CALayer 有一个叫做 drawsAsynchronously 的属性，这似乎是一个解决所有问题的高招。注意，尽管这可能提升性能，但也可能让事情变慢。</p>\n<p>当你设置 drawsAsynchronously 为 YES 时，发生了什么？你的 <code>-drawRect:/-drawInContext:</code> 方法仍然会被在主线程上调用。但是所有调用 Core Graphics 的操作都不会被执行。取而代之的是，绘制命令被推迟，并且在后台线程中异步执行。</p>\n<p>这种方式就是先记录绘图命令，然后在后台线程中重现。为了这个过程的顺利进行，更多的工作需要被做，更多的内存需要被申请。但是主队列中的一些工作便被移出来了(大概意思就是让我们把一些能在后台实现的工作放到后台实现，让主线程更顺畅)。</p>\n<p>对于昂贵的绘图方法，这是最有可能提升性能的，但对于那些绘图方法来说，也不会节省太多资源。</p>\n<hr>\n<p><a href=\"http://objccn.io/issue-3/\" target=\"_blank\" rel=\"noopener\">话题 #3 下的更多文章</a></p>\n<p>原文 <a href=\"http://www.objc.io/issue-3/moving-pixels-onto-the-screen.html\" target=\"_blank\" rel=\"noopener\">Getting Pixels onto the Screen</a></p>\n<p>译文 <a href=\"http://answerhuang.duapp.com/index.php/2013/09/04/pixels-get-onto-the-screen/\" target=\"_blank\" rel=\"noopener\">将像素绘制到屏幕上去 - answer-huang</a></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"视图","path":"api/categories/视图.json"}],"tags":[]},{"title":"NSURLSession的使用说明","slug":"iOS/NSURLSession的使用说明","date":"2017-09-08T18:48:43.000Z","updated":"2017-09-08T18:50:27.000Z","comments":true,"path":"api/articles/iOS/NSURLSession的使用说明.json","excerpt":null,"keywords":null,"cover":"https://www.objccn.io/images/issues/issue-5/NSURLSession.png","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>iOS 7 和 Mac OS X 10.9 Mavericks 中一个显著的变化就是对 Foundation URL 加载系统的彻底重构。</p>\n<p>现在已经有人在深入苹果的网络层基础架构的地方做研究了，所以我想是时候来分享一些对于我对于这些新的 API 的看法和心得了，新的 API 将如何影响我们编写程序，以及它们对于 API 设计理念的影响。</p>\n<h2 id=\"NSURLConnection机制\"><a href=\"#NSURLConnection机制\" class=\"headerlink\" title=\"NSURLConnection机制\"></a>NSURLConnection机制</h2><p><code>NSURLConnection</code> 作为 Core Foundation / CFNetwork 框架的 API 之上的一个抽象，在 2003 年，随着第一版的 Safari 的发布就发布了。<code>NSURLConnection</code> 这个名字，实际上是指代的 Foundation 框架的 URL 加载系统中一系列有关联的组件：<code>NSURLRequest</code>、<code>NSURLResponse</code>、<code>NSURLProtocol</code>、 <code>NSURLCache</code>、 <code>NSHTTPCookieStorage</code>、<code>NSURLCredentialStorage</code> 以及同名类 <code>NSURLConnection</code>。</p>\n<p><code>NSURLRequest</code> 被传递给 <code>NSURLConnection</code>。被委托对象（遵守以前的非正式协议 <code>&lt;NSURLConnectionDelegate&gt;</code> 和 <code>&lt;NSURLConnectionDataDelegate&gt;</code>）异步地返回一个 <code>NSURLResponse</code> 以及包含服务器返回信息的 <code>NSData</code>。</p>\n<h3 id=\"缓存策略\"><a href=\"#缓存策略\" class=\"headerlink\" title=\"缓存策略\"></a>缓存策略</h3><p>在一个请求被发送到服务器之前，系统会先查询共享的缓存信息，然后根据<strong>策略（policy）</strong>以及<strong>可用性（availability）</strong>的不同，一个已经被缓存的响应可能会被立即返回。如果没有缓存的响应可用，则这个请求将根据我们指定的策略来缓存它的响应以便将来的请求可以使用。</p>\n<h3 id=\"鉴权查询\"><a href=\"#鉴权查询\" class=\"headerlink\" title=\"鉴权查询\"></a>鉴权查询</h3><p>在把请求发送给服务器的过程中，服务器可能会发出<strong>鉴权查询（authentication challenge）</strong>，这可以由共享的 cookie 或<strong>机密存储（credential storage）</strong>来自动响应，或者由被委托对象来响应。发送中的请求也可以被注册的 <code>NSURLProtocol</code> 对象所拦截，以便在必要的时候无缝地改变其加载行为。</p>\n<p>不管怎样，<code>NSURLConnection</code> 作为网络基础架构，已经服务了成千上万的 iOS 和 Mac OS 程序，并且做的还算相当不错。但是这些年，一些用例——尤其是在 iPhone 和 iPad 上面——已经对 <code>NSURLConnection</code> 的几个核心概念提出了挑战，让苹果有理由对它进行重构。</p>\n<p>在 2013 的 WWDC 上，苹果推出了 <code>NSURLConnection</code> 的继任者：<code>NSURLSession</code>。</p>\n<hr>\n<h2 id=\"NSURLSession成员\"><a href=\"#NSURLSession成员\" class=\"headerlink\" title=\"NSURLSession成员\"></a>NSURLSession成员</h2><p>和 <code>NSURLConnection</code> 一样，<code>NSURLSession</code> 指的也不仅是同名类 <code>NSURLSession</code>，还包括一系列相互关联的类。<code>NSURLSession</code> 包括了与之前相同的组件，<code>NSURLRequest</code> 与 <code>NSURLCache</code>，但是把 <code>NSURLConnection</code> 替换成了 <code>NSURLSession</code>、<code>NSURLSessionConfiguration</code> 以及 <code>NSURLSessionTask</code> 的 3 个子类：<code>NSURLSessionDataTask</code>，<code>NSURLSessionUploadTask</code>，<code>NSURLSessionDownloadTask</code>。</p>\n<ol>\n<li>NSURLSessionConfiguration可配置性初始化<br>与 <code>NSURLConnection</code> 相比，<code>NSURLsession</code> 最直接的改进就是可以配置每个 session 的缓存，协议，cookie，以及<strong>证书策略（credential policy）</strong>，甚至跨程序共享这些信息。这将允许程序和网络基础框架之间相互独立，不会发生干扰。每个 <code>NSURLSession</code> 对象都由一个 <code>NSURLSessionConfiguration</code> 对象来进行初始化，后者指定了刚才提到的那些策略以及一些用来增强移动设备上性能的新选项。</li>\n<li>抽象类NSURLSessionTask数据加载<br><code>NSURLSession</code> 中另一大块就是 session task。它负责处理数据的加载以及文件和数据在客户端与服务端之间的上传和下载。<code>NSURLSessionTask</code> 与 <code>NSURLConnection</code> 最大的相似之处在于它也负责数据的加载，最大的不同之处在于所有的 task 共享其创造者 <code>NSURLSession</code> 这一<strong>公共委托者（common delegate）</strong>。</li>\n</ol>\n<p>我们先来深入探讨 task，过后再来讨论 <code>NSURLSessionConfiguration</code>。</p>\n<h3 id=\"NSURLSessionTask\"><a href=\"#NSURLSessionTask\" class=\"headerlink\" title=\"NSURLSessionTask\"></a>NSURLSessionTask</h3><p><code>NSURLsessionTask</code> 是一个抽象类，其下有 3 个实体子类封装了现代程序三个最基本的网络任务：</p>\n<ol>\n<li><code>NSURLSessionDataTask</code>：加载数据，当加载任务完成时，它会返回相关联的数据，比如 JSON 或者 XML</li>\n<li><code>NSURLSessionUploadTask</code>：上传文件，当上传任务完成时，也会有上传相关数据返回，所以继承自 <code>NSURLSessionDataTask</code>。</li>\n<li><code>NSURLSessionDownloadTask</code>：下载文件，当下载任务结束时，它会返回已下载文件的一个临时的文件路径。</li>\n</ol>\n<p><img alt=\"NSURLSessionTask class diagram\" src=\"https://www.objccn.io/images/issues/issue-5/NSURLSession.png\" width=\"612\" height=\"294\"></p>\n<p>所有的 task 都是可以取消，暂停或者恢复的。当一个 download task 取消时，可以通过选项来创建一个<strong>恢复数据（resume data）</strong>，然后可以传递给下一次新创建的 download task，以便继续之前的下载。</p>\n<h4 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h4><p>不同于直接使用 <code>alloc-init</code> 初始化方法，task 是由一个 <code>NSURLSession</code> 创建的。每个 task 的构造方法都对应有或者没有 <code>completionHandler</code> 这个 block 的两个版本:</p>\n<ol>\n<li>block回调构造方式: <code>–dataTaskWithRequest:completionHandler:</code><br>通过指定 <code>completionHandler</code> 这个 block 将创建一个隐式的 delegate，来替代该 task 原来的 delegate——session。</li>\n<li>代理回调构造方式：<code>–dataTaskWithRequest:</code><br>对于需要 <code>override</code> 原有 session task 的 delegate 的默认行为的情况,使用代理回调</li>\n</ol>\n<p>这里不会立即运行 task，而是将该 task 对象先返回，允许我们进一步的配置，然后可以使用 <code>resume</code> 方法来让它开始运行。</p>\n<h5 id=\"数据加载工厂\"><a href=\"#数据加载工厂\" class=\"headerlink\" title=\"数据加载工厂\"></a>数据加载工厂</h5><p>Data task 可以通过 <code>NSURL</code> 或 <code>NSURLRequest</code> 创建（使用前者相当于是使用一个对于该 URL 进行标准 <code>GET</code> 请求的 <code>NSURLRequest</code>，这是一种快捷方法）：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURL</span> *URL = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://example.com\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSURLRequest</span> *request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:URL];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sharedSession];</span><br><span class=\"line\"><span class=\"built_in\">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request</span><br><span class=\"line\">completionHandler:</span><br><span class=\"line\">^(<span class=\"built_in\">NSData</span> *data, <span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSError</span> *error) &#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[task resume];</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"数据上传工厂\"><a href=\"#数据上传工厂\" class=\"headerlink\" title=\"数据上传工厂\"></a>数据上传工厂</h5><p>Upload task 的创建需要使用一个 request，另外加上一个要上传的 <code>NSData</code> 对象或者是一个本地文件的路径对应的 <code>NSURL</code>：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURL</span> *URL = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://example.com/upload\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSURLRequest</span> *request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:URL];</span><br><span class=\"line\"><span class=\"built_in\">NSData</span> *data = ...;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sharedSession];</span><br><span class=\"line\"><span class=\"built_in\">NSURLSessionUploadTask</span> *uploadTask = [session uploadTaskWithRequest:request</span><br><span class=\"line\">fromData:data</span><br><span class=\"line\">completionHandler:</span><br><span class=\"line\">^(<span class=\"built_in\">NSData</span> *data, <span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSError</span> *error) &#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[uploadTask resume];</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"数据下载工厂\"><a href=\"#数据下载工厂\" class=\"headerlink\" title=\"数据下载工厂\"></a>数据下载工厂</h5><p>Download task 也需要一个 request，不同之处在于 <code>completionHandler</code> 这个 block。Data task 和 upload task 会在任务完成时一次性返回，但是 Download task 是将数据一点点地写入本地的临时文件。所以在 <code>completionHandler</code> 这个 block 里，我们需要把文件从一个临时地址移动到一个永久的地址保存起来：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURL</span> *URL = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://example.com/file.zip\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSURLRequest</span> *request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:URL];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sharedSession];</span><br><span class=\"line\"><span class=\"built_in\">NSURLSessionDownloadTask</span> *downloadTask = [session downloadTaskWithRequest:request</span><br><span class=\"line\">completionHandler:</span><br><span class=\"line\">^(<span class=\"built_in\">NSURL</span> *location, <span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSError</span> *error) &#123;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *documentsPath = [<span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>) firstObject];</span><br><span class=\"line\"><span class=\"built_in\">NSURL</span> *documentsDirectoryURL = [<span class=\"built_in\">NSURL</span> fileURLWithPath:documentsPath];</span><br><span class=\"line\"><span class=\"built_in\">NSURL</span> *newFileLocation = [documentsDirectoryURL URLByAppendingPathComponent:[[response URL] lastPathComponent]];</span><br><span class=\"line\">[[<span class=\"built_in\">NSFileManager</span> defaultManager] copyItemAtURL:location toURL:newFileLocation error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[downloadTask resume];</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p><span class=\"secondary radius label\">编者注</span> 原文中这块代码以及上文的表述中存有一些问题，详见这个 <a href=\"https://github.com/objcio/articles/issues/24\" target=\"_blank\" rel=\"noopener\">issue</a>，本文已进行更正，如果您有不同意见，欢迎在 <a href=\"https://github.com/objccn/articles\" target=\"_blank\" rel=\"noopener\">Github</a> 上给我们反馈。</p>\n</blockquote>\n<h4 id=\"NSURLSession-的-delegate-方法\"><a href=\"#NSURLSession-的-delegate-方法\" class=\"headerlink\" title=\"NSURLSession 的 delegate 方法\"></a>NSURLSession 的 delegate 方法</h4><p><code>NSURLSession</code> 的 delegate 方法是 <code>NSURLConnection</code> 的演化的十年中对于 ad-hoc 模式的一个显著改善。您可以查看这个<a href=\"https://gist.github.com/floriankugler/6870499\" target=\"_blank\" rel=\"noopener\">映射表</a>来进行一个完整的概览。</p>\n<h5 id=\"连接层-任务层代理\"><a href=\"#连接层-任务层代理\" class=\"headerlink\" title=\"连接层/任务层代理\"></a>连接层/任务层代理</h5><p><code>NSURLSession</code> 既拥有 seesion 的 delegate 方法，又拥有 task 的 delegate 方法用来处理鉴权查询。</p>\n<ol>\n<li>session 的 delegate 方法处理连接层的问题：诸如服务器信任，客户端证书的评估，<a href=\"http://en.wikipedia.org/wiki/NTLM\" target=\"_blank\" rel=\"noopener\">NTLM</a> 和 <a href=\"http://zh.wikipedia.org/wiki/Kerberos\" target=\"_blank\" rel=\"noopener\">Kerberos</a> 协议这类问题。</li>\n<li>task 的 delegate 处理网络请求为基础的问题：如 Basic，Digest，以及<strong>代理身份验证（Proxy authentication）</strong>等。</li>\n<li>网络请求结束代理<br>在 <code>NSURLConnection</code> 中两个delegate方法：<br>数据加载完成：<code>NSURLConnectionDataDelegate</code> 中的 <code>-connectionDidFinishLoading:</code><br>网络连接失败： <code>NSURLConnectionDelegate</code> 中的 <code>-connection:didFailWithError:</code>，<br>在 <code>NSURLSession</code> 中改为一个 delegate 方法：<ol>\n<li><code>NSURLSessionTaskDelegate</code> 的 <code>-URLSession:task:didCompleteWithError:</code></li>\n<li><code>NSURLSession</code> 中表示传输多少字节的参数类型现在改为 <code>int64_t</code>，以前在 <code>NSURLConnection</code> 中相应的参数的类型是 <code>long long</code>。</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"block参数回调代理模式\"><a href=\"#block参数回调代理模式\" class=\"headerlink\" title=\"block参数回调代理模式\"></a>block参数回调代理模式</h5><p><code>NSURLSession</code> 给 Foundation 框架引入了一种全新的模式：即 代理方法中以<code>completionHandler:</code>  这种block 作为参数的方式。</p>\n<ol>\n<li>这种模式允许 delegate 方法可以安全地在主线程与运行，而不会阻塞主线程；</li>\n<li>Delgate 只需要简单地调用 <code>dispatch_async</code> 就可以切换到后台进行相关的操作，然后在操作完成时调用 <code>completionHandler</code> 即可。</li>\n<li>它还可以有效地拥有多个返回值，而不需要我们使用笨拙的参数指针。</li>\n</ol>\n<p>以 <code>NSURLSessionTaskDelegate</code>代理中的方法为例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-URLSession:task:didReceiveChallenge:completionHandler:</span><br></pre></td></tr></table></figure></p>\n<p><code>completionHandler</code> 接受的两个参数：<br>参数一：<code>NSURLSessionAuthChallengeDisposition</code>:鉴权查询的策略<br>参数二：<code>NSURLCredential</code>:证书（仅当第一个参数——应对鉴权查询的策略为使用证书，即 <code>NSURLSessionAuthChallengeUseCredential</code> 时有效，否则该参数为 <code>NULL</code>）。</p>\n<blockquote>\n<p>想要查看更多关于 session task 的信息，可以查看 <a href=\"http://asciiwwdc.com/2013/sessions/705\" target=\"_blank\" rel=\"noopener\">WWDC Session 705: “What’s New in Foundation Networking”</a></p>\n</blockquote>\n<h3 id=\"NSURLSessionConfiguration\"><a href=\"#NSURLSessionConfiguration\" class=\"headerlink\" title=\"NSURLSessionConfiguration\"></a>NSURLSessionConfiguration</h3><p><code>NSURLSessionConfiguration</code> 对象用于对 <code>NSURLSession</code> 对象进行初始化。</p>\n<ol>\n<li>配置开发灵活性<br><code>NSURLSessionConfiguration</code> 扩充了 <code>NSMutableURLRequest</code> 所提供的<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSMutableURLRequest_Class/Reference/Reference.html\" target=\"_blank\" rel=\"noopener\">网络请求层的设置选项</a>，从指定可用网络，到 cookie，安全性，缓存策略，再到使用自定义协议，启动事件的设置，以及用于移动设备优化的几个新属性，你会发现使用 <code>NSURLSessionConfiguration</code> 可以找到几乎任何你想要进行配置的选项，提供给我们相当大的灵活性和控制权。</li>\n<li>配置加载机制<br><code>NSURLSession</code> 在初始化时会把配置它的 <code>NSURLSessionConfiguration</code> 对象进行一次 copy，并保存到自己的 <code>configuration</code> 属性中，而且这个属性是只读的。因此之后再修改最初配置 session 的那个 configuration 对象对于 session 是没有影响的。也就是说，configuration 只在初始化时被读取一次，之后都是不会变化的。</li>\n</ol>\n<h4 id=\"三个配置类工厂方法\"><a href=\"#三个配置类工厂方法\" class=\"headerlink\" title=\"三个配置类工厂方法\"></a>三个配置类工厂方法</h4><p>针对<code>NSURLSession</code> 不同的使用场景，如下三个配置类方法：</p>\n<ol>\n<li><code>+defaultSessionConfiguration</code>： 返回一个标准的 configuration，这个配置实际上与 <code>NSURLConnection</code> 的<strong>网络堆栈（networking stack）</strong>是一样的，具有相同的共享 <code>NSHTTPCookieStorage</code>，共享 <code>NSURLCache</code> 和共享 <code>NSURLCredentialStorage</code>。</li>\n<li><code>+ephemeralSessionConfiguration</code>： 返回一个预设配置，这个配置中不会对缓存，Cookie 和证书进行持久性的存储。这对于实现像秘密浏览这种功能来说是很理想的。</li>\n<li><code>+backgroundSessionConfiguration:(NSString *)identifier</code> 的独特之处在于，它会创建一个<em>后台 session</em>。后台 session 不同于常规的，普通的 session，它甚至可以在应用程序挂起，退出或者崩溃的情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外恢复后台传输的<strong>守护进程（daemon）</strong>提供上下文。</li>\n</ol>\n<p>想要查看更多关于后台 session 的信息，可以查看 <a href=\"http://asciiwwdc.com/2013/sessions/204\" target=\"_blank\" rel=\"noopener\">WWDC Session 204: “What’s New with Multitasking”</a></p>\n<h4 id=\"配置属性\"><a href=\"#配置属性\" class=\"headerlink\" title=\"配置属性\"></a>配置属性</h4><p><code>NSURLSessionConfiguration</code> 拥有 20 个配置属性。熟练掌握这些配置属性的用处，可以让应用程序充分地利用其网络环境。</p>\n<h5 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h5><ol>\n<li><p><code>HTTPAdditionalHeaders</code>: 指定了一组默认的可以设置<strong>出站请求（outbound request）</strong>的数据头。这对于跨 session 共享信息，如内容类型，语言，用户代理和身份认证，是很有用的。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *userPasswordString = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@:%@\"</span>, user, password];</span><br><span class=\"line\"><span class=\"built_in\">NSData</span> * userPasswordData = [userPasswordString dataUsingEncoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *base64EncodedCredential = [userPasswordData base64EncodedStringWithOptions:<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *authString = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"Basic %@\"</span>, base64EncodedCredential];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *userAgentString = <span class=\"string\">@\"AppName/com.example.app (iPhone 5s; iOS 7.0.2; Scale/2.0)\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">configuration.HTTPAdditionalHeaders = @&#123;<span class=\"string\">@\"Accept\"</span>: <span class=\"string\">@\"application/json\"</span>,</span><br><span class=\"line\"><span class=\"string\">@\"Accept-Language\"</span>: <span class=\"string\">@\"en\"</span>,</span><br><span class=\"line\"><span class=\"string\">@\"Authorization\"</span>: authString,</span><br><span class=\"line\"><span class=\"string\">@\"User-Agent\"</span>: userAgentString&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>networkServiceType</code>: 对标准的网络流量，网络电话，语音，视频，以及由一个后台进程使用的流量进行了区分。大多数应用程序都不需要设置这个。</p>\n</li>\n<li><code>allowsCellularAccess</code> 和 <code>discretionary</code> 被用于节省通过蜂窝网络连接的带宽。对于后台传输的情况，推荐大家使用 <code>discretionary</code> 这个属性，而不是 <code>allowsCellularAccess</code>，因为前者会把 WiFi 和电源的可用性考虑在内。</li>\n<li><code>timeoutIntervalForRequest</code> 和 <code>timeoutIntervalForResource</code> 分别指定了对于请求和资源的超时间隔。许多开发人员试图使用 <code>timeoutInterval</code> 去限制发送请求的总时间，但其实它真正的含义是：<strong>分组（packet）</strong>之间的时间。实际上我们应该使用 <code>timeoutIntervalForResource</code> 来规定整体超时的总时间，但应该只将其用于后台传输，而不是用户实际上可能想要去等待的任何东西。</li>\n<li><code>HTTPMaximumConnectionsPerHost</code>: 是 Foundation 框架中 URL 加载系统的一个新的配置选项。它曾经被 <code>NSURLConnection</code> 用于管理私有的连接池。现在有了 <code>NSURLSession</code>，开发者可以在需要时限制连接到特定主机的数量。</li>\n<li><code>HTTPShouldUsePipelining</code>: 这个属性在 <code>NSMutableURLRequest</code> 下也有，它可以被用于开启 <strong>HTTP 管线化（<a href=\"http://en.wikipedia.org/wiki/HTTP_pipelining\" target=\"_blank\" rel=\"noopener\">HTTP pipelining</a>）</strong>，这可以显着降低请求的加载时间，但是由于没有被服务器广泛支持，默认是禁用的。</li>\n<li><code>sessionSendsLaunchEvents</code>: 是另一个新的属性，该属性指定该 session 是否应该从后台启动。</li>\n<li><code>connectionProxyDictionary</code>: 指定了 session 连接中的代理服务器。同样地，大多数面向消费者的应用程序都不需要代理，所以基本上不需要配置这个属性。</li>\n</ol>\n<blockquote>\n<p>关于连接代理的更多信息可以在 <a href=\"https://developer.apple.com/library/mac/documentation/CoreFoundation/Reference/CFProxySupport/Reference/reference.html\" target=\"_blank\" rel=\"noopener\"><code>CFProxySupport</code> Reference</a> 找到。</p>\n</blockquote>\n<h5 id=\"Cookie-策略\"><a href=\"#Cookie-策略\" class=\"headerlink\" title=\"Cookie 策略\"></a>Cookie 策略</h5><ol>\n<li><code>HTTPCookieStorage</code>: 存储了 session 所使用的 cookie。默认情况下会使用 <code>NSHTTPCookieShorage</code> 的 <code>+sharedHTTPCookieStorage</code> 这个单例对象，这与 <code>NSURLConnection</code> 是相同的。</li>\n<li><code>HTTPCookieAcceptPolicy</code>: 决定了什么情况下 session 应该接受从服务器发出的 cookie。</li>\n<li><code>HTTPShouldSetCookies</code>: 指定了请求是否应该使用 session 存储的 cookie，即 <code>HTTPCookieSorage</code> 属性的值。</li>\n</ol>\n<h5 id=\"安全策略\"><a href=\"#安全策略\" class=\"headerlink\" title=\"安全策略\"></a>安全策略</h5><ol>\n<li><code>URLCredentialStorage</code>: 存储了 session 所使用的证书。默认情况下会使用 <code>NSURLCredentialStorage</code> 的 <code>+sharedCredentialStorage</code> 这个单例对象，这与 <code>NSURLConnection</code> 是相同的。</li>\n<li><code>TLSMaximumSupportedProtocol</code> 和 <code>TLSMinimumSupportedProtocol</code> 确定 session 是否支持 <a href=\"http://zh.wikipedia.org/wiki/安全套接层\" target=\"_blank\" rel=\"noopener\">SSL 协议</a>。</li>\n</ol>\n<h5 id=\"缓存策略-1\"><a href=\"#缓存策略-1\" class=\"headerlink\" title=\"缓存策略\"></a>缓存策略</h5><ol>\n<li><code>URLCache</code> : 是 session 使用的缓存。默认情况下会使用 <code>NSURLCache</code> 的 <code>+sharedURLCache</code> 这个单例对象，这与 <code>NSURLConnection</code> 是相同的。</li>\n<li><code>requestCachePolicy</code> : 指定了一个请求的缓存响应应该在什么时候返回。这相当于 <code>NSURLRequest</code> 的 <code>-cachePolicy</code> 方法。</li>\n</ol>\n<h5 id=\"自定义协议\"><a href=\"#自定义协议\" class=\"headerlink\" title=\"自定义协议\"></a>自定义协议</h5><ol>\n<li><code>protocolClasses</code>: 用来配置特定某个 session 所使用的自定义协议（该协议是 <code>NSURLProtocol</code> 的子类）的数组。</li>\n</ol>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>iOS 7 和 Mac OS X 10.9 Mavericks 中 URL 加载系统的变化，是对 <code>NSURLConnection</code> 进行深思熟虑后的一个自然而然的进化。总体而言，苹果的 Foundation 框架团队干了一件令人钦佩的的工作，他们研究并预测了移动开发者现有的和新兴的用例，创造了能够满足日常任务而且非常好用的 API 。</p>\n<p>尽管在这个体系结构中，某些决定对于可组合性和可扩展性而言是一种倒退，但是 <code>NSURLSession</code> 仍然是实现更高级别网络功能的一个强大的基础框架。</p>\n<hr>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"API","path":"api/categories/API.json"}],"tags":[]},{"title":"WKWebView控件和JS脚本传参及交互","slug":"iOS/WKWebView控件和JS脚本传参及交互","date":"2017-07-07T09:54:41.000Z","updated":"2017-09-09T08:07:47.000Z","comments":true,"path":"api/articles/iOS/WKWebView控件和JS脚本传参及交互.json","excerpt":null,"keywords":null,"cover":"http://www.plantuml.com/plantuml/svg/XLPjJzjM5FxkNt55f2O19rAtRnv2cfYg3THr6jloOR3AYI_1O6paE6HexKGfwLBUaa61bVSEA6YZZ0eDQ4B8d_6z3f_w5tQkhvqub6ht0_ZQvzpddESyvznOggLXbEXDuEGFAiwHnRcUllhq6jqu4b9Ojx29Xh2iO5Emoy_g1xlsvGufJf65RQVq36pjyfvTNgGRPL8u4x2kUBP2k9qlvBojaDqJ-iS2FNn5DbUHzpuiXDcNhLaffScPZ2WdCvOffonHPP23SWgBiguRbcofXYvYFJiA7lNZslNgCTdUbYAng7FmX6uy5oEXg5tRf3DxOkJNA9dB-wyxeYH_14zXYEMEkrWeJcMQb0fUAB3tdhZ17O0W-JVEmRndjdDEBelIruQ2nMznofBrj8R5UuO66OhtJ7aKYzsQaLN4BsHBJieP71R6vDI8dCQeJNtGnpXwiVtvDr-rTNPofwwkNmG4oqqPAEziiEvzOElXGqHNtj7JPGW2Dett7IYYAb5LLws4QWsvy5BAq0VLTDPqMPA2fkC66EDnMSlA5kwHn-M-bAcEMU0nEgPXPlwbh2iQDhdNOo4G63-r6Lnt42KGQIo6oDijEdd08et50l29tkyps0G_2nJ4_fc61bYeFNlRwq3gZSo3YVjvVnYfUrntvqVWMaYz_MIN9bbHE3ltSIO3rVEPqHd5jnWpC8zEBoJsDn2MWZMS1juXiDiEzkAAnUpABdGHZypZpqEvbIT9KHNG8LR7SSkn7uaYuzfuv7271ZBTchwUt24l3_sojQghpyYQAIof-Z387eh-dGfC31hcVLdLNUKzqBK9wJCF5qhYwzuV7QWfUHGoiHBK_N26smI5T9sVTwh7K9s0Z4PRICj8mncwi4-AkwGqtx0PCp8-2p2LwF99CwHmo5tk0DhxZPuUDhlU6qWRVvEJAxjQSruSIZ1gCBAhB0e9SVkGlyA2-zKonf0n2DeMwB_5-a41sBClAdPrYSqzn4oudQccXoncoVi8XTAcF240Y5rU81k7dFf4BrqzUtyvT_tdD9dPgLUhFYlmhdvynSXO_vsKZdhwUDBq8a_cbsyW9GtBCaOP56y4wMwS5alsrNhZLByUT6dUhcxqwv_48O87tVR56tfU0HCEugnD1r7UNwxvVeqlG7g__caSQ27vVQvR8BA563y32TLFdaAwVFxrwoYdwegHY-TmSaIruZVA6W-KDHuePuJNCmh-_Cc-AAiAlpE08r9Tegli9k9Od4nkoEa3SpshQJTAudUc56mzo9VElgQ5lrefPvLOE2V5bPu-kFIk9nU138v09Y_xTI2Ih6y1F939xUh_x3U-mvbUel6aeKo07BlSvSelV-gSLiZw5IdEr6jR32qeq2vlkRSHiwpFJ3bJxvoZrrBaKLVKgHpGvpKnqXvbLrIXXCI84Qq_MOETY4Z-pAwiXCIVnSTYX_WJWkETSirrZSMYv9Zj42GMYSUZzPThi0iBYTwsksseFVOZQzI1668xBbt96nDkKgYpXKiTQQe-WaAv8HNaU4FKRZVd-Eq1h84SeIXqyvLTEMjAMF3wWo6dJOnrmFPqJ7SkIEqfZ0Dm05o1Zp9an3GyQFbnDlJMQCSFP0--YTx_TUCI2lZmADp0abeM3pHbG_QccV9TdP322UGMSFEjKEUZE4TCQZ0N1-8mCoJKQ9ecW1yO6n0G6SzIuZtMEDN_5JPe06cca3GciCcKiZNBgEHl_mC0","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"WebKit简介\"><a href=\"#WebKit简介\" class=\"headerlink\" title=\"WebKit简介\"></a>WebKit简介</h3><div id=\"badge-container-huos3203-WKWebView-JS-d03bc0e\" class=\"hexo-github\" style=\"width: =\"></div>\n<script src=\"/hexo-github/badge.js\"></script>\n<script type=\"text/javascript\">\n  loadStyle(\"/hexo-github/style.css\");\n  loadStyle(\"/hexo-github/octicons/octicons.css\");\n  new Badge(\"#badge-container-huos3203-WKWebView-JS-d03bc0e\", \"huos3203\", \"WKWebView-JS\", \"d03bc0e\", false);\n</script>\n\n<p>自iOS8 以后，苹果推出了新框架 WebKit，提供了替换 UIWebView 的组件 WKWebView。各种 UIWebView 的性能问题没有了，速度更快了，占用内存少了，体验更好了，下面列举一些其它的优势:<br>1、在性能、稳定性、功能方面有很大提升（加载速度，内存的提升谁用谁知道）<br>2、更多的支持 HTML5 的特性<br>3、官方宣称的高达60fps的滚动刷新率以及内置手势<br>4、Safari 相同的 JavaScript 引擎<br>5、将 UIWebViewDelegate 与 UIWebView 拆分成了14类与3个协议，包含该更细节功能的实现。</p>\n<p><img src=\"http://www.plantuml.com/plantuml/svg/XLPjJzjM5FxkNt55f2O19rAtRnv2cfYg3THr6jloOR3AYI_1O6paE6HexKGfwLBUaa61bVSEA6YZZ0eDQ4B8d_6z3f_w5tQkhvqub6ht0_ZQvzpddESyvznOggLXbEXDuEGFAiwHnRcUllhq6jqu4b9Ojx29Xh2iO5Emoy_g1xlsvGufJf65RQVq36pjyfvTNgGRPL8u4x2kUBP2k9qlvBojaDqJ-iS2FNn5DbUHzpuiXDcNhLaffScPZ2WdCvOffonHPP23SWgBiguRbcofXYvYFJiA7lNZslNgCTdUbYAng7FmX6uy5oEXg5tRf3DxOkJNA9dB-wyxeYH_14zXYEMEkrWeJcMQb0fUAB3tdhZ17O0W-JVEmRndjdDEBelIruQ2nMznofBrj8R5UuO66OhtJ7aKYzsQaLN4BsHBJieP71R6vDI8dCQeJNtGnpXwiVtvDr-rTNPofwwkNmG4oqqPAEziiEvzOElXGqHNtj7JPGW2Dett7IYYAb5LLws4QWsvy5BAq0VLTDPqMPA2fkC66EDnMSlA5kwHn-M-bAcEMU0nEgPXPlwbh2iQDhdNOo4G63-r6Lnt42KGQIo6oDijEdd08et50l29tkyps0G_2nJ4_fc61bYeFNlRwq3gZSo3YVjvVnYfUrntvqVWMaYz_MIN9bbHE3ltSIO3rVEPqHd5jnWpC8zEBoJsDn2MWZMS1juXiDiEzkAAnUpABdGHZypZpqEvbIT9KHNG8LR7SSkn7uaYuzfuv7271ZBTchwUt24l3_sojQghpyYQAIof-Z387eh-dGfC31hcVLdLNUKzqBK9wJCF5qhYwzuV7QWfUHGoiHBK_N26smI5T9sVTwh7K9s0Z4PRICj8mncwi4-AkwGqtx0PCp8-2p2LwF99CwHmo5tk0DhxZPuUDhlU6qWRVvEJAxjQSruSIZ1gCBAhB0e9SVkGlyA2-zKonf0n2DeMwB_5-a41sBClAdPrYSqzn4oudQccXoncoVi8XTAcF240Y5rU81k7dFf4BrqzUtyvT_tdD9dPgLUhFYlmhdvynSXO_vsKZdhwUDBq8a_cbsyW9GtBCaOP56y4wMwS5alsrNhZLByUT6dUhcxqwv_48O87tVR56tfU0HCEugnD1r7UNwxvVeqlG7g__caSQ27vVQvR8BA563y32TLFdaAwVFxrwoYdwegHY-TmSaIruZVA6W-KDHuePuJNCmh-_Cc-AAiAlpE08r9Tegli9k9Od4nkoEa3SpshQJTAudUc56mzo9VElgQ5lrefPvLOE2V5bPu-kFIk9nU138v09Y_xTI2Ih6y1F939xUh_x3U-mvbUel6aeKo07BlSvSelV-gSLiZw5IdEr6jR32qeq2vlkRSHiwpFJ3bJxvoZrrBaKLVKgHpGvpKnqXvbLrIXXCI84Qq_MOETY4Z-pAwiXCIVnSTYX_WJWkETSirrZSMYv9Zj42GMYSUZzPThi0iBYTwsksseFVOZQzI1668xBbt96nDkKgYpXKiTQQe-WaAv8HNaU4FKRZVd-Eq1h84SeIXqyvLTEMjAMF3wWo6dJOnrmFPqJ7SkIEqfZ0Dm05o1Zp9an3GyQFbnDlJMQCSFP0--YTx_TUCI2lZmADp0abeM3pHbG_QccV9TdP322UGMSFEjKEUZE4TCQZ0N1-8mCoJKQ9ecW1yO6n0G6SzIuZtMEDN_5JPe06cca3GciCcKiZNBgEHl_mC0\"></p>\n<h4 id=\"添加监听代理和JS接口\"><a href=\"#添加监听代理和JS接口\" class=\"headerlink\" title=\"添加监听代理和JS接口\"></a>添加监听代理和JS接口</h4><p>在OC中添加监听的接口清单：以JS脚本的接口<code>showMobile</code>为例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">WKWebViewConfiguration</span> *config = [[<span class=\"built_in\">WKWebViewConfiguration</span> alloc] init];</span><br><span class=\"line\"><span class=\"built_in\">WKUserContentController</span> *userCC = config.userContentController;</span><br><span class=\"line\"><span class=\"comment\">//MARK:在OC中添加监听的接口清单：JS脚本的接口名</span></span><br><span class=\"line\">[userCC addScriptMessageHandler:<span class=\"keyword\">self</span> name:<span class=\"string\">@\"showMobile\"</span>];</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"设置WKUserContentController的代理\"><a href=\"#设置WKUserContentController的代理\" class=\"headerlink\" title=\"设置WKUserContentController的代理\"></a>设置WKUserContentController的代理</h4><ol>\n<li><p>设置代理类遵守<code>WKScriptMessageHandler</code>协议</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> () &lt;<span class=\"title\">WKScriptMessageHandler</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注册对JS接口监听，注入代理类</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[userCC addScriptMessageHandler:<span class=\"keyword\">self</span> name:<span class=\"string\">@\"showMobile\"</span>];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>实现<code>WKUserContentController</code>代理的回调方法,响应JS接口事件</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)userContentController:(<span class=\"built_in\">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class=\"built_in\">WKScriptMessage</span> *)message &#123;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,message.body);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"JS脚本接口\"><a href=\"#JS脚本接口\" class=\"headerlink\" title=\"JS脚本接口\"></a>JS脚本接口</h4><p>js接口声明格式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.webkit.messageHandlers.接口名.postMessage(<span class=\"string\">'参数'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>接口名: 在WKWebView中，当JS执行该接口时，OC会拦截预先监听的接口，并处理相关事件。</p>\n<p>参数：object类型，多个参数时需要封装为集合类型来实现多参传递。</p>\n<p>当OC拦截到该接口时，可以在<code>WKScriptMessageHandler</code>回调方法中的<code>WKScriptMessage</code>参数实例中获取该参数值: <code>message.body</code>。</p>\n<p>三个例子：</p>\n<ol>\n<li><p>JS无参调用OC<br><br>当无参调用OC时，参数必须为<code>null</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.webkit.messageHandlers.showMobile.postMessage(<span class=\"literal\">null</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>JS传参调用OC<br><br>传递单个参数时，直接写入即可，例如：<code>xiao黄</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.webkit.messageHandlers.showName.postMessage(<span class=\"string\">'xiao黄'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>传递多个参数时，需要封装为集合类型实现多参传递。<br><br>例如:当传递一个电话，一条信息，需要封装为<code>[&#39;13300001111&#39;,&#39;Go Climbing This Weekend !!!&#39;]</code><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.webkit.messageHandlers.showSendMsg.postMessage([<span class=\"string\">'13300001111'</span>, <span class=\"string\">'Go Climbing This Weekend !!!'</span>])</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"iOS原生API调用JS脚本\"><a href=\"#iOS原生API调用JS脚本\" class=\"headerlink\" title=\"iOS原生API调用JS脚本\"></a>iOS原生API调用JS脚本</h3><p>在网页加载完成之后调用JS代码才会执行，因为这个时候html页面已经注入到webView中并且可以响应到对应方法。<br><br>例如调用JS函数<code>alertMobile()</code>：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span>.wkWebView evaluateJavaScript:<span class=\"string\">@\"alertMobile()\"</span> completionHandler:^(<span class=\"keyword\">id</span> _Nullable response, <span class=\"built_in\">NSError</span> * _Nullable error) &#123;</span><br><span class=\"line\"><span class=\"comment\">//TODO</span></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ %@\"</span>,response,error);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"在OC中为JS定义属性-函数\"><a href=\"#在OC中为JS定义属性-函数\" class=\"headerlink\" title=\"在OC中为JS定义属性/函数\"></a>在OC中为JS定义属性/函数</h4><ul>\n<li>当注入的类型字符串类型时，必须用<code>&#39;&#39;</code>括起来。<br></li>\n<li>OC注入的参数为全局属性，在html中的JS脚本可以直接调用属性名来获取值。<br></li>\n</ul>\n<p>通过NSString形式，编写JS脚本，通过以下两种方式注入网页</p>\n<p>方式一：在初始化<code>WKWebView</code>时，通过配置<code>WKWebViewConfiguration&gt;userContentController</code>注入JS脚本  。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//MARK:向网页中注入JS脚本例如，参数/函数等</span></span><br><span class=\"line\"><span class=\"built_in\">WKUserScript</span> *script = [[<span class=\"built_in\">WKUserScript</span> alloc] initWithSource:<span class=\"string\">@\"var number=0;\"</span></span><br><span class=\"line\">injectionTime:<span class=\"built_in\">WKUserScriptInjectionTimeAtDocumentStart</span></span><br><span class=\"line\">forMainFrameOnly:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"><span class=\"built_in\">WKUserContentController</span> *userCC = config.userContentController;</span><br><span class=\"line\">[userCC addUserScript:script];</span><br></pre></td></tr></table></figure></p>\n<p>方式二：使用WKWebView实例方法<code>evaluateJavaScript</code>动态注入JS脚本</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span>.wkWebView evaluateJavaScript:<span class=\"string\">@\"var number=0;\"</span> completionHandler:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n<h4 id=\"iOS原生API调用JS函数\"><a href=\"#iOS原生API调用JS函数\" class=\"headerlink\" title=\"iOS原生API调用JS函数\"></a>iOS原生API调用JS函数</h4><p>使用WKWebView实例方法<code>evaluateJavaScript</code>动态调用JS函数<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span>.wkWebView evaluateJavaScript:<span class=\"string\">@\"alertSendMsg('18870707070','下午好！')\"</span> completionHandler:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"控件","path":"api/categories/控件.json"}],"tags":[]},{"title":"PBBReader阅读器解析","slug":"iOS/PBBReader阅读器解析","date":"2017-06-26T17:02:18.000Z","updated":"2017-06-26T17:12:47.000Z","comments":true,"path":"api/articles/iOS/PBBReader阅读器解析.json","excerpt":null,"keywords":null,"cover":"http://www.plantuml.com/plantuml/svg/ZLPRJnj757wVNp4A3zYWjPG-Rf0bBarbgG64I_iG8hIsnsRBiXlDZab95Oa4d3X02MeA936uGDh20w6G6uutc3-pisi_zI_qZ7TjVDbKzPDdvimvt_dcdEyiOYhJ2Awzo5N_jlZB8_VLCd-SgoqTkTPpfxZC2nMK93eZ5CyG9KKegXw-TeeRuoCttS89lzZyv_EQywBY_b66dTh-Xzhk0I9wohT5IKqnJNnJrSZtAhatREYC6ff6wC1ah7qZ-ZEI9CpFYixYeMijOqb2_R6XiInWOzWpndrtKsdnvmRgduoDAvaEdt3UjNS3IIPJA5FrJEV1z3JcJowSpLCHRdeQIJWK6nfCCjNGmsf26JACsJc5pffoQ38sb6NCq75Vs8JSwbxRZGLELIV_mpHE59gS6MAw759JJPi73QQ2yXfef1N4KOfe9ACm0foa5AR4ZInDYiKys4VIL9aJYmmnMPQI2P8qChfwdr2pE_r-LLTPA7m59PYtWQie0AUBmv3m4fvlkpB8Of3bJxB93BgGC1IQaaKUpiQE-_x0EThdkziY5IaqRm0b5B1w94qGCwknOKCpg1mQZSSP1JHrOiKfBEkyzVBSE_UTnSyUzQ9Wo3YYaJIBH0F9bUSCeB3wy1NVo4CUpYydJda31PPN91BjBcJPURhALoxjptkrnL-HRZ22uVMX66Pn3oKf6JihA-wb1PtXh1_o_4Ulm_nBvLNR-ZYbUvTTwsLh4uvxjMwNtY3K7HPVktuDzqctUn9QbjoHn388SmSWOGo8YikrnJr-KhGhgtQft0pgd5jyPSy3orT-hovTeFzaz7PFXYeBTu1OY1x0J7StYioR7BT34wvaR5ivzxSZkxpEyxlyS9MlRRd7ntPfqJdUzqH640Cwq-HfSmq41_IAdtmAf4cIebyePDalm8H2FVxvcstt-2-xz1P74VpgyAYQcM7OI7_11-wvDwCoeFHw10EJ_Zi_sx0hXMQUKph-AeATmdjdwzIB286Sam-rWvtgqxTU6C6cY1AGW2WYBEFMfEsIvGjjs-N0cfKnlBExVkf3symxnHtn2erQR3Gx-1zNg0dzpS__vBbpzymARkzKM7Ju3ogR4M17GL_QUZCDctfTTDfimVs8aPH3mzzu_x9pC58cI3gSCfB2T3G-IA40m466C30H6O25sQAC8B7VWiG63Gu1iocA07CqVYlBb8H6VAU6fyvVmnMLWC-kyxj47-kmQPaztmbJRm3vdfexmjTOuaUIP0Et5dmNxV16V7sEuhuhgNxGLAr2fHSrkQzNgv-dt1oppjOJP_zrTVsSFzloHgutcP5lYINem83smruX-bVgZOBQA-OgCBGV8Re_sc7AjiOHvR9NufTBNcNmjPmOy5XuwcYI1Y2lAqJjvGlSAhSYcDAzFkxuYF1SWzRnoZRFdpPr0ZM-FT86HAB8BZ-6cyBquZaOrVO_mNsV3W3bMVqB","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"支持OS-X浏览PDF简单视图\"><a href=\"#支持OS-X浏览PDF简单视图\" class=\"headerlink\" title=\"支持OS X浏览PDF简单视图\"></a>支持OS X浏览PDF简单视图</h2><p>运行scheme： <code>PDFReaderForOSX</code> 即可</p>\n<h2 id=\"支持iOS\"><a href=\"#支持iOS\" class=\"headerlink\" title=\"支持iOS\"></a>支持iOS</h2><p>pageViewController: pdf翻页效果视图控制器<br>startingViewController:DataViewController,翻页视图控制器的视图源<br>modelController:ModelController:NSObject,数据视图数据源的model模型。<br><img src=\"http://www.plantuml.com/plantuml/svg/ZLPRJnj757wVNp4A3zYWjPG-Rf0bBarbgG64I_iG8hIsnsRBiXlDZab95Oa4d3X02MeA936uGDh20w6G6uutc3-pisi_zI_qZ7TjVDbKzPDdvimvt_dcdEyiOYhJ2Awzo5N_jlZB8_VLCd-SgoqTkTPpfxZC2nMK93eZ5CyG9KKegXw-TeeRuoCttS89lzZyv_EQywBY_b66dTh-Xzhk0I9wohT5IKqnJNnJrSZtAhatREYC6ff6wC1ah7qZ-ZEI9CpFYixYeMijOqb2_R6XiInWOzWpndrtKsdnvmRgduoDAvaEdt3UjNS3IIPJA5FrJEV1z3JcJowSpLCHRdeQIJWK6nfCCjNGmsf26JACsJc5pffoQ38sb6NCq75Vs8JSwbxRZGLELIV_mpHE59gS6MAw759JJPi73QQ2yXfef1N4KOfe9ACm0foa5AR4ZInDYiKys4VIL9aJYmmnMPQI2P8qChfwdr2pE_r-LLTPA7m59PYtWQie0AUBmv3m4fvlkpB8Of3bJxB93BgGC1IQaaKUpiQE-_x0EThdkziY5IaqRm0b5B1w94qGCwknOKCpg1mQZSSP1JHrOiKfBEkyzVBSE_UTnSyUzQ9Wo3YYaJIBH0F9bUSCeB3wy1NVo4CUpYydJda31PPN91BjBcJPURhALoxjptkrnL-HRZ22uVMX66Pn3oKf6JihA-wb1PtXh1_o_4Ulm_nBvLNR-ZYbUvTTwsLh4uvxjMwNtY3K7HPVktuDzqctUn9QbjoHn388SmSWOGo8YikrnJr-KhGhgtQft0pgd5jyPSy3orT-hovTeFzaz7PFXYeBTu1OY1x0J7StYioR7BT34wvaR5ivzxSZkxpEyxlyS9MlRRd7ntPfqJdUzqH640Cwq-HfSmq41_IAdtmAf4cIebyePDalm8H2FVxvcstt-2-xz1P74VpgyAYQcM7OI7_11-wvDwCoeFHw10EJ_Zi_sx0hXMQUKph-AeATmdjdwzIB286Sam-rWvtgqxTU6C6cY1AGW2WYBEFMfEsIvGjjs-N0cfKnlBExVkf3symxnHtn2erQR3Gx-1zNg0dzpS__vBbpzymARkzKM7Ju3ogR4M17GL_QUZCDctfTTDfimVs8aPH3mzzu_x9pC58cI3gSCfB2T3G-IA40m466C30H6O25sQAC8B7VWiG63Gu1iocA07CqVYlBb8H6VAU6fyvVmnMLWC-kyxj47-kmQPaztmbJRm3vdfexmjTOuaUIP0Et5dmNxV16V7sEuhuhgNxGLAr2fHSrkQzNgv-dt1oppjOJP_zrTVsSFzloHgutcP5lYINem83smruX-bVgZOBQA-OgCBGV8Re_sc7AjiOHvR9NufTBNcNmjPmOy5XuwcYI1Y2lAqJjvGlSAhSYcDAzFkxuYF1SWzRnoZRFdpPr0ZM-FT86HAB8BZ-6cyBquZaOrVO_mNsV3W3bMVqB\"></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"}],"tags":[]},{"title":"CoreML机器学习初级教程","slug":"iOS/CoreML机器学习初级教程","date":"2017-06-24T22:10:44.000Z","updated":"2017-06-24T22:24:54.000Z","comments":true,"path":"api/articles/iOS/CoreML机器学习初级教程.json","excerpt":null,"keywords":null,"cover":"http://upload-images.jianshu.io/upload_images/861914-5425960c41207b82.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h3><p><a href=\"https://developer.apple.com/documentation/coreml\" target=\"_blank\" rel=\"noopener\">Core ML开发文档</a><br><a href=\"https://developer.apple.com/machine-learning/\" target=\"_blank\" rel=\"noopener\">ML模型资源页面</a><br>在Working with Models中包含有几个常用的模型模板，例如用于在图片中检测物体——树、动物、人等等。<br><a href=\"https://developer.apple.com/documentation/coreml/integrating_a_core_ml_model_into_your_app\" target=\"_blank\" rel=\"noopener\">Integrating a Core ML Model into Your App</a></p>\n<p><a href=\"https://docs-assets.developer.apple.com/published/51ff0c1668/IntegratingaCoreMLModelintoYourApp.zip\" target=\"_blank\" rel=\"noopener\">官方Core ML文档示例 App</a><br>MarsHabitatPricePredictor 模型的输入只是数字，因此代码直接使用生成的 MarsHabitatPricer 方法和属性，而不是将模型包装在 Vision 模型中。每次都改一下参数，很容易看出模型只是一个线性回归：<br>137 <em> solarPanels + 653.50 </em> greenHouses + 5854 * acres</p>\n<h3 id=\"配置-：将-Core-ML-模型集成到你的-App\"><a href=\"#配置-：将-Core-ML-模型集成到你的-App\" class=\"headerlink\" title=\"配置 ：将 Core ML 模型集成到你的 App\"></a>配置 ：将 Core ML 模型集成到你的 App</h3><p>本教程使用 Places205-GoogLeNet 模型，可以从苹果的<a href=\"https://developer.apple.com/machine-learning/\" target=\"_blank\" rel=\"noopener\">ML</a>页面下载。往下滑找到 Working with Models，下载第一个。还在这个页面，注意一下其它三个模型，它们都用于在图片中检测物体——树、动物、人等等。</p>\n<blockquote>\n<p>注意：如果你有一个训练过的模型，并且是使用受支持的机器学习工具训练的，例如 Caffe、Keras 或 scikit-learn，Converting Trained Models to Core ML 介绍了如何将其转换为 Core ML 格式。</p>\n</blockquote>\n<ol>\n<li>添加模型<br>下载 GoogLeNetPlaces.mlmodel 后，把它从 Finder 拖到项目导航器的 Resources 组里：<br><img src=\"http://upload-images.jianshu.io/upload_images/861914-5425960c41207b82.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n<li>生成模型类<br>选择该文件，然后等一会儿。Xcode 生成了模型类后会显示一个箭头：<br><img src=\"http://upload-images.jianshu.io/upload_images/861914-e00a802f64f0ae13.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n<li>查看模型类<br>点击箭头，查看生成的类：<br><img src=\"http://upload-images.jianshu.io/upload_images/861914-1268b5b918fccf07.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>三个类：<br><code>GoogLeNetPlaces</code>: 主类，包含一个 model 属性和两个 prediction 方法<br><code>GoogLeNetPlacesInput</code>: 输入类,包含一个 CVPixelBuffer 类型的 sceneImage 属性，Vision 框架会负责把我们熟悉的图片格式转换成正确的输入类型。<br><code>GoogLeNetPlacesOutput</code>：输出属性,Vision 框架会将 <code>GoogLeNetPlacesOutput</code> 属性转换为自己的 <code>results</code> 类型.</li>\n</ol>\n<h3 id=\"实现Vision工作流程\"><a href=\"#实现Vision工作流程\" class=\"headerlink\" title=\"实现Vision工作流程\"></a>实现Vision工作流程</h3><p>标准的 Vision 工作流程是创建模型，创建一或多个请求，然后创建并运行请求处理程序。<br>并管理对 <code>prediction</code>方法的调用，所以在所有生成的代码中，我们只会使用 <code>model</code> 属性。</p>\n<ol>\n<li><p>创建模型：在 <code>Vision Model</code> 中包装 <code>Core ML Model</code><br>CoreML模型 是用于 Vision 请求的 Core ML 模型的容器<br>打开 ViewController.swift，并在 import UIKit 下面 import 两个框架：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> CoreML</span><br><span class=\"line\"><span class=\"keyword\">import</span> Vision</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建<code>VNCoreMLRequest</code>图像分析请求<br><code>VNCoreMLRequest</code> 是一个图像分析请求，它使用 Core ML 模型来完成工作。它的 completion handler 接收 request 和 error 对象。<br>Core ML 模型<code>GoogLeNetPlaces</code> 是一个分类器，因为它仅预测一个特征：图像的场景分类。这时request.results 是 <code>VNClassificationObservation</code> 对象数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建一个带有 completion handler 的 Vision 请求</span><br><span class=\"line\">let request = VNCoreMLRequest(model: model) &#123; [weak self] request, error in</span><br><span class=\"line\">    guard let results = request.results as? [VNClassificationObservation],</span><br><span class=\"line\">    let topResult = results.first else &#123;</span><br><span class=\"line\">    fatalError(&quot;unexpected result type from VNCoreMLRequest&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 在主线程上更新 UI</span><br><span class=\"line\">let article = (self?.vowels.contains(topResult.identifier.first!))! ? &quot;an&quot; : &quot;a&quot;</span><br><span class=\"line\">    DispatchQueue.main.async &#123; [weak self] in</span><br><span class=\"line\">        self?.answerLabel.text = &quot;\\(Int(topResult.confidence * 100))% it&apos;s \\(article) \\(topResult.identifier)&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>VNClassificationObservation 有两个属性：identifier - 一个 String，以及 confidence - 介于0和1之间的数字，这个数字是是分类正确的概率。使用对象检测模型时，你可能只会看到那些 confidence 大于某个阈值的对象，例如 30％ 的阈值。<br>然后取第一个结果，它会具有最高的 confidence 值，然后根据 identifier 的首字母把不定冠词设置为“a”或“an”。最后，dispatch 回到主线程来更新 label。你很快会明白分类工作为什么不在主线程，因为它会很慢。</p>\n<h3 id=\"创建并运行VNImageRequestHandler请求处理程序\"><a href=\"#创建并运行VNImageRequestHandler请求处理程序\" class=\"headerlink\" title=\"创建并运行VNImageRequestHandler请求处理程序\"></a>创建并运行VNImageRequestHandler请求处理程序</h3><p><code>VNImageRequestHandler</code> 是标准的 Vision 框架请求处理程序；不特定于 Core ML 模型。给它 image 作为 detectScene(image:) 的参数。然后调用它的 perform 方法来运行处理程序，传入请求数组。在这个例子里，我们只有一个请求。<br>把下面几行添加到 <code>detectScene(image:)</code> 的末尾：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在主线程上运行 Core ML GoogLeNetPlaces 分类器</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> handler = <span class=\"type\">VNImageRequestHandler</span>(ciImage: image)</span><br><span class=\"line\"><span class=\"type\">DispatchQueue</span>.global(qos: .userInteractive).async &#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> handler.perform([request])</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用模型来自动识别场景\"><a href=\"#使用模型来自动识别场景\" class=\"headerlink\" title=\"使用模型来自动识别场景\"></a>使用模型来自动识别场景</h3><p>在两个地方调用 <code>detectScene(image:)</code><br>把下面几行添加到 viewDidLoad() 的末端和 imagePickerController(_:didFinishPickingMediaWithInfo:) 的末端：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">guard let ciImage = CIImage(image: image) else &#123;</span><br><span class=\"line\">    fatalError(&quot;couldn&apos;t convert UIImage to CIImage&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">detectScene(image: ciImage)</span><br></pre></td></tr></table></figure></p>\n<p>现在构建并运行。</p>\n<ol>\n<li>场景一:<br>机器识别出了50%的概率是摩天大厦<br><img src=\"http://upload-images.jianshu.io/upload_images/861914-bb5bec38118f91ff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n<li>场景二<br>机器人识别出了75%的概率是水族池<br><img src=\"http://upload-images.jianshu.io/upload_images/861914-e194482f995324a1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n</ol>\n<h3 id=\"什么是深度学习\"><a href=\"#什么是深度学习\" class=\"headerlink\" title=\"什么是深度学习\"></a>什么是深度学习</h3><p>自20世纪50年代以来，AI 研究人员开发了许多机器学习方法。苹果的 Core ML 框架支持神经网络、树组合、支持向量机、广义线性模型、特征工程和流水线模型。但是，神经网络最近已经取得了很多极为神奇的成功，开始于 2012 年谷歌使用 YouTube 视频训练 AI 来识别猫和人。仅仅五年后，谷歌正在赞助一场确定 5000 种植物和动物的比赛。像 Siri 和 Alexa 这样的 App 也存在它们自己的神经网络。<br>神经网络尝试用节点层来模拟人脑流程，并将节点层用不同的方式连接在一起。每增加一层都需要增加大量计算能力：Inception v3，一个对象识别模型，有48层以及大约2000万个参数。但计算基本上都是矩阵乘法，GPU 来处理会非常有效。GPU 成本的下降使我们能够创建多层深度神经网络，此为深度学习。<br>神经网络，circa 2016<br>神经网络需要大量的训练数据，这些训练数据理想化地代表了全部可能性。用户生成的数据爆炸性地产生也促成了机器学习的复兴。<br>训练模型意味着给神经网络提供训练数据，并让它计算公式，此公式组合输入参数以产生输出。训练是离线的，通常在具有多个 GPU 的机器上。<br>要使用这个模型，就给它新的输入，它就会计算输出：这叫做推论。推论仍然需要大量计算，以从新的输入计算输出。因为有了 Metal 这样的框架，现在可以在手持设备上进行这些计算。<br>在本教程的结尾你会发现，深度学习远非完美。真的很难建立具有代表性的训练数据，很容易就会过度训练模型，以至于它会过度重视一些古怪的特征。<br>苹果提供了什么？<br>苹果在 iOS 5 里引入了 NSLinguisticTagger 来分析自然语言。iOS 8 出了 Metal，提供了对设备 GPU 的底层访问。<br>去年，苹果在 Accelerate 框架添加了 Basic Neural Network Subroutines (BNNS)，使开发者可以构建用于推理（不是训练）的神经网络。<br>今年，苹果给了我们 Core ML 和 Vision！<br>Core ML 让我们更容易在 App 中使用训练过的模型。<br>Vision 让我们轻松访问苹果的模型，用于面部检测、面部特征点、文字、矩形、条形码和物体。<br>你还可以在 Vision 模型中包装任意的图像分析 Core ML 模型，我们在这篇教程中就干这个。由于这两个框架是基于 Metal 构建的，它们能在设备上高效运行，所以不需要把用户的数据发送到服务器。</p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"API","path":"api/categories/API.json"}],"tags":[]},{"title":"iOS11ARKit初探","slug":"iOS/iOS11ARKit初探","date":"2017-06-24T19:46:59.000Z","updated":"2017-06-24T22:24:54.000Z","comments":true,"path":"api/articles/iOS/iOS11ARKit初探.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"iOS11新技术\"><a href=\"#iOS11新技术\" class=\"headerlink\" title=\"iOS11新技术\"></a>iOS11新技术</h2><h3 id=\"ARKit教程\"><a href=\"#ARKit教程\" class=\"headerlink\" title=\"ARKit教程\"></a>ARKit教程</h3><p>增强现实(AR)描述用户体验，将2D或3D元素从设备的摄像头中添加到实时视图中，从而使这些元素出现在真实世界中。ARKit结合了设备运动跟踪，摄像镜头捕捉，先进的场景处理，以及显示方便来简化建立AR体验的任务。<br><a href=\"https://developer.apple.com/documentation/arkit\" target=\"_blank\" rel=\"noopener\">ARKit开发文档</a></p>\n<h4 id=\"理解-Augmented-Reality\"><a href=\"#理解-Augmented-Reality\" class=\"headerlink\" title=\"理解 Augmented Reality\"></a>理解 Augmented Reality</h4><p>理解AR概念、特性和最佳实践来构建很好的AR体验，<br><code>ARSession</code>：一个共享对象，可以管理增强现实体验所需的设备摄像头和运动处理。</p>\n<h4 id=\"AR相关配置\"><a href=\"#AR相关配置\" class=\"headerlink\" title=\"AR相关配置\"></a>AR相关配置</h4><p><code>ARSessionConfiguration</code>:只记录设备方向的轨迹的基本配置<br><code>ARWorldTrackingSessionConfiguration</code>:一种跟踪设备定位和位置的配置，它可以检测设备摄像头看到的真实表面。</p>\n<h4 id=\"AR标准视图\"><a href=\"#AR标准视图\" class=\"headerlink\" title=\"AR标准视图\"></a>AR标准视图</h4><p><a href=\"https://developer.apple.com/documentation/arkit/building_a_basic_ar_experience\" target=\"_blank\" rel=\"noopener\">一个基本的AR体验DEMO</a><br>配置一个AR会话并使用SceneKit或SpriteKit来显示AR内容</p>\n<ol>\n<li><a href=\"https://developer.apple.com/documentation/arkit/arscnview/providing_3d_virtual_content_with_scenekit\" target=\"_blank\" rel=\"noopener\">Providing 3D Virtual Content with SceneKit</a><br> <code>ARSCNView</code>:一种显示AR体验的视图，它通过3D SceneKit内容增强了相机视图。</li>\n<li><a href=\"https://developer.apple.com/documentation/arkit/arskview/providing_2d_virtual_content_with_spritekit\" target=\"_blank\" rel=\"noopener\">Providing 2D Virtual Content with SpriteKit</a><br> <code>ARSKView</code>:一种显示AR体验的视图，增加了2D SpriteKit内容的摄像头视图。</li>\n</ol>\n<p>借助 ARKit 和 Core ML，基于 iOS 11 进行开发。<br>iOS 11 为开发者带来了各种可能性。借助 ARKit，开发者可将生动逼真的增强现实带到 app 之中。而有了 Core ML，开发者可利用机器学习来创建各种更智能的 app。<br><a href=\"https://developer.apple.com/cn/ios/\" target=\"_blank\" rel=\"noopener\">进一步了解基于 iOS 11 的开发</a></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"API","path":"api/categories/API.json"}],"tags":[]},{"title":"UIStackView教程：了解Stack View","slug":"iOS/UIStackView教程了解StackView","date":"2017-02-24T18:12:14.000Z","updated":"2017-02-25T14:33:14.000Z","comments":true,"path":"api/articles/iOS/UIStackView教程了解StackView.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><a href=\"http://blog.csdn.net/kmyhy/article/details/50456444\" target=\"_blank\" rel=\"noopener\">原地址</a></p>\n<h2 id=\"UIStackView简单介绍\"><a href=\"#UIStackView简单介绍\" class=\"headerlink\" title=\"UIStackView简单介绍\"></a>UIStackView简单介绍</h2><p>一个Stack View能够将它所含的View以各种方式沿其轴向进行分布，同时也可以将View沿某个方向等距分布，要隐藏<code>Stack View</code>中的视图，你只需要设置该View的<code>Hidden</code>属性为<code>true</code>，剩下的工作Stack View会自己完成。。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0.png?imageMogr2/2/w/800\"><br>坐标（Axis）、间隔（Spacing）、对齐（Alignment）以及分布（Distribution ）等。<br>distribution属性：决定Stack View如何沿它轴向的水平方向摆放它的subview，当属性值是Fill，这表示subview会沿轴向完全占据Stack View。因此，Stack View会拉伸其中一个subview使其填充剩余空间，尤其是水平内容优先级最低的那个，如果所有subview优先级相同，则拉伸第一个subview。<br>Alignment属性：决定了Stack View如何沿它轴向的垂直方向摆放它的subview，对于一个垂直的Stack View，这个属性可以设置为Fill、Leading、Center和Trailing。<br>对于水平的Stack View，这个属性则稍有不同：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack006.png?imageMogr2/2/w/800\"><br>.Top取代了.Leading，.Bottom取代了.Trailing。此外，水平Stack View还多出了两个属性值：.FirstBaseLine和.LastBaseLine。<br>对于水平的Stack View，这个属性则稍有不同：<br>Fill:<br><img title=\"Fill\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack007.png?imageMogr2/2/w/800\"><br>Leading:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack008.png?imageMogr2/2/w/800\"><br>Center:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack009.png?imageMogr2/2/w/800\"><br>Trailing:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack000.png?imageMogr2/2/w/800\"></p>\n<p>布局方式对比<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack01.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"添加一个新的Stack-View\"><a href=\"#添加一个新的Stack-View\" class=\"headerlink\" title=\"添加一个新的Stack View\"></a>添加一个新的Stack View</h3><p>点击故事板画布左下角<code>Auto Layout工具栏</code>中的<code>Stack按钮</code>：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack3.png?imageMogr2/2/w/800\"><br>另一种解散的方法是选中Stack View，然后点击<code>Editor\\Emebed in\\stack view</code>菜单。</p>\n<h3 id=\"解散一个废弃的Stack-View\"><a href=\"#解散一个废弃的Stack-View\" class=\"headerlink\" title=\"解散一个废弃的Stack View\"></a>解散一个废弃的Stack View</h3><p>首先，选定想解散的Stack View。按下<code>Option键</code>，点击<code>Stack 按钮</code>。这将弹出一个上下文菜单，然后点击Unembed：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack001.png?imageMogr2/2/w/800\"><br>另一种解散的方法是选中Stack View，然后点击<code>Editor\\Unemebed</code>菜单。</p>\n<h2 id=\"使用场景描述\"><a href=\"#使用场景描述\" class=\"headerlink\" title=\"使用场景描述\"></a>使用场景描述</h2><p>当APP运行中增加或删除一个<code>view</code>时，需要重新调整邻近<code>view</code>的位置布局。<br>预见困境：</p>\n<ol>\n<li>在故事板中新建一些布局约束连接，以便能够安装或卸载其中的一些约束</li>\n<li>使用第三方库来实现</li>\n<li>根据任务复杂程度完全用代码实现<br>也许这个在视图附近的视图树中的所有View都不需要在运行时改变，但当你将新视图添加到故事板时，仍然要想方设法为它挤出空间来。</li>\n</ol>\n<p><code>UIStackView</code>提供了一个对多个视图进行水平或垂直布局的方法。通过对几个属性进行简单设置，比如对齐、分布和间距，可以让我们让其所包含的视图适应于其有效空间。</p>\n<h2 id=\"实现需求\"><a href=\"#实现需求\" class=\"headerlink\" title=\"实现需求\"></a>实现需求</h2><p>存在着这几方面的问题:</p>\n<h3 id=\"问题一：自适应横竖屏\"><a href=\"#问题一：自适应横竖屏\" class=\"headerlink\" title=\"问题一：自适应横竖屏\"></a>问题一：自适应横竖屏</h3><p>在横屏状态下（command+左箭头旋转为横屏），发现截图中的一排按钮位置无法适应屏幕宽度的变化。这时可以使用<code>UIStackView</code>来帮助实现自动适应横竖屏的效果。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/UIStackView.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"问题二：控件间留白不紧凑\"><a href=\"#问题二：控件间留白不紧凑\" class=\"headerlink\" title=\"问题二：控件间留白不紧凑\"></a>问题二：控件间留白不紧凑</h3><p>点击WEATHER旁边的Hide按钮。隐藏了下面的文本内容后，留下了一大块的空白区域。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/WEATHERhide.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"Storyboard引入界面\"><a href=\"#Storyboard引入界面\" class=\"headerlink\" title=\"Storyboard引入界面\"></a>Storyboard引入界面</h3><p>打开<code>Main.storyboard</code>，找到<code>Spot Info View Controller</code>这个Scene。将这些标签和按钮设为不同的背景色，是为了在运行时效果更直观。就是在故事板中，这也有助于看到<code>Stack View</code>属性的改变导致其内部视图的变化。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack1.png?imageMogr2/2/w/800\"><br>如果想在运行App时看见这些颜色，在<code>SpotInfoViewController</code>的<code>viewDidLoad()</code>方法中将下列语句注释：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 清空标签和按钮的背景色</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> view <span class=\"keyword\">in</span> backgroundColoredViews </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    view.backgroundColor = <span class=\"type\">UIColor</span>.clearColor()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Size类便于使用storyboard\"><a href=\"#Size类便于使用storyboard\" class=\"headerlink\" title=\"Size类便于使用storyboard\"></a>Size类便于使用storyboard</h3><p>在本案例中，故事板中Scene大小不是默认<code>600x600</code>，在这里Simulated Metrics下的Size属性被设置成iPhone 4-inch。Simulated Metrics属性在运行时并没有任何影响——不同设备上视图的大小仍然会自动改变。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/05-simulated-metrics-iphone-4-inch_639x173.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"创建水平UIStackView\"><a href=\"#创建水平UIStackView\" class=\"headerlink\" title=\"创建水平UIStackView\"></a>创建水平<code>UIStackView</code></h2><h3 id=\"按钮模块\"><a href=\"#按钮模块\" class=\"headerlink\" title=\"按钮模块\"></a>按钮模块</h3><ol>\n<li>选中按钮<br>用<code>Command+左键</code>同时选中<code>Spot Info View Controller</code>底下一排的所有按钮：<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack2.png?imageMogr2/2/w/800\"></li>\n<li>Stack按钮添加一个新的Stack View<br>点击故事板画布左下角<code>Auto Layout工具栏</code>中新增的<code>Stack按钮</code>：    </li>\n</ol>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/Stack按钮?imageMogr2/2/w/800\">\n<p>这些按钮被嵌到一个新的Stack View中：</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack4.png?imageMogr2/2/w/800\">\n<h4 id=\"给新的Stack-View添加布局约束\"><a href=\"#给新的Stack-View添加布局约束\" class=\"headerlink\" title=\"给新的Stack View添加布局约束\"></a>给新的Stack View添加布局约束</h4><p>要在故事板选取一个充满了子视图的Stack View还是比较难的，介绍两种选择技巧。<br>3.1 在<code>Outline视图</code>中选取Stack View</p>\n<img title=\"Outline视图\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack5.png?imageMogr2/2/w/800\">\n<p>3.2 Shift+右键调出View树<br>在Stack View 的任意地方按下<code>Shift+右键</code>或者<code>Control+Shift+左键</code>（如果你正在用触控板的话）。这时将弹出一个上下文菜单，列出了位于所点击的地方的View树，你可以在这个菜单中选择Stack View。</p>\n<img title=\"Shift+右键\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack6.png?imageMogr2/2/w/800\">\n<ol>\n<li>自动布局工具栏中的Pin按钮,添加一个约束<img title=\"自动布局工具栏中的Pin按钮\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack7.png?imageMogr2/2/w/800\">\n</li>\n</ol>\n<p>首先勾选Constrain to margins。然后在Stack View四周添加下列约束：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Top</span>: <span class=\"number\">20</span>, <span class=\"type\">Leading</span>: <span class=\"number\">0</span>, <span class=\"type\">Trailing</span>: <span class=\"number\">0</span>, <span class=\"type\">Bottom</span>: <span class=\"number\">0</span></span><br></pre></td></tr></table></figure><br>仔细检查top、leading、trailing、bottom中的数字并确保它们的I型柱都被选中。然后点击Add 4 Constraints：<br><img title=\"Add4Constraints\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack8.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"按钮等间距分布\"><a href=\"#按钮等间距分布\" class=\"headerlink\" title=\"按钮等间距分布\"></a>按钮等间距分布</h4><p>添加约束后，导致第一个按钮被拉伸：<br><img title=\"第一个按钮被拉伸填充所有剩余空间\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack9.png?imageMogr2/2/w/800\"></p>\n<h5 id=\"使用等宽约束的Spacer-View实现\"><a href=\"#使用等宽约束的Spacer-View实现\" class=\"headerlink\" title=\"使用等宽约束的Spacer View实现\"></a>使用等宽约束的<code>Spacer View</code>实现</h5><p>解决这个问题只能使用空白的View来分隔这些按钮，在按钮之间摆放上一些用于分隔空间的 Spacer View。所有的Spacer View都要添加等宽约束，以及许多额外的约束，才能将这些Spacer View布局正确。<br>这看起来如下图所示。为了直观起见，这些Spacer View的背景色设置成了浅灰色：<br><img title=\"SpacerView添加等宽约束实现\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack04.png?imageMogr2/2/w/800\"><br>如果要在运行时添加一个按钮或者隐藏/删除一个按钮时，要想调整这些Spacer View和约束就要命了。</p>\n<h5 id=\"Distribution属性：沿轴向水平分布\"><a href=\"#Distribution属性：沿轴向水平分布\" class=\"headerlink\" title=\"Distribution属性：沿轴向水平分布\"></a><code>Distribution</code>属性：沿轴向水平分布</h5><p>distribution属性：决定Stack View如何将它的subview沿轴向分布，当属性值是Fill，这表示subview会沿轴向完全占据Stack View。因此，Stack View会拉伸其中一个subview使其填充剩余空间，尤其是水平内容优先级最低的那个，如果所有subview优先级相同，则拉伸第一个subview。<br>打开Stack View属性面板。将<code>Distribution</code>属性由<code>Fill</code>修改为<code>Equal Spacing</code>：<br><img title=\"`Fill`修改为`Equal\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack02.png?imageMogr2/2/w/800\"><br>编译运行，点击某个单元格，旋转模拟器（⌘→）。你将看到最下一排按钮现在按照等间距排列了！<br><img title=\"`Distribution`属性值`Equal\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack03.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"Rating版块\"><a href=\"#Rating版块\" class=\"headerlink\" title=\"Rating版块\"></a>Rating版块</h3><p>选中RATING标签，以及旁边的显示为几个星形图标的标签：<br><img title=\"选中RATING标签\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack05.png?imageMogr2/2/w/800\"><br>然后点击Stack按钮将它们嵌到一个Stack View中：<br><img title=\"Stack按钮\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack3.png?imageMogr2/2/w/800\"><br><img title=\"RATING标签嵌到一个StackView中\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack06.png?imageMogr2/2/w/800\"><br>然后点击Pin按钮。勾选Constrain to margins，并添加如下约束：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Top</span>: <span class=\"number\">20</span>, <span class=\"type\">Leading</span>: <span class=\"number\">0</span>, <span class=\"type\">Bottom</span>: <span class=\"number\">20</span></span><br></pre></td></tr></table></figure><br><img title=\"添加约束\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack07.png?imageMogr2/2/w/800\"><br>打开属性面板，将间距设置为8：<br><img title=\"间距设置为8\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack08.png?imageMogr2/2/w/800\"><br>你可能会看到一个 Misplaced Views的布局约束警告，同时星星标签会显示将会被拉伸到视图之外：<br><img title=\"MisplacedViews的布局约束警告\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack09.png?imageMogr2/2/w/800\"><br>有时候Xcode会临时提示一些警告，或者显示Stack View的位置不正确，这些警告会在你添加其他约束后消失。你完全可以忽略这些警告。<br>要解决这个警告，我们可以修改一下Stack View的Frame然后又改回，或者临时修改它的一条布局约束。<br>让我们试一下。先将Alignment 属性从Fill修改为Top，然后又改回原来的Fill。你将看到这下星星标签显示正常了：<br><img title=\"布局约束警告消失\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack00.png?imageMogr2/2/w/800\"><br>编译运行，进行测试</p>\n<h2 id=\"创建垂直的Stack-View\"><a href=\"#创建垂直的Stack-View\" class=\"headerlink\" title=\"创建垂直的Stack View\"></a>创建垂直的Stack View</h2><p>Xcode会自动根据这两者的位置推断出这将是一个垂直的Stack View，Stack View没有添加任何约束时，会自动适应了两个标签中的最宽的一个的宽度。</p>\n<h3 id=\"WHY-VISIT模块\"><a href=\"#WHY-VISIT模块\" class=\"headerlink\" title=\"WHY VISIT模块\"></a>WHY VISIT模块</h3><p>选中WHY VISIT标签及下面的标签,创建一个垂直的Stack View：<br><img title=\"选中WHY\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack002.png?imageMogr2/2/w/800\"><br>点击Stack 按钮将二者嵌到一个Stack View：<br><img title=\"嵌到一个垂直的StackView\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack003.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"添加约束\"><a href=\"#添加约束\" class=\"headerlink\" title=\"添加约束\"></a>添加约束</h4><p>默认，约束是相对于距离最近的对象，对于Bottom约束来说就是距离它15像素的Hide按钮。但我们其实是想让约束相对于WEATHER标签。<br>选中Stack View，点击Pin按钮。勾选Constrain to margins，设置Top、Leading、Trainling为0。<br>然后，点击Bottom右边的下拉按钮，从列表中选择WEATHER（curent distance =20）：<br><img title=\"Top、Leading、Trainling为0\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack004.png?imageMogr2/2/w/800\"><br>最后点击Add 4 Constraints按钮。显示结果如下图所示：<br><img title=\"Top、Leading、Trainling为0\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack005.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"alignment属性：轴向的垂直方向\"><a href=\"#alignment属性：轴向的垂直方向\" class=\"headerlink\" title=\"alignment属性：轴向的垂直方向\"></a>alignment属性：轴向的垂直方向</h4><p>Stack View问题，它的右边对齐于View的右边。但是底下的标签仍然是原来的宽度。需要使用alignment属性解决这个问题。<br>当你测试完所有Alignment值的布局效果后，将Alignment修改为Fill：<br><img title=\"Top、Leading、Trainling为0\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0001.png?imageMogr2/2/w/800\"><br>将<code>Alignment</code>设置为<code>Fill</code>，表示所有View将沿与Stack View轴向垂直的方向进行全占式分布。这会让WHY VISIT标签扩展它的宽度到100%.</p>\n<p>如果我们只想让底下的标签将宽度扩展到100%怎么办？</p>\n<p>这个问题现在看来还不是多大的问题，因为两个标签在运行时的背景色都是透明的。但对于Weather版块来说就不同了。</p>\n<p>我们将用另外一个Stack View来说明这个问题。</p>\n<h2 id=\"垂直／水平Stack-View嵌套使用\"><a href=\"#垂直／水平Stack-View嵌套使用\" class=\"headerlink\" title=\"垂直／水平Stack View嵌套使用\"></a>垂直／水平Stack View嵌套使用</h2><h3 id=\"Weather版块\"><a href=\"#Weather版块\" class=\"headerlink\" title=\"Weather版块\"></a>Weather版块</h3><p>在Weather版块相对复杂一些，因为它多了一个Hide按钮。<br>要隐藏<code>Stack View</code>中的视图，你只需要设置该View的<code>Hidden</code>属性为<code>true</code>，剩下的工作Stack View会自己完成。这也是我们解决用户隐藏WEATHER标签下文本的主要思路。<br>一种方法是使用嵌套的Stack View，先将WEATHER标签和Hide按钮嵌到一个水平StackView，再将这个Stack View和标签嵌到一个垂直Stack View。<br><img title=\"垂直/水平StackView嵌套使用\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0002.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"垂直stackView\"><a href=\"#垂直stackView\" class=\"headerlink\" title=\"垂直stackView\"></a>垂直stackView</h4><p>注意Alignment属性负责Stack View轴向垂直的方向上的布局。所以，我们需要将Alignment属性设置为 Bottom：<br><img title=\"垂直/水平StackView嵌套使用\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0003.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"水平StackView中出现按钮拉伸标签的问题\"><a href=\"#水平StackView中出现按钮拉伸标签的问题\" class=\"headerlink\" title=\"水平StackView中出现按钮拉伸标签的问题\"></a>水平StackView中出现按钮拉伸标签的问题</h4><p>注意，WEATHER标签被拉伸为和Hide按钮一样高了。这并不合适，因为这会导致WEATHER标签和下面的文本之间多出了一些空间。<br>正确的方法是让 Hide 按钮不要和 Weather 版块呆在同一个Stack View中，或者任何别的Stack View中。<br>这样，在顶层View中还会保留一个subview，你将为它添加一个相对于WEATHER标签的约束——WEATHER标签嵌在Stack View里的。也就是说，你要为位于Stack View之外的按钮加一个约束，这个约束是相对于Stack View内的一个标签！</p>\n<h4 id=\"垂直stack-View1-嵌套WEATHER标签和标签\"><a href=\"#垂直stack-View1-嵌套WEATHER标签和标签\" class=\"headerlink\" title=\"垂直stack View1:嵌套WEATHER标签和标签\"></a>垂直stack View1:嵌套WEATHER标签和标签</h4><p>选中WEATHER标签和标签：<br><img title=\"选中嵌套标签\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0004.png?imageMogr2/2/w/800\"><br>点击 Stack 按钮：<br><img title=\"Stack按钮创建stackView\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0005.png?imageMogr2/2/w/800\"><br>点击Pin 按钮，勾上Constrain to margins，然后添加如下约束：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Top</span>: <span class=\"number\">20</span>, <span class=\"type\">Leading</span>: <span class=\"number\">0</span>, <span class=\"type\">Trailing</span>: <span class=\"number\">0</span>, <span class=\"type\">Bottom</span>: <span class=\"number\">20</span></span><br></pre></td></tr></table></figure><br>将Stack View的Alignment设为Fill：<br><img title=\"Alignment设为Fill\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0006.png?imageMogr2/2/w/800\"><br>我们需要在 Hide 按钮左边和WEATHER标签右边加一条约束，这样WEATHER 标签的宽度就不会拉满整个Stack View了。</p>\n<p>当然，底下的标签宽度还是需要100%占满的。</p>\n<p>我们是通过将WEATHER标签嵌到一个垂直Stack View 来实现的。注意，垂直Stack View的Alignment 属性可以设置为 .Leading，如果将Stack View拉宽，则它里面的View 会保持左对齐。</p>\n<h4 id=\"垂直stack-View2-仅嵌套WEATHER标签\"><a href=\"#垂直stack-View2-仅嵌套WEATHER标签\" class=\"headerlink\" title=\"垂直stack View2: 仅嵌套WEATHER标签\"></a>垂直stack View2: 仅嵌套WEATHER标签</h4><p>从Outline视图中选取WEATHER 标签，或者用Control+Shift+左键的方式选取WEATHER 标签：<br><img title=\"Stack按钮创建stackView\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0006.png?imageMogr2/2/w/800\"><br>然后点击Stack 按钮：<br><img title=\"Stack按钮创建stackView\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0007.png?imageMogr2/2/w/800\"><br>确保Axis 为 Vertical 的情况下，将Alignment 设置为 Leading：<br><img title=\"Alignment设置为Leading\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0008.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"按钮和WEATHER标签两个约束\"><a href=\"#按钮和WEATHER标签两个约束\" class=\"headerlink\" title=\"按钮和WEATHER标签两个约束\"></a>按钮和WEATHER标签两个约束</h4><p>从Hide 按钮用右键拖一条新的约束到 WEATHER 标签：<br><img title=\"AddConstraints\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0009.png?imageMogr2/2/w/800\"><br>按下Shift键，同时选择Horizontal Spacing 和 Baseline。然后点击 Add Constraints：<br><img title=\"AddConstraints\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0000.png?imageMogr2/2/w/800\"><br>编译运行。Hide 按钮的位置现在对了，而且当按下Hide 按钮，位于Stack View 中的标签被隐藏后，下面的视图也会被调整——根本不需要我们进行手动调整。<br><img title=\"编译运行\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack010.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"顶级-Stack-View\"><a href=\"#顶级-Stack-View\" class=\"headerlink\" title=\"顶级 Stack View\"></a>顶级 Stack View</h2><p>在Outline 视图中，用Command+左键选择5个最顶级的 Stack View：<br><img title=\"选中视图\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack011.png?imageMogr2/2/w/800\"><br>然后点击 Stack 按钮：<br><img title=\"Stack按钮\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack012.png?imageMogr2/2/w/800\"><br>点击Pin 按钮，勾上 Constrain to margins，将 4 个边的约束都设为0。然后将Spacing 设置为20，Alignment 设为 Fill。现在故事板会是这个样子：<br><img title=\"添加约束\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack013.png?imageMogr2/2/w/800\"><br>编译运行：<br><img title=\"编译运行\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack014.png?imageMogr2/2/w/800\"><br>噢！这个 Hide 按钮又失去了它 的约束！因为包含 WEATHER 标签的Stack View的外边又套了一层 Stack View。这不是什么大问题，就像之前你做过的那样，再重新为它添加约束就是了。</p>\n<p>右键从Hide 按钮拖一条约束到 WEATHER标签，按下 Shift 键，同时选择 Horizontal Spacing 和 Baseline。然后点击 Add Constraints：<br><img title=\"AddConstraints\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack015.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"重新调整视图位置\"><a href=\"#重新调整视图位置\" class=\"headerlink\" title=\"重新调整视图位置\"></a>重新调整视图位置</h2><p>现在，所有的版块都被嵌到一个顶级的 Stack View中了，我们想修改一下 what to see版块的位置，让它位于 weather 版块之后。</p>\n<p>从 Outline 视图中选择中间的的 Stack View，然后将它拖到第一、二个 Stack View 之间。<br>注意：让箭头稍微偏向你正在拖的Stack View左边一点，以便它能够作为外层 Stack View 的 subview 添加。蓝色的小圆圈应当位于两个 Stack View 之间的左端而不是右端：<br><img title=\"调整视图位置\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack016.png?imageMogr2/2/w/800\"></p>\n<p>现在，weather版块是从上到下的第三个版块，由于 Hide 按钮它并不是 Stack View的subview，所以它不会参与移动，它的frame当前是不正确的。</p>\n<p>点击 Hide 按钮，选中它：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack017.png?imageMogr2/2/w/800\"></p>\n<p>然后点击自动布局工具栏中的 Resolve Auto Layout Issues 按钮，选择 Update Frames：<br><img title=\"Update\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack018.png?imageMogr2/2/w/800\"><br>现在 Hide 按钮将回到正确的位置：<br><img title=\"UpdateHide按钮\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack019.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"基于配置的-Size-类\"><a href=\"#基于配置的-Size-类\" class=\"headerlink\" title=\"基于配置的 Size 类\"></a>基于配置的 Size 类</h2><p>最后还有一个任务没有完成。在横屏模式，垂直空间是比较珍贵的，你想将这些版块之间靠得更近一些。要实现这个，你需要判断当垂直Size类为compact时，将顶层 Stack View的 Spacing属性由 20 改成 10.</p>\n<p>选择顶层 Stack View，点击 Spacing 前面的+按钮：<br><img title=\"前面的+按钮Spacing\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack020.png?imageMogr2/2/w/800\"></p>\n<p>选择 Any Width &gt; Compact Height：<br><img title=\"CompactHeight\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack021.png?imageMogr2/2/w/800\"></p>\n<p>在新出现的 wAny hC 一栏中，将 Spacing 设为 10：<br><img title=\"Spacing设为10\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack022.png?imageMogr2/2/w/800\"><br>编译运行。在竖屏模式下Spacing不会改变。旋转模拟器（⌘←），你会看到各版块之间的间距减少了，现在底部按钮之间的空间也变大了：<br><img title=\"编译运行\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack023.png?imageMogr2/2/w/800\"><br>如果你没有添加最外层的 Stack View，你仍然可以使用 Size 类将每个版块之间的垂直间距设置为 10，但这就不是仅仅设置一个地方就能够办到的了。</p>\n<h2 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h2><p>现在，在隐藏和显示天气信息时仍然会觉得有一些突兀。你将增加一个动画使这个转换变得更平滑。</p>\n<p>Stack View完全支持 <code>UIView 动画</code>。也就是说要以动画方式显示/隐藏它所包含的subview，只需要简单地在一个动画块中切换它的 hidden 属性。</p>\n<p>让我们来看看代码怎么实现。打开 <code>SpotInfoViewController.Swift</code>，找到<br><code>updateWeatherInfoViews(hideWeatherInfo:animated:)</code>方法。</p>\n<p>将方法的最后一行：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br></pre></td></tr></table></figure><br>替换为：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> animated </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">UIView</span>.animateWithDuration(<span class=\"number\">0.3</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">else</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>编译运行，点击Hide 按钮或 Show 按钮。是不是加入动画之后看起来要好得多呢？</p>\n<p>除了对 Stack View 中的视图以动画的方式设置 hidden 属性，你也可以对 Stack View 自身的属性使用 UIView 动画，例如 Alignment 属性、 Distribution 属性、 Spacing 属性和 Axis 属性。<br><a href=\"http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Starter.zip\" target=\"_blank\" rel=\"noopener\">开始项目源码</a><br><a href=\"http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Complete.zip\" target=\"_blank\" rel=\"noopener\">完整项目源码</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2>","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"控件","path":"api/categories/控件.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"}]},{"title":"CFBundleDisplayName更改APP启动图标的名称","slug":"iOS/更改设备屏幕上显示的应用程序图标下方的名称","date":"2017-02-24T14:23:59.000Z","updated":"2017-05-26T18:13:13.000Z","comments":true,"path":"api/articles/iOS/更改设备屏幕上显示的应用程序图标下方的名称.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/qa1823_ExpandAppInProjectNavigator.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>修改APP启动图标上的名称，需配置<code>Info.plist</code>文件，增加<code>CFBundleDisplayName</code>属性键值对。<br>进入到如下界面：<br><!--长宽设置百分比大小无效果--><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/qa1823_ExpandAppInProjectNavigator.png?imageMogr2/2/w/800\"></p>\n<p>在<code>Info.plist</code>文件属性列表中搜索”Bundle display name”，如果存在就修改为新APP名称。<br>如果不存在，在任何一个属性条目下，点击”+”按钮，弹出的下拉列表中选择”Bundle display name”，再双击”Bundle display name”属性值列，输入新APP名称。<br><!--长宽设置百分比大小无效果--><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/qa1823_WatchKitAppInfoPane.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"agvtool自动增加版本号命令行工具\"><a href=\"#agvtool自动增加版本号命令行工具\" class=\"headerlink\" title=\"agvtool自动增加版本号命令行工具\"></a>agvtool自动增加版本号命令行工具</h2><p>版本号和编译号分别是代表了正式发布版本和内部版本， agvtool 是一个自动增加版本号的命令行工具。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/QA1827_AppStoreBuildNumber.png?imageMogr2/2/w/800\"><br>注意：版本号是给用户看的，用于标明当前的发行版本，并且被存储在 App 的 Info.plist 文件的 CFBundleShortVersionString (Bundle versions string, short) 中。编译号是内部使用的，用于标明未发行或者已内部发行的应用程序，并且它被存储在 Info.plist 文件的 CFBundleVersion (Bundle version) 中。</p>\n<p>注意：如果应用程序包含了多个目标（target）， agvtool 工具将会把所有目标都设置为同一个版本号和编译号。</p>\n<h3 id=\"设置-Current-Project-Version-为选定的值\"><a href=\"#设置-Current-Project-Version-为选定的值\" class=\"headerlink\" title=\"设置 Current Project Version 为选定的值\"></a>设置 Current Project Version 为选定的值</h3><p>Xcode 工程文件 project.pbxproj 包含了 CURRENT_PROJECT_VERSION (Current Project Version) 编译设定，这个编译设定指定了当前工程的版本。<br>agvtool 会搜索此编译选项。如果这个值存在就运行，否则不运行，这个值用来更新编译号。</p>\n<h3 id=\"设置-Versioning-System-为-Apple-Generic\"><a href=\"#设置-Versioning-System-为-Apple-Generic\" class=\"headerlink\" title=\"设置 Versioning System 为 Apple Generic\"></a>设置 Versioning System 为 Apple Generic</h3><p>默认情况下苹果不使用任何版本系统，设置为 Apple Generic 确保 Xcode 包含全部的 agvtool 生成的版本信息。</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/QA1827_Versioning.png?imageMogr2/2/w/800\">\n<p>注意： Current Project Version 的值必须是整数或者浮点数，新工程最好设置为1。</p>\n<h3 id=\"设置版本和编译号\"><a href=\"#设置版本和编译号\" class=\"headerlink\" title=\"设置版本和编译号\"></a>设置版本和编译号</h3><p>agvtool 从 Info.plist 文件搜索版本和编译号。如果存在就更新，不存在就不执行。<br>确保 CFBundleVersion (Bundle version) 和 CFBundleShortVersionString (Bundle versions string, short) 存在。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/QA1827_InfoPaneInXcode.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"版本号命令\"><a href=\"#版本号命令\" class=\"headerlink\" title=\"版本号命令\"></a>版本号命令</h3><p>退出 Xcode，在终端下进入到包含 .xcodeproj 工程文件的目录， .xcodeproj 文件包含了 project.pbxproj 文件。</p>\n<ol>\n<li><p>查看版本号：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">agvtool what-marketing-version</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新版本号</p>\n</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">agvtool new-marketing-version &lt;指定的版本号&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"编译号命令\"><a href=\"#编译号命令\" class=\"headerlink\" title=\"编译号命令\"></a>编译号命令</h3><ol>\n<li><p>将编译号设置为指定版本</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">agvtool new-version -all &lt;指定的版本号&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新编译号</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">agvtool next-version -all</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看当前编译号</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">agvtool what-version</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"配置","path":"api/categories/配置.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"经历","path":"api/tags/经历.json"},{"name":"配置","path":"api/tags/配置.json"}]},{"title":"自定义展示型控制器","slug":"自定义展示型控制器","date":"2017-02-17T12:26:11.000Z","updated":"2018-04-24T11:49:45.000Z","comments":true,"path":"api/articles/自定义展示型控制器.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/semi-transparent.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><div id=\"badge-container-huos3203-PresentationsDemo-2cce4c908\" class=\"hexo-github\" style=\"width: =\"></div>\n<script src=\"/hexo-github/badge.js\"></script>\n<script type=\"text/javascript\">\n  loadStyle(\"/hexo-github/style.css\");\n  loadStyle(\"/hexo-github/octicons/octicons.css\");\n  new Badge(\"#badge-container-huos3203-PresentationsDemo-2cce4c908\", \"huos3203\", \"PresentationsDemo\", \"2cce4c908\", false);\n</script>\n\n<h2 id=\"触发转场的方式\"><a href=\"#触发转场的方式\" class=\"headerlink\" title=\"触发转场的方式\"></a>触发转场的方式</h2><h3 id=\"官方支持的自定义转场\"><a href=\"#官方支持的自定义转场\" class=\"headerlink\" title=\"官方支持的自定义转场\"></a>官方支持的自定义转场</h3><ul>\n<li>在 <code>UINavigationController</code> 中 <code>push</code> 和 <code>pop</code>;</li>\n<li>在 <code>UITabBarController</code> 中切换 <code>Tab</code>;</li>\n<li>Modal 转场：<code>presentation</code> 和 <code>dismissal</code>，俗称视图控制器的模态显示和消失，仅限于<code>modalPresentationStyle</code>属性为 <code>UIModalPresentationFullScreen</code> 或 <code>UIModalPresentationCustom</code> 这两种模式;<br><code>UICollectionViewController</code> 的布局转场：仅限于 <code>UICollectionViewController</code> 与 <code>UINavigationController</code> 结合的转场方式，与上面三种都有点不同，不过实现很简单，可跳转至该链接查看。<br>官方的支持包含了 iOS 中的大部分转场方式，还有一种自定义容器中的转场并没有得到系统的直接支持，不过借助协议这种灵活的方式，我们依然能够实现对自定义容器控制器转场的定制，在压轴环节我们将实现这一点。<h3 id=\"相关触发转场的动作\"><a href=\"#相关触发转场的动作\" class=\"headerlink\" title=\"相关触发转场的动作\"></a>相关触发转场的动作</h3><h4 id=\"UINavigationController\"><a href=\"#UINavigationController\" class=\"headerlink\" title=\"UINavigationController\"></a>UINavigationController</h4><code>UINavigationController</code> 中所有修改其<code>viewControllers</code>栈中 <code>VC</code> 的方法都可以自定义转场动画：<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//我们使用的最广泛的 push 和 pop 方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pushViewController</span><span class=\"params\">(<span class=\"number\">_</span> viewController: UIViewController, animated animated: Bool)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">popViewControllerAnimated</span><span class=\"params\">(<span class=\"number\">_</span> animated: Bool)</span></span> -&gt; <span class=\"type\">UIViewController</span>?</span><br><span class=\"line\"><span class=\"comment\">//不怎么常用的 pop 方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">popToRootViewControllerAnimated</span><span class=\"params\">(<span class=\"number\">_</span> animated: Bool)</span></span> -&gt; [<span class=\"type\">UIViewController</span>]?</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">popToRootViewControllerAnimated</span><span class=\"params\">(<span class=\"number\">_</span> animated: Bool)</span></span> -&gt; [<span class=\"type\">UIViewController</span>]?</span><br><span class=\"line\"><span class=\"comment\">//这个方法有有点特别，是对 VC 栈的整体更新，开启动画后的执行比较复杂，具体参考文档说明。不建议在这种情况下开启转场动画。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setViewControllers</span><span class=\"params\">(<span class=\"number\">_</span> viewControllers: [UIViewController], animated animated: Bool)</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"UITabBarController\"><a href=\"#UITabBarController\" class=\"headerlink\" title=\"UITabBarController\"></a>UITabBarController</h4><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注意传递的参数必须是其下的子 VC</span></span><br><span class=\"line\"><span class=\"keyword\">unowned</span>(unsafe) <span class=\"keyword\">var</span> selectedViewController: <span class=\"type\">UIViewController</span>?</span><br><span class=\"line\"><span class=\"keyword\">var</span> selectedIndex: <span class=\"type\">Int</span></span><br><span class=\"line\"><span class=\"comment\">//和上面类似的整体更新</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setViewControllers</span><span class=\"params\">(<span class=\"number\">_</span> viewControllers: [UIViewController]?, animated animated: Bool)</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Modal-转场：\"><a href=\"#Modal-转场：\" class=\"headerlink\" title=\"Modal 转场：\"></a>Modal 转场：</h4><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Presentation 转场</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentViewController</span><span class=\"params\">(<span class=\"number\">_</span> viewControllerToPresent: UIViewController, animated flag: Bool, completion completion: <span class=\"params\">(<span class=\"params\">()</span></span></span></span> -&gt; <span class=\"type\">Void</span>)?)</span><br><span class=\"line\"><span class=\"comment\">// Dismissal 转场</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dismissViewControllerAnimated</span><span class=\"params\">(<span class=\"number\">_</span> flag: Bool, completion completion: <span class=\"params\">(<span class=\"params\">()</span></span></span></span> -&gt; <span class=\"type\">Void</span>)?)</span><br></pre></td></tr></table></figure>\n<h4 id=\"Segue\"><a href=\"#Segue\" class=\"headerlink\" title=\"Segue\"></a>Segue</h4>在 <code>storyboard</code> 里设置 <code>segue</code>有两种方式：<code>Button to VC</code>，这种在点击 <code>Button</code> 的时候触发转场；<code>VC to VC</code>，这种需要在代码中调用<code>performSegueWithIdentifier:sender:</code>。<code>prepareForSegue:sender:</code>方法是在转场发生前修改转场参数的最后机会。这点对于 <code>Modal</code> 转场比较重要，因为在 <code>storyboard</code>里 <code>Modal</code> 转场的 <code>Segue</code> 类型不支持选择 <code>Custom</code> 模式，使用 <code>segue</code> 方式触发时必须在<code>prepareForSegue:sender:</code>里修改模式。</li>\n</ul>\n<h4 id=\"iOS-8-的变化\"><a href=\"#iOS-8-的变化\" class=\"headerlink\" title=\"iOS 8 的变化\"></a>iOS 8 的变化</h4><p>iOS 8 引入了适应性布局，由此添加了两种新的方式来显示一个视图控制器：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">showViewController</span><span class=\"params\">(<span class=\"number\">_</span> vc: UIViewController, sender sender: AnyObject?)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">showDetailViewController</span><span class=\"params\">(<span class=\"number\">_</span> vc: UIViewController, sender sender: AnyObject?)</span></span></span><br></pre></td></tr></table></figure><br>这两个方法咋看上去是给 <code>UISplitViewController</code> 用的，在 <code>storyboard</code> 里 <code>segue</code> 的候选模式里，直接给出了<code>Show(e.g. Push)</code>和<code>Show Detail(e.g. Replace)</code>这样的提示，以至于我之前一直对这两个 segue 有误解。实际上这两个方法智能判断当前的显示环境来决定如何显示，iOS 8 想统一显示视图控制器的方式，不过引入这两个方法增加了使用的复杂性，来看看这两个方法的使用规则。<br>这两个方法在 <code>UISplitViewController</code> 上的确是按名字显示的那样去工作的，而在本文关注的控制器上是这样工作的：<br>|  |ViewController|NavigationController|TabBarController|<br>|:——-|:——-|:——–|:——–|<br>|showViewController:sender: |Presentation| Push | Presentation(by self) |<br>|showDetailViewController:sender: |Presentation| Presentation(by self) | Presentation(by self)|<br><code>UINavigationController</code> 重写了<code>showViewController:sender:</code>而执行 <code>push</code> 操作，上面的<code>by self</code>意思是用容器 <code>VC</code> 本身而非其下子 <code>VC</code> 去执行 <code>presentation</code>。这两个方法的行为可以通过重写来改变。<br>当非容器类 VC 内嵌在这两种容器 VC 里时，会通过最近的容器 VC 来执行：<br>||VC in NavigationController|VC in TabBarController|<br>|:——-|:——-|:——–|<br>|showViewController:sender: |Push(by NavigationController)| Presentation(by TabBarController) |<br>|showDetailViewController:sender: |Presentation(by NavigationController)| Presentation(by TabBarController) |</p>\n<h3 id=\"转场五大工具\"><a href=\"#转场五大工具\" class=\"headerlink\" title=\"转场五大工具\"></a>转场五大工具</h3><p>iOS 7 以协议的方式开放了自定义转场的 API，协议的好处是不再拘泥于具体的某个类，只要是遵守该协议的对象都能参与转场，非常灵活。转场协议由5种协议组成，在实际中只需要我们提供其中的两个或三个便能实现绝大部分的转场动画：</p>\n<h4 id=\"转场代理-Transition-Delegate-：\"><a href=\"#转场代理-Transition-Delegate-：\" class=\"headerlink\" title=\"转场代理(Transition Delegate)：\"></a>转场代理(Transition Delegate)：</h4><p>有如下三种容器转场代理，对应上面三种类型的转场：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"type\">UINavigationControllerDelegate</span>&gt; <span class=\"comment\">//UINavigationController 的 delegate 属性遵守该协议。</span></span><br><span class=\"line\">&lt;<span class=\"type\">UITabBarControllerDelegate</span>&gt; <span class=\"comment\">//UITabBarController 的 delegate 属性遵守该协议。</span></span><br><span class=\"line\">&lt;<span class=\"type\">UIViewControllerTransitioningDelegate</span>&gt; <span class=\"comment\">//UIViewController 的 transitioningDelegate 属性遵守该协议。</span></span><br></pre></td></tr></table></figure><br>这里除了<uiviewcontrollertransitioningdelegate>是 iOS 7 新增的协议，其他两种在 iOS 2 里就存在了，在 iOS 7 时扩充了这两种协议来支持自定义转场。</uiviewcontrollertransitioningdelegate></p>\n<h4 id=\"动画控制器-Animation-Controller-：\"><a href=\"#动画控制器-Animation-Controller-：\" class=\"headerlink\" title=\"动画控制器(Animation Controller)：\"></a>动画控制器(Animation Controller)：</h4><p>最重要的部分，负责添加视图以及执行动画；遵守<uiviewcontrolleranimatedtransitioning>协议；由我们实现。</uiviewcontrolleranimatedtransitioning></p>\n<h4 id=\"交互控制器-Interaction-Controller-：\"><a href=\"#交互控制器-Interaction-Controller-：\" class=\"headerlink\" title=\"交互控制器(Interaction Controller)：\"></a>交互控制器(Interaction Controller)：</h4><p>通过交互手段，通常是手势来驱动动画控制器实现的动画，使得用户能够控制整个过程；遵守<uiviewcontrollerinteractivetransitioning>协议；系统已经打包好现成的类供我们使用。</uiviewcontrollerinteractivetransitioning></p>\n<h4 id=\"转场环境-Transition-Context\"><a href=\"#转场环境-Transition-Context\" class=\"headerlink\" title=\"转场环境(Transition Context):\"></a>转场环境(Transition Context):</h4><p>提供转场中需要的数据；遵守<uiviewcontrollercontexttransitioning>协议；由 UIKit 在转场开始前生成并提供给我们提交的动画控制器和交互控制器使用。</uiviewcontrollercontexttransitioning></p>\n<h4 id=\"转场协调器-Transition-Coordinator-：\"><a href=\"#转场协调器-Transition-Coordinator-：\" class=\"headerlink\" title=\"转场协调器(Transition Coordinator)：\"></a>转场协调器(Transition Coordinator)：</h4><p>可在转场动画发生的同时并行执行其他的动画，其作用与其说协调不如说辅助，主要在 Modal 转场和交互转场取消时使用，其他时候很少用到；遵守<uiviewcontrollertransitioncoordinator>协议；由 UIKit 在转场时生成，UIViewController 在 iOS 7 中新增了方法transitionCoordinator()返回一个遵守该协议的对象，且该方法只在该控制器处于转场过程中才返回一个此类对象，不参与转场时返回 nil。</uiviewcontrollertransitioncoordinator></p>\n<p>总结下，5个协议只需要我们操心3个；实现一个最低限度可用的转场动画，我们只需要提供上面五个组件里的两个：转场代理和动画控制器即可，还有一个转场环境是必需的，不过这由系统提供；当进一步实现交互转场时，还需要我们提供交互控制器，也有现成的类供我们使用。</p>\n<h2 id=\"特殊的-Modal-转场\"><a href=\"#特殊的-Modal-转场\" class=\"headerlink\" title=\"特殊的 Modal 转场\"></a>特殊的 Modal 转场</h2><p>容器类 VC 的转场里 <code>fromView</code> 和 <code>toView</code> 是 <code>containerView</code> 的子层次的视图，而 Modal 转场里 <code>presentingView</code> 与 <code>containerView</code> 是同层次的视图，只有 <code>presentedView</code> 是 <code>containerView</code> 的子层次视图。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/semi-transparent.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"iOS-8引入的UIPresentationController\"><a href=\"#iOS-8引入的UIPresentationController\" class=\"headerlink\" title=\"iOS 8引入的UIPresentationController\"></a>iOS 8引入的UIPresentationController</h3><p><code>UIPresentationController</code>类，该类接管了 <code>UIViewController</code> 的显示过程，为其提供转场和视图管理支持。在 iOS 8.0 以上的系统里，你可以在 <code>presentation</code> 转场结束后打印视图控制器的结构，会发现 <code>presentedVC</code> 是由一个<code>UIPresentationController</code>对象来显示的，查看视图结构也能看到 <code>presentedView</code> 是 <code>UIView</code> 私有子类的<code>UITtansitionView</code>的子视图，这就是前面 <code>containerView</code> 的真面目.<br>当<code>UIViewController</code>的<code>modalPresentationStyle</code>属性为<code>.Custom</code>时(不支持.FullScreen)，我们有机会通过控制器的转场代理提供<code>UIPresentationController</code>的子类对 <code>Modal 转场</code>进行进一步的定制。实际上该类也可以在<code>.FullScreen</code>模式下使用，但是会丢失由该类负责的动画，保险起见还是遵循官方的建议，只在<code>.Custom</code>模式下使用该类。<br><code>UIPresentationController</code>类赋予 Modal 转场以下特性：</p>\n<ol>\n<li>定制 <code>presentedView</code> 的外观，尺寸以及在 <code>containerView</code> 中添加自定义视图并为这些视图添加动画；</li>\n<li>可以选择是否移除 <code>presentingView</code></li>\n<li>可以在不需要动画控制器的情况下单独工作</li>\n<li>iOS 8 中的自适应适应性布局<br><code>UIPresentationController</code>类提供了如下的方法参与转场，对转场过程实现了更加细致的控制，从命名便可以看出与动画控制器里的<code>animateTransition:</code>的关系：<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationTransitionWillBegin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationTransitionDidEnd</span><span class=\"params\">(<span class=\"number\">_</span> completed: Bool)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dismissalTransitionWillBegin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dismissalTransitionDidEnd</span><span class=\"params\">(<span class=\"number\">_</span> completed: Bool)</span></span></span><br></pre></td></tr></table></figure>\n除了 presentingView，UIPresentationController类拥有转场过程中剩下的角色：<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//指定初始化方法。</span></span><br><span class=\"line\"><span class=\"keyword\">init</span>(presentedViewController presentedViewController: <span class=\"type\">UIViewController</span>, presentingViewController presentingViewController: <span class=\"type\">UIViewController</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> presentingViewController: <span class=\"type\">UIViewController</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> presentedViewController: <span class=\"type\">UIViewController</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> containerView: <span class=\"type\">UIView</span>? &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"><span class=\"comment\">//提供给动画控制器使用的视图，默认返回 presentedVC.view，通过重写该方法返回其他视图，但一定要是 presentedVC.view 的上层视图。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentedView</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">UIView</span>?    </span><br></pre></td></tr></table></figure>\n没有 <code>presentingView</code> 是因为 <code>Custom</code> 模式下 <code>presentingView</code> 不受 <code>containerView</code> 管理，<code>UIPresentationController</code>类并没有改变这一点。iOS 8 扩充了转场环境协议，可以通过<code>viewForKey:</code>方便获取转场的视图，而该方法在 <code>Modal</code> 转场中获取的是<code>presentedView()</code>返回的视图。因此我们可以在子类中将 <code>presentedView</code> 包装在其他视图后重写该方法返回包装后的视图当做 <code>presentedView</code> 在动画控制器中使用。</li>\n</ol>\n<h3 id=\"定制presentedView\"><a href=\"#定制presentedView\" class=\"headerlink\" title=\"定制presentedView\"></a>定制presentedView</h3><h4 id=\"外观：重载size方法和frameOfPresentedViewInContainerView属性\"><a href=\"#外观：重载size方法和frameOfPresentedViewInContainerView属性\" class=\"headerlink\" title=\"外观：重载size方法和frameOfPresentedViewInContainerView属性\"></a>外观：重载size方法和frameOfPresentedViewInContainerView属性</h4><p>重载存储属性：get方法返回登场页面的位置和大小<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">var</span> frameOfPresentedViewInContainerView: <span class=\"type\">CGRect</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> presentViewFrame = <span class=\"type\">CGRect</span>.zero</span><br><span class=\"line\">    <span class=\"keyword\">let</span> containerBounds = containerView?.bounds</span><br><span class=\"line\">    <span class=\"comment\">//登场控制器内容页面的大小</span></span><br><span class=\"line\">    presentViewFrame.size = size(forChildContentContainer: presentedViewController, </span><br><span class=\"line\">                                  withParentContainerSize: (containerBounds?.size)!)</span><br><span class=\"line\">    presentViewFrame.origin.x = (containerBounds?.size.width)! - presentViewFrame.size.width</span><br><span class=\"line\">    <span class=\"keyword\">return</span> presentViewFrame</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回登场控制器内容页面的大小，在这里设置为屏幕宽度的三分之一款</span></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">size</span><span class=\"params\">(forChildContentContainer container: UIContentContainer, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   withParentContainerSize parentSize: CGSize)</span></span> -&gt; <span class=\"type\">CGSize</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">CGSize</span>.<span class=\"keyword\">init</span>(width:<span class=\"type\">CGFloat</span>(floorf(<span class=\"type\">Float</span>(parentSize.width/<span class=\"number\">3.0</span>))), height: parentSize.height)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"过渡动画，转场协调器-Transition-Coordinator\"><a href=\"#过渡动画，转场协调器-Transition-Coordinator\" class=\"headerlink\" title=\"过渡动画，转场协调器(Transition Coordinator)\"></a>过渡动画，转场协调器(Transition Coordinator)</h4><p>参与角色都准备好了，但有个问题，无法直接访问动画控制器，不知道转场的持续时间，怎么与转场过程同步？这时候前面提到的用处甚少的转场协调器(Transition Coordinator)将在这里派上用场。该对象可通过 <code>UIViewController</code> 的<code>transitionCoordinator()</code>方法获取，这是 iOS 7 为自定义转场新增的 API，该方法只在控制器处于转场过程中才返回一个与当前转场有关的有效对象，其他时候返回 <code>nil</code>。</p>\n<h5 id=\"转场开始\"><a href=\"#转场开始\" class=\"headerlink\" title=\"转场开始\"></a>转场开始</h5><ol>\n<li>在<code>containerView</code>中插入过渡视图<code>chromeView</code></li>\n<li>为转场中<code>chromeView</code>过渡视图添加转场动画</li>\n<li><code>presentedViewController.transitionCoordinator</code>转场协调器，添加转场的登场和退场动画<figure class=\"highlight swift\"><figcaption><span>presentationTransitionWillBegin</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationTransitionWillBegin</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    chromeView.frame = (<span class=\"keyword\">self</span>.containerView?.bounds)!</span><br><span class=\"line\">    chromeView.alpha = <span class=\"number\">0.0</span></span><br><span class=\"line\">    <span class=\"comment\">//在`containerView`中插入视图`chromeView`    </span></span><br><span class=\"line\">    containerView?.insertSubview(chromeView, at:<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//coordinator转场协调器负责转场动画的呈现和dismissal</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> coordinator = presentedViewController.transitionCoordinator</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (coordinator != <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//添加登场动画</span></span><br><span class=\"line\">        coordinator!.animate(alongsideTransition: &#123;</span><br><span class=\"line\">        (context:<span class=\"type\">UIViewControllerTransitionCoordinatorContext</span>!) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"comment\">//animate the alpha to 1.0.</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.chromeView.alpha = <span class=\"number\">1.0</span></span><br><span class=\"line\">        &#125;, completion:<span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        chromeView.alpha = <span class=\"number\">1.0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"转场结束\"><a href=\"#转场结束\" class=\"headerlink\" title=\"转场结束\"></a>转场结束</h5><p>在<code>presentedViewController.transitionCoordinator</code>转场协调器中添加转场的退场动画<br><figure class=\"highlight swift\"><figcaption><span>dismissalTransitionWillBegin</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dismissalTransitionWillBegin</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> coordinator = presentedViewController.transitionCoordinator</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (coordinator != <span class=\"literal\">nil</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//添加退场动画</span></span><br><span class=\"line\">        coordinator!.animate(alongsideTransition: &#123;</span><br><span class=\"line\">        (context:<span class=\"type\">UIViewControllerTransitionCoordinatorContext</span>!) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.chromeView.alpha = <span class=\"number\">0.0</span></span><br><span class=\"line\">        &#125;, completion:<span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        chromeView.alpha = <span class=\"number\">0.0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"适配屏幕旋转\"><a href=\"#适配屏幕旋转\" class=\"headerlink\" title=\"适配屏幕旋转\"></a>适配屏幕旋转</h4><p>在设备旋转的情况下，重置背景视图的外观和登场控制器内容的外观<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">containerViewWillLayoutSubviews</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    chromeView.frame = (containerView?.bounds)!</span><br><span class=\"line\">    presentedView?.frame = frameOfPresentedViewInContainerView</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Modal的两种PresentationStyle\"><a href=\"#Modal的两种PresentationStyle\" class=\"headerlink\" title=\"Modal的两种PresentationStyle\"></a>Modal的两种PresentationStyle</h4><ol>\n<li>设置整个转场动画是否将覆盖全屏幕<br> <code>.OverFullScreen</code>: 浮动式全屏，即：登场视图下方的视图不会完全被遮挡<br> <code>.FullScreen</code>  : 全覆盖全屏 即：占据全屏来显示登场视图<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设置整个转场动画是否将覆盖全屏幕</span></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">var</span> shouldPresentInFullscreen: <span class=\"type\">Bool</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">var</span> adaptivePresentationStyle: <span class=\"type\">UIModalPresentationStyle</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">UIModalPresentationStyle</span>.fullScreen</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"交互式转场\"><a href=\"#交互式转场\" class=\"headerlink\" title=\"交互式转场\"></a>交互式转场</h2><h3 id=\"实现交互化\"><a href=\"#实现交互化\" class=\"headerlink\" title=\"实现交互化\"></a>实现交互化</h3><p>在非交互转场的基础上将之交互化需要两个条件：<br>由转场代理提供交互控制器，这是一个遵守<uiviewcontrollerinteractivetransitioning>协议的对象，不过系统已经打包好了现成的类<code>UIPercentDrivenInteractiveTransition</code>供我们使用。我们不需要做任何配置，仅仅在转场代理的相应方法中提供一个该类实例便能工作。另外交互控制器必须有动画控制器才能工作。<br>交互控制器还需要交互手段的配合，最常见的是使用手势，或是其他事件，来驱动整个转场进程。</uiviewcontrollerinteractivetransitioning></p>\n<h3 id=\"使用一个变量来标记交互状态配合转场交互\"><a href=\"#使用一个变量来标记交互状态配合转场交互\" class=\"headerlink\" title=\"使用一个变量来标记交互状态配合转场交互\"></a>使用一个变量来标记交互状态配合转场交互</h3><p>如果在转场代理中提供了交互控制器，而转场发生时并没有方法来驱动转场进程(比如手势)，转场过程将一直处于开始阶段无法结束。<br>在两个容器控制器<code>NavigationController</code>和<code>TabBarController</code>转场为例：</p>\n<ol>\n<li>在 <code>NavigationController</code> 中点击 <code>NavigationBar</code> 也能实现 <code>pop</code> 返回操作，但此时没有了交互手段的支持，转场过程卡壳；</li>\n<li>在 <code>TabBarController</code> 的代理里提供交互控制器存在同样的问题，点击 <code>TabBar</code> 切换页面时也没有实现交互控制。因此仅在确实处于交互状态时才提供交互控制器，可以使用一个变量来标记交互状态，该变量由交互手势来更新状态。</li>\n</ol>\n<h3 id=\"转场动画控制器：向转场中添加视图，执行转场动画\"><a href=\"#转场动画控制器：向转场中添加视图，执行转场动画\" class=\"headerlink\" title=\"转场动画控制器：向转场中添加视图，执行转场动画\"></a>转场动画控制器：向转场中添加视图，执行转场动画</h3><p>转场 API 是协议的好处是不受限于具体的类，只要对象实现该协议便能参与转场过程，这也带来另外一个好处：封装便于复用，尽管三大转场代理协议的方法不尽相同。<br>但它们返回的动画控制器遵守的是同一个协议，因此可以将动画控制器封装作为第三方动画控制器在其他控制器的转场过程中使用。<br><code>UIViewControllerAnimatedTransitioning</code>代理协议方法，提供了转场所需要的重要数据：</p>\n<ol>\n<li><code>containerView()</code>：运行转场动画的容器视图</li>\n<li>转场视图控制器<ul>\n<li>方法一：<code>viewController(forKey:)</code>：<code>UITransitionContextViewControllerKey</code>枚举值：<code>from</code>，<code>to</code></li>\n<li>方法二：<code>viewForKey(_ key: String) -&gt; UIView? AVAILABLE_IOS(8_0)</code>:iOS 8新增 API 用于方便获取参与转场的视图.两个键值：<code>UITransitionContextFromViewKey</code>,<code>UITransitionContextToViewKey</code>.</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleAnimatedTransitioning</span>: <span class=\"title\">NSObject</span>,<span class=\"title\">UIViewControllerAnimatedTransitioning</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//used to determine if the presentation animation is presenting (as opposed to dismissing).</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> isPresentation : <span class=\"type\">Bool</span> = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//returns the duration in seconds of the transition animation.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">transitionDuration</span><span class=\"params\">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class=\"type\">TimeInterval</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//返回动画时间</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0.5</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//get the respective views of these view controllers. </span></span><br><span class=\"line\">    <span class=\"comment\">//Next we get the container view and if the presentation animation is presenting, we add the to view to the container view.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animateTransition</span><span class=\"params\">(using transitionContext: UIViewControllerContextTransitioning)</span></span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//get the from and to view controllers from the UIViewControllerContextTransitioning object.</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> fromVC = transitionContext.viewController(forKey: <span class=\"type\">UITransitionContextViewControllerKey</span>.from)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> toVC = transitionContext.viewController(forKey: <span class=\"type\">UITransitionContextViewControllerKey</span>.to)</span><br><span class=\"line\">        <span class=\"comment\">//determine the start and end positions of the view.</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> fromView = fromVC?.view</span><br><span class=\"line\">        <span class=\"keyword\">let</span> toView = toVC?.view</span><br><span class=\"line\">        <span class=\"keyword\">let</span> containerView = transitionContext.containerView</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> isPresentation </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            containerView.addSubview(toView!)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//decide on which view controller to animate based on whether the transition is a presentation or dismissal</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> animatingVC = isPresentation ? toVC : fromVC</span><br><span class=\"line\">        <span class=\"keyword\">let</span> animatingView = animatingVC?.view</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> finalFrameForVC = transitionContext.finalFrame(<span class=\"keyword\">for</span>: animatingVC!)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> initialFrameForVC = finalFrameForVC</span><br><span class=\"line\">        <span class=\"comment\">//This will animate the view from right to left during a presentation and vice versa during dismissal.</span></span><br><span class=\"line\">        initialFrameForVC.origin.x += initialFrameForVC.size.width</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> initialFrame = isPresentation ? initialFrameForVC : finalFrameForVC</span><br><span class=\"line\">        <span class=\"keyword\">let</span> finalFrame = isPresentation ? finalFrameForVC : initialFrameForVC</span><br><span class=\"line\"></span><br><span class=\"line\">        animatingView?.frame = initialFrame</span><br><span class=\"line\">        <span class=\"comment\">//根据协议中的方法获取动画的时间。</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> duration = transitionDuration(using: transitionContext)</span><br><span class=\"line\">        <span class=\"type\">UIView</span>.animate(withDuration: duration, delay:<span class=\"number\">0</span>, usingSpringWithDamping:<span class=\"number\">300.0</span>, initialSpringVelocity:<span class=\"number\">5.0</span>, options:<span class=\"type\">UIViewAnimationOptions</span>.allowUserInteraction, animations:&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//we move the view to the final position.</span></span><br><span class=\"line\">            animatingView?.frame = finalFrame</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;, completion:&#123; (value: <span class=\"type\">Bool</span>) <span class=\"keyword\">in</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> !<span class=\"keyword\">self</span>.isPresentation &#123;</span><br><span class=\"line\">                <span class=\"comment\">//If the transition is a dismissal, we remove the view.</span></span><br><span class=\"line\">                fromView?.removeFromSuperview()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//we complete the transition by calling transitionContext.completeTransition()</span></span><br><span class=\"line\">            transitionContext.completeTransition(<span class=\"literal\">true</span>)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//    UIView.transitionFromView(fromView, toView: toView, duration: durantion, options: .TransitionCurlDown, completion: &#123; _ in</span></span><br><span class=\"line\">    <span class=\"comment\">//    let isCancelled = transitionContext.transitionWasCancelled()</span></span><br><span class=\"line\">    <span class=\"comment\">//    transitionContext.completeTransition(!isCancelled)</span></span><br><span class=\"line\">    <span class=\"comment\">//    &#125;)</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//如果实现了，会在转场动画结束后调用，可以执行一些收尾工作。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationEnded</span><span class=\"params\">(<span class=\"number\">_</span> transitionCompleted: Bool)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"转场代理协议-Transition-Delegate\"><a href=\"#转场代理协议-Transition-Delegate\" class=\"headerlink\" title=\"转场代理协议(Transition Delegate)\"></a>转场代理协议(Transition Delegate)</h2><p>自定义转场的第一步便是提供转场代理，告诉系统使用我们提供的代理而不是系统的默认代理来执行转场。</p>\n<h3 id=\"实现转场代理协议方法，整合动画控制器和自定义展示控制器\"><a href=\"#实现转场代理协议方法，整合动画控制器和自定义展示控制器\" class=\"headerlink\" title=\"实现转场代理协议方法，整合动画控制器和自定义展示控制器\"></a>实现转场代理协议方法，整合动画控制器和自定义展示控制器</h3><ol>\n<li>返回管理用户信息视图控制器如何展示的控制器。前面实现的<code>ExamplePresentationViewController</code>类可同时处理 <code>presentation</code>转场 和 <code>dismissal</code> 转场。</li>\n<li>动画控制器为 <code>presentation</code> 和 <code>dismissal</code> 转场分别提供了动画控制器。<blockquote>\n<p><code>UIPresentationController</code>只在 iOS 8中可用，通过available关键字可以解决 API 的版本差异。</p>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleTransitioningDelegate</span>: <span class=\"title\">NSObject</span>,<span class=\"title\">UIViewControllerTransitioningDelegate</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//returns a presentation controller that manages the presentation of a view controller.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationController</span><span class=\"params\">(forPresented presented: UIViewController, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                            presenting: UIViewController?, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                source: UIViewController)</span></span> -&gt; <span class=\"type\">UIPresentationController</span>? </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//presentation动画控制器</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> presentationController = <span class=\"type\">ExamplePresentationViewController</span>(presentedViewController:presented, </span><br><span class=\"line\">                                                                                    presenting:presenting)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> presentationController</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//为presentation转场提供登场转场动画控制器</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationController</span><span class=\"params\">(forPresented presented: UIViewController, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                         presenting: UIViewController, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                             source: UIViewController)</span></span> -&gt; <span class=\"type\">UIViewControllerAnimatedTransitioning</span>? </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//登场转场动画控制器</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> animator = <span class=\"type\">ExampleAnimatedTransitioning</span>()</span><br><span class=\"line\">        animator.isPresentation = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> animator</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//为dismissal 转场提供退场转场动画控制器</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationController</span><span class=\"params\">(forDismissed dismissed: UIViewController)</span></span> -&gt; <span class=\"type\">UIViewControllerAnimatedTransitioning</span>? </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//退场转场动画控制器</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> animator = <span class=\"type\">ExampleAnimatedTransitioning</span>()</span><br><span class=\"line\">        animator.isPresentation = <span class=\"literal\">false</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> animator</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用自定义的转场的代理\"><a href=\"#使用自定义的转场的代理\" class=\"headerlink\" title=\"使用自定义的转场的代理\"></a>使用自定义的转场的代理</h3><p>自定义转场的第一步便是提供转场代理，告诉系统使用我们提供的代理而不是系统的默认代理来执行转场。<br>UIViewControllerTransitioningDelegate转场代理：</p>\n<ol>\n<li>强引用代理变量:强引用的变量来维护该代理</li>\n<li>Modal转场代理的特性：由presentedVC自身来遵循转场代理<code>presentedVC.modalPresentationStyle</code>，和前两个容器控制器转场代理不同。</li>\n<li>两种支持自定义转场模式：<code>.Custom</code>或<code>.FullScreen</code>,默认值为<code>.FullScreen</code><figure class=\"highlight swift\"><figcaption><span>fromVC.class</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//强引用的变量来维护该代理</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> exampleTransitionDelegate = <span class=\"type\">ExampleTransitioningDelegate</span>()</span><br><span class=\"line\"><span class=\"comment\">//create an instance of ExampleViewController which will provide the content to display.</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> presentedVC = <span class=\"type\">ExampleViewController</span>()</span><br><span class=\"line\">presentedVC.modalPresentationStyle = .custom</span><br><span class=\"line\">presentedVC.transitioningDelegate = exampleTransitionDelegate</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//present this view controller.</span></span><br><span class=\"line\">present(toVC, animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"两种常规的转场方式\"><a href=\"#两种常规的转场方式\" class=\"headerlink\" title=\"两种常规的转场方式\"></a>两种常规的转场方式</h2><h3 id=\"UIView方式-transitionFromView\"><a href=\"#UIView方式-transitionFromView\" class=\"headerlink\" title=\"UIView方式:transitionFromView\"></a>UIView方式:transitionFromView</h3><p>不需要获取 <code>containerView</code> 以及手动添加 <code>toView</code> 就能实现一个指定类型的转场动画，而缺点则是只能使用指定类型的动画。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UIView</span>.transitionFromView(fromView, toView: toView, duration: durantion, options: .<span class=\"type\">TransitionCurlDown</span>, completion: &#123; <span class=\"number\">_</span> <span class=\"keyword\">in</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isCancelled = transitionContext.transitionWasCancelled()</span><br><span class=\"line\">transitionContext.completeTransition(!isCancelled)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"UIViewController方式：在子-VC-间转换的方法\"><a href=\"#UIViewController方式：在子-VC-间转换的方法\" class=\"headerlink\" title=\"UIViewController方式：在子 VC 间转换的方法\"></a>UIViewController方式：在子 VC 间转换的方法</h3><p>该方法用 toVC 的视图转换 fromVC 的视图在父视图中的位置，并且执行<code>animations闭包</code>里的动画。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transitionFromViewController:toViewController:duration:options:animations:completion:</span><br></pre></td></tr></table></figure><br>该方法仅限于在自定义容器控制器里使用，如果直接使用 <code>UINavigationController</code> 和 <code>UITabBarController</code> 调用该方法执行子VC间转换会抛出异常。</p>\n<blockquote>\n<p>不过 iOS 7 中这两个容器控制器开放的自定义转场做的是同样的事情，回头再看第一章 Transition 解释，转场协议 API 将这个方法拆分成了上面的几个组件，并且加入了激动人心的交互控制，以便我们能够方便定制转场动画。</p>\n</blockquote>\n<p><a href=\"http://www.appcoda.com/presentation-controllers-tutorial/\" target=\"_blank\" rel=\"noopener\">原文</a></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"转场","path":"api/categories/转场.json"}],"tags":[{"name":"动画","path":"api/tags/动画.json"},{"name":"转场","path":"api/tags/转场.json"}]},{"title":"整理iOS中几种常用的展示型视图控制器","slug":"iOS中几种常用的展示控制器使用","date":"2017-02-16T17:53:18.000Z","updated":"2017-02-16T21:56:31.000Z","comments":true,"path":"api/articles/iOS中几种常用的展示控制器使用.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/iPhoneipadalert.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><a href=\"https://www.dropbox.com/s/4gj6levvlav2xzc/PresentationsDemoStart.zip?dl=0\" target=\"_blank\" rel=\"noopener\">开始项目</a><br><a href=\"https://github.com/appcoda/Presentation-Controllers-Demo\" target=\"_blank\" rel=\"noopener\">完整项目</a></p>\n<h2 id=\"UIAlertController\"><a href=\"#UIAlertController\" class=\"headerlink\" title=\"UIAlertController\"></a>UIAlertController</h2><p>在iOS8中，提供<code>UIAlertController</code>控制器代替<code>UIAlertView</code>和<code>UIActionSheet</code>两个控件。给用户展示提示信息的新的一种方式。</p>\n<h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><ol>\n<li>能够自适应的（在iPad上，an <code>action sheet</code> style alert will present itself in a popover），</li>\n<li>显示方式：可以轻松切换<code>Action sheets</code>和<code>alert view</code>两种显示样式<code>alert view</code>被以modal态显示presenting视图控制器上，<code>Action sheets</code>被固定在以屏幕底部。 </li>\n<li>按钮事件实现：使用闭包的方式来处理，相较之前通过实现代理的方式要简单很多。</li>\n<li>子控件支持：<code>Alert view</code>支持按钮和输入框两种，Action sheets仅支持按钮一种控件。</li>\n<li>不同于以往的两类<code>UIAlertController</code>继承自<code>UIViewController</code>。这意味着可以使用视图控制器提供展示信息的功能。</li>\n</ol>\n<h3 id=\"创建使用UIAlertController\"><a href=\"#创建使用UIAlertController\" class=\"headerlink\" title=\"创建使用UIAlertController\"></a>创建使用UIAlertController</h3><p>用<code>title</code>，<code>message</code>参数来实例化<code>alertController</code>实例，然后在实例中添加两个闭包的按钮<br><figure class=\"highlight swift\"><figcaption><span>showAlertWasTapped</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@IBAction</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">showAlertWasTapped</span><span class=\"params\">(sender: UIButton)</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> alertController = <span class=\"type\">UIAlertController</span>(title: <span class=\"string\">\"Appcoda\"</span>, message: <span class=\"string\">\"Message in alert dialog\"</span>, preferredStyle: <span class=\"type\">UIAlertControllerStyle</span>.<span class=\"type\">Alert</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> deleteAction = <span class=\"type\">UIAlertAction</span>(title: <span class=\"string\">\"Delete\"</span>, style: <span class=\"type\">UIAlertActionStyle</span>.<span class=\"type\">Destructive</span>, handler: &#123;(alert :<span class=\"type\">UIAlertAction</span>!) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"built_in\">println</span>(<span class=\"string\">\"Delete button tapped\"</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    alertController.addAction(deleteAction)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> okAction = <span class=\"type\">UIAlertAction</span>(title: <span class=\"string\">\"OK\"</span>, style: <span class=\"type\">UIAlertActionStyle</span>.<span class=\"type\">Default</span>, handler: &#123;(alert :<span class=\"type\">UIAlertAction</span>!) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"built_in\">println</span>(<span class=\"string\">\"OK button tapped\"</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    alertController.addAction(okAction)</span><br><span class=\"line\"></span><br><span class=\"line\">    presentViewController(alertController, animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>运行效果：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/iPhoneipadalert.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"UIAlertControllerStyle枚举：Alert切换ActionSheet\"><a href=\"#UIAlertControllerStyle枚举：Alert切换ActionSheet\" class=\"headerlink\" title=\"UIAlertControllerStyle枚举：Alert切换ActionSheet\"></a>UIAlertControllerStyle枚举：<code>Alert</code>切换<code>ActionSheet</code></h3><p>在<code>UIAlertController</code>之前，切换<code>alert</code>和<code>action sheet</code>需要重写大量的代码，但现在只需要改变一个枚举值<code>UIAlertControllerStyle.Alert</code>为<code>UIAlertControllerStyle.ActionSheet</code>.<br><figure class=\"highlight swift\"><figcaption><span>UIAlertControllerStyle.ActionSheet</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> alertController = <span class=\"type\">UIAlertController</span>(title: <span class=\"string\">\"Appcoda\"</span>, message: <span class=\"string\">\"Message in alert dialog\"</span>, preferredStyle: <span class=\"type\">UIAlertControllerStyle</span>.<span class=\"type\">ActionSheet</span>)</span><br></pre></td></tr></table></figure><br>在iPhone上，屏幕底部显示一个<code>action sheet</code>。<br>问题：在iPad上，点击上面的按钮崩溃，需要定义锚点位置。</p>\n<h3 id=\"popoverPresentationController锚点：sourceView-sourceRect\"><a href=\"#popoverPresentationController锚点：sourceView-sourceRect\" class=\"headerlink\" title=\"popoverPresentationController锚点：sourceView/sourceRect\"></a>popoverPresentationController锚点：sourceView/sourceRect</h3><p><code>popover controller</code>在<code>alertController</code>视图内展示，需要一个<code>popover箭头</code>指向<code>alertController</code>视图的某一位置。<br>通过设置<code>sourceView</code>来确定<code>popover箭头</code>位置，这个<code>popover</code>以及<code>popover箭头</code>指向的矩形区域都在这个<code>sourceView</code>上。<br>在调用<code>presentViewController()</code>之前添加代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alertController.popoverPresentationController?.sourceView = view</span><br><span class=\"line\">alertController.popoverPresentationController?.sourceRect = sender.frame</span><br></pre></td></tr></table></figure><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/popover箭头.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"UIPopoverPresentationController\"><a href=\"#UIPopoverPresentationController\" class=\"headerlink\" title=\"UIPopoverPresentationController\"></a>UIPopoverPresentationController</h2><p><code>Alert</code>主要用于显示用户的提示信息，当展示的信息很多时，就需要借助<code>popover presentation controller</code>。</p>\n<h3 id=\"在compact和regular两种屏幕中显示模态视图\"><a href=\"#在compact和regular两种屏幕中显示模态视图\" class=\"headerlink\" title=\"在compact和regular两种屏幕中显示模态视图\"></a>在compact和regular两种屏幕中显示模态视图</h3><p>在<code>storyboard</code>文件，设置视图的<code>storyboard ID</code>:<code>PopoverViewController</code>，设置模态视图展示样式，展示在<code>compact-width</code>和<code>regular-width</code>的两种设备屏幕上。<br>实现如下：<br><figure class=\"highlight swift\"><figcaption><span>actionWasTapped</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@IBAction</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">actionWasTapped</span><span class=\"params\">(sender: UIBarButtonItem)</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> storyboard : <span class=\"type\">UIStoryboard</span> = <span class=\"type\">UIStoryboard</span>(name: <span class=\"string\">\"Main\"</span>, bundle: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> vc = storyboard.instantiateViewControllerWithIdentifier(<span class=\"string\">\"PopoverViewController\"</span>) <span class=\"keyword\">as</span>! <span class=\"type\">UIViewController</span></span><br><span class=\"line\">    vc.modalPresentationStyle = <span class=\"type\">UIModalPresentationStyle</span>.<span class=\"type\">Popover</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> popover: <span class=\"type\">UIPopoverPresentationController</span> = vc.popoverPresentationController!</span><br><span class=\"line\">    popover.barButtonItem = sender  <span class=\"comment\">//`popover箭头`锚的位置</span></span><br><span class=\"line\">    presentViewController(vc, animated: <span class=\"literal\">true</span>, completion:<span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"设置锚点四种方式\"><a href=\"#设置锚点四种方式\" class=\"headerlink\" title=\"设置锚点四种方式\"></a>设置锚点四种方式</h4><ol>\n<li>barButtonItem<br>先获取该视图控制器的<code>popoverPresentationController</code>控制器，通过<code>popover</code>控制器的<code>barButtonItem</code>属性来设置锚点控件。当弹出时<code>popover箭头</code>就指向这个barButtonItem控件。</li>\n<li>通过指定<code>sourceView</code>和<code>sourceRect</code>两个属性，就像前面例子中一样来指定锚点位置。</li>\n<li>通过其他属性来实现，例如：<code>permittedArrowDirections</code>，也能够指定锚点。</li>\n<li>如果在在展示过程中，无法确定箭头的方向时，就是用默认值：<code>UIPopoverArrowDirection.Any</code>.<br>在iPad显示：</li>\n</ol>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/UIPopoverArrowDirection.png?imageMogr2/2/w/800\">\n<p>在iPhone上以模态显示：</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/iPhonemodally.png?imageMogr2/2/w/800\">\n<h3 id=\"在iPhone设备上dissmiss模态视图\"><a href=\"#在iPhone设备上dissmiss模态视图\" class=\"headerlink\" title=\"在iPhone设备上dissmiss模态视图\"></a>在iPhone设备上dissmiss模态视图</h3><p>要在iPhone设备上，实现模态视图dissmiss功能，需要借助导航控制器，同时这个模态视图需要遵循<code>UIPopoverPresentationController</code>协议，实现两个代理方法</p>\n<h4 id=\"实现UIPopoverPresentationController协议\"><a href=\"#实现UIPopoverPresentationController协议\" class=\"headerlink\" title=\"实现UIPopoverPresentationController协议\"></a>实现<code>UIPopoverPresentationController</code>协议</h4><ol>\n<li><code>PopoverViewController</code>类定义修改如下:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PopoverViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">UIPopoverPresentationControllerDelegate</span> </span>&#123;</span><br></pre></td></tr></table></figure></li>\n<li>在actionWasTapped()函数中调用<code>presentViewController()</code>之前添加：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">popover.delegate = <span class=\"keyword\">self</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法一：返回自适应设备的视图展示样式\"><a href=\"#方法一：返回自适应设备的视图展示样式\" class=\"headerlink\" title=\"方法一：返回自适应设备的视图展示样式\"></a>方法一：返回自适应设备的视图展示样式</h4>当APP在<code>compact-width</code>设备上弹出一个视图时调用.这个方法告诉OS系统使用的视图展示样式。<br>这里OS系统被告知在<code>compact-width</code>设备上，使用全屏的样式展示视图。<figure class=\"highlight swift\"><figcaption><span>adaptivePresentationStyleForPresentationController()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">adaptivePresentationStyleForPresentationController</span><span class=\"params\">(controller: UIPresentationController)</span></span> -&gt; <span class=\"type\">UIModalPresentationStyle</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">UIModalPresentationStyle</span>.<span class=\"type\">FullScreen</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二：返回自定义的视图控制器\"><a href=\"#方法二：返回自定义的视图控制器\" class=\"headerlink\" title=\"方法二：返回自定义的视图控制器\"></a>方法二：返回自定义的视图控制器</h4>当前展现的视图和原来的展示方式不同时调用.我们设置这个视图的<code>Popover presentation</code>展示方式，但是我们指定在<code>compact-width</code>设备上，这样它会以full screen样式展示。在这个函数中，样式切换发生时，会return自定义的视图控制器。<figure class=\"highlight swift\"><figcaption><span>presentationController(_:viewControllerForAdaptivePresentationStyle)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationController</span><span class=\"params\">(controller: UIPresentationController, viewControllerForAdaptivePresentationStyle style: UIModalPresentationStyle)</span></span> -&gt; <span class=\"type\">UIViewController</span>? </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> navigationController = <span class=\"type\">UINavigationController</span>(rootViewController: controller.presentedViewController)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> btnDone = <span class=\"type\">UIBarButtonItem</span>(title: <span class=\"string\">\"Done\"</span>, style: .<span class=\"type\">Done</span>, target: <span class=\"keyword\">self</span>, action: <span class=\"string\">\"dismiss\"</span>)</span><br><span class=\"line\">    navigationController.topViewController.navigationItem.rightBarButtonItem = btnDone</span><br><span class=\"line\">    <span class=\"keyword\">return</span> navigationController</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"Done按钮的dismiss事件\"><a href=\"#Done按钮的dismiss事件\" class=\"headerlink\" title=\"Done按钮的dismiss事件\"></a><code>Done</code>按钮的dismiss事件</h4><p>在导航控制器中国封装这个视图，在导航条上添加一个<code>Done</code>按钮，点击<code>Done</code>dismiss这个视图<br><figure class=\"highlight swift\"><figcaption><span>dismiss</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dismiss</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.dismissViewControllerAnimated(<span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在iPhone上，显示修改后的视图控制器，多出带按钮的导航栏。<br>在iPad上，视图控制器显示没有导航控制器，因为它不使用全屏幕显示。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/adaptivePresentationStyleForPresentationController.png?imageMogr2/2/w/800\"><br>如果想让iPhone像iPad一样显示一个Popover，只<code>adaptivePresentationStyleForPresentationController</code>返回：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"type\">UIModalPresentationStyle</span>.<span class=\"type\">None</span></span><br></pre></td></tr></table></figure><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/UIModalPresentationStyle.None.png?imageMogr2/2/w/800\"></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"转场","path":"api/categories/转场.json"}],"tags":[{"name":"动画","path":"api/tags/动画.json"},{"name":"转场","path":"api/tags/转场.json"},{"name":"UI","path":"api/tags/UI.json"}]},{"title":"在OC和swift中区分多个targets","slug":"iOS/在OC和swift中区分多个targets","date":"2017-01-11T13:49:33.000Z","updated":"2017-08-17T14:54:01.000Z","comments":true,"path":"api/articles/iOS/在OC和swift中区分多个targets.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"build-setting预编译位置\"><a href=\"#build-setting预编译位置\" class=\"headerlink\" title=\"build setting预编译位置\"></a>build setting预编译位置</h2><ol>\n<li>Preprocessor Macros</li>\n<li>Other Swift Flags</li>\n</ol>\n<p>为生产和开发target配置预处理宏/编译器标识。之后我们就可以使用该标识在我们的代码来检测应用程序正在运行的版本。</p>\n<h3 id=\"Objective-C项目中Preprocessor-Macros\"><a href=\"#Objective-C项目中Preprocessor-Macros\" class=\"headerlink\" title=\"Objective-C项目中Preprocessor Macros\"></a>Objective-C项目中Preprocessor Macros</h3><h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><hr>\n<p>添加位置：选择项目中对应的target名-&gt;在<code>Build Settings</code>下<code>Apple LLVM 7.0 - Preprocessing</code>-&gt;<code>Preprocessor Macros</code>。<br>添加变量：在Rebug和Release区域添加一个变量<code>DEVELOPMENT</code><br>    对应target1: 设<code>DEVELOPMENT=1</code>表示开发版<br>    对应target2: 设<code>DEVELOPMENT=0</code>表示生产版</p>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><hr>\n<p>根据已配置的宏DEV_VERSION，我们可以在代码中利用它动态地编译项目。下面是一个简单的例子：<br>Objective-C中使用<code>＃if</code>检查<code>DEVELOPMENT</code>的环境，并相应的设置URLs/ API密钥。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#if DEVELOPMENT</span></span><br><span class=\"line\">     <span class=\"meta\">#define SERVER_URL @<span class=\"meta-string\">\"http://dev.server.com/api/\"</span></span></span><br><span class=\"line\">     <span class=\"meta\">#define API_TOKEN @<span class=\"meta-string\">\"DI2023409jf90ew\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#else</span></span><br><span class=\"line\">     <span class=\"meta\">#define SERVER_URL @<span class=\"meta-string\">\"http://prod.server.com/api/\"</span></span></span><br><span class=\"line\">     <span class=\"meta\">#define API_TOKEN @<span class=\"meta-string\">\"71a629j0f090232\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Swift中Other-Swift-Flags\"><a href=\"#Swift中Other-Swift-Flags\" class=\"headerlink\" title=\"Swift中Other Swift Flags\"></a>Swift中Other Swift Flags</h3><p>对于swift的项目，编译器不再支持预处理指令。作为替代，它使用编译时的属性和build配置。</p>\n<h4 id=\"配置-1\"><a href=\"#配置-1\" class=\"headerlink\" title=\"配置\"></a>配置</h4><hr>\n<p>选中开发target，添加一个标识表示开发版本<br>选中<code>target</code> -&gt; <code>Build Setting</code>-&gt;<code>Swift Compiler - Custom Flags</code>-&gt;将值设为<code>-DDEVELOPMENT</code>表示这个target作为开发版本。</p>\n<h4 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h4><hr>\n<p>Swift中你仍然可以使用<code>#if</code>判定build的参数动态编译。然而，除了使用<code>#define</code>定义基本常量，在swift中我们也可以用<code>let</code>定义一个全局常量。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"keyword\">if</span> <span class=\"type\">DEVELOPMENT</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"type\">SERVER_URL</span> = <span class=\"string\">\"http://dev.server.com/api/\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"type\">API_TOKEN</span> = <span class=\"string\">\"DI2023409jf90ew\"</span></span><br><span class=\"line\">#<span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"type\">SERVER_URL</span> = <span class=\"string\">\"http://prod.server.com/api/\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"type\">API_TOKEN</span> = <span class=\"string\">\"71a629j0f090232\"</span></span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.cocoachina.com/ios/20160331/15832.html\" target=\"_blank\" rel=\"noopener\">参照</a></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"配置","path":"api/categories/配置.json"}],"tags":[{"name":"targets","path":"api/tags/targets.json"}]},{"title":"UIImage的渲染模式","slug":"iOS/UIImage的渲染模式","date":"2015-11-26T16:15:11.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/UIImage的渲染模式.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>设置UIImage的渲染模式：UIImage.renderingMode<br>在 iOS 7 中 UIImage 添加了一个 <code>renderingMode</code> 属性。我们可以使用 <code>imageWithRenderingMode:</code>并传入一个合适的<code>UIImageRenderingMode</code> 来指定这个 image 要不要以 Template 的方式进行渲染。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIImageRenderingModeAutomatic</span> <span class=\"comment\">// 根据图片的使用环境和所处的绘图上下文自动调整渲染模式。</span></span><br><span class=\"line\"><span class=\"built_in\">UIImageRenderingModeAlwaysOriginal</span> <span class=\"comment\">// 始终绘制图片原始状态，不使用Tint Color。</span></span><br><span class=\"line\"><span class=\"built_in\">UIImageRenderingModeAlwaysTemplate</span> <span class=\"comment\">// 始终根据Tint Color绘制图片，忽略图片的颜色信息。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UIImage</span> *img = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"myimage\"</span>];</span><br><span class=\"line\">img = [img imageWithRenderingMode:<span class=\"built_in\">UIImageRenderingModeAlwaysTemplate</span>];</span><br><span class=\"line\"><span class=\"comment\">//实际效果，效果依旧显示为baritem的Tint Color</span></span><br><span class=\"line\"><span class=\"built_in\">UIBarButtonItem</span> *barButtonItem = [[<span class=\"built_in\">UIBarButtonItem</span> alloc] initWithImage:setImage</span><br><span class=\"line\">                                                   style:<span class=\"built_in\">UIBarButtonItemStylePlain</span></span><br><span class=\"line\">                                                  target:<span class=\"keyword\">self</span></span><br><span class=\"line\">                                                  action:<span class=\"keyword\">@selector</span>(setAction:)];</span><br><span class=\"line\">```    </span><br><span class=\"line\">在新的 Xcode 中，我们可以直接在 Image Asset 里的 Render As 选项来指定是不是需要作为 template 使用。相应的，在`<span class=\"built_in\">UIApperance</span>`中，Apple 也为我们对于 `Size Classes` 添加了相应的方法。使用 `+appearanceForTraitCollection:` 方法，我们就可以针对不同 trait 下的应用的 apperance 进行很简单的设定。</span><br><span class=\"line\"></span><br><span class=\"line\">```objc</span><br><span class=\"line\"><span class=\"built_in\">UIView</span>.appearanceForTraitCollection(<span class=\"built_in\">UITraitCollection</span>(verticalSizeClass:.Compact)).tintColor = <span class=\"built_in\">UIColor</span>.redColor()  </span><br><span class=\"line\"><span class=\"built_in\">UIView</span>.appearanceForTraitCollection(<span class=\"built_in\">UITraitCollection</span>(verticalSizeClass:.Regular)).tintColor = <span class=\"built_in\">UIColor</span>.greenColor()</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"控件","path":"api/categories/控件.json"}],"tags":[{"name":"UI","path":"api/tags/UI.json"},{"name":"坑","path":"api/tags/坑.json"}]},{"title":"mupdf集成pyc加密算法","slug":"编译/mupdf集成pyc加密算法","date":"2015-08-14T10:45:35.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/编译/mupdf集成pyc加密算法.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"加密算法中区分64位\"><a href=\"#加密算法中区分64位\" class=\"headerlink\" title=\"加密算法中区分64位\"></a>加密算法中区分64位</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if __LP64__ || (TARGET_OS_EMBEDDED &amp;&amp; !TARGET_OS_IPHONE) || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64</span><br><span class=\"line\">    #ifndef uint32</span><br><span class=\"line\">        #define uint32 unsigned int</span><br><span class=\"line\">    #endif</span><br><span class=\"line\">#else</span><br><span class=\"line\">    #ifndef uint32</span><br><span class=\"line\">        #define uint32 unsigned long int</span><br><span class=\"line\">    #endif</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<ol>\n<li>把SMS4.h文件内容合并到include/mupdf/fitz/stream.h文件中，然后删除SMS4.h文件</li>\n<li>把SMS4.c文件内容合并到source/fitz/stream-open.c 文件中，然后删除SMS4.c</li>\n<li>在include/mupdf/fitz/stream.h增加以下内容:  用于方法声明，供其他类使用。<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> void set_key_info(char* key, long long code_len);  </span><br><span class=\"line\">int pbb_read(int fd, unsigned char *buf, int size);  </span><br><span class=\"line\">int fpbb_read(unsigned char *buf, int count, int size, FILE* fp);  \t</span><br><span class=\"line\"> ```  </span><br><span class=\"line\">4. 替换source/pdf/pdf-write.c  2530：fread 替换为 fpbb_read</span><br><span class=\"line\">5. 替换source/fitz/stream-prog.c  57: read 替换为  pbb_read</span><br><span class=\"line\">6. 替换source/fitz/stream-open.c  73: read 替换为  pbb_read </span><br><span class=\"line\">7. 配置document Type    public.data,public.centent</span><br><span class=\"line\"></span><br><span class=\"line\">传递秘钥：</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>char keycode[] = {-12,7,106,95,82,118,-64,-78,-98,5,-3,-128,-28,95,-84,120};<br>long long keylength = 37761;<br>set_key_info(keycode, keylength);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t</span><br><span class=\"line\">#### ijkplayer</span><br><span class=\"line\">- https://github.com/kolyvan/kxmovie.git  </span><br><span class=\"line\">- https://github.com/Bilibili/ijkplayer.git</span><br><span class=\"line\">- 支持所有视频格式的操作：</span><br><span class=\"line\">\t- cd ijkplyer-master/config/</span><br><span class=\"line\">\t- rm module.sh</span><br><span class=\"line\">\t- ln -s module-default.sh module.sh</span><br><span class=\"line\">- 加密集成  </span><br><span class=\"line\">  - 处理文件的目录位置：ijkplyer-master/ios/ffmpeg-arm64,armv7,armv7s,i386,x86_64/libavformat目录</span><br><span class=\"line\">  - 把pyckey.h,sms4.h文件内容移动到处理文件目录中的avformat.h文件中</span><br><span class=\"line\">  - 把pyckey.c, sms4.c文件内容移动到处理文件目录中的file.c文件中  </span><br><span class=\"line\">  - 将extra.tar.gz解压，放入ijkplayer-master/extra目录下 </span><br><span class=\"line\">  - 暴漏头文件，编辑目录中的Makefile文件</span><br><span class=\"line\">  - - HEADERS = 新增.h文件，例如:url.h</span><br><span class=\"line\">  - - OBJS = 新增.o文件，例如:url.o</span><br></pre></td></tr></table></figure></p>\n<p>  注意：要替换ios目录下针对不同内核的目录arm64,armv7,armv7s,i386，都需要操作如上步骤。<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">然后，在IOS目录下执行编译命令脚本集合文件:</span><br></pre></td></tr></table></figure></p>\n<p>  ./compile-ffmpeg.sh clean<br>  ./compile-ffmpeg.sh all<br>```</p>\n<h4 id=\"将ijkplayer集成到自己的项目中\"><a href=\"#将ijkplayer集成到自己的项目中\" class=\"headerlink\" title=\"将ijkplayer集成到自己的项目中\"></a>将ijkplayer集成到自己的项目中</h4><ol>\n<li>将ijkplayer-master/ios、目录下的IJKMediaPlayer目录拷贝到自己项目的同目录下</li>\n<li>打开自己的项目，将IJKMediaPlayer.xcodeproj项目文件拖入自己项目中</li>\n<li>选择项目名称，配置Targets<ul>\n<li>选中 build phases标签，添加 Target Dpendencies  ，选中IJKMediaFramework 添加即可。 </li>\n</ul>\n</li>\n<li>因为移动了IJK项目目录到本项目，需要重新配置IJKMediaPlayer中文件关联设置<ul>\n<li>需要将ijkplayer-master/目录下的ijkmedia目录中的ijkplayer目录和ijksdl目录(Android.mk除外)，拷贝到IJKMediaPlyaer项目的IJKMediaPlyaer/IJKMediaPllayer/ijkmedia/目录下</li>\n<li>需要将编译后得到的静态库（ijkplayer-master/ios/build/universal/目录）拷贝至IJKMediaPlayer目录：$(PROJECT_DIR)/ffmpeg/universal/lib</li>\n<li>选中IJKMediaPlayer项目名称，配置Targets</li>\n<li>选中 build Setting标签：<br><strong>设置HeaderSearch Paths</strong>:$(PROJECT_DIR)/IJKMediaPlayer/ijkmedia $(PROJECT_DIR)/ffmpeg/universal/include<br><strong>设置Library Search Paths</strong>:$(PROJECT_DIR)/ffmpeg/universal/lib  </li>\n</ul>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"}],"tags":[{"name":"加密","path":"api/tags/加密.json"}]},{"title":"在IOS中自定义URL Schemes 教程","slug":"iOS/在IOS中自定义URLSchemes教程","date":"2014-08-28T20:32:48.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/在IOS中自定义URLSchemes教程.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2.gif?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"URL-Schemes\"><a href=\"#URL-Schemes\" class=\"headerlink\" title=\"URL Schemes\"></a>URL Schemes</h4><p>iPhone SDK中最酷的功能之一是一个应用程序能够把自己和自定义的URL协议绑定，这个URL协议可用于启动该应用程序（通过浏览器或者iPhone上的另一个程序）。创建这样的绑定并不难，难得的是你忍不住要在你的程序里用它！</p>\n<p>首先，你需要说明你想如何在程序中响应这个URL。最简单的自定义协议的方法是“唤醒”，而且可以通过URL把数据信息传递给程序，这样，程序被唤醒后能做更多的事情。</p>\n<h4 id=\"注册自定义URL协议\"><a href=\"#注册自定义URL协议\" class=\"headerlink\" title=\"注册自定义URL协议\"></a>注册自定义URL协议</h4><p>首先需要向iPhone注册一个自定义URL协议。这是在你的项目文件夹的info.plist文件进行的（就是你改变应用程序图标的同一个文件）。</p>\n<p>默认，Xcode在图形窗口中打开info.pllist，当然也可以直接用文本模式打开——对有的人来说这反而更简单。</p>\n<h6 id=\"Step1-右键，选择“Add-Row”-在下拉选框中选择“URL-types”，类型为Array\"><a href=\"#Step1-右键，选择“Add-Row”-在下拉选框中选择“URL-types”，类型为Array\" class=\"headerlink\" title=\"Step1. 右键，选择“Add Row”,在下拉选框中选择“URL types”，类型为Array:\"></a>Step1. 右键，选择“Add Row”,在下拉选框中选择“<strong>URL types</strong>”，类型为Array:</h6><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2.gif?imageMogr2/2/w/800\">\n<h6 id=\"Step2-打开“Item-0″类型为Dic-添加新key为”URL-identifier”-类型为String。可以是任何值，但建议用“反域名”-例如-“com-myapp”-。\"><a href=\"#Step2-打开“Item-0″类型为Dic-添加新key为”URL-identifier”-类型为String。可以是任何值，但建议用“反域名”-例如-“com-myapp”-。\" class=\"headerlink\" title=\"Step2. 打开“Item 0″类型为Dic,添加新key为”URL identifier”,类型为String。可以是任何值，但建议用“反域名”(例如 “com.myapp”)。\"></a>Step2. 打开“Item 0″类型为Dic,添加新key为”URL identifier”,类型为String。可以是任何值，但建议用“反域名”(例如 “com.myapp”)。</h6><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2a.gif?imageMogr2/2/w/800\">\n<h5 id=\"Step3-打开“Item-0″类型为Dic-添加新key为“URL-Schemes”-类型为Array\"><a href=\"#Step3-打开“Item-0″类型为Dic-添加新key为“URL-Schemes”-类型为Array\" class=\"headerlink\" title=\"Step3. 打开“Item 0″类型为Dic,添加新key为“URL Schemes”,类型为Array:\"></a>Step3. 打开“Item 0″类型为Dic,添加新key为“URL Schemes”,类型为Array:</h5><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2b.gif?imageMogr2/2/w/800\">\n<a id=\"more\"></a>\n<ul>\n<li><p>类型为Array:  </p>\n  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2c.gif?imageMogr2/2/w/800\">\n</li>\n</ul>\n<h5 id=\"Step4-在URL-Schemes数组中添加Value，输入你的URL协议名-例如“myapp-”-应写做“myapp”-。如果有必要，你可以在这里加入多个协议。\"><a href=\"#Step4-在URL-Schemes数组中添加Value，输入你的URL协议名-例如“myapp-”-应写做“myapp”-。如果有必要，你可以在这里加入多个协议。\" class=\"headerlink\" title=\"Step4. 在URL Schemes数组中添加Value，输入你的URL协议名 (例如“myapp://” 应写做“myapp”)。如果有必要，你可以在这里加入多个协议。\"></a>Step4. 在URL Schemes数组中添加Value，输入你的URL协议名 (例如“myapp://” 应写做“myapp”)。如果有必要，你可以在这里加入多个协议。</h5><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2d.gif?imageMogr2/2/w/800\">\n<h6 id=\"完成后如图所示：\"><a href=\"#完成后如图所示：\" class=\"headerlink\" title=\"完成后如图所示：\"></a>完成后如图所示：</h6><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2e.gif?imageMogr2/2/w/800\">\n<ul>\n<li><h6 id=\"另两种视图浏览方式：\"><a href=\"#另两种视图浏览方式：\" class=\"headerlink\" title=\"另两种视图浏览方式：\"></a>另两种视图浏览方式：</h6>在info.plist页面上右击，选择<strong>Raw Keys/Values</strong>显示如下：  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2f.png?imageMogr2/2/w/800\">\n<h6 id=\"xml\"><a href=\"#xml\" class=\"headerlink\" title=\"xml\"></a>xml</h6><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2g.gif?imageMogr2/2/w/800\">\n<!--more-->\n<h4 id=\"处理URL\"><a href=\"#处理URL\" class=\"headerlink\" title=\"处理URL\"></a>处理URL</h4></li>\n</ul>\n<p>现在，URL已经注册好了。任何人都可以用打开URL的方式通过你的协议去启动一个应用程序。</p>\n<ul>\n<li><h5 id=\"使用Safari-方式启动-app-Calling-Custom-URL-Scheme-from-Safari【下载】\"><a href=\"#使用Safari-方式启动-app-Calling-Custom-URL-Scheme-from-Safari【下载】\" class=\"headerlink\" title=\"使用Safari 方式启动 app:Calling Custom URL Scheme from Safari【下载】\"></a>使用Safari 方式启动 app:Calling Custom URL Scheme from Safari【<a href=\"http://iosdevelopertips.com/downloads/#customURLScheme\" target=\"_blank\" rel=\"noopener\">下载</a>】</h5></li>\n</ul>\n<p>Using the simulator, here’s how to call the app:</p>\n<ul>\n<li>Run the application from within Xcode  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme4a.png?imageMogr2/2/w/800\"></li>\n<li>Once installed, the custom URL scheme will now be registered</li>\n<li>Close the app via the Hardware menu in simulator and choose Home</li>\n<li>Start Safari</li>\n<li>Enter the URL scheme defined previously in the browser address bar (see below)  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme32.png?imageMogr2/2/w/800\">\n</li>\n</ul>\n<ul>\n<li><h5 id=\"通过其他应用启动：Calling-Custom-URL-Scheme-from-Another-iPhone-App【下载】\"><a href=\"#通过其他应用启动：Calling-Custom-URL-Scheme-from-Another-iPhone-App【下载】\" class=\"headerlink\" title=\"通过其他应用启动：Calling Custom URL Scheme from Another iPhone App【下载】\"></a>通过其他应用启动：Calling Custom URL Scheme from Another iPhone App【<a href=\"http://iosdevelopertips.com/downloads/#customURLScheme\" target=\"_blank\" rel=\"noopener\">下载</a>】</h5><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme4b.png?imageMogr2/2/w/800\">  \n</li>\n</ul>\n<p>按钮的实现：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> - (<span class=\"keyword\">void</span>)buttonPressed:(<span class=\"built_in\">UIButton</span> *)button</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSString</span> *customURL = <span class=\"string\">@\"iOSDevTips://\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ([[<span class=\"built_in\">UIApplication</span> sharedApplication] </span><br><span class=\"line\">    canOpenURL:[<span class=\"built_in\">NSURL</span> URLWithString:customURL]])</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    [[<span class=\"built_in\">UIApplication</span> sharedApplication] openURL:[<span class=\"built_in\">NSURL</span> URLWithString:customURL]];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIAlertView</span> *alert = [[<span class=\"built_in\">UIAlertView</span> alloc] initWithTitle:<span class=\"string\">@\"URL error\"</span></span><br><span class=\"line\">                          message:[<span class=\"built_in\">NSString</span> stringWithFormat:</span><br><span class=\"line\">                            <span class=\"string\">@\"No custom URL defined for %@\"</span>, customURL]</span><br><span class=\"line\">                          delegate:<span class=\"keyword\">self</span> cancelButtonTitle:<span class=\"string\">@\"Ok\"</span> </span><br><span class=\"line\">                          otherButtonTitles:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [alert show];</span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>Line 5 we check to see if the custom URL is defined, and if so, use the shared application instance to open the URL (line 8).<br>The <strong><code>openURL:</code></strong>method starts the application and passes the URL into the app. The current application is exited during this process.  </p>\n<ul>\n<li><h5 id=\"通过URL-Schemes-传递参数启动应用：Passing-Parameters-To-App-Via-Custom-URL-Scheme\"><a href=\"#通过URL-Schemes-传递参数启动应用：Passing-Parameters-To-App-Via-Custom-URL-Scheme\" class=\"headerlink\" title=\"通过URL Schemes 传递参数启动应用：Passing Parameters To App Via Custom URL Scheme\"></a>通过URL Schemes 传递参数启动应用：Passing Parameters To App Via Custom URL Scheme</h5>Chances are you’ll need to pass parameters into the application with the custom URL definition. Let’s look at how we can do this with.</li>\n</ul>\n<p>The <strong><code>NSURL</code></strong>class which is the basis for calling from one app to another conforms to the <code>RFC 1808</code> (Relative Uniform Resource Locators). Therefore the same URL formatting you may be familiar with for web-based content will apply here as well.</p>\n<p>In the application with the custom <code>URL scheme</code>, the app delegate must implement the method with the signature below:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application  openURL:(<span class=\"built_in\">NSURL</span> *)url </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t  sourceApplication:(<span class=\"built_in\">NSString</span> *)sourceApplication </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t         annotation:(<span class=\"keyword\">id</span>)annotation</span><br></pre></td></tr></table></figure><br>The trick to passing in parameters from one app to another is via the URL.<br>For example, assume we are using the following custom <code>URL scheme</code>and want to pass in a value for a ‘<strong>token</strong>’ and a flag indicating registration state, we could create URL as follows:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *customURL = <span class=\"string\">@\"iOSDevTips://?token=123abct&amp;registered=1\"</span>;</span><br></pre></td></tr></table></figure><br>As in web development, the string <strong><code>?token=123abct&amp;registered=1</code></strong> is known as the <code>query</code> string.</p>\n<p>Inside the app delegate of the app being called (the app with the custom URL), the code to retrieve the parameters would be as follows:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application openURL:(<span class=\"built_in\">NSURL</span> *)url</span><br><span class=\"line\">        sourceApplication:(<span class=\"built_in\">NSString</span> *)sourceApplication annotation:(<span class=\"keyword\">id</span>)annotation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Calling Application Bundle ID: %@\"</span>, sourceApplication);</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"URL scheme:%@\"</span>, [url scheme]);</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"URL query: %@\"</span>, [url query]);</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>The output from the app with the custom URL (using my Bundle ID), when called from another app, is as follows:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Calling Application Bundle ID: com<span class=\"number\">.3</span>Sixty.CallCustomURL</span><br><span class=\"line\">URL scheme:iOSDevTips</span><br><span class=\"line\">URL query: token=<span class=\"number\">123</span>abct&amp;registered=<span class=\"number\">1</span></span><br></pre></td></tr></table></figure><br>Take note of the ‘<strong>Calling Application Bundle ID</strong>’ as you could use this to ensure that only an application that you define can interact directly with your app.</p>\n<p>Let’s change up the delegate method to verify the calling application Bundle ID is known:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application openURL:(<span class=\"built_in\">NSURL</span> *)url</span><br><span class=\"line\">        sourceApplication:(<span class=\"built_in\">NSString</span> *)sourceApplication annotation:(<span class=\"keyword\">id</span>)annotation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Check the calling application Bundle ID</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ([sourceApplication isEqualToString:<span class=\"string\">@\"com.3Sixty.CallCustomURL\"</span>])</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Calling Application Bundle ID: %@\"</span>, sourceApplication);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"URL scheme:%@\"</span>, [url scheme]);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"URL query: %@\"</span>, [url query]);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>It’s important to note that you cannot prevent another application from calling your app via custom <strong><code>URL scheme</code></strong>, however you can skip any further processing and <code>return NO</code> as shown above. With that said, if you desire to keep other apps from calling your app, create a unique (non-obvious) <code>URL scheme</code>. Although this will guarantee you app won’t be called, it will make it more unlikely.</p>\n<p>Custom URL Scheme Example Projects</p>\n<p>I realize it can be a little tricky to follow all the steps above. I’ve included two (very basic) iOS apps, one that has the custom URL scheme defined and one that calls the app, passing in a short parameter list (query string). These are good starting points to experiment with custom URL’s.</p>\n<p><a href=\"http://iosdevelopertips.com/downloads/#customURLScheme\" target=\"_blank\" rel=\"noopener\">Download Xcode project for app with Custom URL scheme</a><br><a href=\"http://iosdevelopertips.com/downloads/#customURLScheme\" target=\"_blank\" rel=\"noopener\">Download Xcode project for app to call custom URL scheme</a></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"schemes","path":"api/categories/schemes.json"}],"tags":[{"name":"协议","path":"api/tags/协议.json"},{"name":"scheme","path":"api/tags/scheme.json"}]},{"title":"TextKit之便笺实战","slug":"iOS/TextKit之便笺实战","date":"2014-07-03T17:29:00.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/TextKit之便笺实战.json","excerpt":null,"keywords":null,"cover":"/images/bianqian.png","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"便笺练习功能点\"><a href=\"#便笺练习功能点\" class=\"headerlink\" title=\"便笺练习功能点:\"></a>便笺练习功能点:</h2><p>通过实现以下特效，练习并掌握布局管理器（layout manger），文本容器（text containers）和文本存储器（text storage）等用法。</p>\n<ul>\n<li>动态样式（Dynamic type）  </li>\n<li>凸版印刷效果（Letterpress effects）  </li>\n<li>环绕路径（Exclusion paths）  </li>\n<li>动态文本格式及存储（Dynamic text formatting and storage）  </li>\n</ul>\n<p>这个应用中我们将实现回流文本，字体大小的动态变换，以及闪回文本等效果。<br>效果图:<br><img src=\"/images/bianqian.png\" alt=\"image\"><br>App开始运行后自动生成一组便笺实例并利用<code>tableViewController</code>显示出来。<code>Storyboards</code>和<code>segues</code>会将被选中的单元格所对应的便笺内容显示出来以供用户编辑。<br>项目开发包：<a href=\"http://cdn4.raywenderlich.com/wp-content/uploads/2013/09/TextKitNotepad-starter.zip\" target=\"_blank\" rel=\"noopener\">Notepad.zip</a></p>\n<h2 id=\"动态样式\"><a href=\"#动态样式\" class=\"headerlink\" title=\"动态样式\"></a>动态样式</h2><p><code>动态样式（Dynamic type）</code>是iOS 7里面变化最大的特性之一; 它使得app可以遵从用户选择的字体大小和粗细。<br>选择 <strong>通用-&gt;文字大小</strong> 或 <strong>通用-&gt;辅助功能</strong> 来查看app中的字体设置。</p>\n<p><img src=\"/images/UserTextPreferences.png\" alt=\"image\"><br>iOS 7 支持通过<code>粗体</code>、<code>设置字体大小</code>等方式提高支持动态文本的应用的易读性。<br>例如<strong><code>UIFont</code></strong>新增的一个方法： <strong><code>preferredFontForTextStyle</code></strong> 用来根据用户对字体大小的设置来自动制定字体样式。<br>下面表格中是六种可用字体样式的示例：<br><img src=\"/images/TextStyles.png\" alt=\"image\"><br>最左边一列是最小字体；中间一列是最大字体；最右边一列是粗体效果。  </p>\n<h3 id=\"使用系统动态字体样式\"><a href=\"#使用系统动态字体样式\" class=\"headerlink\" title=\"使用系统动态字体样式\"></a>使用系统动态字体样式</h3><p>使用动态文本，是通过给<code>文本字体</code>设置字体样式<strong>style</strong>而不是指定具体的<code>字体名称</code>和<code>大小</code>。这样，系统会在运行时自动根据这一样式以及用户的字体大小设置来选择使用合适的字体。</p>\n<h4 id=\"preferredFontForTextStyle-方法设置字体样式\"><a href=\"#preferredFontForTextStyle-方法设置字体样式\" class=\"headerlink\" title=\"preferredFontForTextStyle:方法设置字体样式\"></a><code>preferredFontForTextStyle:</code>方法设置字体样式</h4><ol>\n<li>打开 <code>NoteEditorViewController.m/swift</code> 在<code>viewDidLoad：</code>方法实现的最后面加入以下代码：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.textView.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.textView.font = <span class=\"type\">UIFont</span>.preferredFont(forTextStyle: .body)</span><br></pre></td></tr></table></figure></li>\n<li>打开 <code>NotesListViewController.m/swift</code> 在 <code>tableView:cellForRowAtIndexPath:</code> 方法中增加如下代码:<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cell.textLabel.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleHeadline</span>];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cell.textLabel?.font = <span class=\"type\">UIFont</span>.preferredFont(forTextStyle: .headline)</span><br></pre></td></tr></table></figure>\n上面两行代码都用到了新版iOS的字体样式.   <blockquote>\n<p>字体样式：通过语义法命名字体，例如 <code>UIFontTextStyleSubHeadline</code>, 可以避免在代码里每一处都指定具体的字体名称和样式， 而且确保app能对用户的字体大小设置做出恰当的回应。</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"APP响应用户字体设置\"><a href=\"#APP响应用户字体设置\" class=\"headerlink\" title=\"APP响应用户字体设置\"></a>APP响应用户字体设置</h4><ol>\n<li>设置系统字体<br>返回到<strong>通用-&gt;文字大小</strong>重新修改字体设置.<br>再运行App, <strong>Note</strong>页面的文字大小是当前设定的字体大小；前后截屏对比,分辨率小了一半。<br><img src=\"/images/NotepadWithDynamicType.png\" alt=\"image\"> </li>\n<li>设置系统字体生效<br>当我们返回到<strong>通用-&gt;文字大小</strong>重新修改字体设置. 再打开<strong>Note</strong>页面, 会发现app并没有<strong>立即</strong>对字体设置的变化做出相应反应。</li>\n</ol>\n<h5 id=\"监听系统通知：实现APP响应用户字体设置\"><a href=\"#监听系统通知：实现APP响应用户字体设置\" class=\"headerlink\" title=\"监听系统通知：实现APP响应用户字体设置\"></a>监听系统通知：实现APP响应用户字体设置</h5><p>当用户修改了他们的字体大小设置之后，这一样式对应的字体并不会自动更新，必须重新请求才能获取新的值。用户设置变化后，<code>preferredFontForTextStyle:</code>方法返回的字体也会变化。</p>\n<ol>\n<li>添加监听系统通知<code>UIContentSizeCategoryDidChangeNotification</code>通知APP响应用户字体设置的变化<br>打开 <code>NoteEditorViewController.m</code> 并在 <code>viewDidLoad</code> 方法的实现的最后加入以下代码：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter]</span><br><span class=\"line\">                              addObserver:<span class=\"keyword\">self</span></span><br><span class=\"line\">                                 selector:<span class=\"keyword\">@selector</span>(preferredContentSizeChanged:)</span><br><span class=\"line\">                                     name:<span class=\"built_in\">UIContentSizeCategoryDidChangeNotification</span></span><br><span class=\"line\">                                   object:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//字体变化通知:调用preferredContentSizeChanged:方法</span></span><br><span class=\"line\"><span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(<span class=\"keyword\">self</span>, selector: #selector(<span class=\"type\">NoteEditorViewController</span>.preferredContentSizeChanged(<span class=\"number\">_</span>:)), name: <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>.<span class=\"type\">UIContentSizeCategoryDidChange</span>, object: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure></li>\n<li>添加系统通知响应事件<br>收到用于指定本类接收字体设定变化的通知后，调用<code>preferredContentSizeChanged:</code>方法<br>在<code>NoteEditorViewController.m</code>中<code>viewDidLoad</code>方法之后紧接着添加以下方法：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)preferredContentSizeChanged:(<span class=\"built_in\">NSNotification</span> *)notification</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.textView.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//字体变化通知时调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">preferredContentSizeChanged</span><span class=\"params\">(<span class=\"number\">_</span> notification:NSNotification)</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.textView.font = <span class=\"type\">UIFont</span>.preferredFont(forTextStyle: .body)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n这一方法作用是根据新的字体设置来设定<code>textView</code>中的字体。<br>Build并运行app，修改字体大小设置，Note页面就可以即时更新字体大小了。<a id=\"more\"></a>\n</li>\n</ol>\n<h3 id=\"更新布局\"><a href=\"#更新布局\" class=\"headerlink\" title=\"更新布局\"></a>更新布局</h3><p>现在，如果你把字体设置到很小，那每个单元格的空白区域是不是太多了，看上去文字比较稀疏，如下面所示：<br>  <img src=\"/images/ChangingLayout.png\" alt=\"image\">  </p>\n<p>这是<strong>动态样式</strong>有点小复杂的部分：要保证App在字体大小变化后，同时也修改文字表格的行高。<br>在<code>NotesListViewController.m</code>中实现<code>tableView:heightForRowAtIndexPath:</code> 代理方法:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">UILabel</span>* label;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!label) &#123;</span><br><span class=\"line\">        label = [[<span class=\"built_in\">UILabel</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, FLT_MAX, FLT_MAX)];</span><br><span class=\"line\">        label.text = <span class=\"string\">@\"test\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    label.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleHeadline</span>];</span><br><span class=\"line\">    [label sizeToFit];  <span class=\"comment\">//自适应文本内容大小</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> label.frame.size.height * <span class=\"number\">1.7</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, heightForRowAt indexPath: IndexPath)</span></span> -&gt; <span class=\"type\">CGFloat</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> label = <span class=\"type\">UILabel</span>.<span class=\"keyword\">init</span>(frame: <span class=\"type\">CGRect</span>.<span class=\"keyword\">init</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"type\">FLT_MAX</span>, height: <span class=\"type\">FLT_MAX</span>))</span><br><span class=\"line\">    label.text = <span class=\"string\">\"test\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> font = <span class=\"type\">UIFont</span>.preferredFont(forTextStyle: .headline)</span><br><span class=\"line\">    label.font = font</span><br><span class=\"line\">    label.sizeToFit()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> label.frame.size.height * <span class=\"number\">1.7</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上代码创建了一个共享的——或者说静态的——<strong>UILabel</strong>实例，设定它的字体和表中单元格内文本字体一致。然后调用它的<code>sizeToFit</code>方法，使这个<code>label</code>的<code>frame</code>恰好能放得下它的内容文字, 然后把这个<code>label</code>的高度乘个<code>1.7</code>作为表内单元格高度。<br>Build并运行app，修改字体大小设置，行高也会随着字体大小的变化而变化。 如下图所示：<br><img src=\"/images/TableViewAdaptsHeights.png\" alt=\"image\">  </p>\n<h3 id=\"凸版印刷效果（Letterpress-effects）\"><a href=\"#凸版印刷效果（Letterpress-effects）\" class=\"headerlink\" title=\"凸版印刷效果（Letterpress effects）\"></a>凸版印刷效果（Letterpress effects）</h3><p>凸版印刷效果（Letterpress effects）给文字加上精致的阴影和高光是文字看上去有一定立体感——就好像轻轻嵌入屏幕里一样。  </p>\n<blockquote>\n<font size=\"3\">注: 使用“凸版印刷（letterpress）”这一印刷术语是向早期印刷业的致敬。所谓凸版印刷，就是将涂上油墨的图文凸版嵌在印版上，然后在纸面上按压就把图文凸版上的油墨转移到纸面上了——纸面受力在文字边缘形成好看的突起。现在这一工艺已广泛被数码打印所取代。</font>  \n\n</blockquote>\n<p>打开NotesListViewController.m 将<code>tableView:cellForRowAtIndexPath:</code>方法中的代码用以下代码替换:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">NSString</span> *CellIdentifier = <span class=\"string\">@\"Cell\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier </span><br><span class=\"line\">                                                        forIndexPath:indexPath];</span><br><span class=\"line\">Note* note = [<span class=\"keyword\">self</span> notes][indexPath.row];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UIFont</span>* font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleHeadline</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UIColor</span>* textColor = [<span class=\"built_in\">UIColor</span> colorWithRed:<span class=\"number\">0.175</span>f green:<span class=\"number\">0.458</span>f blue:<span class=\"number\">0.831</span>f alpha:<span class=\"number\">1.0</span>f];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *attrs = @&#123; <span class=\"built_in\">NSForegroundColorAttributeName</span> : textColor,</span><br><span class=\"line\">                                    <span class=\"built_in\">NSFontAttributeName</span> : font,</span><br><span class=\"line\">                              <span class=\"built_in\">NSTextEffectAttributeName</span> : <span class=\"built_in\">NSTextEffectLetterpressStyle</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSAttributedString</span>* attrString = [[<span class=\"built_in\">NSAttributedString</span> alloc]</span><br><span class=\"line\">                                       initWithString:note.title</span><br><span class=\"line\">                                           attributes:attrs];</span><br><span class=\"line\">cell.textLabel.attributedText = attrString;</span><br><span class=\"line\"><span class=\"keyword\">return</span> cell;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class=\"type\">UITableViewCell</span></span><br><span class=\"line\">&#123;    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class=\"string\">\"noteListCell\"</span>, <span class=\"keyword\">for</span>: indexPath)</span><br><span class=\"line\">    <span class=\"comment\">// Configure the cell...</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> note = notes[indexPath.row] <span class=\"keyword\">as</span>! <span class=\"type\">NoteModel</span></span><br><span class=\"line\">    <span class=\"comment\">//cell.textLabel?.text = note.title</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> font = <span class=\"type\">UIFont</span>.preferredFont(forTextStyle: .headline)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> textColor = <span class=\"type\">UIColor</span>.<span class=\"keyword\">init</span>(red: <span class=\"number\">0.175</span>, green: <span class=\"number\">0.458</span>, blue: <span class=\"number\">0.831</span>, alpha: <span class=\"number\">1.0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//字体凸版印刷效果</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> store:[<span class=\"type\">String</span>:<span class=\"type\">Any</span>] = [<span class=\"type\">NSForegroundColorAttributeName</span>:textColor,</span><br><span class=\"line\">    <span class=\"type\">NSFontAttributeName</span>:font,</span><br><span class=\"line\">    <span class=\"type\">NSTextEffectAttributeName</span>:<span class=\"type\">NSTextEffectLetterpressStyle</span>]</span><br><span class=\"line\">    cell.textLabel?.attributedText = <span class=\"type\">NSAttributedString</span>.<span class=\"keyword\">init</span>(string: note.title, attributes: store)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cell</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码为单元格的标题创建了一个使用了凸版印刷效果的<strong><code>NSAttributedString</code></strong>。  </p><p><br>Build并运行app， 表格将显示凸版印刷效果，如下图所示：<br><img src=\"/images/Letterpress.png\" alt=\"image\"><br>凸版印刷效果是很精巧——但是并不表示你可以随意过度使用它。视觉特效能让文字看上去更有趣，但并不表示一定能让你的文字更清晰易读。</p>\n<h3 id=\"环绕路径（Exclusion-paths）\"><a href=\"#环绕路径（Exclusion-paths）\" class=\"headerlink\" title=\"环绕路径（Exclusion paths）\"></a>环绕路径（Exclusion paths）</h3><p>文字环绕图片或其它内容分布是大多数文字处理软件的标准特性之一。<code>Text Kit</code>允许你通过环绕路径（<code>exclusion paths</code>）将文字按照复杂路径和形状分布。  </p>\n<p>在便笺右上角添加一个曲线形视图，告知用户便笺创建的日期：   </p>\n<ul>\n<li>首先添加一个视图  </li>\n<li>创建一个环绕路径，使文字按照这个路径分布。 </li>\n</ul>\n<h4 id=\"添加视图\"><a href=\"#添加视图\" class=\"headerlink\" title=\"添加视图\"></a>添加视图</h4><p>打开 <code>NoteEditorViewController.m</code> 在顶部的<code>imports</code>和接口实现中添加变量加入以下代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"TimeIndicatorView.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NoteEditorViewController</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TimeIndicatorView* _timeView;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>实例化这个用以显示文本创建日期的视图实例，并把它作为一个子视图添加进去<br>在NoteEditorViewController.m的<code>viewDidLoad</code>方法的最后添加以下代码：<br><figure class=\"highlight objc\"><figcaption><span>objc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_timeView = [[TimeIndicatorView alloc] initWithDate:_note.timestamp];</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:_timeView];</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"设置视图位置及自动适应布局：viewDidLayoutSubviews\"><a href=\"#设置视图位置及自动适应布局：viewDidLayoutSubviews\" class=\"headerlink\" title=\"设置视图位置及自动适应布局：viewDidLayoutSubviews\"></a>设置视图位置及自动适应布局：<code>viewDidLayoutSubviews</code></h4><p>当<strong>NoteEditor</strong>视图的控件调用系统方法<code>viewDidLayoutSubviews</code>方法，对子视图进行布局时，<code>TimeIndicatorView</code>作为子控件也需要有相应的变化。<br>在控件接收到文本内容的尺寸发生了变化的时候调用<code>updateTimeIndicatorFrame</code>： </p>\n<ol>\n<li>第一调用<code>updateSize</code>来设定<code>_timeView</code>的尺寸  </li>\n<li>第二将<code>_timeView</code>放在右上角<br>在NoteEditorViewController.m 的最后添加如下代码：<figure class=\"highlight objc\"><figcaption><span>objc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLayoutSubviews </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> updateTimeIndicatorFrame];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)updateTimeIndicatorFrame</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [_timeView updateSize];</span><br><span class=\"line\">    _timeView.frame = <span class=\"built_in\">CGRectOffset</span>(_timeView.frame,</span><br><span class=\"line\">                          <span class=\"keyword\">self</span>.view.frame.size.width - _timeView.frame.size.width, <span class=\"number\">0.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//视图的控件调用viewDidLayoutSubviews对子视图进行布局时，TimeIndicatorView作为子控件也需要有相应的变化。</span></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLayoutSubviews</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    updateTimeIndicatorFrame()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">updateTimeIndicatorFrame</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//第一调用updateSize来设定_timeView的尺寸</span></span><br><span class=\"line\">    timeIndicatorView.updateSize()</span><br><span class=\"line\">    <span class=\"comment\">//通过偏移frame参数，将timeIndicatorView放在右上角</span></span><br><span class=\"line\">    timeIndicatorView.frame = timeIndicatorView.frame.offsetBy(dx: ibTextView.frame.width - timeIndicatorView.frame.width,</span><br><span class=\"line\">                                                               dy: <span class=\"number\">0.0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"响应系统偏好设置字体样式\"><a href=\"#响应系统偏好设置字体样式\" class=\"headerlink\" title=\"响应系统偏好设置字体样式\"></a>响应系统偏好设置字体样式</h4><p>修改<code>NoteEditorViewController.m</code>中<code>preferredContentSizeChanged:</code>方法如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)preferredContentSizeChanged:(<span class=\"built_in\">NSNotification</span> *)n </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.textView.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> updateTimeIndicatorFrame];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>Build并运行app，点击选择一个便笺，日期显示视图将出现在右上角，如下图所示：<br><img src=\"/images/TimIndicator.png\" alt=\"修改设备中文本大小设置，这个视图也将自动调整到相应的合适尺寸\">    </p>\n<h3 id=\"文本环绕视图\"><a href=\"#文本环绕视图\" class=\"headerlink\" title=\"文本环绕视图\"></a>文本环绕视图</h3><ol>\n<li>根据日期视图<code>_timeView</code>创建基于贝赛尔路径的环绕路径</li>\n<li>设置文本容器的环绕路径：使用文本容器的exclusionPaths属性指定。它是一个UIBezierPath数组类型。</li>\n</ol>\n<h4 id=\"curvePathWithOrigin-创建文本容器的赛尔路径\"><a href=\"#curvePathWithOrigin-创建文本容器的赛尔路径\" class=\"headerlink\" title=\"curvePathWithOrigin:创建文本容器的赛尔路径\"></a>curvePathWithOrigin:创建文本容器的赛尔路径</h4><p>根据日期视图<code>_timeView</code>创建基于贝赛尔路径的环绕路径<br>添加<code>curvePathWithOrigin:</code>方法，定义文本遵循的环绕路径：<br><figure class=\"highlight objc\"><figcaption><span>objc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIBezierPath</span> *)curvePathWithOrigin:(<span class=\"built_in\">CGPoint</span>)origin</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">UIBezierPath</span> bezierPathWithArcCenter:origin</span><br><span class=\"line\">                                          radius: [<span class=\"keyword\">self</span> radiusToSurroundFrame:_label.frame]</span><br><span class=\"line\">                                      startAngle: <span class=\"number\">-180.0</span>f</span><br><span class=\"line\">                                        endAngle: <span class=\"number\">180.0</span>f</span><br><span class=\"line\">                                       clockwise: <span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">curvePathWithOrigin</span><span class=\"params\">(origin:CGPoint)</span></span>-&gt;<span class=\"type\">UIBezierPath</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//画弧形</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = <span class=\"type\">UIBezierPath</span>.<span class=\"keyword\">init</span>(arcCenter: origin,</span><br><span class=\"line\">    radius: radiusToSurroundFrame(frame: timeLabel.frame),</span><br><span class=\"line\">                             startAngle: -<span class=\"number\">180</span>,                <span class=\"comment\">//-180.0</span></span><br><span class=\"line\">                               endAngle: <span class=\"number\">180.0</span>,               <span class=\"comment\">//CGFloat(M_PI * 2),   //180.0</span></span><br><span class=\"line\">                              clockwise: <span class=\"literal\">true</span>)</span><br><span class=\"line\">    <span class=\"comment\">//        UIColor.blueColor().set()</span></span><br><span class=\"line\">    <span class=\"comment\">//        path.fill()</span></span><br><span class=\"line\">    <span class=\"comment\">//        UIColor.blueColor().set()</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> path</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"设置文本容器的环绕路径：exclusionPaths\"><a href=\"#设置文本容器的环绕路径：exclusionPaths\" class=\"headerlink\" title=\"设置文本容器的环绕路径：exclusionPaths\"></a>设置文本容器的环绕路径：exclusionPaths</h4><p><code>exclusionPaths</code>是<code>NSArray</code>类型，因此一个文本容器是可以支持多个环绕路径，文本<strong>环绕路径</strong>发生改变后会通知文本管理器，然后<strong>环绕路径</strong>的变化就可以动态地，甚至是动画式地体现到文本上！<br>在<code>updateTimeIndicatorFrame</code>方法实现的最后面添加如下代码：<br><figure class=\"highlight objc\"><figcaption><span>objc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIBezierPath</span>* exclusionPath = [_timeView curvePathWithOrigin:_timeView.center];</span><br><span class=\"line\">    _textView.textContainer.exclusionPaths  = @[exclusionPath];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> exclusionPath = timeIndicatorView.curvePathWithOrigin(origin: timeIndicatorView.center)</span><br><span class=\"line\">    ibTextView.textContainer.exclusionPaths = [exclusionPath]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>Build并运行app，选择一个便笺项，如下图所示：<br><img src=\"/images/ExclusionPath.png\" alt=\"实现文本环绕效果\">  </p>\n<h2 id=\"动态文本格式及存储（Dynamic-text-formatting-and-storage）\"><a href=\"#动态文本格式及存储（Dynamic-text-formatting-and-storage）\" class=\"headerlink\" title=\"动态文本格式及存储（Dynamic text formatting and storage）\"></a>动态文本格式及存储（Dynamic text formatting and storage）</h2><p>你已经看到了<code>Text Kit</code>可以根据用户设置的字体大小动态地调整字体。但是如果字体也可以根据实际的文字本身来进行动态更新是不是会更酷呢？<br>实现类似markdown语法的效果：  </p>\n<ul>\n<li>把波浪线(~)之间的文本变为艺术字体  </li>\n<li>把下划线(_)之间的文本变为斜体  </li>\n<li>为破折号(-)之间的文本添加删除线  </li>\n<li>把字母全部大写的单词变为红色<br><img src=\"/images/DynamicTextExample.png\" alt=\"利用Text Kit framework来实现的效果\">   </li>\n</ul>\n<h3 id=\"Text-Kit文本系统工作机制\"><a href=\"#Text-Kit文本系统工作机制\" class=\"headerlink\" title=\"Text Kit文本系统工作机制\"></a>Text Kit文本系统工作机制</h3><p><code>Text Kit 堆栈</code>存储、处理以及显示文本：<br><img src=\"/images/TextKitStack-443x320.png\" alt=\"image\"><br>当你创建<code>UITextView</code>, <code>UILabel</code> or <code>UITextField</code>的时候，Apple系统自动在后台帮你创建了这些类。你可以使用这些默认的实现或者是自定义一部分，以便达到想要的效果。</p>\n<ul>\n<li><strong><code>NSTextStorage</code>文本存储器</strong>: 作为一个<code>NSMutableAttributedString</code>的子类，动态处理的文本可以通过<code>attributedString</code>的方式存储，并且将文本内容的任何变化都通知给布局管理器。可以自定义<code>NSTextStorage</code>的子类，当文本发生变化时，动态地对文本属性做出相应改变。  </li>\n<li><strong><code>NSLayoutManager</code>布局引擎</strong>: 获取存储的文本并经过修饰处理再显示在屏幕上； </li>\n<li><strong><code>NSTextContainer</code>文本容器</strong>: 描述所要处理的文本在屏幕上的位置信息。每一个文本容器都有一个关联的<code>UITextView</code>. 可以创建 <code>NSTextContainer</code>的子类来定义<strong>一个复杂的形状</strong>，然后在这个形状内处理文本。  </li>\n</ul>\n<h3 id=\"NSTextStorage文本存储器动态添加文本属性\"><a href=\"#NSTextStorage文本存储器动态添加文本属性\" class=\"headerlink\" title=\"NSTextStorage文本存储器动态添加文本属性\"></a><code>NSTextStorage</code>文本存储器动态添加文本属性</h3><ol>\n<li>需要创建一个<code>NSTextStorage</code>的子类，用以在用户输入文本的时候，动态地添加文本属性。</li>\n<li>将<code>UITextView</code>的默认文本存储器,用自定义的实现替换掉。</li>\n</ol>\n<h4 id=\"创建文本存储器NSTextStorage子类\"><a href=\"#创建文本存储器NSTextStorage子类\" class=\"headerlink\" title=\"创建文本存储器NSTextStorage子类\"></a>创建文本存储器NSTextStorage子类</h4><p>新建<strong><code>NSTextStorage</code></strong>的子类，类命名为<strong><code>SyntaxHighlightTextStorage</code></strong><br>打开<strong>SyntaxHighlightTextStorage.m</strong>并添加实例变量并初始化：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"SyntaxHighlightTextStorage.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">SyntaxHighlightTextStorage</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableAttributedString</span> *\t_backingStore;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _backingStore = [<span class=\"built_in\">NSMutableAttributedString</span> new];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyntaxHighlightTextStorage</span>: <span class=\"title\">NSTextStorage</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//文本存储器子类必须提供它自己的“数据持久化层”。</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> backingStore = <span class=\"type\">NSMutableAttributedString</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"重载文本存储器的数据持久化层方法\"><a href=\"#重载文本存储器的数据持久化层方法\" class=\"headerlink\" title=\"重载文本存储器的数据持久化层方法\"></a>重载文本存储器的数据持久化层方法</h4><p>要使用<strong><code>NSMutableAttributedString</code></strong>作为“后台存储” (后面会详细讲解)，文本存储器子类必须提供它自己的“数据持久化层”：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)string</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [_backingStore string];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSDictionary</span> *)attributesAtIndex:(<span class=\"built_in\">NSUInteger</span>)location</span><br><span class=\"line\">                     effectiveRange:(<span class=\"built_in\">NSRangePointer</span>)range</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [_backingStore attributesAtIndex:location</span><br><span class=\"line\">                             effectiveRange:range];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">var</span> string: <span class=\"type\">String</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> backingStore.string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">attributes</span><span class=\"params\">(at location: Int, effectiveRange range: NSRangePointer?)</span></span> -&gt; [<span class=\"type\">String</span> : <span class=\"type\">Any</span>]</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> range == <span class=\"literal\">nil</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [:]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//print(\"backingStore:location\\(location),effectiveRange:\\(range!)\")</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> backingStore.attributes(at: location, effectiveRange: range!)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>上面两个方法直接把任务代理给了后台存储。  </p>\n<h4 id=\"重载编辑文本时通知布局管理器的方法\"><a href=\"#重载编辑文本时通知布局管理器的方法\" class=\"headerlink\" title=\"重载编辑文本时通知布局管理器的方法\"></a>重载编辑文本时通知布局管理器的方法</h4><p>同样的，这些方法也是把任务代理给后台存储。它们通过调用<code>beginEditing</code> / <code>edited</code> / <code>endEditing</code>这些方法来完成一些编辑任务。这样做是为了在编辑发生后让文本存储器的类通知相关的布局管理器。<br>最后，还在这个文件中，重载以下方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)replaceCharactersInRange:(<span class=\"built_in\">NSRange</span>)range withString:(<span class=\"built_in\">NSString</span> *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"replaceCharactersInRange:%@ withString:%@\"</span>, <span class=\"built_in\">NSStringFromRange</span>(range), str);</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> beginEditing];</span><br><span class=\"line\">    [_backingStore replaceCharactersInRange:range withString:str];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> edited:<span class=\"built_in\">NSTextStorageEditedCharacters</span> | <span class=\"built_in\">NSTextStorageEditedAttributes</span></span><br><span class=\"line\">              range:range</span><br><span class=\"line\">     changeInLength:str.length - range.length];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> endEditing];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setAttributes:(<span class=\"built_in\">NSDictionary</span> *)attrs range:(<span class=\"built_in\">NSRange</span>)range</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"setAttributes:%@ range:%@\"</span>, attrs, <span class=\"built_in\">NSStringFromRange</span>(range));</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> beginEditing];</span><br><span class=\"line\">    [_backingStore setAttributes:attrs range:range];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> edited:<span class=\"built_in\">NSTextStorageEditedAttributes</span> range:range changeInLength:<span class=\"number\">0</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> endEditing];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">replaceCharacters</span><span class=\"params\">(<span class=\"keyword\">in</span> range: NSRange, with str: String)</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"replaceCharactersInRange:\\(NSStringFromRange(range)) withString:\\(str)\"</span>)</span><br><span class=\"line\">    beginEditing()</span><br><span class=\"line\">    backingStore.replaceCharacters(<span class=\"keyword\">in</span>: range, with: str)</span><br><span class=\"line\">    edited([.editedAttributes,.editedCharacters], range: range, changeInLength: str.utf16.<span class=\"built_in\">count</span> - range.length)</span><br><span class=\"line\">    endEditing()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setAttributes</span><span class=\"params\">(<span class=\"number\">_</span> attrs: [String : Any]?, range: NSRange)</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//Sets the attributes for the characters in the specified range to the specified attributes.</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"setAttributes:\\(attrs!) range:\\(NSStringFromRange(range))\"</span>)</span><br><span class=\"line\">    beginEditing()</span><br><span class=\"line\">    backingStore.setAttributes(attrs!, range: range)</span><br><span class=\"line\">    edited(.editedAttributes, range: range, changeInLength: <span class=\"number\">0</span>)</span><br><span class=\"line\">    endEditing()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"类族介绍\"><a href=\"#类族介绍\" class=\"headerlink\" title=\"类族介绍\"></a>类族介绍</h4><p>类族是Apple的framework中广泛用到的一种设计模式。类族就是抽象工厂模式的实现，无需指定具体的类就可以为创建一族相关或从属的对象提供一个公共接口。一些我们很熟悉的类<code>NSArray</code>和<code>NSNumber</code>类似的就是一族类的公共接口。</p>\n<p>上例中<code>NSTextStorage</code>文本存储器就是一个类族的公共接口，需要大量代码来创建文本存储器的子类。在扩展功能时，通过创建子类及重载几个方法之外，有些特定需求是要自己实现的，比方<code>attributedString</code>数据的后台存储。</p>\n<p>Apple使用类族来封装同一个公共<code>抽象超类</code>下的私有具体子类，<code>抽象超类</code>声明了客户在创建<code>私有子类实例</code>时必须要实现的方法。客户是完全无法知道工厂正在用哪一个私有类，它只和公共接口相互协作。<br>使用类族当然可以简化接口，使学习和使用类更加容易，但是必须要需要指出的是要在功能扩展和接口简化之间达到平衡。创建一个类族的抽象超类的定制子类也常常是非常难的。 </p>\n<h3 id=\"创建UITextView使用自定义Text-Kit堆栈\"><a href=\"#创建UITextView使用自定义Text-Kit堆栈\" class=\"headerlink\" title=\"创建UITextView使用自定义Text Kit堆栈\"></a>创建UITextView使用自定义Text Kit堆栈</h3><p>现在有了一个自定义的<code>NSTextStorage</code>，还需创建一个<code>UITextView</code>来使用它。 </p>\n<h4 id=\"storyboard创建UITextView时，Text-Kit组件只读问题\"><a href=\"#storyboard创建UITextView时，Text-Kit组件只读问题\" class=\"headerlink\" title=\"storyboard创建UITextView时，Text Kit组件只读问题\"></a>storyboard创建UITextView时，Text Kit组件只读问题</h4><p>从<strong>storyboard</strong>编辑器实例化<code>UITextView</code>会自动创建<strong><code>NSTextStorage</code></strong>, <strong><code>NSLayoutManager</code></strong>和<strong><code>NSTextContainer</code></strong> (例如<strong>Text Kit</strong>堆栈)实例以及所有的这三个只读属性。<br>虽然没有办法从<strong>storyboard</strong>编辑器中改变这种设定，但可以手动编程创建<code>UITextView</code>和<strong>Text Kit</strong>堆栈。  </p>\n<h4 id=\"在UITextView中使用自定义的SyntaxHighlightTextStorage\"><a href=\"#在UITextView中使用自定义的SyntaxHighlightTextStorage\" class=\"headerlink\" title=\"在UITextView中使用自定义的SyntaxHighlightTextStorage\"></a>在UITextView中使用自定义的SyntaxHighlightTextStorage</h4><h5 id=\"清理IB相关设置\"><a href=\"#清理IB相关设置\" class=\"headerlink\" title=\"清理IB相关设置\"></a>清理IB相关设置</h5><ul>\n<li>在IB中打开<strong>Main.storyboard</strong> 找到<strong>NoteEditorViewController</strong>。 删除<code>UITextView</code>实例。<br>然后，打开<strong>NoteEditorViewController.m</strong>删除<strong>UITextView outlet</strong>。<br>既然不再为文本视图使用<code>IBOutlet</code>，而是要编程添加，所以也就不需要这些代码了。<br>从<code>viewDidLoad</code> 方法中删除以下代码：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.textView.text = <span class=\"keyword\">self</span>.note.contents;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.textView.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.textView.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"手动创建UITextView和Text-Kit堆栈\"><a href=\"#手动创建UITextView和Text-Kit堆栈\" class=\"headerlink\" title=\"手动创建UITextView和Text Kit堆栈\"></a>手动创建<code>UITextView</code>和Text Kit堆栈</h5><ul>\n<li>在<strong>NoteEditorViewController.m</strong>最上面，添加下面一行代码:<figure class=\"highlight objc\"><figcaption><span>objc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"SyntaxHighlightTextStorage.h\"</span></span></span><br></pre></td></tr></table></figure>\n在NoteEditorViewController.m中<code>TimeIndicatorView</code>实例变量后面紧接着添加以下代码：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SyntaxHighlightTextStorage* _textStorage;</span><br><span class=\"line\"><span class=\"built_in\">UITextView</span>* _textView;</span><br></pre></td></tr></table></figure>\n文本存储器子类有两个实例变量，还有一个文本视图稍后需要添加。  </li>\n</ul>\n<h5 id=\"创建Text-Kit堆栈\"><a href=\"#创建Text-Kit堆栈\" class=\"headerlink\" title=\"创建Text Kit堆栈\"></a>创建<code>Text Kit</code>堆栈</h5><ul>\n<li>创建自定义的<code>NSTextStorage</code>文本存储器实例，一个用来承载便笺内容的<code>NSAttributedString</code>  </li>\n<li>创建一个<code>NSLayoutManager</code>布局管理器，并添加到文本存储器。</li>\n<li>创建一个<code>NSTextContainer</code>文本容器，并添加到布局管理器。然后把布局管理器和文本存储器联系起来  </li>\n<li>最后用你自定义的文本容器和代理组创建实际的文本视图，  并把文本视图添加为子视图<br>在NoteEditorViewController.m中，添加下面方法：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)createTextView</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. Create the text storage that backs the editor</span></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* attrs = @&#123;<span class=\"built_in\">NSFontAttributeName</span>:</span><br><span class=\"line\">        [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>]&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">NSAttributedString</span>* attrString = [[<span class=\"built_in\">NSAttributedString</span> alloc]</span><br><span class=\"line\">                                   initWithString:_note.contents</span><br><span class=\"line\">                                       attributes:attrs];</span><br><span class=\"line\">    _textStorage = [SyntaxHighlightTextStorage new];</span><br><span class=\"line\">    [_textStorage appendAttributedString:attrString];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CGRect</span> newTextViewRect = <span class=\"keyword\">self</span>.view.bounds;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. Create the layout manager</span></span><br><span class=\"line\">    <span class=\"built_in\">NSLayoutManager</span> *layoutManager = [[<span class=\"built_in\">NSLayoutManager</span> alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. Create a text container</span></span><br><span class=\"line\">    <span class=\"built_in\">CGSize</span> containerSize = <span class=\"built_in\">CGSizeMake</span>(newTextViewRect.size.width,  <span class=\"built_in\">CGFLOAT_MAX</span>);</span><br><span class=\"line\">    <span class=\"built_in\">NSTextContainer</span> *container = [[<span class=\"built_in\">NSTextContainer</span> alloc] initWithSize:containerSize];</span><br><span class=\"line\">    container.widthTracksTextView = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    [layoutManager addTextContainer:container];</span><br><span class=\"line\">    [_textStorage addLayoutManager:layoutManager];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4. Create a UITextView</span></span><br><span class=\"line\">    _textView = [[<span class=\"built_in\">UITextView</span> alloc] initWithFrame:newTextViewRect</span><br><span class=\"line\">                                    textContainer:container];</span><br><span class=\"line\">    _textView.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:_textView];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建文本区域</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createTextView</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. Create the text storage that backs the editor</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bodyFont = <span class=\"type\">UIFont</span>.preferredFont(forTextStyle: <span class=\"type\">UIFontTextStyle</span>.body)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> attrs = [<span class=\"type\">NSFontAttributeName</span>:bodyFont]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> attrString = <span class=\"type\">NSAttributedString</span>(string: note.contents,attributes: attrs)</span><br><span class=\"line\">    textStorage = <span class=\"type\">SyntaxHighlightTextStorage</span>()</span><br><span class=\"line\">    textStorage.append(attrString)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// --------使用Storyboard声明TextView时,只需一行，可惜为只读属性----------</span></span><br><span class=\"line\">    textStorage.addLayoutManager(ibTextView.layoutManager)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**--------使用代码声明TextView时，4步骤----------</span></span><br><span class=\"line\"><span class=\"comment\">    let newTextViewRect = view.bounds</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    // 2. Create the layout manager</span></span><br><span class=\"line\"><span class=\"comment\">    let layoutManager = NSLayoutManager()</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    // 3. Create a text container</span></span><br><span class=\"line\"><span class=\"comment\">    //文本容器的宽度会自动匹配视图的宽度，但是它的高度是无限高的——或者说无限接近于CGFloat.max，它的值可以是无限大。</span></span><br><span class=\"line\"><span class=\"comment\">    let containerSize = CGSize.init(width: newTextViewRect.size.width,</span></span><br><span class=\"line\"><span class=\"comment\">    height: CGFloat.greatestFiniteMagnitude)</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    let container = NSTextContainer.init(size: containerSize)</span></span><br><span class=\"line\"><span class=\"comment\">    //A Boolean that controls whether the receiver adjusts the width of its bounding rectangle when its text view is resized.</span></span><br><span class=\"line\"><span class=\"comment\">    container.widthTracksTextView = true</span></span><br><span class=\"line\"><span class=\"comment\">    //</span></span><br><span class=\"line\"><span class=\"comment\">    layoutManager.addTextContainer(container)</span></span><br><span class=\"line\"><span class=\"comment\">    textStorage.addLayoutManager(layoutManager)</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    // 4. Create a UITextView</span></span><br><span class=\"line\"><span class=\"comment\">    textView = UITextView()//.init(frame: newTextViewRect, textContainer: container)</span></span><br><span class=\"line\"><span class=\"comment\">    textView.isScrollEnabled = true</span></span><br><span class=\"line\"><span class=\"comment\">    textView.delegate = self</span></span><br><span class=\"line\"><span class=\"comment\">    view.addSubview(textView)</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>现在回顾之前那个图表所展示的四个关键类(文本存储器<code>storage</code>, 布局管理器<code>layout manager</code>, 文本容器<code>container</code> 和文本视图<code>textView</code>)之间的关系，是不是觉得理解起来容易多了。<br><img src=\"/images/TextKitStack-443x320.png\" alt=\"image\"></p>\n<blockquote>\n<font size=\"3\">注意:文本容器的宽度会自动匹配视图的宽度，但是它的高度是无限高的——或者说无限接近于<code>CGFLOAT_MAX</code>，它的值可以是无限大。不管怎么说，它的高度足够让<code>UITextView</code>上下滚动以容纳很长的文本。</font>    \n\n</blockquote>\n<p>在<code>viewDidLoad</code>方法中调用超类的<code>viewDidLoad</code>方法的语句后面添加以下一行代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span> createTextView];</span><br></pre></td></tr></table></figure><br>然后修改<code>preferredContentSizeChanged</code>的第一行代码为：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_textView.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"自定义视图实现在storyboard中自动布局约束的效果\"><a href=\"#自定义视图实现在storyboard中自动布局约束的效果\" class=\"headerlink\" title=\"自定义视图实现在storyboard中自动布局约束的效果\"></a>自定义视图实现在<code>storyboard</code>中自动布局约束的效果</h5><p>用自定义的实例变量来替换掉旧的<code>outlet</code>属性。自定义视图不会自动继承<code>storyboard</code>中的布局约束组的规则。当设备方向变化后，视图的边界是不会自动随之改变的，这样就需要自己来编程设定视图边界。  </p>\n<p>可以在<code>viewDidLayoutSubviews</code>方法的最后添加以下代码来实现：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_textView.frame = <span class=\"keyword\">self</span>.view.bounds;</span><br></pre></td></tr></table></figure><br>Build并运行app，打开一个便笺项，在Xcode控制台上有<code>SyntaxHighlightTextStorage</code>生成的运行日志，用来告诉你这些文本处理的代码确实被调用：<br><img src=\"/images/LogMessages-480x266.png\" alt=\"image\"><br>看来你的文本解析器的基础非常可靠了 —— 那现在来添加动态格式。</p>\n<h3 id=\"通过正则修改文本存储器的动态格式（Dynamic-formatting）\"><a href=\"#通过正则修改文本存储器的动态格式（Dynamic-formatting）\" class=\"headerlink\" title=\"通过正则修改文本存储器的动态格式（Dynamic formatting）\"></a>通过正则修改文本存储器的动态格式（Dynamic formatting）</h3><p>接下来将对你的自定义文本存储器进行修改以将＊星号符之间的文本＊变为黑体：</p>\n<h4 id=\"processEditing：将文本的变化通知给布局管理器\"><a href=\"#processEditing：将文本的变化通知给布局管理器\" class=\"headerlink\" title=\"processEditing：将文本的变化通知给布局管理器\"></a><code>processEditing</code>：将文本的变化通知给布局管理器</h4><p><code>processEditing</code> 将文本的变化通知给布局管理器。它也为文本编辑之后的处理提供便利。<br>打开<strong>SyntaxHighlightTextStorage.m</strong> 添加以下方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)processEditing</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> performReplacementsForRange:[<span class=\"keyword\">self</span> editedRange]];</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> processEditing];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>####<br>NSUnionRange：在range1和range2之间比较，如果一个range完全包含在另一个range内，则返回较大的range<br>上面的代码拓展了受黑体格式类型影响的文本范围。因为<code>changedRange</code>一般只是作用到单独的一个字符； 而<code>lineRangeForRange</code> 则扩展到一整行<br>在 <code>processEditing</code>方法之后紧接着添加以下代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)performReplacementsForRange:(<span class=\"built_in\">NSRange</span>)changedRange</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSRange</span> extendedRange = <span class=\"built_in\">NSUnionRange</span>(changedRange, [[_backingStore string]</span><br><span class=\"line\">                             lineRangeForRange:<span class=\"built_in\">NSMakeRange</span>(changedRange.location, <span class=\"number\">0</span>)]);</span><br><span class=\"line\">    extendedRange = <span class=\"built_in\">NSUnionRange</span>(changedRange, [[_backingStore string] </span><br><span class=\"line\">                          lineRangeForRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"built_in\">NSMaxRange</span>(changedRange), <span class=\"number\">0</span>)]);</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> applyStylesToRange:extendedRange];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在指定的区域中进行替换</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">performReplacementsForRange</span><span class=\"params\">(<span class=\"number\">_</span> changedRange:NSRange)</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//定位正在编辑文本的位置区间</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> locationRange = <span class=\"type\">NSMakeRange</span>(changedRange.location, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//定位到文本当前行的位置区间</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> range1 = (backingStore.string <span class=\"keyword\">as</span> <span class=\"type\">NSString</span>).lineRange(<span class=\"keyword\">for</span>: locationRange)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//扩展范围</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> extendedRange = <span class=\"type\">NSUnionRange</span>(changedRange, range1)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> maxRange = <span class=\"type\">NSMakeRange</span>(<span class=\"type\">NSMaxRange</span>(changedRange), <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> range2 = (backingStore.string <span class=\"keyword\">as</span> <span class=\"type\">NSString</span>).lineRange(<span class=\"keyword\">for</span>: maxRange)</span><br><span class=\"line\">    extendedRange = <span class=\"type\">NSUnionRange</span>(changedRange, range2)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"在指定的区域中进行替换:\\(extendedRange)\"</span>)</span><br><span class=\"line\">    applyStylesToRange(searchRange: extendedRange)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>在 <code>performReplacementsForRange</code>方法之后紧接着添加以下代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)applyStylesToRange:(<span class=\"built_in\">NSRange</span>)searchRange</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. create some fonts</span></span><br><span class=\"line\">    <span class=\"built_in\">UIFontDescriptor</span>* fontDescriptor = [<span class=\"built_in\">UIFontDescriptor</span></span><br><span class=\"line\">                             preferredFontDescriptorWithTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br><span class=\"line\">    <span class=\"built_in\">UIFontDescriptor</span>* boldFontDescriptor = [fontDescriptor</span><br><span class=\"line\">                           fontDescriptorWithSymbolicTraits:<span class=\"built_in\">UIFontDescriptorTraitBold</span>];</span><br><span class=\"line\">    <span class=\"built_in\">UIFont</span>* boldFont =  [<span class=\"built_in\">UIFont</span> fontWithDescriptor:boldFontDescriptor size: <span class=\"number\">0.0</span>];</span><br><span class=\"line\">    <span class=\"built_in\">UIFont</span>* normalFont =  [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. match items surrounded by asterisks</span></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span>* regexStr = <span class=\"string\">@\"(*w+(sw+)**)s\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSRegularExpression</span>* regex = [<span class=\"built_in\">NSRegularExpression</span></span><br><span class=\"line\">                                   regularExpressionWithPattern:regexStr</span><br><span class=\"line\">                                                        options:<span class=\"number\">0</span></span><br><span class=\"line\">                                                          error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* boldAttributes = @&#123; <span class=\"built_in\">NSFontAttributeName</span> : boldFont &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* normalAttributes = @&#123; <span class=\"built_in\">NSFontAttributeName</span> : normalFont &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. iterate over each match, making the text bold</span></span><br><span class=\"line\">    [regex enumerateMatchesInString:[_backingStore string]</span><br><span class=\"line\">              options:<span class=\"number\">0</span></span><br><span class=\"line\">                range:searchRange</span><br><span class=\"line\">           usingBlock:^(<span class=\"built_in\">NSTextCheckingResult</span> *match,</span><br><span class=\"line\">                        <span class=\"built_in\">NSMatchingFlags</span> flags,</span><br><span class=\"line\">                        <span class=\"built_in\">BOOL</span> *stop)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">NSRange</span> matchRange = [match rangeAtIndex:<span class=\"number\">1</span>];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> addAttributes:boldAttributes range:matchRange];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 4. reset the style to the original</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">NSMaxRange</span>(matchRange)+<span class=\"number\">1</span> &lt; <span class=\"keyword\">self</span>.length) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span> addAttributes:normalAttributes</span><br><span class=\"line\">                range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"built_in\">NSMaxRange</span>(matchRange)+<span class=\"number\">1</span>, <span class=\"number\">1</span>)];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码有以下作用：  </p>\n<ol>\n<li>创建一个粗体及一个正常字体并使用字体描述器（<strong>Font descriptors</strong>）来格式化文本。字体描述器能使你无需对字体手动编码来设置字体和样式。  </li>\n<li>创建一个正则表达式来定位星号符包围的文本。例如，在字符串“iOS 7 is *awesome*”中，存储在regExStr中的正则表达式将会匹配并返回文本“*awesome*”。</li>\n<li>对正则表达式匹配到并返回的文本进行枚举并添加粗体属性。  </li>\n</ol>\n<p>将后一个星号符之后的文本都重置为“常规”样式。以保证添加在后一个星号符之后的文本不被粗体风格所影响。</p>\n<blockquote>\n<font size=\"3\">注： 字体描述器（<strong>Font descriptors</strong>）是一种描述性语言，它使你可以通过设置属性来修改字体，或者无需初始化<code>UIFont</code>实例便可获取字体规格的细节。</font>    \n\n</blockquote>\n<p>Build并运行app；向便笺中输入文本，并将其中一个词用星号符包围。这个词将会自动变为黑体，如下面截图所示：<br><img src=\"/images/BoldText.png\" alt=\"image\">  </p>\n<p>##进一步添加样式<br>为限定文本添加风格的基本原则很简单：<strong>使用正则表达式来寻找和替换限定字符，然后用applyStylesToRange来设置想要的文本样式即可。</strong><br>在SyntaxHighlightTextStorage.m中添加以下实例变量：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>) createHighlightPatterns &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIFontDescriptor</span> *scriptFontDescriptor =</span><br><span class=\"line\">      [<span class=\"built_in\">UIFontDescriptor</span> fontDescriptorWithFontAttributes:</span><br><span class=\"line\">          @&#123;<span class=\"built_in\">UIFontDescriptorFamilyAttribute</span>: <span class=\"string\">@\"Zapfino\"</span>&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. base our script font on the preferred body font size</span></span><br><span class=\"line\">    <span class=\"built_in\">UIFontDescriptor</span>* bodyFontDescriptor = [<span class=\"built_in\">UIFontDescriptor</span></span><br><span class=\"line\">      preferredFontDescriptorWithTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSNumber</span>* bodyFontSize = bodyFontDescriptor.</span><br><span class=\"line\">                  fontAttributes[<span class=\"built_in\">UIFontDescriptorSizeAttribute</span>];</span><br><span class=\"line\">    <span class=\"built_in\">UIFont</span>* scriptFont = [<span class=\"built_in\">UIFont</span></span><br><span class=\"line\">              fontWithDescriptor:scriptFontDescriptor size:[bodyFontSize floatValue]];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. create the attributes</span></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* boldAttributes = [<span class=\"keyword\">self</span></span><br><span class=\"line\">     createAttributesForFontStyle:<span class=\"built_in\">UIFontTextStyleBody</span></span><br><span class=\"line\">                        withTrait:<span class=\"built_in\">UIFontDescriptorTraitBold</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* italicAttributes = [<span class=\"keyword\">self</span></span><br><span class=\"line\">     createAttributesForFontStyle:<span class=\"built_in\">UIFontTextStyleBody</span></span><br><span class=\"line\">                        withTrait:<span class=\"built_in\">UIFontDescriptorTraitItalic</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* strikeThroughAttributes = @&#123; <span class=\"built_in\">NSStrikethroughStyleAttributeName</span> : @<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* scriptAttributes = @&#123; <span class=\"built_in\">NSFontAttributeName</span> : scriptFont&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* redTextAttributes =</span><br><span class=\"line\">                          @&#123; <span class=\"built_in\">NSForegroundColorAttributeName</span> : [<span class=\"built_in\">UIColor</span> redColor]&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// construct a dictionary of replacements based on regexes</span></span><br><span class=\"line\">    _replacements = @&#123;</span><br><span class=\"line\">              <span class=\"string\">@\"(\\*w+(sw+)\\*\\*)s\"</span> : boldAttributes,</span><br><span class=\"line\">              <span class=\"string\">@\"(_w+(sw+)\\*_)s\"</span> : italicAttributes,</span><br><span class=\"line\">              <span class=\"string\">@\"([0-9]+.)s\"</span> : boldAttributes,</span><br><span class=\"line\">              <span class=\"string\">@\"(-w+(sw+)\\*-)s\"</span> : strikeThroughAttributes,</span><br><span class=\"line\">              <span class=\"string\">@\"(~w+(sw+)\\*~)s\"</span> : scriptAttributes,</span><br><span class=\"line\">              <span class=\"string\">@\"s([A-Z]&#123;2,&#125;)s\"</span> : redTextAttributes&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个方法的作用：</p>\n<ol>\n<li>首先，它使用Zapfino字体来创建了“<code>script</code>”风格。<strong>Font descriptors</strong>会决定当前正文的首选字体，以保证<code>script</code>不会影响到用户的字体大小设置。  </li>\n<li>然后，它会为每种匹配的字体样式构造各个属性。你稍后将用到 <strong><code>createAttributesForFontStyle:withTrait:</code></strong>。</li>\n<li>最后，它将创建一个<code>NSDictionary</code>并将正则表达式映射到上面声明的属性上。</li>\n</ol>\n<p>如果你对正则表达式不是非常熟悉，上面的的dictionary对你来说可能很陌生。但是，如果你一点一点仔细分析它其中包含的正则表达式，其实不用很费力就能理解了。  </p>\n<p>以上面实现的第一个正则表达式为例，它的工作是匹配星号符包围的文本：<br>(*w+(sw+)**)s<br>上面两个两个相连的斜杠，其中一个是用来将Objective-C中的特殊字符转义成实体字符。去掉用来转义的斜杠，来看下这个正则表达式的核心部分：<br>(*w+(sw+)**)s<br>现在，逐步来分析这个正则表达式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*\t \t \t  ——  匹配星号符  </span><br><span class=\"line\">w+   \t \t —— 后接一个或多个 “word”式 字符串  </span><br><span class=\"line\">(sw+)*\t   —— 后接零个或多组空格然后再接 “word” 式字符串  </span><br><span class=\"line\">*)   \t  —— 后接星号符  </span><br><span class=\"line\">s   \t  —— 以空格结尾  </span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<font size=\"3\">注：如果你想对正则表达式有更多了解，请参考 <a href=\"http://www.raywenderlich.com/30288/nsregularexpression-tutorial-and-cheat-sheet\" target=\"_blank\" rel=\"noopener\">NSRegularExpression tutorial and cheat sheet</a>.</font>  \n\n</blockquote>\n<p>现在你需要调用<code>createHighlightPatterns：</code><br>将<strong>SyntaxHighlightTextStorage.m</strong> 中的<code>init</code>方法更新如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</span><br><span class=\"line\">        _backingStore = [<span class=\"built_in\">NSMutableAttributedString</span> new];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> createHighlightPatterns];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在SyntaxHighlightTextStorage.m方法中添加以下代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSDictionary</span>*)createAttributesForFontStyle:(<span class=\"built_in\">NSString</span>*)style</span><br><span class=\"line\">                                    withTrait:(uint32_t)trait &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIFontDescriptor</span> *fontDescriptor = [<span class=\"built_in\">UIFontDescriptor</span></span><br><span class=\"line\">                               preferredFontDescriptorWithTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">UIFontDescriptor</span> *descriptorWithTrait = [fontDescriptor</span><br><span class=\"line\">                                    fontDescriptorWithSymbolicTraits:trait];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">UIFont</span>* font =  [<span class=\"built_in\">UIFont</span> fontWithDescriptor:descriptorWithTrait size: <span class=\"number\">0.0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> @&#123; <span class=\"built_in\">NSFontAttributeName</span> : font &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码作用是将提供的字体样式作用到正文字体上。它给<code>fontWithDescriptor:size:</code> 提供的<code>size</code>值为0，这样做会迫使<code>UIFont</code>返回用户设置的字体大小。</p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"控件","path":"api/categories/控件.json"}],"tags":[{"name":"TextKit","path":"api/tags/TextKit.json"},{"name":"案例","path":"api/tags/案例.json"}]},{"title":"iOS Document Interaction 编程指南","slug":"iOS/iOSDocumentInteraction编程指南","date":"2014-07-01T23:12:01.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/iOSDocumentInteraction编程指南.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"关于-Document-Interaction\"><a href=\"#关于-Document-Interaction\" class=\"headerlink\" title=\"关于 Document Interaction\"></a>关于 Document Interaction</h4><p>  iOS支持在你的app中通过调用其他app来预览和显示文档。iOS还支持文件关联，允许其他app调用你的app打开文件。这些技术包括了UIKit中提供的<a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIDocumentInteractionController_class/Reference/Reference.html\" target=\"_blank\" rel=\"noopener\">UIDocumentInteractionController</a>类，以及<a href=\"https://developer.apple.com/library/ios/documentation/QuickLook/Reference/QuickLookFrameworkReference_iPhoneOS/_index.html\" target=\"_blank\" rel=\"noopener\">Quick Look</a>框架。</p>\n<ul>\n<li>######预览文档和呈现选项菜单<br>如果app需要打开自身并不支持的文件时，就需要使用<strong>UIDocumentInteractionController</strong>。一个<strong>document interaction controller</strong>通过<strong>Quick Look框架</strong>判断文档是否能被另一个app打开和预览。也就是说，app可以通过<strong>documentinteraction controller</strong>提供一些支持打开该文件方式的菜单。</li>\n</ul>\n<p>具体实现需要以下步骤：</p>\n<ul>\n<li><ul>\n<li>需要通过其他APP打开的文件，来实例化<code>UIDocumentInteractionController</code>实例对象。  </li>\n</ul>\n</li>\n<li><ul>\n<li>在自己的APP UI中提供一个代表这种文件的图像标（一般显示文件名或者图标）。</li>\n</ul>\n</li>\n<li><ul>\n<li>用户交互，如触摸这个控件，则调用<code>documentinteractioncontroller</code>对象。  </li>\n</ul>\n</li>\n</ul>\n<p>三种交互界面:</p>\n<pre><code>1. 预览文件的内容。\n2. 一个包含预览和打开操作的菜单。可以通过实现某些委托方法，向菜单中加入其他操作，比如复制、打印。\n3. 一个菜单，仅包含“以其它方式打开”操作。\n</code></pre><p>同时，<code>documentinteractioncontroller</code>内置了一些手势，必要时可以直接实现它们。  </p>\n<ul>\n<li><p>######使用<code>documentinteractioncontroller</code>的场景:<strong>与文件交互的app都可以使用。</strong></p>\n</li>\n<li><ul>\n<li>需要从网络下载文件的APP:<br>例如，email程序需要打开和预览邮件附件。</li>\n</ul>\n</li>\n<li><ul>\n<li>不下载文件的APP:<br>例如，APP需要支持文件共享（参考“File-Sharing Support” in <a href=\"https://developer.apple.com/library/ios/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007898\" target=\"_blank\" rel=\"noopener\">iOS Technology Overview</a>), 即可以对同步到app Documents/Shared目录下的文件使用<code>documentinteractioncontroller</code>。<a id=\"more\"></a>\n<h4 id=\"创建Document-Interaction-Controller\"><a href=\"#创建Document-Interaction-Controller\" class=\"headerlink\" title=\"创建Document Interaction Controller\"></a>创建Document Interaction Controller</h4>创建时，通过需要其他APP打开的文件，来实例化<code>UIDocumentInteractionController</code>实例对象，并设置它的<code>delegate</code>属性。<br><code>delegate</code>对象负责告诉<strong>document  interaction controller</strong>呈现视图时需要的信息，以及当视图显示和用户交互时要执行的动作。<br>如以下代码所示。注意方法的调用者必须返回对象。<figure class=\"highlight objc\"><figcaption><span>实例化document interaction controller</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIDocumentInteractionController</span> *) setupControllerWithURL: (<span class=\"built_in\">NSURL</span>) fileURL</span><br><span class=\"line\">    \t\t\t\t\t\t\t\t\t\t\t usingDelegate: (<span class=\"keyword\">id</span> &lt;<span class=\"built_in\">UIDocumentInteractionControllerDelegate</span>&gt;) interactionDelegate </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t   <span class=\"built_in\">UIDocumentInteractionController</span> *interactionController =</span><br><span class=\"line\">\t       \t\t\t\t\t\t\t\t\t[<span class=\"built_in\">UIDocumentInteractionController</span> interactionControllerWithURL: fileURL];</span><br><span class=\"line\">\t   interactionController.delegate = interactionDelegate;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t   <span class=\"keyword\">return</span> interactionController;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>实例创建后，可以通过它的属性来读取与之关联的文件信息，包括文件名、类型和URL。该实例中还有一个<code>icons</code>属性，其中包含了多个 <code>UIImage</code> 对象,可以用于表示该文档的多个大小的图标。这些信息可用于UI。</p>\n<p>如果用其他APP打开该文件，可以利用该实例的 <code>annotation</code> 属性，该属性包含了其他APP所需的附加信息。当然信息的格式必须能够被该APP识别。<br>例如:当程序想与套件中的其他程序进行交互时，就可以使用<code>annotation</code> 属性。当被调用应用程序打开一个文件时，<code>option</code> 字典中会包含 <code>annotation</code> 的值，可以使用<font color=\"red\" size=\"1\">UIApplicationLaunchOptionsAnnotationKey</font> 作为键在<code>option</code>字典中检索它。</p>\n<h4 id=\"呈现-Document-Interaction-Controller\"><a href=\"#呈现-Document-Interaction-Controller\" class=\"headerlink\" title=\"呈现 Document Interaction Controller\"></a>呈现 Document Interaction Controller</h4><p>用户可以通过 <code>Document interaction controller</code>实例，来预览该文件，或者通过弹出菜单让用户选择相应的动作。  </p>\n<ul>\n<li><p>模式化显示文件预览窗口，调用如下方法:</p>\n<figure class=\"highlight objc\"><figcaption><span>模式化预览窗口调用的方法 Declared In UIDocumentInteractionController.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Displays a full-screen preview of the target document.</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)presentPreviewAnimated:(<span class=\"built_in\">BOOL</span>)animated;</span><br></pre></td></tr></table></figure>\n<p>预览窗口是以模式视图显示的，同时必须实现以下协议方法:</p>\n<figure class=\"highlight objc\"><figcaption><span>Declared In UIDocumentInteractionController.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Called when a document interaction controller needs the starting point for animating the display of a document preview.</span></span><br><span class=\"line\">- (<span class=\"built_in\">UIViewController</span> *) documentInteractionControllerViewControllerForPreview: (<span class=\"built_in\">UIDocumentInteractionController</span> *) controller</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注:该方法最终需要返回一个<strong><code>VC</code></strong>，来作为预览窗口的父窗口。假如没有实现该方法，或者在该方法中返回 nil，或者返回的<strong><code>VC</code></strong>无法呈现模式窗口，则该预览窗口不会显示。<br>最终会被<strong><code>documentinteractioncontroller</code></strong>会自动解散它呈现出来的窗口。或调用系统提供销毁模态视图的方法，手动销毁如下：</p>\n<figure class=\"highlight objc\"><figcaption><span>Declared In UIDocumentInteractionController.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Dismisses the currently active menu.</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dismissMenuAnimated:(<span class=\"built_in\">BOOL</span>)animated  </span><br><span class=\"line\"><span class=\"comment\">//Dismisses the currently active document preview.</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dismissPreviewAnimated:(<span class=\"built_in\">BOOL</span>)animated</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>通过弹出菜单提示用户选择相应动作，调用如下方法:</p>\n<figure class=\"highlight objc\"><figcaption><span>弹出\"通过其他方式打开\"菜单 Declared In UIDocumentInteractionController.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Displays an options menu and anchors it to the specified location in the view.</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)presentOptionsMenuFromRect:(<span class=\"built_in\">CGRect</span>)rect inView:(<span class=\"built_in\">UIView</span> *)view animated:(<span class=\"built_in\">BOOL</span>)animated</span><br><span class=\"line\"><span class=\"comment\">//Displays an options menu and anchors it to the specified bar button item.</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)presentOptionsMenuFromBarButtonItem:(<span class=\"built_in\">UIBarButtonItem</span> *)item animated:(<span class=\"built_in\">BOOL</span>)animated</span><br></pre></td></tr></table></figure></li>\n<li>提示用户用其他程序打开该文件，调用如下方法:<figure class=\"highlight objc\"><figcaption><span>提示用户用其他程序打开 Declared In UIDocumentInteractionController.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Displays a menu for opening the document and anchors that menu to the specified view.</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)presentOpenInMenuFromRect:(<span class=\"built_in\">CGRect</span>)rect inView:(<span class=\"built_in\">UIView</span> *)view animated:(<span class=\"built_in\">BOOL</span>)animated</span><br><span class=\"line\"><span class=\"comment\">//Displays a menu for opening the document and anchors that menu to the specified bar button item.</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)presentOpenInMenuFromBarButtonItem:(<span class=\"built_in\">UIBarButtonItem</span> *)item animated:(<span class=\"built_in\">BOOL</span>)animated</span><br></pre></td></tr></table></figure>\n以上几种方法都会显示一个视图或一个预览窗口或是弹出菜单。任何一个方法的调用，都要检查返回值。返回值为 <code>NO</code>，表示这个视图没有任何内容，将不能显示。<br>例如，<strong><code>presentOpenInMenuFromRect:inView:animated:</code></strong>方法返回<code>NO</code>,表明已安装的程序中没有任何程序能够打开该文档。</li>\n</ul>\n<h4 id=\"注册应用程序支持的文档类型\"><a href=\"#注册应用程序支持的文档类型\" class=\"headerlink\" title=\"注册应用程序支持的文档类型\"></a>注册应用程序支持的文档类型</h4><p>如果你的程序可以打开某种特定的文件类型，则可以通过<strong>Info.plist</strong>文件注册程序所能打开的文档类型。当其他程序向系统询问哪些程序可以识别该类型的文件时，你的程序就会被列到选项菜单中，供用户选择。  </p>\n<ul>\n<li>有如下概念:  </li>\n<li><ul>\n<li>需要在程序的<strong><code>Info.plist</code></strong>文件中添加新字段<strong><code>CFBundleDocumentTypes</code></strong> 键 (查看 “<a href=\"https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html#//apple_ref/doc/uid/TP40009249\" target=\"_blank\" rel=\"noopener\">CoreFoundation Keys</a>”) 。系统会将该键中包含的内容进行登记，这样其他程序就可以通过<strong><code>document interaction controller</code></strong>访问到这些信息。</li>\n</ul>\n</li>\n<li><ul>\n<li><strong><code>CFBundleDocumentTypes</code></strong> 键是一个<code>dictionary</code>数组，一个<code>dictionary</code>表示了一个指定的文档类型。一个文档类型通常与某种文件类型是一一对应的。但是，如果你的程序对多个文件类型采用同样的处理方式，你也可以把这些类型都分成一个组，统一视作一个文档类型。<br>例如，你的程序中使用到的本地文档类型，有一个是旧格式的，还有一个新格式（似乎是影射微软<strong>office</strong>文档），这样就可以将二者分成一组，都放到同一个文档类型下。这样，旧格式和新格式的文件都将显示为同一个文档类型，并以同样的方式打开。  </li>\n</ul>\n</li>\n</ul>\n<p><strong><code>CFBundleDocumentTypes</code></strong> 数组中的每个<code>dictionary</code>包含以下键：<br><figure class=\"highlight objc\"><figcaption><span>字典键名称</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFBundleTypeName</span> \t\t\t<span class=\"comment\">//指定文档类型名称。</span></span><br><span class=\"line\"><span class=\"built_in\">CFBundleTypeIconFiles</span>    <span class=\"comment\">//是一个数组，包含多个图片文件名，用于作为该文档的图标。</span></span><br><span class=\"line\">LSItemContentTypes \t\t<span class=\"comment\">//是一个数组，包含多个 UTI 类型的字符串。UTI 类型是本文档类型（组）所包含的文件类型。</span></span><br><span class=\"line\">LSHandlerRank \t\t\t\t<span class=\"comment\">//表示应用程序是“拥有”还是仅仅是“打开”这种类型而已。</span></span><br></pre></td></tr></table></figure><br>在应用程序的角度而言，一个文档类型其实就是一种文件类型（或者多个文件类型），该程序将一个文档类型的文件都视作同样的东西对待。例如，一个图片处理程序可能将各种图片文件都看成不同的文档类型，这样便于根据每个类型进行相应的优化。但是，对于字处理程序来说，它并不关心真正的图形格式，它把所有的图片格式都作为一个文档类型对待。</p>\n<ul>\n<li><strong><code>CFBundleDocumentTypes</code></strong>字典数组示例:<figure class=\"highlight html\"><figcaption><span>自定义文件格式的文档类型</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>CFBundleTypeName<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>My File Format<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>CFBundleTypeIconFiles<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>MySmallIcon.png<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>MyLargeIcon.png<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>LSItemContentTypes<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>com.example.myformat<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>LSHandlerRank<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>Owner<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"打开支持的文件类型\"><a href=\"#打开支持的文件类型\" class=\"headerlink\" title=\"打开支持的文件类型\"></a>打开支持的文件类型</h4><p>系统可能会请求某个程序打开某种文件，并呈现给用户。这种情况通常发生在某个应用程序调用 <strong><code>document interaction controller</code></strong> 去处理某个文件的时候。<br>这时应用程序可以通过委托方法:<br><figure class=\"highlight objc\"><figcaption><span>获得文件的信息 Declared In UIApplication.h</span><a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/UIApplicationDelegate/application:didFinishLaunchingWithOptions:\" target=\"_blank\" rel=\"noopener\">link</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Tells the delegate that the launch process is almost done and the app is almost ready to run.</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<font size=\"1\">注:如果你的程序要处理某些自定义的文件类型，就必须实现这个委托方法（而不是<strong><code>applicationDidFinishLaunching:</code></strong>方法) 并用这个方法启动应用程序</font>  \n\n</blockquote>\n<p>该方法的<strong><code>option</code></strong>包含了要打开的文件的相关信息，可以通过以下键名一一解析：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIApplicationLaunchOptionsURLKey</span> \t\t\t\t\t <span class=\"comment\">//该文件的NSURL</span></span><br><span class=\"line\"><span class=\"built_in\">UIApplicationLaunchOptionsSourceApplicationKey</span> \t<span class=\"comment\">//发送请求的应用程序的Bundle ID</span></span><br><span class=\"line\"><span class=\"built_in\">UIApplicationLaunchOptionsSourceApplicationKey</span>\t\t<span class=\"comment\">//源程序向目标程序传递的与该文件相关的属性列表对象</span></span><br></pre></td></tr></table></figure><br>如果 <strong><code>UIApplicationLaunchOptionsURLKey</code></strong> 键存在，你的程序应当立即用该<strong><code>URL</code></strong>打开该文件并将内容呈现给用户。其他键可用于收集与打开的文件相关的参数和信息。</p>\n<h4 id=\"使用-Quick-Look-框架\"><a href=\"#使用-Quick-Look-框架\" class=\"headerlink\" title=\"使用 Quick Look 框架\"></a>使用 Quick Look 框架</h4><p><strong><code>Quick Look</code></strong>框架提供了增强的预览功能，可以选择呈现预览窗口时的动画风格，并可以像预览单个文件一样预览多个文件。<br>该框架主要提供了 <strong><code>QLPreviewController</code></strong> 类。该类依赖于委托对象响应预览动作，以及一个用于提供预览文件的数据源，内置了所支持的文件类型的 <strong>AirPrint</strong> 打印。  </p>\n<ul>\n<li><h6 id=\"Quick-Look-Previews-中的预览及打印\"><a href=\"#Quick-Look-Previews-中的预览及打印\" class=\"headerlink\" title=\"Quick Look Previews 中的预览及打印\"></a>Quick Look Previews 中的预览及打印</h6>从 iOS 4.2 开始，<strong><code>QLPreviewController</code></strong> 提供了包含了一个 <code>action</code> 按钮（即打印按钮）的预览视图。对于 <strong><code>QLPreviewController</code></strong> 能预览的文件，不用编写任何打印代码，只需点击<code>action</code>按钮就能直接打印该文档。  </li>\n</ul>\n<p>通过以下方式显示<strong><code>QLPreviewController</code></strong>:</p>\n<ul>\n<li><ul>\n<li>通过导航控制器，将预览窗口以“<strong><code>push</code> 方式</strong>”显示。</li>\n</ul>\n</li>\n<li><ul>\n<li>通过 <strong>UIViewController</strong> 的 <strong><code>presentModalViewController:animated:</code></strong>方法，将预览窗口以模态窗口的方式全屏显示。</li>\n</ul>\n</li>\n<li><ul>\n<li>显示一个<strong><code>document interaction controller</code></strong>(如 “预览及打开文件” 中所述），再在选项菜单中选择“<strong><code>Quick Look</code></strong>”即可。  </li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<font size=\"1\">预览窗口中会包括一个标题，显示文件 URL 的最后一段路径。如果要重载标题，可以定制<strong><code>PreviewItem</code></strong> 类，并实现<strong><code>QLPreviewItem</code></strong> 协议中的 <strong>previewItemTitle</strong>方法。</font>\n\n</blockquote>\n<ul>\n<li><h6 id=\"QLPreviewController能够预览下列文件：\"><a href=\"#QLPreviewController能够预览下列文件：\" class=\"headerlink\" title=\"QLPreviewController能够预览下列文件：\"></a><strong><code>QLPreviewController</code></strong>能够预览下列文件：</h6></li>\n<li><ul>\n<li>iWork 文档</li>\n</ul>\n</li>\n<li><ul>\n<li>Microsoft Office 文档(Office ‘97 以后版本)</li>\n</ul>\n</li>\n<li><ul>\n<li>Rich Text Format (RTF) 文档</li>\n</ul>\n</li>\n<li><ul>\n<li>PDF 文档</li>\n</ul>\n</li>\n<li><ul>\n<li>图片</li>\n</ul>\n</li>\n<li><ul>\n<li>文本文件，其 uniform type identifier (UTI)  在 public.text 文件中定义 (查看UniformType Identifiers 参考)</li>\n</ul>\n</li>\n<li><ul>\n<li>Comma-separated value (csv) 文件  </li>\n</ul>\n</li>\n</ul>\n<p>使用<strong><code>QLPreviewController</code></strong>，必须指定数据源对象（即实现 <strong><code>QLPreviewControllerDataSource</code></strong> 协议，请查看<a href=\"https://developer.apple.com/library/ios/documentation/NetworkingInternet/Reference/QLPreviewControllerDataSource_Protocol/Reference/Reference.html#//apple_ref/doc/uid/TP40009665\" target=\"_blank\" rel=\"noopener\">QLPreviewControllerDataSource</a>协议参考）。数据源为 <strong><code>QLPreviewController</code></strong>提供预览对象（<strong><code>preivew item</code></strong>），及指明它们的数量以便在一个预览导航列表中包含它们。在这个列表中包含多个对象，在模态预览窗口（全屏显示）显示了导航箭头，以便用户在多个预览对象间切换。对于用导航控制器“push方式”显示的<strong><code>QLPreviewController</code></strong>，你可以在导航条上提供按钮以便在预览对象列表见切换。</p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"API","path":"api/categories/API.json"}],"tags":[{"name":"指南","path":"api/tags/指南.json"}]},{"title":"UIDevice类介绍","slug":"iOS/UIDevice类介绍","date":"2014-06-17T15:12:53.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/UIDevice类介绍.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"UIDevice-h\"><a href=\"#UIDevice-h\" class=\"headerlink\" title=\"UIDevice.h\"></a>UIDevice.h</h3><figure class=\"highlight objc\"><figcaption><span>设备的基本属性</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">UIDevice</span> *)currentDevice; \t\t  <span class=\"comment\">// 获取当前设备</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSString</span>    *name;               \t  <span class=\"comment\">// e.g. \"My iPhone\"  </span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span>    *model;              \t  <span class=\"comment\">// e.g. @\"iPhone\", @\"iPod touch\"  </span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span>    *localizedModel;     \t  <span class=\"comment\">// localized version of model  </span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span>    *systemName;     \t\t  <span class=\"comment\">// e.g. @\"iOS\"  </span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span>    *systemVersion;   \t  <span class=\"comment\">// e.g. @\"4.0\"  </span></span><br><span class=\"line\"><span class=\"built_in\">UIDeviceOrientation</span> orientation;    <span class=\"comment\">//除非正在生成设备方向的通知，否则返回UIDeviceOrientationUnknown  </span></span><br><span class=\"line\"><span class=\"built_in\">NSUUID</span> *identifierForVendor         <span class=\"comment\">//可用于唯一标识该设备，同一供应商不同应用具有相同的UUID</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><figcaption><span>方向属性值</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIDeviceOrientationUnknown</span>,</span><br><span class=\"line\"><span class=\"built_in\">UIDeviceOrientationPortrait</span>,                    <span class=\"comment\">// 竖向，头向上</span></span><br><span class=\"line\"><span class=\"built_in\">UIDeviceOrientationPortraitUpsideDown</span>,  \t\t<span class=\"comment\">// 竖向，头向下</span></span><br><span class=\"line\"><span class=\"built_in\">UIDeviceOrientationLandscapeLeft</span>,         \t\t<span class=\"comment\">// 横向，头向左</span></span><br><span class=\"line\"><span class=\"built_in\">UIDeviceOrientationLandscapeRight</span>,       \t\t<span class=\"comment\">// 横向，头向右</span></span><br><span class=\"line\"><span class=\"built_in\">UIDeviceOrientationFaceUp</span>,                  \t<span class=\"comment\">// 平放，屏幕朝下</span></span><br><span class=\"line\"><span class=\"built_in\">UIDeviceOrientationFaceDown</span>                \t <span class=\"comment\">// 平放，屏幕朝下</span></span><br></pre></td></tr></table></figure>\n<p>//使用内置的宏定义的函数，根据<strong>orientation</strong>判断设备方向,返回值类型<strong>BOOL</strong>.<br><figure class=\"highlight\"><figcaption><span>纵向宏定义,返回YES:纵向</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define UIDeviceOrientationIsPortrait(orientation)  ((orientation) == UIDeviceOrientationPortrait || (orientation) == UIDeviceOrientationPortraitUpsideDown)</span><br></pre></td></tr></table></figure><br><figure class=\"highlight\"><figcaption><span>横向宏定义,返回YES:横向</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define UIDeviceOrientationIsLandscape(orientation) ((orientation) == UIDeviceOrientationLandscapeLeft || (orientation) == UIDeviceOrientationLandscapeRight)</span><br></pre></td></tr></table></figure><br><a id=\"more\"></a></p>\n<h4 id=\"横竖屏相关参数-方法与通知\"><a href=\"#横竖屏相关参数-方法与通知\" class=\"headerlink\" title=\"横竖屏相关参数,方法与通知\"></a>横竖屏相关参数,方法与通知</h4><ul>\n<li>检测当前设备是否生成设备转向通知<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">BOOL</span> generatesDeviceOrientationNotifications</span><br></pre></td></tr></table></figure></li>\n<li>设备方向开始改变时，触发该方法，可以重写实现一些操作。<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)beginGeneratingDeviceOrientationNotifications;</span><br></pre></td></tr></table></figure></li>\n<li>设备结束方向改变时，触发的事件，可以重写该实现一些操作。<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)endGeneratingDeviceOrientationNotifications;</span><br></pre></td></tr></table></figure></li>\n<li>通知<figure class=\"highlight objc\"><figcaption><span>屏幕方向变化通知</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIDeviceOrientationDidChangeNotification</span>;</span><br></pre></td></tr></table></figure>\n####手机电池相关属性与通知</li>\n<li>电池属性<figure class=\"highlight objc\"><figcaption><span>电池属性</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">BOOL</span> batteryMonitoringEnabled\t\t      <span class=\"comment\">// 是否启动电池监控，默认为NO </span></span><br><span class=\"line\"><span class=\"built_in\">UIDeviceBatteryState</span> batteryState \t\t<span class=\"comment\">//电池状态</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> batteryLevel   \t\t\t\t\t <span class=\"comment\">//电量百分比， 0 .. 1.0,监控禁用时为-1</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><figcaption><span>电池状态UIDeviceBatteryState属性值</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIDeviceBatteryStateUnknown</span>,\t\t <span class=\"comment\">//禁用电池监控</span></span><br><span class=\"line\"><span class=\"built_in\">UIDeviceBatteryStateUnplugged</span>,      <span class=\"comment\">// 未充电</span></span><br><span class=\"line\"><span class=\"built_in\">UIDeviceBatteryStateCharging</span>,       <span class=\"comment\">// 正在充电</span></span><br><span class=\"line\"><span class=\"built_in\">UIDeviceBatteryStateFull</span>,           <span class=\"comment\">// 满电</span></span><br></pre></td></tr></table></figure></li>\n<li>电池通知<figure class=\"highlight objc\"><figcaption><span>电池状态变化通知</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIDeviceBatteryStateDidChangeNotification</span>   <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">3</span>_0);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><figcaption><span>电池电量变化通知</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIDeviceBatteryLevelDidChangeNotification</span>   <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">3</span>_0);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"设备的其他属性及方法\"><a href=\"#设备的其他属性及方法\" class=\"headerlink\" title=\"设备的其他属性及方法\"></a>设备的其他属性及方法</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">BOOL</span> proximityMonitoringEnabled <span class=\"comment\">// 是否启动接近监控（例如接电话时脸靠近屏幕），默认为NO</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> proximityState <span class=\"comment\">// 如果设备不具备接近感应器，则总是返回NO</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> multitaskingSupported <span class=\"comment\">// 是否支持多任务</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UIUserInterfaceIdiom</span> userInterfaceIdiom <span class=\"comment\">// 当前用户界面模式</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)playInputClick   <span class=\"comment\">// 播放一个输入的声音</span></span><br></pre></td></tr></table></figure>\n<p>//用户界面类型<br><figure class=\"highlight objc\"><figcaption><span>iOS3.2以上有效</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#if __IPHONE_3_2 <span class=\"meta-string\">&lt;= __IPHONE_OS_VERSION_MAX_ALLOWED</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-string\">    UIUserInterfaceIdiomPhone,           // iPhone 和 iPod touch 风格</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-string\">    UIUserInterfaceIdiomPad,              // iPad 风格</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-string\">#endif</span></span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight\"><figcaption><span>获取当前用户界面模式的宏定义</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define UI_USER_INTERFACE_IDIOM() ([[UIDevice currentDevice] respondsToSelector:@selector(userInterfaceIdiom)] ? [[UIDevice currentDevice] userInterfaceIdiom] : UIUserInterfaceIdiomPhone)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"一些协议的定义\"><a href=\"#一些协议的定义\" class=\"headerlink\" title=\"一些协议的定义\"></a>一些协议的定义</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">UIInputViewAudioFeedback</span></span></span><br><span class=\"line\"><span class=\"keyword\">@optional</span></span><br><span class=\"line\"><span class=\"comment\">// 实现该方法，返回YES则自定义的视图能够播放输入的声音</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">BOOL</span> enableInputClicksWhenVisible; </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"其他通知\"><a href=\"#其他通知\" class=\"headerlink\" title=\"其他通知\"></a>其他通知</h4><figure class=\"highlight objc\"><figcaption><span>接近状态变化通知</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIDeviceProximityStateDidChangeNotification</span> <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">3</span>_0);</span><br></pre></td></tr></table></figure>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"设备","path":"api/categories/设备.json"}],"tags":[{"name":"设备","path":"api/tags/设备.json"}]},{"title":"IOS7新宠Text Kit","slug":"iOS/IOS7新宠TextKit","date":"2014-06-16T22:24:48.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/IOS7新宠TextKit.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/TextRenderingArchitecture-iOS6.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"Text-Kit\"><a href=\"#Text-Kit\" class=\"headerlink\" title=\"Text Kit\"></a>Text Kit</h2><p><strong><code>Text Kit</code></strong>：是个庞大的framework，继承了<code>Core Text</code>的全部功能，构建了快速、先进的文本排版和渲染引擎，更让开发者们高兴的是，设计者把它封装在了一个面向对象的API中。并且与UIKit框架很好的集成，它让程序能够通过<strong>NSTextStorage</strong>对象存储文本排版和显示文本等主要信息，并支持排版所需要的所有特性，包括字距调整、连写、换行和对齐等。  </p>\n<blockquote>\n<font size=\"3\">更直观的理解，<strong>UITextView</strong>，<strong>UITextField</strong>、<strong>UILabel</strong>等UIKit控件都已经基于<strong>Text Kit</strong>重新构建，是为UIKit框架提供高质量排版服务而扩展的一些类和协议.<br>例如：NSTextStorage对象，它本身是<strong>NSMutableAttributedString</strong>的子类，支持分批编辑，这就意味着在改变一个范围内的字符样式时，不用整体替换文本内容，就能完成排版效果。其中支持分页文本、文本包装、富文本编辑、交互式文本着色、文本折叠和自定义截取等特性。</font>  \n\n</blockquote>\n<p>IOS6之前，想实现一些丰富的文本排版，例如在textView中显示不同样式的文本，或者图片和文字混排等，就需要借助于UIWebView或者深入研究一下<code>Core Text</code>。后来iOS6，增加一个很棒的属性:<code>NSAttributedString</code>，主要用于支持UILabel、UITextField、UITextView等UIKit控件自主排版的功能。很显然，IOS7并没有满足于这一改进，同时推出一款功能更为齐全，易用的<code>Text Kit</code>新宠。<br>在iOS 6中, 用于文本的UIKit控件是基于WebKit和Core Graphics的字符串绘制方法来实现的。如下面层级体系图所示：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextRenderingArchitecture-iOS6.png?imageMogr2/2/w/800\"><br>iOS 7的整体构架要更清晰，所有基于文本的UIKit控件（除了UIWebView）现在都可以使用Text Kit，如下图所示：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextRenderingArchitecture-iOS7.png?imageMogr2/2/w/800\"></p>\n<a id=\"more\"></a>\n<h2 id=\"Text-Kit中4个重要的角色\"><a href=\"#Text-Kit中4个重要的角色\" class=\"headerlink\" title=\"Text Kit中4个重要的角色\"></a>Text Kit中4个重要的角色</h2><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit_obj.jpg?imageMogr2/2/w/800\">\n<ul>\n<li><ul>\n<li><strong><code>Text Views</code></strong>: 用来显示文本内容的控件，主要包括<code>UILabel</code>、<code>UITextView</code>和<code>UITextField</code>。  </li>\n</ul>\n</li>\n<li><ul>\n<li><strong><code>Text containers</code></strong>: 对应着<code>NSTextContainer</code>类。<code>NSTextContainer</code>定义了文本可以排版的区域。一般来说，都是矩形区域，当然，也可以根据需求，通过子类化<code>NSTextContainer</code>来创建别的一些形状，例如圆形、不规则的形状等。<code>NSTextContainer</code>不仅可以创建文本可以填充的区域，它还维护着一个数组——该数组定义了一个区域，排版的时候文字不会填充该区域，因此，我们可以在排版文字的时候，填充非文本元素。    </li>\n</ul>\n</li>\n<li><ul>\n<li><strong><code>Layout manager</code></strong>: 对应着<code>NSLayoutManager</code>类。该类负责对文字进行编辑排版处理——通过将存储在<code>NSTextStorage</code>中的数据转换为可以在视图控件中显示的文本内容，并把统一的字符编码映射到对应的字形(<code>glyphs</code>)上，然后将字形排版到<code>NSTextContainer</code>定义的区域中。  </li>\n</ul>\n</li>\n<li><ul>\n<li><strong><code>Text storage</code></strong>: 对应着<code>NSTextStorage</code>类。该类定义了<code>Text Kit</code>扩展文本处理系统中的基本存储机制。<code>NSTextStorage</code>继承自<code>NSmutableAttributedString</code>，主要用来存储文本的字符和相关属性。另外，当<code>NSTextStorage</code>中的字符或属性发生了改变，会通知<code>NSLayoutManager</code>，进而做到文本内容的显示更新。<br>通常情况下，<strong><code>NSTextStorage</code></strong>、<strong><code>NSLayoutManager</code></strong>和<strong><code>NSTextContainer</code></strong>是一一对应关系:  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit_obj1.jpg?imageMogr2/2/w/800\">\n如果将文字显示为多列，或多页，可以按照下图关系，使用多个<strong><code>NSTextContainer</code></strong>:<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit_obj2.jpg?imageMogr2/2/w/800\">\n如果针对不同的排版方式，可以按照下图关系，使用多个<strong><code>NSLayoutManager</code></strong>:<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit_obj3.jpg?imageMogr2/2/w/800\">\n通常由<strong><code>NSLayoutManager</code></strong>从<strong><code>NSTextStorage</code></strong>中读取出文本数据，然后根据一定的排版方式，将文本排版到<strong><code>NSTextContainer</code></strong>中，再由<strong><code>NSTextContainer</code></strong>结合<code>UITextView</code>将最终效果显示出来。<br>如下图，为了更直观理解，对<code>UITextView</code>的组成做了分解: <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit.jpg?imageMogr2/2/w/800\">\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Text-Kit示例\"><a href=\"#Text-Kit示例\" class=\"headerlink\" title=\"Text Kit示例\"></a>Text Kit示例</h2><ol>\n<li>打开Xcode 5，新建一个Single View Application模板的程序，将工程命名为ExclusionPath。</li>\n<li>打开Main.storyboard文件，然后再默认View Controller的View里面分别添加一个UITextView和UIImageView。并将这两个控件连接到ViewController.h中(名称分别为textView何imageView)。然后给textView设置一些字符串，imageView设置一个图片。</li>\n<li><ol>\n<li>打开ViewController.m文件，找到viewDidLoad方法，用如下代码替换该方法：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建一个平移手势对象，该对象可以调用imagePanned：方法</span></span><br><span class=\"line\">    <span class=\"built_in\">UIPanGestureRecognizer</span> *panGes = [[<span class=\"built_in\">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(imagePanned:)];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.imageView addGestureRecognizer:panGes];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.textView.textContainer.exclusionPaths = @[[<span class=\"keyword\">self</span> translatedBezierPath]];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n在上面的代码中，给imageView添加了一个平移手势。另外通过调用translatedBezierPath方法，给textView的textContainer设置exclusionPaths属性值。表示需要排除的区域（也就是图片在排版中显示的位置）。  </li>\n</ol>\n</li>\n<li><ol>\n<li><strong>translatedBezierPath</strong>方法实现如下：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIBezierPath</span> *)translatedBezierPath</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGRect</span> butterflyImageRect = [<span class=\"keyword\">self</span>.textView convertRect:<span class=\"keyword\">self</span>.imageView.frame fromView:<span class=\"keyword\">self</span>.view];</span><br><span class=\"line\">    <span class=\"built_in\">UIBezierPath</span> *newButterflyPath = [<span class=\"built_in\">UIBezierPath</span> bezierPathWithRect:butterflyImageRect];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> newButterflyPath;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n在上面的代码中，利用imageView的frame属性创建了一个UIBezierPath，然后将该值返回。  </li>\n</ol>\n</li>\n<li><ol>\n<li><strong>imagePanned:</strong>方法实现如下：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)imagePanned:(<span class=\"keyword\">id</span>)sender</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([sender isKindOfClass:[<span class=\"built_in\">UIPanGestureRecognizer</span> <span class=\"keyword\">class</span>]]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">UIPanGestureRecognizer</span> *localSender = sender;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (localSender.state == <span class=\"built_in\">UIGestureRecognizerStateBegan</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.gestureStartingPoint = [localSender translationInView:<span class=\"keyword\">self</span>.textView];</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.gestureStartingCenter = <span class=\"keyword\">self</span>.imageView.center;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (localSender.state == <span class=\"built_in\">UIGestureRecognizerStateChanged</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">CGPoint</span> currentPoint = [localSender translationInView:<span class=\"keyword\">self</span>.textView];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">CGFloat</span> distanceX = currentPoint.x - <span class=\"keyword\">self</span>.gestureStartingPoint.x;</span><br><span class=\"line\">            <span class=\"built_in\">CGFloat</span> distanceY = currentPoint.y - <span class=\"keyword\">self</span>.gestureStartingPoint.y;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">CGPoint</span> newCenter = <span class=\"keyword\">self</span>.gestureStartingCenter;</span><br><span class=\"line\"></span><br><span class=\"line\">            newCenter.x += distanceX;</span><br><span class=\"line\">            newCenter.y += distanceY;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.imageView.center = newCenter;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.textView.textContainer.exclusionPaths = @[[<span class=\"keyword\">self</span> translatedBezierPath]];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (localSender.state == <span class=\"built_in\">UIGestureRecognizerStateEnded</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.gestureStartingPoint = <span class=\"built_in\">CGPointZero</span>;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.gestureStartingCenter = <span class=\"built_in\">CGPointZero</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n在上面的代码中首先根据平移的距离来设置imageView的位置，然后利用<code>translatedBezierPath</code>方法重新计算了一下排除区域。<br>示例效果:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit_gif.gif)</li>?imageMogr2/2/w/800\"></li></ol></li></ol>","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"}],"tags":[{"name":"TextKit","path":"api/tags/TextKit.json"},{"name":"概念","path":"api/tags/概念.json"}]},{"title":"IOS7的变革","slug":"iOS/IOS7的变革","date":"2014-06-11T10:17:19.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/IOS7的变革.json","excerpt":null,"keywords":null,"cover":"/images/uiimagerenderingmode.png","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"性能提高以及被遗弃的功能\"><a href=\"#性能提高以及被遗弃的功能\" class=\"headerlink\" title=\"性能提高以及被遗弃的功能\"></a>性能提高以及被遗弃的功能</h2><h3 id=\"新增截屏通知-UIApplicationUserDidTakeScreenshotNotification\"><a href=\"#新增截屏通知-UIApplicationUserDidTakeScreenshotNotification\" class=\"headerlink\" title=\"新增截屏通知:UIApplicationUserDidTakeScreenshotNotification\"></a>新增截屏通知:<code>UIApplicationUserDidTakeScreenshotNotification</code></h3><p>在IOS 7之前，开发者使用了一种<strong><a href=\"http://dlj.bz/XflV\" target=\"_blank\" rel=\"noopener\">很赞的方法</a></strong>，来<strong>拦截</strong>截屏事件的.<br>比如，Snapchat的实现原理: 用户通过<strong>Snapchat</strong>发送的照片将会在数秒内自动被删除，而且在浏览照片时，必须将手指按在屏幕上，否则会立即关闭。然而，在 iOS 6 中，<font color=\"red\"><strong>截屏将打断触控操作</strong></font>，开发者就利用这个功能点，在恰当时机捕捉到了截屏事件。  </p>\n<p>在iOS 7中，专门为<font color=\"red\"><strong>截屏完成后</strong></font>提供了一个通知:<br>  <code>UIApplicationUserDidTakeScreenshotNotification</code>.同时，也规避了IOS 6中<font color=\"red\"><strong>截屏将打断触控操作</strong></font>的关键功能点。以至于在截屏之前，无法拦截用户的截屏操作。<br>注册<font color=\"red\"><strong>截屏完成后</strong></font>通知:<br><figure class=\"highlight objc\"><figcaption><span>注册监听事件，接收截屏完成后的通知</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter]  addObserver:<span class=\"keyword\">self</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t  selector:<span class=\"keyword\">@selector</span>(mymethod:)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t  \t    name:<span class=\"built_in\">UIApplicationUserDidTakeScreenshotNotification</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t    object:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure></p>\n<p>Note:<br>    1.This notification is posted after the screenshot is taken.<br>    2.This notification does not contain a userInfo dictionary.</p>\n<h3 id=\"新增手势-UIScreenEdgePanGestureRecognizer\"><a href=\"#新增手势-UIScreenEdgePanGestureRecognizer\" class=\"headerlink\" title=\"新增手势: UIScreenEdgePanGestureRecognizer\"></a>新增手势: UIScreenEdgePanGestureRecognizer</h3><p><code>UIScreenEdgePanGestureRecognizer</code> inherits from <code>UIPanGestureRecognizer</code> and lets you <strong>detect gestures starting near the edge of the screen</strong>.<br>Using this new gesture recognizer is quite simple, as shown below:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIScreenEdgePanGestureRecognizer</span> *recognizer = [[<span class=\"built_in\">UIScreenEdgePanGestureRecognizer</span> alloc] </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\tinitWithTarget:<span class=\"keyword\">self</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\taction:<span class=\"keyword\">@selector</span>(handleScreenEdgeRecognizer:)];</span><br><span class=\"line\"><span class=\"comment\">// accept gestures that start from the left; we're probably building another hamburger menu!</span></span><br><span class=\"line\">recognizer.edges = <span class=\"built_in\">UIRectEdgeLeft</span>; </span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addGestureRecognizer:recognizer];</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h3 id=\"新增返回类型-–-instancetype\"><a href=\"#新增返回类型-–-instancetype\" class=\"headerlink\" title=\"新增返回类型 – instancetype\"></a>新增返回类型 – <code>instancetype</code></h3><p>  苹果改变了大部分 initializer和简易构造函数（convenience constructors），<code>instancetype</code>可以代替<code>id</code>作返回类型。</p>\n<pre><code>instancetype 作用：\n        1.作为从Objective-C方法的返回类型。\n        2.在编译时，该方法的返回类型将是该方法所属的类的实例，编译器就会对返回的实例做一些检查，有bug及时发现及时解决。这一点优于id类型。\n        3.在调用子类方法时，就可以省去对返回值的强制类型转换。\n</code></pre><p>  举例:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *d = [<span class=\"built_in\">NSArray</span> arrayWithObjects:@(<span class=\"number\">1</span>),@(<span class=\"number\">2</span>), <span class=\"literal\">nil</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%i\"</span>, d.count);</span><br><span class=\"line\">```  </span><br><span class=\"line\">这段代码显然有错误，但在Xcode4<span class=\"number\">.6</span>上是可以编译通过的。是由于Objective-C是动态性语言。</span><br><span class=\"line\">``` objc</span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)arrayWithObjects:(<span class=\"keyword\">id</span>)firstObj, ...;</span><br></pre></td></tr></table></figure></p>\n<p>并且，arrayWithObjects:返回<code>id</code>类型：是运行时的动态类型，编译器无法知道它的真实类型，即使调用一个id类型没有的方法，也不会产生编译警告。</p>\n<p>那么，为什么<code>arrayWithObjects:</code>方法的返回类型还是<code>id</code>类型？来看看<code>NSArray</code>子类：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyArray</span> : <span class=\"title\">NSArray</span></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>Now consider the use of your new subclass in the code below:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\tMyArray *array = [MyArray arrayWithObjects:@(<span class=\"number\">1</span>), @(<span class=\"number\">2</span>), <span class=\"literal\">nil</span>];</span><br><span class=\"line\">```  </span><br><span class=\"line\">如果方法`arrayWithObjects:`返回值的类型是`<span class=\"built_in\">NSArray</span> *`，那么子类`MyArray`就需要被强制转换为所需的类`<span class=\"built_in\">NSArray</span>`。这是正是`<span class=\"keyword\">instancetype</span>`返回类型的用武之地。</span><br><span class=\"line\">在iPhone <span class=\"number\">7.0</span> SDK的<span class=\"built_in\">NSArray</span>中的头文件，已更新为：</span><br><span class=\"line\">``` objc</span><br><span class=\"line\">\t+ (<span class=\"keyword\">instancetype</span>)arrayWithObjects:(<span class=\"keyword\">id</span>)firstObj, ...;</span><br></pre></td></tr></table></figure></p>\n<p>唯一的区别是返回类<code>instancetype</code>取代<code>id</code>。这种新的返回类型会告知编译器，返回值是该方法所属的类的实例对象。<br>也就是说:当<code>NSArray</code>调用<code>arrayWithObjects:</code>时，返回类型推断为NSArray*;<br>当<code>MyArray</code>调用<code>arrayWithObjects:</code>时，返回类型推断为MyArray*。  </p>\n<p><code>instancetype</code>解决<code>id</code>类型的问题，同时也继承<code>id</code>类型功能。如果编译在Xcode 5的原代码，你会看到下面的警告：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\twarning: incompatible pointer types initializing 'NSDictionary *' with an expression of type 'NSArray *' [-Wincompatible-pointer-types]</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *d = [<span class=\"built_in\">NSArray</span> arrayWithObjects:@(<span class=\"number\">1</span>), @(<span class=\"number\">2</span>), <span class=\"literal\">nil</span>];</span><br><span class=\"line\">                ^    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  </span><br><span class=\"line\">```  </span><br><span class=\"line\">  w00t — now that’s helpful! You now have the opportunity to fix the problem before it turns into a crash later down the line.  </span><br><span class=\"line\"></span><br><span class=\"line\">  Initializers are also candidates <span class=\"keyword\">for</span> using <span class=\"keyword\">this</span> new <span class=\"keyword\">return</span> type. The compiler has warned you <span class=\"keyword\">for</span> some time now <span class=\"keyword\">if</span> you set the <span class=\"keyword\">return</span> type of an initializer to that of an incompatible type. But presumably it’s just implicitly converting the <span class=\"keyword\">id</span> <span class=\"keyword\">return</span> type to <span class=\"keyword\">instancetype</span> under the hood. You should still use <span class=\"keyword\">instancetype</span> <span class=\"keyword\">for</span> initializers though, because it’s better to be <span class=\"keyword\">explicit</span> <span class=\"keyword\">for</span> habit’s sake.  </span><br><span class=\"line\"></span><br><span class=\"line\">  Strive to use <span class=\"keyword\">instancetype</span> as much as possible going forward; it’s become a standard <span class=\"keyword\">for</span> Apple — and you never know when it will save you some painful debugging time later on.</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">### UIScrollView新增属性：`UIScrollViewKeyboardDismissMode`</span></span><br><span class=\"line\">像Messages app一样在滚动的时候，将键盘隐藏，是一种非常好的体验。  </span><br><span class=\"line\">在以前，将这项功能整合到app很难，现在仅仅只需要在Storyboard中简单的改变一个属性值，或者增加一行代码即可。</span><br><span class=\"line\"></span><br><span class=\"line\">这个属性使用了新的`<span class=\"built_in\">UIScrollViewKeyboardDismissMode</span>` <span class=\"keyword\">enum</span>枚举类型。这个<span class=\"keyword\">enum</span>枚举类型可能的值如下：  </span><br><span class=\"line\">``` objc  <span class=\"built_in\">UIScrollViewKeyboardDismissMode</span>枚举值</span><br><span class=\"line\">\t<span class=\"comment\">// the keyboard is not dismissed automatically when scrolling</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">UIScrollViewKeyboardDismissModeNone</span>   </span><br><span class=\"line\">    <span class=\"comment\">// dismisses the keyboard when a drag begins </span></span><br><span class=\"line\">\t\t<span class=\"built_in\">UIScrollViewKeyboardDismissModeOnDrag</span>  </span><br><span class=\"line\">    <span class=\"comment\">// the keyboard follows the dragging touch off screen, and may be pulled upward again to cancel the dismiss </span></span><br><span class=\"line\">\t\t<span class=\"built_in\">UIScrollViewKeyboardDismissModeInteractive</span>  </span><br><span class=\"line\">```  </span><br><span class=\"line\">在storyboard中设置该属性值:  </span><br><span class=\"line\">![<span class=\"built_in\">UIScrollViewKeyboardDismissMode</span>](/images/<span class=\"built_in\">UIScrollViewKeyboardDismissMode</span>.png)  </span><br><span class=\"line\"><span class=\"meta\">### UIKit使用[NSAttributedString]((http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSAttributedString_Class/)显示HTML，[TextKit](http://)</span></span><br><span class=\"line\">在app中使用Webviews有时会让人非常沮丧，即使只是显示少量的HTML内容 ,Webviews也会消耗大量的内存。</span><br><span class=\"line\">现在提供了一种全新的简单易用的方式来展示HTML内容，适用于任意的`<span class=\"built_in\">UIKit</span>`控件，如`<span class=\"built_in\">UILabel</span>`或`<span class=\"built_in\">UITextField</span>`等。   </span><br><span class=\"line\"><span class=\"number\">1.</span>用少量HTML片段，初始化`<span class=\"built_in\">NSAttributedString</span>`对象:</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% codeblock lang:objc Time to be Awesome - awesome.rb %&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *html = <span class=\"string\">@\"&lt;bold&gt;Wow!&lt;/bold&gt; Now &lt;em&gt;iOS&lt;/em&gt; can create &lt;h3&gt;NSAttributedString&lt;/h3&gt; from HTMLs!\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *options = @&#123;<span class=\"built_in\">NSDocumentTypeDocumentAttribute</span>: <span class=\"built_in\">NSHTMLTextDocumentType</span>&#125;;</span><br><span class=\"line\">&#123;% endcodeblock %&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">``` objc 用少量HTML片段，初始化`<span class=\"built_in\">NSAttributedString</span>`对象 http:<span class=\"comment\">//developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSAttributedString_Class/</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *html = <span class=\"string\">@\"&lt;bold&gt;Wow!&lt;/bold&gt; Now &lt;em&gt;iOS&lt;/em&gt; can create &lt;h3&gt;NSAttributedString&lt;/h3&gt; from HTMLs!\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *options = @&#123;<span class=\"built_in\">NSDocumentTypeDocumentAttribute</span>: <span class=\"built_in\">NSHTMLTextDocumentType</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">NSData</span> *htmlData = [html dataUsingEncoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSAttributedString</span> *attrString = [[<span class=\"built_in\">NSAttributedString</span> alloc] initWithData:htmlData</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t                      options:options </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t                       documentAttributes:<span class=\"literal\">nil</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t   \t\t\t                        error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">```\t\t\t\t\t\t\t\t   \t</span><br><span class=\"line\"><span class=\"built_in\">NSDocumentTypeDocumentAttribute</span>包括:</span><br><span class=\"line\">&lt;!--https:<span class=\"comment\">//gist.githubusercontent.com/huos3203/ecba275d5e4404678354/raw/1636f62209b056b4acbe07021f596e1ffd5ef301/%E8%A7%A3%E6%9E%90NSAttributedString%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%88%90HTML%E7%89%87%E6%AE%B5</span></span><br><span class=\"line\">--&gt;</span><br><span class=\"line\">\t<span class=\"built_in\">NSPlainTextDocumentType</span>\t\t<span class=\"comment\">//Plain text document.</span></span><br><span class=\"line\">    <span class=\"built_in\">NSRTFTextDocumentType</span>\t\t<span class=\"comment\">//Rich text format document.</span></span><br><span class=\"line\">    <span class=\"built_in\">NSRTFDTextDocumentType</span>\t\t<span class=\"comment\">//Rich text format with attachments document.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>相反，也可以将`<span class=\"built_in\">NSAttributedString</span>`对象，解析成HTML片段：</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% gist ecba275d5e4404678354 %E8%A7%A3%E6%<span class=\"number\">9</span>E%<span class=\"number\">90</span>NSAttributedString%E5%AF%B9%E8%B1%A1%EF%BC%<span class=\"number\">8</span>C%E8%<span class=\"number\">8</span>E%B7%E5%<span class=\"number\">8</span>F%<span class=\"number\">96</span>%E6%<span class=\"number\">88</span>%<span class=\"number\">90</span>HTML%E7%<span class=\"number\">89</span>%<span class=\"number\">87</span>%E6%AE%B5.m %&#125;\t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">### NSLinkAttributeName让标签（UILabel,UITextView）支持超链接</span></span><br><span class=\"line\"> </span><br><span class=\"line\">首先，创建一个`<span class=\"built_in\">NSAttributedString</span>`对象,然后，调用`addAttribute:value:range:`方法，添加 `<span class=\"built_in\">NSLinkAttributeName</span>`属性并赋值，如下：  </span><br><span class=\"line\">``` objc <span class=\"built_in\">UITextView</span>支持超链接</span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableAttributedString</span> *attributedString = [[<span class=\"built_in\">NSMutableAttributedString</span> alloc] initWithString:<span class=\"string\">@\"This is an example by @marcelofabri_\"</span>]; </span><br><span class=\"line\">\t[attributedString addAttribute:<span class=\"built_in\">NSLinkAttributeName</span> </span><br><span class=\"line\">                         value:<span class=\"string\">@\"username://marcelofabri_\"</span> </span><br><span class=\"line\">                         range:[[attributedString string] rangeOfString:<span class=\"string\">@\"@marcelofabri_\"</span>]]; </span><br><span class=\"line\">\t<span class=\"built_in\">NSDictionary</span> *linkAttributes = @&#123;<span class=\"built_in\">NSForegroundColorAttributeName</span>: [<span class=\"built_in\">UIColor</span> greenColor], </span><br><span class=\"line\">                                 <span class=\"built_in\">NSUnderlineColorAttributeName</span>: [<span class=\"built_in\">UIColor</span> lightGrayColor], </span><br><span class=\"line\">                                 <span class=\"built_in\">NSUnderlineStyleAttributeName</span>: @(<span class=\"built_in\">NSUnderlinePatternSolid</span>)&#125;;  </span><br><span class=\"line\">\t<span class=\"comment\">// assume that textView is a UITextView previously created (either by code or Interface Builder) </span></span><br><span class=\"line\">\ttextView.linkTextAttributes = linkAttributes; <span class=\"comment\">// customizes the appearance of links </span></span><br><span class=\"line\">\ttextView.attributedText = attributedString; </span><br><span class=\"line\">\ttextView.delegate = <span class=\"keyword\">self</span>;</span><br></pre></td></tr></table></figure></p>\n<p>当然，也可以使用<code>UITextViewDelegate</code>新增的协议方法<font color=\"red\"><strong>shouldInteractWithURL</strong></font>，来自定义点击事件：<br><figure class=\"highlight objc\"><figcaption><span>协议方法shouldInteractWithURL</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)textView:(<span class=\"built_in\">UITextView</span> *)textView shouldInteractWithURL:(<span class=\"built_in\">NSURL</span> *)URL </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t               inRange:(<span class=\"built_in\">NSRange</span>)characterRange &#123; </span><br><span class=\"line\">\t\t\t    <span class=\"keyword\">if</span> ([[URL scheme] isEqualToString:<span class=\"string\">@\"username\"</span>]) &#123; </span><br><span class=\"line\">\t\t\t        <span class=\"built_in\">NSString</span> *username = [URL host];  </span><br><span class=\"line\">\t\t\t        <span class=\"comment\">// do something with this username </span></span><br><span class=\"line\">\t\t\t        <span class=\"comment\">// ... </span></span><br><span class=\"line\">\t\t\t        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>; </span><br><span class=\"line\">\t\t\t    &#125; </span><br><span class=\"line\">\t\t\t    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>; <span class=\"comment\">// let the system open this URL </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Tint-images-with-UIImage-renderingMode\"><a href=\"#Tint-images-with-UIImage-renderingMode\" class=\"headerlink\" title=\"Tint images with UIImage.renderingMode\"></a>Tint images with <code>UIImage.renderingMode</code></h3><p>Tinting is a big part of the new look and feel of iOS 7, and you have control whether your image is tinted or not when rendered.<br>UIImage now has a read-only property named <code>renderingMode</code> as well as a new method <code>imageWithRenderingMode:</code> which uses the new enum <code>UIImageRenderingMode</code> containing the following possible values:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Use the default rendering mode for the context where the image is used</span><br><span class=\"line\">\tUIImageRenderingModeAutomatic  </span><br><span class=\"line\">// Always draw the original image, without treating it as a template</span><br><span class=\"line\">\tUIImageRenderingModeAlwaysOriginal  </span><br><span class=\"line\">// Always draw the image as a template image, ignoring its color information</span><br><span class=\"line\">\tUIImageRenderingModeAlwaysTemplate</span><br></pre></td></tr></table></figure></p>\n<p>The code below shows how easy it is to create an image with a given rendering mode:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIImage</span> *img = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"myimage\"</span>]; </span><br><span class=\"line\">img = [img imageWithRenderingMode:<span class=\"built_in\">UIImageRenderingModeAlwaysTemplate</span>];</span><br></pre></td></tr></table></figure></p>\n<p>The default value of renderingMode is UIImageRenderingModeAutomatic.<br>Whether the image will be tinted or not depends on where it’s being displayed as shown by the examples below:<br><img src=\"/images/uiimagerenderingmode.png\" alt=\"image\"></p>\n<h3 id=\"Usage-of-tintColor-vs-barTintColor\"><a href=\"#Usage-of-tintColor-vs-barTintColor\" class=\"headerlink\" title=\"Usage of tintColor vs barTintColor\"></a>Usage of tintColor vs barTintColor</h3><p>In iOS 7 you can tint your entire app with a given color or even implement color themes to help your app stand out from the rest.Setting the tint color of your app is as easy as using the new property <code>tintColor</code> of <code>UIView</code>.<br>Does that property sound familiar? it should — some classes such as <code>UINavigationBar</code>, <code>UISearchBar</code>, <code>UITabBar</code> and <code>UIToolbar</code> already had a property with this name. They now have a new property: <code>barTintColor</code>.<br>In order to avoid getting tripped up by the new property, you should perform the following check if your app needs to support iOS 6 or earlier:</p>\n<figure class=\"highlight objc\"><figcaption><span>bar通过判断是否包含setBarTintColor:确定系统版本</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UINavigationBar</span> *bar = <span class=\"keyword\">self</span>.navigationController.navigationBar;</span><br><span class=\"line\"><span class=\"built_in\">UIColor</span> *color = [<span class=\"built_in\">UIColor</span> greenColor];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> ([bar respondsToSelector:<span class=\"keyword\">@selector</span>(setBarTintColor:)]) &#123; </span><br><span class=\"line\">\t\t<span class=\"comment\">// iOS 7+</span></span><br><span class=\"line\">\t\t    bar.barTintColor = color;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">\t\t<span class=\"comment\">// iOS 6 or earlier</span></span><br><span class=\"line\">\t\t    bar.tintColor = color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```\t  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">### Check which wireless routes are available</span></span><br><span class=\"line\">The ability to customize a video player (and friends) has evolved throughout the past few iOS versions. As an example, prior to iOS <span class=\"number\">6</span> you couldn’t change the AirPlay icon on a `<span class=\"built_in\">MPVolumeView</span>`.  </span><br><span class=\"line\">In iOS <span class=\"number\">7</span>, you’re finally able to know <span class=\"keyword\">if</span> a remote device is available via AirPlay, Bluetooth, or some other wireless mechanism. This allows your app to behave appropriately, such as hiding an AirPlay icon when that service isn’t available on other devices.  </span><br><span class=\"line\">The following two new properties and notifications have been added to <span class=\"built_in\">MPVolumeView</span>:  </span><br><span class=\"line\"></span><br><span class=\"line\">``` objc  </span><br><span class=\"line\"><span class=\"comment\">// is there a route that the device can connect to?</span></span><br><span class=\"line\">\t<span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">BOOL</span> wirelessRoutesAvailable;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"comment\">// is the device currently connected?</span></span><br><span class=\"line\">\t<span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">BOOL</span> wirelessRouteActive;   </span><br><span class=\"line\">  <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">MPVolumeViewWirelessRoutesAvailableDidChangeNotification</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">MPVolumeViewWirelessRouteActiveDidChangeNotification</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"NSArray-firstObject-的实现\"><a href=\"#NSArray-firstObject-的实现\" class=\"headerlink\" title=\"-[NSArray firstObject]的实现\"></a><code>-[NSArray firstObject]</code>的实现</h3><p><code>-[NSArray firstObject]</code>可能是Objective-C中被调用做多的API。 在iOS4.0中<code>firstObject</code>已经被使用，但是那时仅仅是一个私有方法。在iOS7以前，常用方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *arr = @[]; </span><br><span class=\"line\"><span class=\"keyword\">id</span> item = [arr firstObject]; </span><br><span class=\"line\"><span class=\"comment\">// 前你需要做以下工作 </span></span><br><span class=\"line\"><span class=\"keyword\">id</span> item = [arr count] &gt; <span class=\"number\">0</span> ? arr[<span class=\"number\">0</span>] : <span class=\"literal\">nil</span>;</span><br></pre></td></tr></table></figure></p>\n<p>因为上面的方式很常用，一般创建一个类别实现该方法<code>firstObject</code>增加到NSArray中。</p>\n<p>这个方法的问题:<code>方法名</code>必须是唯一的，否则,这个方法所引发的问题无法预估。所以在<code>NSArray</code>中最好不要重载<code>firstObject</code>方法，是有风险的。</p>\n<h3 id=\"UIButtonTypeRoundRect被UIButtonTypeSystem取代\"><a href=\"#UIButtonTypeRoundRect被UIButtonTypeSystem取代\" class=\"headerlink\" title=\"UIButtonTypeRoundRect被UIButtonTypeSystem取代\"></a>UIButtonTypeRoundRect被UIButtonTypeSystem取代</h3><p><img src=\"http://cdn1.raywenderlich.com/wp-content/uploads/2010/05/Rate.jpg\" alt=\"alt text\" title=\"UIButtonTypeRoundRect被UIButtonTypeSystem取代\"></p>\n<h4 id=\"UIPasteboard由共享变为沙盒化了\"><a href=\"#UIPasteboard由共享变为沙盒化了\" class=\"headerlink\" title=\"UIPasteboard由共享变为沙盒化了\"></a><code>UIPasteboard</code>由共享变为沙盒化了</h4><p>UIPasteboard过去是用来做app之间的数据分享的。开发者一般使用它来存储标识符，比如:OpenUDID。<br>但在在iOS7中，使用 <code>+[UIPasteboard pasteboardWithName:create:]</code>和 <code>+[UIPasteboard pasteboardWithUniqueName]</code>创建剪贴板，而且只对相同的app group可见，这样再和其他的相关app分享以前的OpenUDID等标识符时，就会出现问题。</p>\n<h4 id=\"MAC地址-被统一化\"><a href=\"#MAC地址-被统一化\" class=\"headerlink\" title=\"MAC地址:被统一化\"></a><code>MAC地址</code>:被统一化</h4><p>在IOS7之前，生成iOS设备唯一标示符的方法是使用iOS设备的Media Access Control（MAC）地址。 一个MAC地址是一个唯一的号码，它是物理网络层级方面分配给网络适配器的。<br>然而，苹果并不希望有人通过MAC地址来分辨用户，在iOS7以上，查询MAC地址，它现在只会返回02:00:00:00:00:00。<br>目前，苹果推荐开发者使用以下两种方式，来获取作为框架和应用的唯一标示符：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"built_in\">NSString</span> *identifierForVendor = [[<span class=\"built_in\">UIDevice</span> currentDevice].identifierForVendor UUIDString]; </span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *identifierForAdvertising = [[ASIdentifierManager sharedManager].advertisingIdentifier UUIDString];</span><br><span class=\"line\">``` </span><br><span class=\"line\">`identifierForVendor`：由同一个公司发行的的app在相同的设备上运行的时候都会有这个相同的标识符。然而，如果用户删除了这个供应商的app然后再重新安装的话，这个标识符就会不一致。</span><br><span class=\"line\">`advertisingIdentifier`：返回给在这个设备上所有软件供应商公用的唯一值，所以只能在广告的时候使用。这个值会因为很多情况而有所变化，比如说用户初始化设备的时候便会改变。</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">####  app启动麦克风，需争征得用户同意  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">  以前如果app需要使用用户的位置，通讯录，日历，提醒以及照片，接受推送消息，使用用户的社交网络的时候需要征得用户的同意。</span><br><span class=\"line\">  现在在iOS7当中，使用麦克风也需要取得用户同意了。如果用户不允许app使用麦克风的话，那么需要使用麦克风的app就不能接收不到任何声音。</span><br><span class=\"line\">  以下的代码是用来查询用户是否允许app使用麦克风：  </span><br><span class=\"line\">```\tobjc\t\t</span><br><span class=\"line\">\t<span class=\"comment\">//第一次调用这个方法的时候，系统会提示用户让他同意你的app获取麦克风的数据 </span></span><br><span class=\"line\">\t<span class=\"comment\">// 其他时候调用方法的时候，则不会提醒用户 </span></span><br><span class=\"line\">\t<span class=\"comment\">// 而会传递之前的值来要求用户同意 </span></span><br><span class=\"line\">\t[[<span class=\"built_in\">AVAudioSession</span> sharedInstance] requestRecordPermission:^(<span class=\"built_in\">BOOL</span> granted) &#123; </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t    <span class=\"keyword\">if</span> (granted) &#123; </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t        <span class=\"comment\">// 用户同意获取数据 </span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t    &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t        <span class=\"comment\">// 可以显示一个提示框告诉用户这个app没有得到允许？ </span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t    &#125; </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t    &#125;</span><br><span class=\"line\">    ];</span><br></pre></td></tr></table></figure></p>\n<p>如果没有经过用户同意，就调用麦克风，iOS系统自动弹出以下警示栏：<br><img src=\"/images/microphone.jpg\" alt=\"image\"></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"特性","path":"api/categories/特性.json"}],"tags":[{"name":"IOS7","path":"api/tags/IOS7.json"}]},{"title":"在IOS中像SnapChat一样监控screenshots","slug":"iOS/在IOS中像SnapChat一样监控screenshots","date":"2014-06-10T18:45:37.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/在IOS中像SnapChat一样监控screenshots.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>A <a href=\"http://stackoverflow.com/questions/2121970/notification-of-or-detecting-screenshot-being-taken/2122117\" target=\"_blank\" rel=\"noopener\">number</a> of <a href=\"http://stackoverflow.com/questions/13484516/ios-detection-of-screenshot\" target=\"_blank\" rel=\"noopener\">Stack</a>  <a href=\"http://stackoverflow.com/questions/10122212/iphone-screenshot\" target=\"_blank\" rel=\"noopener\">Overflow</a>questions were having issues with this, so I figured I’d explain. From reverse engineering, this is the exact method used by SnapChat, but it’s also pretty much what I’d have done myself.<br><a id=\"more\"></a><br>The process is pretty simple, and relies on a quirk of iOS: taking a screenshot cancels all touches on the screen. Because of that, anything that you want to protect will require you to have the user to touch the screen to see. If that works for your purposes, the general solution is to simply intercept the touch cancellation, and quickly remove any sensitive information from the screen. If you’re also implementing a screenshot counter, as with SnapChat, you will also need to take into account the other cases when a touch might be cancelled: from a system gesture (Notification Center or the iPad’s multitasking gestures), or by activating other pieces of system UI (the power down menu, or the multitasking switcher).</p>\n<p>On a technical level, the two basic pieces are UILongPressGestureRecognizer (or -touchesCancelled:withEvent:, if you want) and UIApplicationDelegate. In your long press handler, you should hide your sensitive information when the gesture recognizer’s state is UIGestureRecognizerStateCancelled, and if you want to track the number of screenshots, increment a counter. Then, in the UIApplicationDelegate, decrement that counter when you receive the -applicationWillEnterBackground: or -applicationDidResignActive: notification to account for the other possibilities for a cancelled touch. You might also need to handle other situations where a touch could be cancelled, if other parts of your app might cause that to happen.</p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"}],"tags":[{"name":"截屏","path":"api/tags/截屏.json"}]},{"title":"IOS7截屏问题","slug":"iOS/IOS7截屏问题","date":"2014-06-10T18:29:31.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/IOS7截屏问题.json","excerpt":null,"keywords":null,"cover":"http://resource.feng.com/resource/h027/h71/img201307301647042.jpg","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"iOS-7截图最新变化-不再影响用户其他操作\"><a href=\"#iOS-7截图最新变化-不再影响用户其他操作\" class=\"headerlink\" title=\"iOS 7截图最新变化: 不再影响用户其他操作\"></a>iOS 7截图最新变化: 不再影响用户其他操作</h3><p>   在 iOS 7 中，截图动作已经发生了变化，就如苹果在版本说明中描述的那样：用户截图时，有效点击不会再失效了。这个微小的变化对于多款依赖截屏来提醒用户一些不必要动作的应用来说，具有很重要的意义，比如 Snapchat 和 Facebook Poke。<br><a id=\"more\"></a><br>　　用户在应用中打开 Snapchat 照片，查看照片时用户需要单指按在屏幕上让照片处于打开的状态。如果用户试图截图，那么照片马上就会关闭。这是 Snapchat 用来检测“非法”截图的办法。用户拍了照片发送给好友后，这些照片会根据用户所预先设定的时间按时自动销毁。如果接收方在此期间试图进行截图的话，用户也将得到通知。</p>\n<p>   Snapchat在美国青少年群体中十分流行，因为它拥有一种独特的“阅后即焚”机制。用户通过该应用发送的照片将会在数秒内自动被删除，而且它还将采用一种特殊手段阻止照片接收者截屏，并将其截屏企图报告给发送者。在 iOS 6 中，截屏将打断触控操作，而用户观看 Snapchat 照片时，必须将手指按在屏幕上。</p>\n<p>　　在 iOS 7 中截图的操作不会迫使 SnapChat 查看照片的窗口关闭，也就是说当用户截图时系统也不会发出提醒通知。截图不会影响用户在屏幕上的操作，照片不会关闭应用也无法识别截图的动作。如果一名 iOS 6 用户试图截图 iOS 7 用户会收到通知，而反过来的话 iOS 6 用户则不会受到通知。这对于 Snapchat 来说，绝对是个恶梦，因为该服务的风靡与阅后即焚机制关系很大。</p>\n<p>　　虽然 iOS 7 的这个变化对于 iOS 7 Snapchat 用户来说有一定的意义，但是这也对 Snapchat 等应用提出更高的要求，他们必须研究出新的办法来检测截图操作，确保这个新特性不会对他们的应用产生影响。</p>\n<p>　　所幸 iOS 7 beta 4 的发布可以让开发商放下心来。9to5Mac 的 Scott Buscemi 不久前宣布，新版本中新增了一个截屏侦测 API。开发者并未透露这个其具体特性，但他暗示说这个 API 对 Snapchat 来说非常至关重要.<br>　　<br><strong>UIApplication.h</strong></p>\n<pre><code>// This notification is posted after the user takes a screenshot (for example by pressing both the home and lock screen buttons)\nUIKIT_EXTERN NSString *const UIApplicationUserDidTakeScreenshotNotification NS_AVAILABLE_IOS(7_0);\n</code></pre><p>　　据悉，iOS 7 beta 2 发布之后，此前一些无法实现的有趣操作也随之变得可行。由于 iOS 6 的截屏将取消触控操作，使得用户难以截取拉了半截的锁屏界面。而在 iOS 7 beta 2 中，一切变得容易起来（见下图）。  </p>\n<p>　　<img src=\"http://resource.feng.com/resource/h027/h71/img201307301647042.jpg\" alt=\"alt text\" title=\"Snapchat福音 iOS 7 beta 4恢复截屏侦测\"></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"}],"tags":[{"name":"截屏","path":"api/tags/截屏.json"}]}]}