{"name":"语法","postlist":[{"title":"Objective-C的运行时以及swift的动态性","slug":"swift/Objective-C的运行时以及swift的动态性","date":"2017-09-25T20:01:36.000Z","updated":"2017-10-02T22:00:42.000Z","comments":true,"path":"api/articles/swift/Objective-C的运行时以及swift的动态性.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"Objective-C-运行时\"><a href=\"#Objective-C-运行时\" class=\"headerlink\" title=\"Objective-C 运行时\"></a>Objective-C 运行时</h2><p>Objective-C 是一门基于运行时的编程语言，这意味着所有方法、变量、类之间的链接，都会推迟到应用实际运行的最后一刻才会建立。这将给开发人员极高的灵活性，因为我们可以修改这些链接。而不同的是，Swift 绝大多数时候是一门面向编译时的语言。因此在 Swift 当中，灵活性受到了限制，不过您会因此得到更多的安全性。</p>\n<h3 id=\"runtime-h开源库\"><a href=\"#runtime-h开源库\" class=\"headerlink\" title=\"runtime.h开源库\"></a>runtime.h开源库</h3><p>Objective-C 的运行时本质上是一个库。它负责了 “Objective” 这个部分，因此您所知、所爱的面向对象编程，都是在这里实现的。如果您想要访问里面的函数的话，只需要导入这个库即可：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>runtime.h</code>开源库主要由 C 和汇编编写而成，其实现了诸如类、对象、方法调度、协议等面向对象编程这个部分。</p>\n<h4 id=\"构建模块\"><a href=\"#构建模块\" class=\"headerlink\" title=\"构建模块\"></a>构建模块</h4><h5 id=\"对象结构体\"><a href=\"#对象结构体\" class=\"headerlink\" title=\"对象结构体\"></a>对象结构体</h5><p>那么什么是对象呢？对象在 runtime.h 当中是这样定义的：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_class *Class;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> objc_object &#123;</span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>isa</strong>:建立<code>对象</code>只与一个类引用关联，也就是这个 isa 的意思所在。这也就是 Objective-C 当中的所有对象都需要实现的。</p>\n<h5 id=\"类结构体\"><a href=\"#类结构体\" class=\"headerlink\" title=\"类结构体\"></a>类结构体</h5><p>那么类又是什么呢？类的定义要稍微复杂一些。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_class &#123;</span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">    Class super_class;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> version;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> info;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> instance_size;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_ivar_list *ivars;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list **methodLists;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_cache *cache;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *protocols;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>属性说明：<br><strong>isa</strong>属性：建立自身与 <code>super_class</code> 这个值进行关联。<br><strong>super_class</strong>:除了 NSObject 这个类之外，super_class 的值永远不会为 nil，因为 Objective-C 当中的其余类都是以某种方式继承自 NSObject 的。<br><strong>ivars</strong>：变量列表<br><strong>methodLists</strong>：方法列表<br><strong>protocols</strong>：协议列表<br>其他属性：<code>name</code>、<code>version</code>、<code>info</code> 之类的值，不过这些并不是我们感兴趣的内容。<br>这些就是我们能在运行时修改和读取的。可以看到，对象其实本质上是一个非常简单的结构体，类同样也是。</p>\n<h3 id=\"allocateClassPair函数创建类\"><a href=\"#allocateClassPair函数创建类\" class=\"headerlink\" title=\"allocateClassPair函数创建类\"></a>allocateClassPair函数创建类</h3><p>我们可以借助运行时函数，从而在运行时动态创建类。</p>\n<ol>\n<li>要用的 Objective-C 运行时函数：<code>allocateClassPair</code>。提供三个参数即可：<br><strong>isa</strong>：关联引用，这里提供了NSObject<br>类名：<br>额外字节的定义：通常我们都直接赋值 0 即可</li>\n<li>添加变量、方法以及协议</li>\n<li><code>registerClassPair</code>注册这个 ClassPair,注册之后，我们就无法修改变量列表了，不过其余的内容仍然可以修改。</li>\n<li>初始化类结束~我们所创建的这个类和其余的 Objective-C 类毫无区别。<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类函数的构造器</span></span><br><span class=\"line\">Class myClass = objc_allocateClassPair([<span class=\"built_in\">NSObject</span> <span class=\"keyword\">class</span>], <span class=\"string\">\"MyClass\"</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在这里添加变量、方法和协议</span></span><br><span class=\"line\"></span><br><span class=\"line\">objc_registerClassPair(myClass);</span><br><span class=\"line\"><span class=\"comment\">// 当类注册之后，变量列表将会被锁定</span></span><br><span class=\"line\"></span><br><span class=\"line\">[[myClass alloc] init];</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>我们为什么要这么做呢？因为这个函数被大量运用在库提供者制作的框架当中。如果您无法知道用户将会创建什么样的数据，那么您就需要在运行时进行类的创建了。Core Data 就使用了这个功能。此外，如果您愿意的话，它还可以用在 JSON 解析当中。</p>\n<h3 id=\"在类别中添加存储属性\"><a href=\"#在类别中添加存储属性\" class=\"headerlink\" title=\"在类别中添加存储属性\"></a>在类别中添加存储属性</h3><p>如果您想要扩展一个不是自己创建的类，想要向其中添加函数，有一个便捷的方法便是使用 Objective-C 的类别 (Category) 特性。Swift 的扩展与之非常相似。类别的一个问题便在于，它无法添加存储属性。您可以添加一个计算属性，但是存储属性是无法添加的。</p>\n<p>运行时的另一个特性便是：我们可以借助 <code>setAssociatedObject</code> 和 <code>getAssociatedObject</code> 这两个函数，向既有的类当中添加存储属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation NSObject (AssociatedObject)</span><br><span class=\"line\">@dynamic associatedObject;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setAssociatedObject:(id)object &#123;</span><br><span class=\"line\">    objc_setAssociatedObject(self, @selector(associatedObject), object,</span><br><span class=\"line\">    OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (id)associatedObject &#123;</span><br><span class=\"line\">    return objc_getAssociatedObject(self, @selector(associatedObject));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对于不是自己创建的类而言，使用这个方法进行扩展无疑是非常好用的。</p>\n<h3 id=\"内省机制\"><a href=\"#内省机制\" class=\"headerlink\" title=\"内省机制\"></a>内省机制</h3><p>「内省 (introspection)」机制是用来判别这个类能执行何种操作。通常，我们所使用的往往是最基础的内省功能。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类成员判断</span></span><br><span class=\"line\">[myObject isMemberOfClass:<span class=\"built_in\">NSObject</span>.class];</span><br><span class=\"line\"><span class=\"comment\">//类方法判断</span></span><br><span class=\"line\">[myObject respondsToSelector:<span class=\"keyword\">@selector</span>(doStuff:)];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// isa == class</span></span><br><span class=\"line\">class_respondsToSelector(myObject.class, <span class=\"keyword\">@selector</span>(doStuff:));</span><br></pre></td></tr></table></figure></p>\n<p><code>isMemberOfClass</code>:是 Foundation 当中的一部分，这里我们查看 myObject 是否是 NSObject 的子类。<br><code>respondsToSelector:</code>:当我们使用了一个带有可选方法的协议时，为了避免崩溃发生，可以借助这个函数来判断这个对象是否可以调用此可选方法。<br><strong>在运行时层面</strong><br><code>isMemberOfClass</code>: 对比两者的 <strong>isa</strong> 是否相同。<br><code>respondsToSelector</code>:则封装了一个 Objective-C 运行时函数：<code>respondsToSelector</code>，其接受 <code>Selector</code> 和<code>类</code>为参数。</p>\n<h3 id=\"单元测试：方法列表\"><a href=\"#单元测试：方法列表\" class=\"headerlink\" title=\"单元测试：方法列表\"></a>单元测试：方法列表</h3><p>如果您写过单元测试的话，您就会知道当我们在编写 XCTestCase 的时候，需要完成 setUp 和 tearDown 的设定，随后才能编写相关的 test 函数。当测试运行的时候，系统会自行遍历所有的测试函数，并自动运行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unsigned int count;</span><br><span class=\"line\">Method *methods = class_copyMethodList(myObject.class,&amp;count);</span><br><span class=\"line\">//Ivar *list = class_copyIvarList(myObject.class,&amp;count);</span><br><span class=\"line\"></span><br><span class=\"line\">for(unsigned i = 0; i &lt; count; i++) &#123;</span><br><span class=\"line\">    SEL selector = method_getName(methods[i]);</span><br><span class=\"line\">    NSString *selectorString = NSStringFromSelector(selector);</span><br><span class=\"line\">    if ([selectorString containsString:@&quot;test&quot;]) &#123;</span><br><span class=\"line\">        [myObject performSelector:selector];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">free(methods);</span><br></pre></td></tr></table></figure></p>\n<p>这个功能是借助 Objective-C 的运行时机制实现的,即：借助运行时函数获取可以复制方法列表，还可以复制变量列表。可以获取方法名，然后将其转换为字符串，检查其是否包含有 “test”，如果有便可以运行。现在我们便搭建好了 XCTest 的最简单版本！</p>\n<h3 id=\"方法-变量的结构体成员\"><a href=\"#方法-变量的结构体成员\" class=\"headerlink\" title=\"方法/变量的结构体成员\"></a>方法/变量的结构体成员</h3><ol>\n<li><p>变量结构体：包含了变量类型和变量名称。偏移量 (offset) 则是内存管理方面的内容。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_ivar &#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *ivar_name;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *ivar_type;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ivar_offset;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法结构体：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_method &#123;</span><br><span class=\"line\">    SEL method_name;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *method_types;</span><br><span class=\"line\">    IMP method_imp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>SEL</strong>： 使用Selector 来表示的Objective-C方法的名称，对应在 performSelector 当中所匹配的内容。<br><strong>方法类型</strong>：使用编码字符串来表示其类型。<br><strong>IMP</strong>：是方法实现的一种特定的表示方式。</p>\n<h4 id=\"给对象添加方法\"><a href=\"#给对象添加方法\" class=\"headerlink\" title=\"给对象添加方法\"></a>给对象添加方法</h4><p>了解方法结构体后，可知我们同样可以在运行时向对象当中添加方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">Method doStuff = class_getInstanceMethod(<span class=\"keyword\">self</span>.class, <span class=\"keyword\">@selector</span>(doStuff));</span><br><span class=\"line\"><span class=\"comment\">//获取方法的实现</span></span><br><span class=\"line\">IMP doStuffImplementation = method_getImplementation(doStuff);</span><br><span class=\"line\"><span class=\"comment\">//获取方法的类型</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types = method_getTypeEncoding(doStuff); <span class=\"comment\">//“v@:@\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">class_addMethod(myClass.class, <span class=\"keyword\">@selector</span>(doStuff:), doStuffImplementation, types);</span><br></pre></td></tr></table></figure></p>\n<p><code>class_addMethod</code>: 向对象当中添加方法的运行时函数。它所需的参数，即上述方法结构体当中的那三个值：Selector、方法实现和方法类型。</p>\n<h4 id=\"调用新加的方法\"><a href=\"#调用新加的方法\" class=\"headerlink\" title=\"调用新加的方法\"></a>调用新加的方法</h4><p>当然，我们添加了方法目的就是要使用它们。我们可以使用 <code>[self doStuff]</code> 或者<code>[self performSelector:@selector(doStuff)]</code>来进行调用，实际上在运行时级别，它们都是借助 <code>objc_msgSend</code> 向对象发送了一个消息。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方式一</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> doStuff];</span><br><span class=\"line\"><span class=\"comment\">//方式二</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(doStuff)];</span><br><span class=\"line\"><span class=\"comment\">//方式三</span></span><br><span class=\"line\">objc_msgSend(<span class=\"keyword\">self</span>, <span class=\"keyword\">@selector</span>(message));</span><br></pre></td></tr></table></figure></p>\n<p>但是如果调用方法所在的对象为 nil 的时候，我们就会得到一个异常，应用便会崩溃。但事实证明，在崩溃之前会预留几个步骤，从而允许我们对某个不存在的函数进行一些操作。</p>\n<h3 id=\"方法转发\"><a href=\"#方法转发\" class=\"headerlink\" title=\"方法转发\"></a>方法转发</h3><p>当我们试图桥接两个不同的框架的时候，可以将方法转发 (forward) 给其余目标。这个功能便非常有用。当我们调用某个未实现的方法时，这便是会发生的操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1</span><br><span class=\"line\">+(BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class=\"line\">    // 添加实例方法并返回 YES 的一次机会，它随后会再次尝试发送消息</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">+(BOOL)resolveClassMethod:(SEL)sel&#123;</span><br><span class=\"line\">    // 添加类方法并返回 YES 的一次机会，它随后会再次尝试发送消息</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 2</span><br><span class=\"line\">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class=\"line\">    // 返回可以处理 Selector 的对象</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 3</span><br><span class=\"line\">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class=\"line\">    // 您需要实现它来创建 NSInvocation</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)forwardInvocation:(NSInvocation *)invocation &#123;</span><br><span class=\"line\">    // 在您所选择的目标上调用 Selector</span><br><span class=\"line\">    [invocation invokeWithTarget:target];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当您调用了某个不存在的方法时，运行时有如下处理步骤：</p>\n<ol>\n<li>首先调用两个类方法：一个名为 <code>resolveInstanceMethod</code>类方法，如果所调用的方法是类方法，则调用为调用 <code>resolveClassMethod</code>类方法。这时候我们便有机会来添加方法了，步骤的话我们之前就已经展示过了。如果我们返回了 YES，就意味着原始方法将会再次被调用。</li>\n<li><code>forwardingTargetForSelector</code>：当不要添加新方法时，可以直接返回需要调用方法的目标对象即可，之后这个对象就会调用 Selector。</li>\n<li><code>forwardInvocation</code>方法：实现在您所选择的目标对象上调用 Selector，所有的调用过程都被封装到 <code>NSInvocation</code> 对象当中。如果您需要这么做，那么还需要实现 <code>methodSignatureForSelector</code>。<br>完成以上步骤，便可以可以将方法转发给其他对象。<h3 id=\"方法混淆：替换或交换\"><a href=\"#方法混淆：替换或交换\" class=\"headerlink\" title=\"方法混淆：替换或交换\"></a>方法混淆：替换或交换</h3>您可以使用运行时当中最著名的动态特性：方法混淆 (swizzling),即使用 <code>class_replaceMethod</code> 或者 <code>method_exchangeImplementations</code> 来替换方法。之所以想要混淆，是因为它可以用于日志记录和 Mock 测试。<br>混淆的基本方法如下所示：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">void</span>)load &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        Class <span class=\"keyword\">class</span> = [<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        SEL originalSelector = <span class=\"keyword\">@selector</span>(doSomething);</span><br><span class=\"line\">        SEL swizzledSelector = <span class=\"keyword\">@selector</span>(mo_doSomething);</span><br><span class=\"line\"></span><br><span class=\"line\">        Method originalMethod = class_getInstanceMethod(<span class=\"keyword\">class</span>,</span><br><span class=\"line\">        originalSelector);</span><br><span class=\"line\">        Method swizzledMethod = class_getInstanceMethod(<span class=\"keyword\">class</span>,</span><br><span class=\"line\">        swizzledSelector);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">BOOL</span> didAddMethod = class_addMethod(<span class=\"keyword\">class</span>, originalSelector,</span><br><span class=\"line\">                                method_getImplementation(swizzledMethod),</span><br><span class=\"line\">                                method_getTypeEncoding(swizzledMethod));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (didAddMethod) &#123;</span><br><span class=\"line\">            class_replaceMethod(<span class=\"keyword\">class</span>,swizzledSelector,</span><br><span class=\"line\">                                method_getImplementation(originalMethod),</span><br><span class=\"line\">                                method_getTypeEncoding(originalMethod));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>当类加载之后，会调用一个名为 <code>load</code> 的类函数。由于我们只打算混淆一次，因此我们需要使用 <code>dispatch_once</code>。接着我们便可以得到该方法，然后使用 <code>class_replaceMethod</code> 或者 <code>method_exchangeImplementations</code> 来替换方法。</p>\n<h2 id=\"Foundation\"><a href=\"#Foundation\" class=\"headerlink\" title=\"Foundation\"></a>Foundation</h2><p>Foundation 框架实现了基于运行时一个特性的两个API：</p>\n<ol>\n<li><code>键值编码 (key-value-coding, KVC)</code></li>\n<li><code>键值观察 (key-value observing, KVO)</code><br>KVC 和 KVO 允许我们将 UI 和数据进行绑定，这也是 Rx 以及其他响应式框架实现的基础。<h3 id=\"KVC\"><a href=\"#KVC\" class=\"headerlink\" title=\"KVC\"></a>KVC</h3>KVC 的工作方式如下所示：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSNumber</span> *number;</span><br><span class=\"line\"></span><br><span class=\"line\">[myClass valueForKey:<span class=\"string\">@\"number\"</span>];</span><br><span class=\"line\">[myClass setValue:@(<span class=\"number\">4</span>) forKey:<span class=\"string\">@\"number\"</span>];</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>例如，假设我们有这个 number 属性，您可以将属性名称作为键，来获取属性值或者设置属性值。这个功能可以用在此前我们所看到的获取变量列表、协议列表，以及危险的混淆功能当中。</p>\n<h3 id=\"KVO\"><a href=\"#KVO\" class=\"headerlink\" title=\"KVO\"></a>KVO</h3><p>通常所说的 Objective-C 「动态性」，往往都是指 KVO。虽然还有其余的函数，但是这些是最常见、最常用的。这也就是人们所说的，Swift 缺失的部分。</p>\n<ol>\n<li>使用KVO对状态的变化进行注册<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[myClass addObserver:<span class=\"keyword\">self</span></span><br><span class=\"line\">forKeyPath:<span class=\"string\">@\"number\"</span></span><br><span class=\"line\">options:<span class=\"built_in\">NSKeyValueObservingOptionInitial</span> | <span class=\"built_in\">NSKeyValueObservingOptionNew</span></span><br><span class=\"line\">context:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath</span><br><span class=\"line\">ofObject:(<span class=\"keyword\">id</span>)object</span><br><span class=\"line\">change:(<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSKeyValueChangeKey</span>,<span class=\"keyword\">id</span>&gt; *)change</span><br><span class=\"line\">context:(<span class=\"keyword\">void</span> *)context&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Respond to observation.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>在观察的值发生变更之后，KVO 会调用此方法立即通知观察者。通过这个方法，我们便可以按需更新 UI。</p>\n<ol>\n<li>弊端：难以调试<br>KVO这些操作都存有隐患。比方说 KVO，特别是当我们对某个不是自己所创建的类进行观察时，往往会发现有出乎意料的变化发生。通常而言，这些问题是非常难以调试的，也很难去理解为什么出错。在实际产品当中，我并不建议使用它们，尽管它们非常好用。但是在实际产品当中，我会很谨慎地去使用这些功能。</li>\n</ol>\n<p>Apple 也是如此认为的，因此它们在视图控制器当中添加了这个私有方法，可以使用 class-dump 来查看。</p>\n<ul>\n<li>(void)                   attentionClassDumpUser:<br>yesItsUsAgain:<br>althoughSwizzlingAndOverridingPrivateMethodsIsFun:<br>itWasntMuchFunWhenYourAppStoppedWorking:<br>pleaseRefrainFromDoingSoInTheFutureOkayThanksBye:</li>\n</ul>\n<p>的确，很让人抓狂。</p>\n<h2 id=\"Swift\"><a href=\"#Swift\" class=\"headerlink\" title=\"Swift\"></a>Swift</h2><p>Swift 是一种强类型语言。即默认类型是安全的静态类型。如果需要的话，不安全类型也是存在的，但是 Swift 仍然是尽力推动我们使用安全的静态类型。Swift 中的动态性可以通过 Objective-C 运行时来获得。</p>\n<p>本来这是很好的，但是 Swift 开源并迁移到 Linux 之后，由于 Linux 上的 Swift 并不提供 Objective-C 运行时，事情就大条了。社区的关键点在于，让 Swift 未来能够自己配备动态性，而不是依赖于 Apple。</p>\n<h3 id=\"Swift中的两个动态修饰符\"><a href=\"#Swift中的两个动态修饰符\" class=\"headerlink\" title=\"Swift中的两个动态修饰符\"></a>Swift中的两个动态修饰符</h3><ol>\n<li><code>@objc</code>: 将Swift API 暴露给 Objective-C 运行时，但是它仍然不能保证编译器会尝试对其进行优化。</li>\n<li><code>@dynamic</code>:动态功能修饰符，它隐含添加了 <code>@objc</code>功能。</li>\n</ol>\n<h3 id=\"Swift中运行时方法\"><a href=\"#Swift中运行时方法\" class=\"headerlink\" title=\"Swift中运行时方法\"></a>Swift中运行时方法</h3><p>回到我们的动态特性当中，让我们来看一看 Swift 当中这些动态特性是什么样的。假设我们需要使用内省机制、转发方法、替换和绑定方法。</p>\n<h4 id=\"方法转发-1\"><a href=\"#方法转发-1\" class=\"headerlink\" title=\"方法转发\"></a>方法转发</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\">override <span class=\"keyword\">class</span> func resolveInstanceMethod(_ sel: Selector!)</span><br><span class=\"line\">-&gt; Bool &#123;</span><br><span class=\"line\"><span class=\"comment\">// 添加实例方法并返回 true 的一次机会，它随后会再次尝试发送消息</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\">override func forwardingTarget(<span class=\"keyword\">for</span> aSelector: Selector!) -&gt;</span><br><span class=\"line\">Any? &#123;</span><br><span class=\"line\"><span class=\"comment\">// 返回可以处理 Selector 的对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3 - Swift 不支持 NSInvocation</span></span><br></pre></td></tr></table></figure>\n<p>resolveInstanceMethod 同样会被调用，forwardingTarget 看起来似乎更贴近于 Swift 3 风格的 API。但是 NSInvocation 并不能在 Swift 当中使用。我们同样可以实现方法转发，因此看起来也不算太坏。</p>\n<h4 id=\"方法混淆\"><a href=\"#方法混淆\" class=\"headerlink\" title=\"方法混淆\"></a>方法混淆</h4><p><code>load</code> 在 Swift 不再会被调用，因此我们需要在 <code>initialize</code> 中进行混淆。在 Objective-C 当中使用的 <code>dispatch_once</code>，但是在 Swift 3 中被废弃。事情变得略为复杂。虽然对于特定类型的函数而言，我们仍然可以将其定义为动态函数，但是它会消除大部分混淆的功能。</p>\n<h4 id=\"内省机制-1\"><a href=\"#内省机制-1\" class=\"headerlink\" title=\"内省机制\"></a>内省机制</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if self is MyClass &#123;</span><br><span class=\"line\">    // YAY</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let myString = &quot;myString&quot;;</span><br><span class=\"line\">let mirror = Mirror(reflecting: myString)</span><br><span class=\"line\">print(mirror.subjectType) // “String&quot;</span><br><span class=\"line\">let string = String(reflecting: type(of:</span><br><span class=\"line\">myString)) // Swift.String</span><br><span class=\"line\"></span><br><span class=\"line\">// No native method introspection</span><br></pre></td></tr></table></figure>\n<p><code>is</code> 替代了 <code>isMemberOfClass</code>，它同样也可以对 Swift 值类型:结构体、枚举以及其他 Swift 当中的新类型使用。此外还有一个新的映射 API，它主要针对于管道 (pipe) 和数据。</p>\n<h4 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h4><p>目前，我们没有原生的办法来实现内省。这也预示着这个功能未来可能会出现，但是目前我们还无法实现。这很令人沮丧，特别是当您想到我们此前所实现的 XCTestCase。如果您打算为 Linux 编写单元测试的时候，就无法自动遍历所有的函数。您必须实现 static var allTests，然后手动列出所有的测试函数。这很糟糕。</p>\n<h4 id=\"KVC-KVO功能的削弱\"><a href=\"#KVC-KVO功能的削弱\" class=\"headerlink\" title=\"KVC/KVO功能的削弱\"></a>KVC/KVO功能的削弱</h4><p>KVO 的魅力在于，您可以在不是自己所创建的类当中使用它，也可以只对您想要监听变化的类使用。KVO 和 KVC 在 Swift 被极大地削弱了。<br>两点要求：</p>\n<ol>\n<li>被观察的对象必须要继承自 NSObject，并且使用一个 Objective-C 类型。</li>\n<li>被观察的变量必须要声明为 @dynamic。您必须要对想要观察的事务了如指掌。<br>问题是 Swift 并没有很好的替代方案。您可以使用 Rx 或者基于协议来观察对象。但是语言自身是没有原生的解决方案的。</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总而言之，Objective-C 的动态性无疑是非常强大的、极其有用，虽然也存在危险性。Swift 目前没有足够的替代方案来解决这些问题，但是可以预见在不久的将来 Swift 的动态性将会出现，这是值得我们期待的。</p>\n","raw":null,"categories":[{"name":"swift","path":"api/categories/swift.json"},{"name":"语法","path":"api/categories/语法.json"}],"tags":[]},{"title":"swift错误处理","slug":"swift/错误处理","date":"2017-01-11T17:04:21.000Z","updated":"2017-01-12T11:57:41.000Z","comments":true,"path":"api/articles/swift/错误处理.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>Error handling is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime.<br>Some operations aren’t guaranteed to always complete execution or produce a useful output. Optionals are used to represent the absence of a value, but when an operation fails, it’s often useful to understand what caused the failure, so that your code can respond accordingly.<br>As an example, consider the task of reading and processing data from a file on disk. There are a number of ways this task can fail, including the file not existing at the specified path, the file not having read permissions, or the file not being encoded in a compatible format. Distinguishing among these different situations allows a program to resolve some errors and to communicate to the user any errors it can’t resolve.<br>举例，在读取和处理磁盘上的一个文件的数据时，会有有许多方法失败，包括指定的文件路径找不到，没有文件的读取权限，或文件编码格式不兼容。在这些不同情况下，就可以让程序提示用户导致程序无法执行的具体原因。</p>\n<h1 id=\"Representing-and-Throwing-Errors\"><a href=\"#Representing-and-Throwing-Errors\" class=\"headerlink\" title=\"Representing and Throwing Errors\"></a>Representing and Throwing Errors</h1><p>In Swift, errors are represented by values of types that conform to the Error protocol. This empty protocol indicates that a type can be used for error handling.<br>在swift中，错误类型是遵循Error 协议。</p>\n<p>Swift enumerations are particularly well suited to modeling a group of related error conditions, with associated values allowing for additional information about the nature of an error to be communicated. For example, here’s how you might represent the error conditions of operating a vending machine inside a game:<br>swift枚举类型特别适合为一组错误条件建模，用来关联导致错误的真正原因的相关信息。例如：<br>一个在操作一台游戏机时的会出现的错误枚举类：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">VendingMachineError</span>: <span class=\"title\">Error</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> invalidSelection</span><br><span class=\"line\"><span class=\"keyword\">case</span> insufficientFunds(coinsNeeded: <span class=\"type\">Int</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> outOfStock</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Throwing an error lets you indicate that something unexpected happened and the normal flow of execution can’t continue. You use a throw statement to throw an error. For example, the following code throws an error to indicate that five additional coins are needed by the vending machine:<br>抛出错误说明游戏出现异常，导致其他操作无法进行。这是需要通过Throw语句来抛出这个错误。例如，以下代码抛出了一个错误表明需要five：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"type\">VendingMachineError</span>.insufficientFunds(coinsNeeded: <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Handling-Errors\"><a href=\"#Handling-Errors\" class=\"headerlink\" title=\"Handling Errors\"></a>Handling Errors</h1><p>When an error is thrown, some surrounding piece of code must be responsible for handling the error—for example, by correcting the problem, trying an alternative approach, or informing the user of the failure.<br>当错误抛出后，这段代码必须来处理这个错误。例如：通过纠正问题，尝试其他方式实现，或通知用户的失败。</p>\n<p>There are four ways to handle errors in Swift. You can propagate the error from a function to the code that calls that function, handle the error using a do-catch statement, handle the error as an optional value, or assert that the error will not occur. Each approach is described in a section below.<br>在swift中有四种处理错误机制:</p>\n<pre><code>1. 向调用方法中传递这个错误\n2. 使用do-catch语句处理\n3. 把错误设置为可选型\n4.断言不会出现异常的情况下，使用try!禁止异常抛出\n</code></pre><p>When a function throws an error, it changes the flow of your program, so it’s important that you can quickly identify places in your code that can throw errors. To identify these places in your code, write the try keyword—or the try? or try! variation—before a piece of code that calls a function, method, or initializer that can throw an error. These keywords are described in the sections below.<br>当一个方法抛出错误时，会打断程序正常的工作流，必须快速定位到可能抛出错误的代码。可以使用关键字<code>try</code> 要注意 <code>try?</code>或<code>try!</code>之间的差异。在调用一个函数，方法或者构造器之前，来抛出异常。</p>\n<h2 id=\"Propagating-Errors-Using-Throwing-Functions\"><a href=\"#Propagating-Errors-Using-Throwing-Functions\" class=\"headerlink\" title=\"Propagating Errors Using Throwing Functions\"></a>Propagating Errors Using Throwing Functions</h2><p>To indicate that a function, method, or initializer can throw an error, you write the throws keyword in the function’s declaration after its parameters. A function marked with throws is called a throwing function. If the function specifies a return type, you write the throwskeyword before the return arrow (-&gt;).<br>函数，方法或构造器都可以抛出异常，只需要在声明它们时添加关键字：<code>throws</code>即可，这种方法被称为<code>throws</code>函数，<code>throws</code>关键字位置在参数之后，返回值(-&gt;)之前</p>\n<p>A throwing function propagates errors that are thrown inside of it to the scope from which it’s called.<br>抛出函数会把错误抛给调用它的函数周期中去。</p>\n<a id=\"more\"></a>\n<p>Only throwing functions can propagate errors. Any errors thrown inside a nonthrowing function must be handled inside the function.<br>只有抛出函数能传递错误，如果不是抛出函数，它自己必须处理掉任何抛进来的错误。</p>\n<p>In the example below, the VendingMachine class has a <code>vend(itemNamed:)</code> method that throws an appropriate VendingMachineError if the requested item is not available, is out of stock, or has a cost that exceeds the current deposited amount:<br>在下面的例子中，对某个请求内容不可用时，自动售货机会通过<code>vend(itemNamed:)</code>方法抛出一个对应的<code>VendingMachineError</code>错误，缺货或超过目前的存款金额成本：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Item</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> price: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">count</span>: <span class=\"type\">Int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VendingMachine</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> inventory = [</span><br><span class=\"line\">        <span class=\"string\">\"Candy Bar\"</span>: <span class=\"type\">Item</span>(price: <span class=\"number\">12</span>, <span class=\"built_in\">count</span>: <span class=\"number\">7</span>),</span><br><span class=\"line\">        <span class=\"string\">\"Chips\"</span>: <span class=\"type\">Item</span>(price: <span class=\"number\">10</span>, <span class=\"built_in\">count</span>: <span class=\"number\">4</span>),</span><br><span class=\"line\">        <span class=\"string\">\"Pretzels\"</span>: <span class=\"type\">Item</span>(price: <span class=\"number\">7</span>, <span class=\"built_in\">count</span>: <span class=\"number\">11</span>)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    <span class=\"keyword\">var</span> coinsDeposited = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">vend</span><span class=\"params\">(itemNamed name: String)</span></span> <span class=\"keyword\">throws</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> item = inventory[name] <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"type\">VendingMachineError</span>.invalidSelection</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> item.<span class=\"built_in\">count</span> &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"type\">VendingMachineError</span>.outOfStock</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> item.price &lt;= coinsDeposited <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"type\">VendingMachineError</span>.insufficientFunds(coinsNeeded: item.price - coinsDeposited)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        coinsDeposited -= item.price</span><br><span class=\"line\">        <span class=\"keyword\">var</span> newItem = item</span><br><span class=\"line\">        newItem.<span class=\"built_in\">count</span> -= <span class=\"number\">1</span></span><br><span class=\"line\">        inventory[name] = newItem</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Dispensing \\(name)\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>The implementation of the <code>vend(itemNamed:)</code> method uses guard statements to exit the method early and throw appropriate errors if any of the requirements for purchasing a snack aren’t met. Because a throw statement immediately transfers program control, an item will be vended only if all of these requirements are met.<br><code>vend(itemNamed:)</code>方法的实现中使用 <code>guard语句</code>来判断，当在购买操作不符合相应条件会直接抛出相应的错误，来打断该方法的其他操作。因为<code>throw语句</code>会立即转移程序控制权，保证了机器仅出售满足所有条件的物品。</p>\n<p>Because the <code>vend(itemNamed:)</code> method propagates any errors it throws, any code that calls this method must either handle the errors—using a <code>do-catch</code> statement, <code>try?</code>, or <code>try!</code>—or continue to propagate them. For example, the <code>buyFavoriteSnack(person:vendingMachine:)</code> in the example below is also a throwing function, and any errors that the <code>vend(itemNamed:)</code> method throws will propagate up to the point where the <code>buyFavoriteSnack(person:vendingMachine:)</code>function is called.<br>因为vend(itemNamed:)的方法抛出所有错误，所以调用该方法的函数必须处理错误（ <code>do-catch, try?, or try!</code>处理，或使用<code>try</code>向上抛出）。</p>\n<p>例如，<code>buyFavoriteSnack(person:vendingMachine:)</code>也是一个抛出函数，从<code>vend(itemNamed:)</code>方法接受到的所有错误，都会被会<code>buyFavoriteSnack(person:vendingMachine:)</code>继续抛给调用它的函数中。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> favoriteSnacks = [</span><br><span class=\"line\">    <span class=\"string\">\"Alice\"</span>: <span class=\"string\">\"Chips\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"Bob\"</span>: <span class=\"string\">\"Licorice\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"Eve\"</span>: <span class=\"string\">\"Pretzels\"</span>,</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buyFavoriteSnack</span><span class=\"params\">(person: String, vendingMachine: VendingMachine)</span></span> <span class=\"keyword\">throws</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> snackName = favoriteSnacks[person] ?? <span class=\"string\">\"Candy Bar\"</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> vendingMachine.vend(itemNamed: snackName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>In this example, the <code>buyFavoriteSnack(person: vendingMachine:)</code> function looks up a given person’s favorite snack and tries to buy it for them by calling the <code>vend(itemNamed:)</code> method. Because the <code>vend(itemNamed:)</code> method can throw an error, it’s called with the trykeyword in front of it.<br><code>buyFavoriteSnack(person: vendingMachine:)</code> 函数查找买家中意的snake，并<code>vend(itemNamed:)</code>调用尝试购买。使用在方法前使用<code>try</code>关键字来抛出异常，并向上传递。</p>\n<p>Throwing initializers can propagate errors in the same way as throwing functions. For example, the initializer for the <code>PurchasedSnackstructure</code> in the listing below calls a throwing function as part of the initialization process, and it handles any errors that it encounters by propagating them to its caller.<br>抛出构造器也能向抛出函数一样传递错误，例如：<code>PurchasedSnackstructure</code>的构造器中调用了抛出函数：<code>vend(itemNamed:)</code>，抛出构造器可以通过向上传递来处理这些错误。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PurchasedSnack</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, vendingMachine: <span class=\"type\">VendingMachine</span>) <span class=\"keyword\">throws</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> vendingMachine.vend(itemNamed: name)</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Handling-Errors-Using-Do-Catch\"><a href=\"#Handling-Errors-Using-Do-Catch\" class=\"headerlink\" title=\"Handling Errors Using Do-Catch\"></a>Handling Errors Using Do-Catch</h2><p>You use a do-catch statement to handle errors by running a block of code. If an error is thrown by the code in the <code>do</code> clause, it is matched against the <code>catch</code>clauses to determine which one of them can handle the error.<br>使用<code>do-catch</code>语句通过运行代码块来处理错误。在<code>do</code>分句中如果抛出了一个错误，那么就可以在<code>catch</code>分句中进行处理的匹配到错误<br>Here is the general form of a <code>do-catch</code>statement:<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> expression</span><br><span class=\"line\">    statements</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> pattern <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">    statements</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> pattern <span class=\"number\">2</span> <span class=\"keyword\">where</span> condition &#123;</span><br><span class=\"line\">    statements</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>You write a pattern after catch to indicate what errors that clause can handle. If a <code>catch</code> clause doesn’t have a pattern, the clause matches any <code>error</code> and binds the <code>error</code> to a local constant named error. For more information about pattern matching, see Patterns.<br>在关键字catch后边跟随匹配模式，这个<code>catch分句</code>就会处理匹配到的错误，如果关键字<code>catch分句</code>没有任何匹配模式，那么这个分句将会匹配到所有错误，并把这些错误信息赋值给系统常量<code>error</code>。</p>\n<p>The <code>catch</code>clauses don’t have to handle every possible error that the code in its <code>do</code> clause can throw. If none of the catch clauses handle the error, the error propagates to the surrounding scope. However, the error must be handled by some surrounding scope—either by an enclosing <code>do-catch</code> clause that handles the error or by being inside a throwing function. For example, the following code handles all three cases of the <code>VendingMachineError</code>enumeration, but all other errors have to be handled by its surrounding scope:<br><code>catch分句</code>不必对<code>do分句</code>中的代码可能抛出每一个的错误，如果某个错误没有被<code>catch分句</code>匹配到处理，这个错误将会传递到调用它的函数周期中，这个错误必须在这个函数周期中处理，或通过<code>do-catch语句</code>来处理，或通过内部的抛出函数处理。</p>\n<p>例如，下面的代码处理<code>VendingMachineError</code>枚举类中的三个错误<code>cases</code>，但其他的错误都是由其周边范围处理：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vendingMachine = <span class=\"type\">VendingMachine</span>()</span><br><span class=\"line\">vendingMachine.coinsDeposited = <span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> buyFavoriteSnack(person: <span class=\"string\">\"Alice\"</span>, vendingMachine: vendingMachine)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"type\">VendingMachineError</span>.invalidSelection &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Invalid Selection.\"</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"type\">VendingMachineError</span>.outOfStock &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Out of Stock.\"</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"type\">VendingMachineError</span>.insufficientFunds(<span class=\"keyword\">let</span> coinsNeeded) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Insufficient funds. Please insert an additional \\(coinsNeeded) coins.\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Prints \"Insufficient funds. Please insert an additional 2 coins.\"</span></span><br></pre></td></tr></table></figure></p>\n<p>In the above example, the <code>buyFavoriteSnack(person:vendingMachine:)</code> function is called in a try expression, because it can throw an error. If an error is thrown, execution immediately transfers to the <code>catch</code> clauses, which decide whether to allow propagation to continue. If no error is thrown, the remaining statements in the do statement are executed.<br>在上述代码中因为<code>buyFavoriteSnack(person:vendingMachine:)</code>函数会抛出错误异常，所以要在try表达式中调用。如果抛出异常就会立马执行是否继续传递的catch分句，如果没有抛出异常，会保持do分句中的代码正常进行。</p>\n<h2 id=\"Converting-Errors-to-Optional-Values\"><a href=\"#Converting-Errors-to-Optional-Values\" class=\"headerlink\" title=\"Converting Errors to Optional Values\"></a>Converting Errors to Optional Values</h2><p>You use try? to handle an error by converting it to an optional value. If an error is thrown while evaluating the <code>try?</code> expression, the value of the expression is nil. For example, in the following code x and y have the same value and behavior:<br>使用<code>try?表达式</code>处理错误，是通过把错误转换为<code>可选值(?)类型</code>处理。在<code>try?</code>表达式中出现抛出错误时，这个表达式的值<code>=nil</code>。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someThrowingFunction</span><span class=\"params\">()</span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"keyword\">try</span>? someThrowingFunction()</span><br><span class=\"line\"><span class=\"keyword\">let</span> y: <span class=\"type\">Int</span>?</span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    y = <span class=\"keyword\">try</span> someThrowingFunction()</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">    y = <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>If someThrowingFunction() throws an error, the value of x and y is nil. Otherwise, the value of x and y is the value that the function returned. Note that x and y are an optional of whatever type someThrowingFunction() returns. Here the function returns an integer, so xand y are optional integers.<br>如果函数<code>someThrowingFunction()</code>抛出异常，<code>x,y = nil</code>，否则:<code>x,y</code>就时函数<code>return</code>的值。</p>\n<blockquote>\n<p>注意：<code>x,y</code>是一个可选的someThrowingFunction()返回类型。在这里函数返回integer，那么x,y是可选的integer类型。</p>\n</blockquote>\n<p>Using <code>try?</code> lets you write concise error handling code when you want to handle all errors in the same way. For example, the following code uses several approaches to fetch data, or returns nil if all of the approaches fail.<br>当用这种方式来处理所有错误时，使用<code>try?</code>表达式能写更简洁的错误处理代码，例如：下面的代码使用几种方法来获取数据，如果这些方法失败就会返回nil。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fetchData</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Data</span>? &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> data = <span class=\"keyword\">try</span>? fetchDataFromDisk() &#123; <span class=\"keyword\">return</span> data &#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> data = <span class=\"keyword\">try</span>? fetchDataFromServer() &#123; <span class=\"keyword\">return</span> data &#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Disabling-Error-Propagation\"><a href=\"#Disabling-Error-Propagation\" class=\"headerlink\" title=\"Disabling Error Propagation\"></a>Disabling Error Propagation</h2><p>Sometimes you know a throwing function or method won’t, in fact, throw an error at runtime. On those occasions, you can write <code>try!</code> before the expression to disable error propagation and wrap the call in a runtime assertion that no error will be thrown. If an error actually is thrown, you’ll get a runtime error.<br>有时你认为不会出现异常的抛出函数或方法，但事实上，却在运行时抛出异常了。在其他情况下，可以使用<code>try!</code>表达式来禁止错误传递，并且十分肯定断言在运行时不会有异常抛出。如果有异常抛出，就会得到一个运行时错误。</p>\n<p>For example, the following code uses a <code>loadImage(atPath:)</code> function, which loads the image resource at a given path or throws an error if the image can’t be loaded. In this case, because the image is shipped with the application, no error will be thrown at runtime, so it is appropriate to disable error propagation.<br>例如：使用<code>loadImage(atPath:)</code>函数要么通过这个路径加载image，要么image加载失败抛出一个错误。在这种情况下，因为<code>image</code>在app资源目录<code>resources</code>中，所以在运行时肯定不会有异常抛出。因此可以使用<code>try!</code>禁止错误传递。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> photo = <span class=\"keyword\">try</span>! loadImage(atPath: <span class=\"string\">\"./Resources/John Appleseed.jpg\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Specifying-Cleanup-Actions\"><a href=\"#Specifying-Cleanup-Actions\" class=\"headerlink\" title=\"Specifying Cleanup Actions\"></a>Specifying Cleanup Actions</h2><p>You use a defer statement to execute a set of statements just before code execution leaves the current block of code. This statement lets you do any necessary cleanup that should be performed regardless of how execution leaves the current block of code—whether it leaves because an error was thrown or because of a statement such as return or break. For example, you can use a defer statement to ensure that file descriptors are closed and manually allocated memory is freed.<br>在代码执行离开当前代码块之前，使用一个“defer语句”来执行一组语句。defer语句让做一些必要的清理操作，在执行如何离开当前代码块：因为抛出异常或者因为<code>return，break语句</code>导致。例如：使用<code>defer语句</code>执行关闭文件和内存的释放操作，来确保清理操作完成。</p>\n<p>A defer statement defers execution until the current scope is exited. This statement consists of the defer keyword and the statements to be executed later. The deferred statements may not contain any code that would transfer control out of the statements, such as a break or a return statement, or by throwing an error. Deferred actions are executed in reverse order of how they are specified—that is, the code in the first defer statement executes after code in the second, and so on.<br><code>defer语句</code>推迟在直到当前作用域推出时，再执行。<code>defer语句</code>由<code>defer</code>关键字和一些清理操作语句组成。<code>defer语句</code>不包含transfer control out of the statements例如<code>（return，break，throw）</code>等。</p>\n<p><code>defer</code>延迟操作是按照指定的顺序执行的，就是先执行最后一个<code>defer语句</code>中的代码之后，再执行第倒数第二个<code>defer语句</code>的代码，以此类推，倒叙清理退场。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">processFile</span><span class=\"params\">(filename: String)</span></span> <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> exists(filename) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> file = <span class=\"keyword\">open</span>(filename)</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> &#123;</span><br><span class=\"line\">            close(file)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">let</span> line = <span class=\"keyword\">try</span> file.readline() </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Work with the file.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">            <span class=\"comment\">// close(file) is called here, at the end of the scope.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>The above example uses a defer statement to ensure that the <code>open(_:)</code> function has a corresponding call to <code>close(_:)</code>.<br>使用defer语句，确保了在open的同时与之相关的还有close。</p>\n<p>You can use a defer statement even when no error handling code is involved.<br>即使在没有涉及错误处理代码的时候，也可以使用“延迟”语句。</p>\n","raw":null,"categories":[{"name":"swift","path":"api/categories/swift.json"},{"name":"语法","path":"api/categories/语法.json"}],"tags":[{"name":"安全","path":"api/tags/安全.json"}]},{"title":"Swift入门","slug":"swift/Swift入门","date":"2015-11-27T17:18:21.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/swift/Swift入门.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><ul>\n<li><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.html#//apple_ref/doc/uid/TP40014097-CH2-XID_1\" target=\"_blank\" rel=\"noopener\">苹果官方</a>  </li>\n<li><a href=\"http://wiki.jikexueyuan.com/project/swift/\" target=\"_blank\" rel=\"noopener\">中文版</a><h4 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h4>Apple基于已有的编译器、调试器、框架作为其基础架构。通过ARC(Automatic Reference Counting，自动引用计数)来简化内存管理。我们的框架栈则一直基于Cocoa，且Objective-C进化支持了块、collection literal和模块，允许现代语言的框架无需深入即可使用。<br>(by gashero)感谢这些基础工作，才使得可以在Apple软件开发中引入新的编程语言Swift。</li>\n</ul>\n<h4 id=\"swift有点\"><a href=\"#swift有点\" class=\"headerlink\" title=\"swift有点\"></a>swift有点</h4><p>编译器是按照性能优化的，而语言是为开发优化的</p>\n<p>Swift采用了Objective-C的命名参数和动态对象模型。提供了对Cocoa框架和mix-and-match的互操作性。基于这些基础，Swift引入了很多新功能和结合面向过程和面向对象的功能。<br>Swift对新的程序员也是友好的：</p>\n<ol>\n<li>它是工业级品质的系统编程语言，却又像脚本语言一样的友好。</li>\n<li>它支持playground，允许程序员实验一段Swift代码功能并立即看到结果，而无需麻烦的构建和运行一个应用。<br>Swift集成了现代编程语言思想，以及Apple工程文化的智慧，编译器是按照性能优化的，而语言是为开发优化的，无需互相折中。</li>\n</ol>\n<h4 id=\"swift语法\"><a href=\"#swift语法\" class=\"headerlink\" title=\"swift语法\"></a>swift语法</h4><p>Playground允许你编辑代码并立即看到结果,可以从”Hello, world”开始学起并过渡到整个系统。<br>在Xcode的playground中打开:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println(<span class=\"string\">\"Hello, world\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>在Swift，这就是完整的程序:</p>\n<ol>\n<li>无需导入(import)输入输出和字符串处理的系统库。</li>\n<li>全局范围的代码就是用于程序的入口，所以你无需编写一个 main() 函数。也无需在每个语句后写分号。</li>\n</ol>\n<p>所有这些使得Swift成为Apple软件开发者创新的源泉。</p>\n<h4 id=\"简单值-–-使用-let-来定义常量，-var-定义变量\"><a href=\"#简单值-–-使用-let-来定义常量，-var-定义变量\" class=\"headerlink\" title=\"简单值  – 使用 let 来定义常量， var 定义变量\"></a>简单值  – 使用 let 来定义常量， var 定义变量</h4><p>提供一个值就可以创建常量或变量，并让编译器推断其类型,一个常量或变量必须与赋值时拥有相同的类型。因此你不用严格定义类型。<br>常量定义类似于函数式编程语言中的变量,常量的值无需在编译时指定，但是至少要赋值一次,赋值后就无法修改。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myVariable = <span class=\"number\">42</span></span><br><span class=\"line\">myVariable = <span class=\"number\">50</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myConstant = <span class=\"number\">42</span></span><br></pre></td></tr></table></figure></p>\n<p>在上面例子中，编译其会推断myVariable是一个整数类型，因为其初始化值就是个整数。</p>\n<h6 id=\"1-显示-隐式-初始化数据类型-—-类型与变量名绑定，属于静态类型语言\"><a href=\"#1-显示-隐式-初始化数据类型-—-类型与变量名绑定，属于静态类型语言\" class=\"headerlink\" title=\"1. 显示/隐式 初始化数据类型 —   类型与变量名绑定，属于静态类型语言\"></a>1. 显示/隐式 初始化数据类型 —   类型与变量名绑定，属于静态类型语言</h6><p>类型与变量名绑定，属于静态类型语言。有助于静态优化。与Python、JavaScript等有所区别。<br>例如：初始化值没有提供足够的信息(或没有初始化值)，可以在变量名后写类型，以冒号分隔。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> imlicitInteger = <span class=\"number\">70</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> imlicitDouble = <span class=\"number\">70.0</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> explicitDouble: <span class=\"type\">Double</span> = <span class=\"number\">70</span></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"2-变量-拼接到字符串-–-变量值永远不会隐含转换到其他类型\"><a href=\"#2-变量-拼接到字符串-–-变量值永远不会隐含转换到其他类型\" class=\"headerlink\" title=\"2. 变量  拼接到字符串  – 变量值永远不会隐含转换到其他类型\"></a>2. 变量  拼接到字符串  – 变量值永远不会隐含转换到其他类型</h6><ul>\n<li><p>String(变量名)</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> label = <span class=\"string\">\"The width is \"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> width = <span class=\"number\">94</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> widthLabel = label + <span class=\"type\">String</span>(width)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>以小括号来写值，并用反斜线(“”)放在小括号之前</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> apples = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> oranges = <span class=\"number\">5</span>     <span class=\"comment\">//by gashero</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> appleSummary = <span class=\"string\">\"I have \\(apples) apples.\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fruitSummary = <span class=\"string\">\"I have \\(apples + oranges) pieces of fruit.\"</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"数组和字典的用法\"><a href=\"#数组和字典的用法\" class=\"headerlink\" title=\"数组和字典的用法\"></a>数组和字典的用法</h4><ol>\n<li>声明并初始化<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> emptyArray = <span class=\"type\">String</span>[]()</span><br><span class=\"line\"><span class=\"keyword\">let</span> emptyDictionary = <span class=\"type\">Dictionary</span>&lt;<span class=\"type\">String</span>, <span class=\"type\">Float</span>&gt;()</span><br><span class=\"line\">shoppingList = [] <span class=\"comment\">//去购物并买些东西</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如果数组类型无法推断，你可以写空的数组为 “[]” 和空的字典为 “[:]“。</p>\n<ol>\n<li>访问<br>创建一个数组和字典使用方括号 “[]”，访问其元素则是通过方括号中的索引或键。                      <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> shoppingList = [<span class=\"string\">\"catfish\"</span>, <span class=\"string\">\"water\"</span>, <span class=\"string\">\"tulips\"</span>, <span class=\"string\">\"blue paint\"</span>]</span><br><span class=\"line\">shoppingList[<span class=\"number\">1</span>] = <span class=\"string\">\"bottle of water\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> occupations = [</span><br><span class=\"line\">   <span class=\"string\">\"Malcolm\"</span>: <span class=\"string\">\"Captain\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"Kaylee\"</span>: <span class=\"string\">\"Mechanic\"</span>,</span><br><span class=\"line\">]</span><br><span class=\"line\">occupations[<span class=\"string\">\"Jayne\"</span>] = <span class=\"string\">\"Public Relations\"</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"控制流-–-条件控制，循环控制\"><a href=\"#控制流-–-条件控制，循环控制\" class=\"headerlink\" title=\"控制流  –  条件控制，循环控制\"></a>控制流  –  条件控制，循环控制</h4><h6 id=\"1-条件控制\"><a href=\"#1-条件控制\" class=\"headerlink\" title=\"1. 条件控制\"></a>1. 条件控制</h6><ul>\n<li><p>if  条件必须是布尔表达式<br>在 if 语句中，条件必须是布尔表达式，这意味着 if score { … } 是错误的，不能隐含的与0比较。<br>你可以一起使用 if 和 let 来防止值的丢失。这些值是可选的。<br>可选值可以包含一个值或包含一个 nil 来指定值还不存在。写一个问号 “?” 在类型后表示值是可选的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> optionalString: <span class=\"type\">String</span>? = <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">optionalString == <span class=\"literal\">nil</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> optionalName: <span class=\"type\">String</span>? = <span class=\"string\">\"John Appleseed\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> greeting = <span class=\"string\">\"Hello!\"</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> name = optionalName &#123;</span><br><span class=\"line\">    greeting = <span class=\"string\">\"Hello, \\(name)\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>switch 支持多种数据以及多种比较，不限制必须是整数和测试相等  </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> vegetable = <span class=\"string\">\"red pepper\"</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> vegetable &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">\"celery\"</span>:</span><br><span class=\"line\">    <span class=\"keyword\">let</span> vegetableComment = <span class=\"string\">\"Add some raisins and make ants on a log.\"</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">\"cucumber\"</span>, <span class=\"string\">\"watercress\"</span>:</span><br><span class=\"line\">    <span class=\"keyword\">let</span> vegetableComment = <span class=\"string\">\"That would make a good tea sandwich.\"</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">let</span> x <span class=\"keyword\">where</span> x.hasSuffix(<span class=\"string\">\"pepper\"</span>):</span><br><span class=\"line\">    <span class=\"keyword\">let</span> vegetableComment = <span class=\"string\">\"Is it a spicy \\(x)?\"</span></span><br><span class=\"line\"><span class=\"keyword\">default</span>:    <span class=\"comment\">//by gashero</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> vegetableComment = <span class=\"string\">\"Everything tastes good in soup.\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在执行匹配的情况后，程序会从 switch 跳出，而不是继续执行下一个情况。所以不再需要 break 跳出 switch 。</p>\n<h6 id=\"2-循环控制\"><a href=\"#2-循环控制\" class=\"headerlink\" title=\"2. 循环控制\"></a>2. 循环控制</h6><ul>\n<li>for-in 来迭代字典中的每个元素<br>可使用 for-in 来迭代字典中的每个元素，提供一对名字来使用每个键值对。<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> interestingNumbers = [</span><br><span class=\"line\">    <span class=\"string\">\"Prime\"</span>: [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>],</span><br><span class=\"line\">    <span class=\"string\">\"Fibonacci\"</span>: [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>],</span><br><span class=\"line\">    <span class=\"string\">\"Square\"</span>: [<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span>],</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"keyword\">var</span> largest = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (kind, numbers) <span class=\"keyword\">in</span> interestingNumbers &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> number <span class=\"keyword\">in</span> numbers &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> number &gt; largest &#123;</span><br><span class=\"line\">            largest = number</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```  </span><br><span class=\"line\">你可以在循环中保持一个索引，通过“..”来表示索引范围或明确声明一个初始值、条件、增量。   </span><br><span class=\"line\">这两个循环做相同的事情:  </span><br><span class=\"line\">```swift</span><br><span class=\"line\"><span class=\"keyword\">var</span> firstForLoop = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">3</span> &#123;</span><br><span class=\"line\">    firstForLoop += i</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">firstForLoop</span><br><span class=\"line\"><span class=\"keyword\">var</span> secondForLoop = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; ++i &#123;</span><br><span class=\"line\">    secondForLoop += <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>使用 .. 构造范围忽略最高值，而用 … 构造的范围则包含两个值。</p>\n<ul>\n<li>while 来重复执行代码块直到条件改变<br>使用 while 来重复执行代码块直到条件改变。循环的条件可以放在末尾来确保循环至少执行一次。<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> n &lt; <span class=\"number\">100</span> &#123;</span><br><span class=\"line\">    n = n * <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">n</span><br><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    m = m * <span class=\"number\">2</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> m &lt; <span class=\"number\">100</span></span><br><span class=\"line\">m</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"函数与闭包-–-函数是闭包的特殊情况\"><a href=\"#函数与闭包-–-函数是闭包的特殊情况\" class=\"headerlink\" title=\"函数与闭包  – 函数是闭包的特殊情况\"></a>函数与闭包  – 函数是闭包的特殊情况</h4><h6 id=\"1-闭包-无需名字，只需要放在大括号中即可\"><a href=\"#1-闭包-无需名字，只需要放在大括号中即可\" class=\"headerlink\" title=\"1. 闭包 无需名字，只需要放在大括号中即可\"></a>1. 闭包 无需名字，只需要放在大括号中即可</h6><p>编写闭包时有多种选项:</p>\n<ol>\n<li><p>使用 in 到特定参数和主体的返回值。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numbers.<span class=\"built_in\">map</span>(&#123;</span><br><span class=\"line\">    (number: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"number\">3</span> * number</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>单一语句的闭包可以直接返回值<br>例如：当一个闭包的类型是已知时，例如代表回调，你可以忽略其参数和返回值，或两者</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numbers.<span class=\"built_in\">map</span>(&#123;number <span class=\"keyword\">in</span> <span class=\"number\">3</span> * number&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过数字而不是名字来引用一个参数，这对于很短的闭包很有用。<br>例如：一个闭包传递其最后一个参数到函数作为返回值。  </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sort</span>([<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">12</span>, <span class=\"number\">2</span>]) &#123; $<span class=\"number\">0</span> &gt; $<span class=\"number\">1</span> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h6 id=\"2-函数\"><a href=\"#2-函数\" class=\"headerlink\" title=\"2. 函数\"></a>2. 函数</h6><ul>\n<li><p>函数的声明   –  使用func 声明一个函数  使用 -&gt;分隔参数的名字和返回值类型,<br>调用函数使用他的名字加上小括号中的参数列表</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">greet</span><span class=\"params\">(name: String, day: String)</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello \\(name), today is \\(day).\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">greet(<span class=\"string\">\"Bob\"</span>, <span class=\"string\">\"Tuesday\"</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数的嵌套<br>内嵌函数可以访问其定义所在函数的变量。<br>你可以使用内嵌函数来组织代码，避免过长和过于复杂：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">returnFifteen</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> y = <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        y += <span class=\"number\">5</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    add()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数接收的参数</p>\n<ol>\n<li><p>可变参数的个数  sumOf(numbers: Int…) -&gt; Int{}<br>函数可以接受可变参数个数，收集到一个数组中</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sumOf</span><span class=\"params\">(numbers: Int...)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> number <span class=\"keyword\">in</span> numbers &#123;</span><br><span class=\"line\">        sum += number</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//例子</span></span><br><span class=\"line\">sumOf(<span class=\"number\">42</span>, <span class=\"number\">597</span>, <span class=\"number\">12</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>其他函数作为参数  func hasAnyMatches(list: Int[], condition: Int -&gt; Bool) -&gt; Bool{}</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hasAnyMatches</span><span class=\"params\">(list: Int[], condition: Int -&gt; Bool)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> list &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> condition(item) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lessThanTen</span><span class=\"params\">(number: Int)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> number &lt; <span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">20</span>, <span class=\"number\">19</span>, <span class=\"number\">7</span>, <span class=\"number\">12</span>]</span><br><span class=\"line\">hasAnyMatches(numbers, lessThanTen)</span><br></pre></td></tr></table></figure>\n<p>函数实际是闭包的特殊情况。你可以写一个闭包而无需名字，只需要放在大括号中即可。使用 in 到特定参数和主体的返回值。</p>\n</li>\n</ol>\n</li>\n<li><p>函数的返回值</p>\n<ol>\n<li><p>返回多个值 ： getGasPrices() -&gt; (Double, Double, Double)<br>使用元组(tuple)来返回多个值                           </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getGasPrices</span><span class=\"params\">()</span></span> -&gt; (<span class=\"type\">Double</span>, <span class=\"type\">Double</span>, <span class=\"type\">Double</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"number\">3.59</span>, <span class=\"number\">3.69</span>, <span class=\"number\">3.79</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>返回另一个函数  ： makeIncrementer() -&gt; (Int -&gt; Int)<br>函数是第一类型的</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeIncrementer</span><span class=\"params\">()</span></span> -&gt; (<span class=\"type\">Int</span> -&gt; <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addOne</span><span class=\"params\">(number: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> + number</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> addOne</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> increment = makeIncrementer()</span><br><span class=\"line\">increment(<span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"对象与类\"><a href=\"#对象与类\" class=\"headerlink\" title=\"对象与类\"></a>对象与类</h4><h6 id=\"1-类的创建-：class-类名\"><a href=\"#1-类的创建-：class-类名\" class=\"headerlink\" title=\"1. 类的创建  ：class 类名 {}\"></a>1. 类的创建  ：class 类名 {}</h6><ol>\n<li><p>使用 class 可以创建一个类。<br>一个属性的声明则是在类里作为常量或变量声明的，除了是在类的上下文中。方法和函数也是这么写的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> numberOfSides = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">simpleDescription</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"A shape with \\(numberOfSides) sides.\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>类的构造器  ： 构造器来在创建实例时设置类，使用 init 来创建</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NamedShape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> numberOfSides: <span class=\"type\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\">    &#125;   <span class=\"comment\">//by gashero</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">simpleDescription</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"A Shape with \\(numberOfSides) sides.\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>self 用来区分 name 属性和 name 参数。<br>构造器的声明跟函数一样，除了会创建类的实例。每个属性都需要赋值，无论在声明里还是在构造器里。</p>\n<ol>\n<li>类的析构器，来执行对象销毁时的清理工作，使用 deinit 来创建<br>使用 deinit 来创建一个析构器，来执行对象销毁时的清理工作。</li>\n<li>超类的继承    <ul>\n<li>子类包括其超类的名字，以冒号分隔。在继承标准根类时无需声明，所以你可以忽略超类。  </li>\n<li>子类的方法可以通过标记 override 重载超类中的实现，而没有 override 的会被编译器看作是错误,编译器也会检查那些没有被重载的方法。<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span>: <span class=\"title\">NamedShape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sideLength: <span class=\"type\">Double</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(sideLength: <span class=\"type\">Double</span>, name: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.sideLength = sideLength</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(name: name)</span><br><span class=\"line\">        numberOfSides = <span class=\"number\">4</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">area</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Double</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sideLength * sideLength</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">simpleDescription</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"A square with sides of length \\(sideLength).\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> test = <span class=\"type\">Square</span>(sideLength: <span class=\"number\">5.2</span>, name: <span class=\"string\">\"my test square\"</span>)</span><br><span class=\"line\">test.area()</span><br><span class=\"line\">test.simpleDescription()</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h6 id=\"2-类的实例创建-类名-点语法来访问实例的属性和方法\"><a href=\"#2-类的实例创建-类名-点语法来访问实例的属性和方法\" class=\"headerlink\" title=\"2. 类的实例创建   :  类名()  ,点语法来访问实例的属性和方法\"></a>2. 类的实例创建   :  类名()  ,点语法来访问实例的属性和方法</h6><p>通过在类名后加小括号来创建类的实例。使用点语法来访问实例的属性和方法。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> shape = <span class=\"type\">Shape</span>()</span><br><span class=\"line\">shape.numberOfSides = <span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> shapeDescription = shape.simpleDescription()</span><br></pre></td></tr></table></figure></p>\n<p>可选类型 Int?<br>可选绑定 if while</p>\n<p>强制取值表达式 expression!<br>可选链表达式   expression?</p>\n<p>类型转换运算符 is , as, is?, as!</p>\n<p>标示符模式<br>值绑定模式<br>可选模式<br>类型转换模式</p>\n<p>实例方法  func<br>类型方法 class func</p>\n","raw":null,"categories":[{"name":"swift","path":"api/categories/swift.json"},{"name":"语法","path":"api/categories/语法.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"}]},{"title":"[转]Swift最佳实践","slug":"swift/[转]Swift最佳实践","date":"2015-09-29T17:05:21.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/swift/[转]Swift最佳实践.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>[英文][SwiftCommunityBestPractices]<br>[SwiftCommunityBestPractices]: <a href=\"https://github.com/schwa/Swift-Community-Best-Practices\" target=\"_blank\" rel=\"noopener\">https://github.com/schwa/Swift-Community-Best-Practices</a><br>[SwiftCommunity]: <a href=\"http://swift-lang.schwa.io/\" target=\"_blank\" rel=\"noopener\">http://swift-lang.schwa.io/</a><br>[swiftCaptureLists]: <a href=\"http://www.russbishop.net/swift-capture-lists\" target=\"_blank\" rel=\"noopener\">http://www.russbishop.net/swift-capture-lists</a><br>[SwiftURL]: <a href=\"https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html</a><br>[驼峰命名法URL]: <a href=\"http://www.wikiwand.com/en/Studly_caps\" target=\"_blank\" rel=\"noopener\">http://www.wikiwand.com/en/Studly_caps</a><br>[匈牙利命名法URL]: <a href=\"http://www.wikiwand.com/en/Hungarian_notation\" target=\"_blank\" rel=\"noopener\">http://www.wikiwand.com/en/Hungarian_notation</a></p>\n<h2 id=\"黄金法则\"><a href=\"#黄金法则\" class=\"headerlink\" title=\"黄金法则\"></a>黄金法则</h2><ul>\n<li>Apple 通常是对的。应紧随苹果所推荐的或他的 Demo 中所展示的方式。您应该尽可能地遵守 Apple 在 [The Swift Programming Language][SwiftURL] 一书中所定义的代码风格。但我们还是可以看到他们的示例代码中有不符合这些规则的地方，毕竟 Apple 是一家大公司嘛。</li>\n<li>不要仅仅为了减少字符的键入数量而使用模棱两可的简短命名，较长的命名都可以依赖自动完成、自我暗示、复制粘贴来减低键入的难度。命名的详细程度往往对代码维护者很有帮助。但过于冗长的命名却会绕过Swift的主要特性之一: 类型推导,所以命名的原则应该是简洁明了。</li>\n</ul>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><h3 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a>命名</h3><p>按照 [The Swift Programming Language][SwiftURL] 所推荐的命名法则，类型名称应该使用[首字母大写的驼峰命名法][uppercamelcaseURL] (例如: “VehicleController”)。</p>\n<p>变量与常量应该使用首字母小写的驼峰命名法(例如: “ vehicleName “ )。</p>\n<p>推荐使用 Swift 模块来定义代码的命名空间，而非在 Swift 代码上使用 Objective-C 样式的类前缀(除非接口要与 Objective-C 交互)。</p>\n<p>不推荐使用任何形式的[匈牙利命名法][匈牙利命名法URL]（比如：k 代表常量，m 代表方法）,取代代之我们应该使用短而简洁的名字并使用 Xcode 的类型快速帮助 (⌥ + 左击)。同样我们也不要使用类似 <code>SNAKE_CASE</code> 这样的名字。</p>\n<p>这些法则之上，唯一例外的情况就是枚举值了，枚举值在这里应该首字母大写(这是 Apple 的 [The Swift Programming Language][SwiftURL] 中的规范)：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Planet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"type\">Mercury</span>, <span class=\"type\">Venus</span>, <span class=\"type\">Earth</span>, <span class=\"type\">Mars</span>, <span class=\"type\">Jupiter</span>, <span class=\"type\">Saturn</span>, <span class=\"type\">Uranus</span>, <span class=\"type\">Nepture</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>有必要的话命名不要缩写<br>实际上在 Xcode 的”文本自动补全”功能下你可以轻而易举地键入 类似 <code>ViewController</code> 的长命名。</li>\n<li>极为常见的缩写<br>例如: <code>URL</code> 缩写应该是全部大写 ( “URL” )或者酌情全部小写( “url” )。<blockquote>\n<p>URL 的类型和变量命名推荐的规则： 如果 url 是一个类型，它应该被大写，如果是一个变量，那么应该小写。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>不应该使用注释来禁用代码,被注释掉的代码会污染你的源代码。<br>如果你当前想要删除一段代码，但将来又可能会用到，推荐你依赖 git 或你的 bug 追踪系统来管理。</p>\n<p>(TODO: 追加一个关于文档注释的小节，使用 nshipster 的链接)</p>\n<h3 id=\"类型推导\"><a href=\"#类型推导\" class=\"headerlink\" title=\"类型推导\"></a>类型推导</h3><p>如果可能的话，使用 Swift 的类型推导，以避免冗余的类型信息。例如：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> currentLocation = <span class=\"type\">Location</span>()</span><br></pre></td></tr></table></figure></p>\n<p>而非：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> currentLocation: <span class=\"type\">Location</span> = <span class=\"type\">Location</span>()</span><br></pre></td></tr></table></figure>\n<h3 id=\"内省\"><a href=\"#内省\" class=\"headerlink\" title=\"内省\"></a>内省</h3><p>让编译器自动推断所有的情况，这是可以做到的。在一些领域 <code>self</code> 应该被显式地使用，包括在 init 中设置参数，或者 <code>non-escaping</code>闭包。<br>例如：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Example</span></span>&#123;</span><br><span class=\"line\"> \t  <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">\t   <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\"> \t      <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\"> \t  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"捕获列表的类型推导\"><a href=\"#捕获列表的类型推导\" class=\"headerlink\" title=\"捕获列表的类型推导\"></a>捕获列表的类型推导</h3><p>在一个捕获列表( capture list )中指定参数类型会导致代码冗余。如果需要的话，仅指定类型即可。  </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> people = [</span><br><span class=\"line\">    (<span class=\"string\">\"Mary\"</span>, <span class=\"number\">42</span>),</span><br><span class=\"line\">    (<span class=\"string\">\"Susan\"</span>, <span class=\"number\">27</span>),</span><br><span class=\"line\">    (<span class=\"string\">\"Charlie\"</span>, <span class=\"number\">18</span>),</span><br><span class=\"line\">]\t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = people.<span class=\"built_in\">map</span>() &#123;</span><br><span class=\"line\">    (name: <span class=\"type\">String</span>, age: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">String</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"\\(name) is \\(age) years old\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果编译器可以推导出来的话，完全可以把类型删掉：<br><code>(name: String, age: Int) -&gt; String</code><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> strings = people.<span class=\"built_in\">map</span>() &#123;</span><br><span class=\"line\">    (name, age) <span class=\"keyword\">in</span> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"\\(name) is \\(age) years old\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用编号的参数名 (“$0”) 进一步降低冗长，往往能彻底消除捕获列表的代码冗余。在闭包中当参数名没有附带任何更多信息时仅使用编号形式即可( 如非常简单的映射和过滤器 )。</p>\n<p>Apple 能够并且将会改变闭包的参数类型，通过他们的 Objective-C 框架的 Swift 变种提供出来。<br>例如，<code>optionals</code> 被删除或更改为 <code>auto-unwrapping</code> 等。故意 under-specifying 可选并依赖 Swift 来推导类型，可以减少在这些情况下代码被破译的风险。</p>\n<p>你应该避免指定返回类型，例如这个捕获列表( capture list )就是完全多余的:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    ()-&gt;<span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Fired.\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>(以上内容也可以参考:[这里][swiftCaptureLists])</p>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>类型定义中使用的常量应当被申明成静态类型。例如:<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PhysicsModel</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> speedOfLightInAVacuum = <span class=\"number\">299_792_458</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Spaceship</span> </span>&#123;</span><br><span class=\"line\">  \t\t <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> topSpeed = <span class=\"type\">PhysicsModel</span>.speedOfLightInAVacuum</span><br><span class=\"line\"> \t     <span class=\"keyword\">var</span> speed: <span class=\"type\">Double</span></span><br><span class=\"line\">  \t\t <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fullSpeedAhead</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      \t\t speed = <span class=\"type\">Spaceship</span>.topSpeed</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>将常量标示为 <code>static</code> ，允许它们可以被无类型的实例引用。</p>\n<p>一般应该避免生成全局范围的常量，单例除外。</p>\n","raw":null,"categories":[{"name":"swift","path":"api/categories/swift.json"},{"name":"语法","path":"api/categories/语法.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"}]}]}