{"total":157,"pageSize":10,"pageCount":16,"data":[{"title":"腾讯云docker服务器上部署jira系统","slug":"远程操作mysql数据库","date":"2017-05-24T17:07:47.000Z","updated":"2017-05-24T17:49:46.000Z","comments":true,"path":"api/articles/远程操作mysql数据库.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"腾讯云服务器\"><a href=\"#腾讯云服务器\" class=\"headerlink\" title=\"腾讯云服务器\"></a>腾讯云服务器</h2><ol>\n<li><p>申请账户，体验5天，搭建一个jira服务，还有微信小程序服务</p>\n</li>\n<li><p>需要在服务器上安装docker （腾讯服务器提供了一款支持docker的Ubuntu系统）</p>\n</li>\n<li>想使用daocloud加速器，就要更新docker版本<br>docker run –detach –publish 8080:8080 cptactionhank/atlassian-jira:latest<br><a href=\"http://[dockerhost]:8080\" target=\"_blank\" rel=\"noopener\">http://[dockerhost]:8080</a> and finish the configuration</li>\n</ol>\n<h3 id=\"远程服务器的基本操作\"><a href=\"#远程服务器的基本操作\" class=\"headerlink\" title=\"远程服务器的基本操作\"></a>远程服务器的基本操作</h3><ol>\n<li>登录：<code>ssh -l username 服务ip／域名</code><br> ssh ubuntu@123.<strong><em>.</em>.<em>6   5<em>*</em></em></strong>RtH<br> sudo docker pull cptactionhank/atlassian-jira</li>\n<li>服务器端拷贝文件目录<br> scp -i localDir serveruser@serverip:serverDir</li>\n</ol>\n<h3 id=\"docker下安装mysql数据库镜像\"><a href=\"#docker下安装mysql数据库镜像\" class=\"headerlink\" title=\"docker下安装mysql数据库镜像\"></a>docker下安装mysql数据库镜像</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker pull mysql </span><br><span class=\"line\">sudo docker run --name jiradb -e MYSQL_ROOT_PASSWORD=jiradb -d mysql/mysql-server:latest</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>-name : 容器名<br>MYSQL_ROOT_PASSWORD : 数据库密码<br>-d : 镜像名:tag 版本</p>\n</blockquote>\n<h4 id=\"终端：单行登录mysql\"><a href=\"#终端：单行登录mysql\" class=\"headerlink\" title=\"终端：单行登录mysql\"></a>终端：单行登录mysql</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker exec -it jiradb mysql -ujira -pjira</span><br></pre></td></tr></table></figure>\n<h4 id=\"进入mysql终端-访问数据库\"><a href=\"#进入mysql终端-访问数据库\" class=\"headerlink\" title=\"进入mysql终端,访问数据库\"></a>进入mysql终端,访问数据库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker exec -it jiradb bash</span><br><span class=\"line\">#登录数据库  默认用户root 密码为空，如果前边设置了MYSQL_ROOT_PASSWORD的值，则需要密码</span><br><span class=\"line\">mysql -uroot -p   #登录本地数据库 可以 省略-h参数 -h 127.0.0.1</span><br><span class=\"line\">回车</span><br><span class=\"line\">输入密码：jiradb  #就是$MYSQL_ROOT_PASSWORD的值</span><br><span class=\"line\">即登录</span><br></pre></td></tr></table></figure>\n<h4 id=\"用户权限控制\"><a href=\"#用户权限控制\" class=\"headerlink\" title=\"用户权限控制\"></a>用户权限控制</h4><ol>\n<li><p>查看sql服务器的状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">status;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建用户名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create user jira identified by &apos;jira&apos;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>赋予权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grant all privileges on *.* to &apos;jira&apos;@&apos;%&apos; identified by &apos;jira&apos; with grant option;</span><br><span class=\"line\">grant all privileges on *.* to &apos;jira&apos;@&apos;localhost&apos; identified by &apos;jira&apos; with grant option;</span><br><span class=\"line\">flush privileges;</span><br><span class=\"line\">quit;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"数据库操作\"><a href=\"#数据库操作\" class=\"headerlink\" title=\"数据库操作\"></a>数据库操作</h4><ol>\n<li><p>创建数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create database jiradb character set &apos;UTF8&apos;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看当前数据库名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select database();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>切换指定数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use jiradb;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看数据库表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show tables;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>创建表</p>\n<h5 id=\"jira和数据库关联结果\"><a href=\"#jira和数据库关联结果\" class=\"headerlink\" title=\"jira和数据库关联结果\"></a>jira和数据库关联结果</h5><p>无法通过 docker 中mysql镜像的盒子来实现jira和数据库关联：<br>从另一个容器中的应用来访问jiradb容器中的mysql服务：没成功<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Connect to MySQL from an application in another Docker container</span><br><span class=\"line\">sudo docker run --name jirad --link jiradb:mysql/mysql-server -d cptactionhank/atlassian-jira:latest</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure></p>\n<p>最终采用在ubuntu系统中安装mysql：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$sudo apt-get -y install mysql-server</span><br></pre></td></tr></table></figure></p>\n<p>##问题：Could not reach any registry endpoint<br>安装Linux加速器：<br>curl -sSL <a href=\"https://get.daocloud.io/daotools/set_mirror.sh\" target=\"_blank\" rel=\"noopener\">https://get.daocloud.io/daotools/set_mirror.sh</a> | sh -s <a href=\"http://142900b5.m.daocloud.io\" target=\"_blank\" rel=\"noopener\">http://142900b5.m.daocloud.io</a><br>该脚本可以将 –registry-mirror 加入到你的 Docker 配置文件 /etc/default/docker 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。<br>ubuntu 系统安装daocloud检测工具：<br>curl -sSL <a href=\"https://get.daocloud.io/daomonit/install.sh\" target=\"_blank\" rel=\"noopener\">https://get.daocloud.io/daomonit/install.sh</a> | sh -s d0312f829e9807ee0bf157cdc9c9cca42380395c </p>\n<h3 id=\"更新服务器上的docker\"><a href=\"#更新服务器上的docker\" class=\"headerlink\" title=\"更新服务器上的docker\"></a>更新服务器上的docker</h3><p><a href=\"https://docs.docker.com/engine/installation/linux/ubuntulinux/#/prerequisites-by-ubuntu-version\" target=\"_blank\" rel=\"noopener\">官网教程</a></p>\n<h3 id=\"Update-your-apt-sources\"><a href=\"#Update-your-apt-sources\" class=\"headerlink\" title=\"Update your apt sources\"></a>Update your apt sources</h3><p>To set APT to use packages from the Docker repository:</p>\n<ol>\n<li>Log into your machine as a user with sudo or root privileges.</li>\n<li>Open a terminal window.</li>\n<li><p>Update package information, ensure that APT works with the https method, and that CA certificates are installed.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install apt-transport-https ca-certificates</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Docker资源库<br>|Ubuntu version|    Repository|<br>|—|—-|<br>|Precise 12.04 (LTS)|deb <a href=\"https://apt.dockerproject.org/repo\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo</a> ubuntu-precise main|<br>|Trusty 14.04 (LTS)    |deb <a href=\"https://apt.dockerproject.org/repo\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo</a> ubuntu-trusty main|<br>|Wily 15.10         |deb <a href=\"https://apt.dockerproject.org/repo\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo</a> ubuntu-wily main|<br>|Xenial 16.04 (LTS)    |deb <a href=\"https://apt.dockerproject.org/repo\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo</a> ubuntu-xenial main|</p>\n<blockquote>\n<p>Note: Docker does not provide packages for all architectures. Binary artifacts are built nightly, and you can download them from <a href=\"https://master.dockerproject.org\" target=\"_blank\" rel=\"noopener\">https://master.dockerproject.org</a>. To install docker on a multi-architecture system, add an [arch=…] clause to the entry. Refer to Debian Multiarch wiki for details.</p>\n</blockquote>\n</li>\n<li>导入库<br><repo> = deb <a href=\"https://apt.dockerproject.org/repo\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo</a> ubuntu-precise main<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">\"&lt;REPO&gt;\"</span> | sudo tee /etc/apt/sources.list.d/docker.list</span><br></pre></td></tr></table></figure>\n</repo></li>\n</ol>\n<p>`<br>6.Update the APT package index.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br></pre></td></tr></table></figure></p>\n<p>7.Verify that APT is pulling from the right repository.<br>When you run the following command, an entry is returned for each version of Docker that is available for you to install. Each entry should have the URL <a href=\"https://apt.dockerproject.org/repo/\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo/</a>. The version currently installed is marked with <em>*</em>.The output below is truncated.</p>\n<p>$ apt-cache policy docker-engine</p>\n<p>docker-engine:<br>Installed: 1.12.2-0~trusty<br>Candidate: 1.12.2-0~trusty<br>Version table:<br><em>*</em> 1.12.2-0~trusty 0<br>500 <a href=\"https://apt.dockerproject.org/repo/\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo/</a> ubuntu-trusty/main amd64 Packages<br>100 /var/lib/dpkg/status<br>1.12.1-0~trusty 0<br>500 <a href=\"https://apt.dockerproject.org/repo/\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo/</a> ubuntu-trusty/main amd64 Packages<br>1.12.0-0~trusty 0<br>500 <a href=\"https://apt.dockerproject.org/repo/\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo/</a> ubuntu-trusty/main amd64 Packages</p>\n<p>From now on when you run apt-get upgrade, APT pulls from the new repository.</p>\n<p>To upgrade your kernel and install the additional packages, do the following:</p>\n<p>Open a terminal on your Ubuntu host.<br>Update your package manager.<br>$ sudo apt-get update<br>Install both the required and optional packages.<br>$ sudo apt-get install linux-image-generic-lts-trusty<br>Repeat this step for other packages you need to install.<br>Reboot your host to use the updated kernel.<br>$ sudo reboot<br>After your system reboots, go ahead and install Docker.</p>\n<p>Install the latest version<br>Make sure you have satisfied all the prerequisites, then follow these steps.</p>\n<p>Note: For production systems, it is recommended that you install a specific version so that you do not accidentally update Docker. You should plan upgrades for production systems carefully.<br>Log into your Ubuntu installation as a user with sudo privileges.<br>Update your APT package index.<br>$ sudo apt-get update<br>Install Docker.<br>$ sudo apt-get install docker-engine<br>Start the docker daemon.<br>$ sudo service docker start<br>Verify that docker is installed correctly by running the hello-world image.<br>$ sudo docker run hello-world<br>This command downloads a test image and runs it in a container. When the container runs, it prints an informational message and exits.</p>\n","raw":null,"categories":[{"name":"docker","path":"api/categories/docker.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"}]},{"title":"iOS和OSX集成gitAPI","slug":"开源库/iOS和OSX集成gitAPI","date":"2017-05-17T17:33:46.000Z","updated":"2017-09-24T09:18:26.000Z","comments":true,"path":"api/articles/开源库/iOS和OSX集成gitAPI.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/ObjectiveGitxiaoguo.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>在项目中使用git submodule工具集成子项目ObjectiveGit</p>\n<h4 id=\"在新项目中使用git-submodule集成gitAPI\"><a href=\"#在新项目中使用git-submodule集成gitAPI\" class=\"headerlink\" title=\"在新项目中使用git submodule集成gitAPI\"></a>在新项目中使用git submodule集成gitAPI</h4><p>参考官方提供的两个demo</p>\n<ul>\n<li><p>OS X: <a href=\"https://github.com/Abizern/CommitViewer\" target=\"_blank\" rel=\"noopener\">CommitViewer</a>   </p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/ObjectiveGitxiaoguo.png?imageMogr2/2/w/800\">\n</li>\n<li><p>iOS: <a href=\"https://github.com/Raekye/ObjectiveGit-iOS-Example\" target=\"_blank\" rel=\"noopener\">ObjectiveGit iOS Example</a></p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule add https://github.com/libgit2/objective-git.git External/ObjectiveGit</span><br><span class=\"line\">如果之前配置过，直接更新：</span><br><span class=\"line\">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>cd External/ObjectiveGit</code>，然后执行<code>./script/bootstrap</code>安装相关依赖.</li>\n<li>拖动 <code>ObjectiveGitFramework.xcodeproj</code> 文件 到iOS/OSX项目导航窗口 .</li>\n<li>在build Phases中配置APP的依赖，根据平台添加<code>ObjectiveGit-Mac</code> or <code>ObjectiveGit-iOS</code>.</li>\n<li>APP通过连接器链接 <code>ObjectiveGit.framework</code>.</li>\n<li>在build setting中“Header Search Paths” (<code>HEADER_SEARCH_PATHS</code>)设置<code>libgit2</code>头文件在项目的路径，例如：<code>External/ObjectiveGit/External/libgit2/include</code>. </li>\n<li>Add a new “Copy Files” build phase, set the destination to “Frameworks” and add <code>ObjectiveGit.framework</code> to the list. This will package the framework with your application as an embedded private framework.</li>\n</ol>\n<ul>\n<li>It’s hard to tell the difference between the platforms, but the Mac framework is in <code>build/Debug</code> whereas the iOS framework is in <code>build/Debug-iphoneos</code></li>\n</ul>\n<ol>\n<li>Don’t forget to <code>#import &lt;ObjectiveGit/ObjectiveGit.h&gt;</code> or <code>@import ObjectiveGit;</code> as you would with any other framework.</li>\n</ol>\n<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ul>\n<li>类变量关联.xib控件text值    </li>\n<li>字体样式菜单来改变字体样式    <h4 id=\"在OSX中设置控件的Bindings代替IBOutlet\"><a href=\"#在OSX中设置控件的Bindings代替IBOutlet\" class=\"headerlink\" title=\"在OSX中设置控件的Bindings代替IBOutlet\"></a>在OSX中设置控件的Bindings代替IBOutlet</h4></li>\n</ul>\n<p>先关联再使用属性依赖特性来同步数据</p>\n<h5 id=\"类变量关联-xib控件text值\"><a href=\"#类变量关联-xib控件text值\" class=\"headerlink\" title=\"类变量关联.xib控件text值\"></a>类变量关联.xib控件text值</h5><p><a href=\"http://stackoverflow.com/questions/8161012/referencing-bindings-in-connections-inspector\" target=\"_blank\" rel=\"noopener\">相关参考</a>      </p>\n<ol>\n<li>选中NSTextField的bindings检查器面板   </li>\n<li>在<code>value</code>单元内设置bind to 的值，通过下拉框选中 <code>Delegate</code>      </li>\n<li>Model key Path:输入类变量的名称。    <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/NSTextFieldBindings.png?imageMogr2/2/w/800\">   </li>\n<li>切换到 NSTextField／Delegate的Connections检查器面板,就会看到已经建立了关联：     <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/textFieldConections.png?imageMogr2/2/w/800\">   <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/delegatebinding.png?imageMogr2/2/w/800\">   \n</li>\n</ol>\n<h5 id=\"依赖属性\"><a href=\"#依赖属性\" class=\"headerlink\" title=\"依赖属性\"></a>依赖属性</h5><p>Foundation 框架提供的表示属性依赖的机制如下：<br>参考<a href=\"https://github.com/huos3203/BookObjc/blob/master/publish/issue7/issue-7-3-DJBen.md#依赖的属性\" target=\"_blank\" rel=\"noopener\">属性的依赖</a><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class=\"built_in\">NSString</span> *)key</span><br><span class=\"line\"></span><br><span class=\"line\">或</span><br><span class=\"line\">+ (<span class=\"built_in\">NSSet</span> *)keyPathsForValuesAffecting&lt;键名&gt;</span><br></pre></td></tr></table></figure></p>\n<p>将属性关联起来，这样就可以将类变量的值同步至UI控件中了：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class=\"built_in\">NSString</span> *)key </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSSet</span> *keySet = [<span class=\"built_in\">NSSet</span> setWithObjects:<span class=\"string\">@\"commit\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([key isEqualToString:<span class=\"string\">@\"messageTitle\"</span>] ||</span><br><span class=\"line\">        [key isEqualToString:<span class=\"string\">@\"messageDetails\"</span>] ||</span><br><span class=\"line\">        [key isEqualToString:<span class=\"string\">@\"author\"</span>] ||</span><br><span class=\"line\">        [key isEqualToString:<span class=\"string\">@\"date\"</span>])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> keySet;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"实现字体样式菜单来改变字体样式\"><a href=\"#实现字体样式菜单来改变字体样式\" class=\"headerlink\" title=\"实现字体样式菜单来改变字体样式\"></a>实现字体样式菜单来改变字体样式</h4><ol>\n<li>在xib中拖一个Object并设置为NSFontManager.h类的实现。   </li>\n<li>选中NSFontManager.h的connections面板，将Received Actions关联到对应的菜单项即可  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/fontManage.png?imageMogr2/2/w/800\">\n</li>\n</ol>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"API","path":"api/categories/API.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"}]},{"title":"使用sourceTree与git-subtree工具","slug":"git/使用sourceTree与git-subtree工具","date":"2017-05-17T11:23:22.000Z","updated":"2017-05-17T17:52:28.000Z","comments":true,"path":"api/articles/git/使用sourceTree与git-subtree工具.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/gittree.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"git-subtree-合并\"><a href=\"#git-subtree-合并\" class=\"headerlink\" title=\"git subtree 合并\"></a>git subtree 合并</h3><p>git subtree：合并策略，通过git subtree命令能将依赖库某分支合并到主项目的分支中，在开发过程中，只需对主项目分支进行统一管理。</p>\n<h4 id=\"创建合并subtree-add命令\"><a href=\"#创建合并subtree-add命令\" class=\"headerlink\" title=\"创建合并subtree add命令\"></a>创建合并subtree add命令</h4><p>命令如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;git subtree&apos; add -P &lt;prefix&gt; &lt;commit&gt;</span><br><span class=\"line\">&apos;git subtree&apos; add -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"两步走\"><a href=\"#两步走\" class=\"headerlink\" title=\"两步走\"></a>两步走</h5><p>先fetch库再subtree add合并</p>\n<ol>\n<li><p>先将依赖库fetch到本地仓库中</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建lib的远程版本库: </span><br><span class=\"line\">git init --bare lib-rep</span><br><span class=\"line\"><span class=\"comment\">#-f：远端库添加后立即执行fetch操作</span></span><br><span class=\"line\">git remote add -f librepo ../lib-rep</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过git subtree命令将依赖库合并到主项目中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git subtree add -P lib librepo master</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"squash合并法\"><a href=\"#squash合并法\" class=\"headerlink\" title=\"squash合并法\"></a>squash合并法</h5><p><code>--squash</code>: 适用于add/pull/merge子命令。先合并引用库的更新记录，将合并结果并到主项目中。<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git subtree add --prefix=themes/jacman --squash https://huos3203@github.com/huos3203/jacman.git master</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"subtree其他命令\"><a href=\"#subtree其他命令\" class=\"headerlink\" title=\"subtree其他命令\"></a>subtree其他命令</h4><p>git subtree支持创建(add)之外,还支持更新(pull),推送(push),合并(merge),抽离(split)以下命令:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'git subtree'</span> pull -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br><span class=\"line\"><span class=\"string\">'git subtree'</span> push -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br><span class=\"line\"><span class=\"string\">'git subtree'</span> merge -P &lt;prefix&gt; &lt;commit&gt;</span><br><span class=\"line\"><span class=\"string\">'git subtree'</span> split -P &lt;prefix&gt; [OPTIONS] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure></p>\n<p>从子树库中拉取最新代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git subtree pull --prefix=themes/jacman --squash https://huos3203@github.com/huos3203/jacman.git master</span><br></pre></td></tr></table></figure></p>\n<p>将自己的代码发布到子树库:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git subtree push --prefix=themes/jacman --squash https://huos3203@github.com/huos3203/jacman.git master</span><br></pre></td></tr></table></figure></p>\n<p>相关参数：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-q | --quiet</span><br><span class=\"line\">-d | --debug</span><br><span class=\"line\">-P &lt;prefix&gt; | --prefix=&lt;prefix&gt;      引用库对应的本地目录</span><br><span class=\"line\">-m &lt;message&gt; | --message=&lt;message&gt;   适用于add/pull/merge子命令。设置产生的合并提交的说明文本</span><br><span class=\"line\">--squash                             适用于add/pull/merge子命令。先合并引用库的更新记录，将合并结果并到主项目中。</span><br><span class=\"line\">使用此选项时，subtree add/pull会产生两个提交版本：一个是子项目的历史记录，一个是Merge操作。好处是可以让主项目历史记录很规整，缺点是子项目更新时常常需要解决冲突。一个更好的解决方案是：单独建一个分支进行--no-squash的subtree更新，然后再--squash合并到主分支。每次在此分支做操作前都需要先把主分支合并进来。参考：http://www.fwolf.com/blog/post/246</span><br></pre></td></tr></table></figure></p>\n<p>split子命令选项：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--annotate=&lt;annotation&gt;              创建合成历史时有可能形成内容不同但提交信息完全相同的提交版本，使用这个选项在每个提交消息前加上此前缀用来区分。</span><br><span class=\"line\">-b &lt;branch&gt; | --branch=&lt;branch&gt;      创建合成的提交历史时，创建此参数指定的新分支包含生成的合成历史。&lt;branch&gt;必须是还不存在的。</span><br><span class=\"line\">--onto=&lt;onto&gt;</span><br><span class=\"line\">--rejoin</span><br><span class=\"line\">--ignore-joins</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用sourcetree管理\"><a href=\"#使用sourcetree管理\" class=\"headerlink\" title=\"使用sourcetree管理\"></a>使用sourcetree管理</h4><ol>\n<li>配置 subtree<br>菜单：Repository -&gt; Add/Link subtree…(添加／链接子树…)<br>在左边栏的SUBTREES(子树)中显示：<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/gittree.png?imageMogr2/2/w/800\"></li>\n<li>拉取依赖库的最新代码<br>在右边栏右击已存在的subtree，并选择 pull subtree…菜单项：<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/gitsubtreepull.png?imageMogr2/2/w/800\">\n第二步的功能代码如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git -c subtree pull -P themes/.jacman --squash https://huos3203@github.com/huos3203/jacman.git master</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"submodule嵌套\"><a href=\"#submodule嵌套\" class=\"headerlink\" title=\"submodule嵌套\"></a>submodule嵌套</h3><p>git submodule：嵌套策略，将依赖库直接clone到主项目目录中，通过配置.submodule文件来隔离管理主项目／子依赖库的版本。<br>添加子模块：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule add https://github.com/libgit2/objective-git.git External/ObjectiveGit</span><br></pre></td></tr></table></figure></p>\n<p>更新子模块：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>submodule那样每次子项目修改了后要init和update.万一哪次没update就直接”commit -a” 或者 “add .” 全commit上去就悲剧了。</p>\n</blockquote>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"IDE","path":"api/categories/IDE.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"}]},{"title":"开发思想模式总结","slug":"架构/开发思想模式总结","date":"2017-05-15T16:14:07.000Z","updated":"2017-08-17T14:54:01.000Z","comments":true,"path":"api/articles/架构/开发思想模式总结.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>OOP面向对象编程：1. 封装，2，继承，3. 多态<br>五大原则：<br>SRP单一职责原则：一个类的功能要单一，表现突出的VIPER模式<br>OCP开放封闭原则:模块扩展性为开放的，模块更改性则为封闭的。<br>LSP替换原则，<br>DIP依赖原则，<br>ISP接口分离原则：模块间的功能通过抽象接口隔离</p>\n<p>封装：将抽象事物的特征，行为，转化为代码中的类：属性和方法即为封装，体现2.对属性和方法的访问权限的控制 私有，公有不同级别的保护。<br>继承：广义上也是一种对代码的复用。继承有两种方式：实现继承和接口继承。</p>\n<p>多态：一个类实例的同一个方法，在不同情形有不同的表现形式。类似多个构造器和便利构造器，实现的功能都是初始化类实例的作用</p>\n<h2 id=\"子类场景\"><a href=\"#子类场景\" class=\"headerlink\" title=\"子类场景\"></a>子类场景</h2><p>优点：代码封装，重用组件</p>\n<ol>\n<li>自定义系统控件时： 如：对UITableViewCell等视图，自定义布局。</li>\n<li>针对多平台，多版本来编写代码<br>实现：创建一个基类，创建iPhone子类／iPad子类来继承重写特性方法。</li>\n<li>子类化模型对象，继承isEqual:,hash,copyWithZone:和description等方法，参考开源框架<a href=\"http://southpeak.github.io/2015/01/11/sourcecode-mantle/\" target=\"_blank\" rel=\"noopener\">Mantle</a></li>\n</ol>\n<h2 id=\"子类的场景替代方案\"><a href=\"#子类的场景替代方案\" class=\"headerlink\" title=\"子类的场景替代方案\"></a>子类的场景替代方案</h2><p>深层次的集成的替代方案：</p>\n<ol>\n<li>子类使用相同的接口，协议替代，</li>\n<li>当对象正常运行需要大量配置时，使用代理来完成配置 </li>\n<li>对现有的类增加简单功能时，使用类别来扩展</li>\n<li>重写一堆相同方法子类时，使用配置对象代替</li>\n<li>当重用某些功能时，使用组合多个对象来代替，而不是扩展它们</li>\n</ol>\n<h2 id=\"简明架构：VIPER模式：单一职责，\"><a href=\"#简明架构：VIPER模式：单一职责，\" class=\"headerlink\" title=\"简明架构：VIPER模式：单一职责，\"></a>简明架构：VIPER模式：单一职责，</h2><p>将APP逻辑结构划分为不同的责任层：<br>View视图，Interactor交互器，Presenter展示器，Entity实体，Routing路由</p>\n<ol>\n<li>接口隔离原则：隔离依赖项，</li>\n<li>单一职责原则：利于测试各层间边界处的交互。</li>\n<li>轻量化VC，提高可读性，维护性。</li>\n</ol>\n<h2 id=\"基于用例的应用设计-待办事项清单示例\"><a href=\"#基于用例的应用设计-待办事项清单示例\" class=\"headerlink\" title=\"基于用例的应用设计  待办事项清单示例\"></a>基于用例的应用设计  待办事项清单示例</h2><p>用例别称为验收标准，或行为集，它们用来描述应用的用途。独立于用户界面，主要针对在应用程序中的负责业务逻辑层的测试操作。<br>举例：清单可以根据时间，类型以及名字排序，这就是一个用例。<br>特征：足够小，良好的定义。<br>作用：将复杂的应用分解成较小的用例。</p>\n<p>单一职责原则：便于测试<br>测试用例：<br>模拟网络数据-&gt;拦截HTTP请求-&gt;模拟一个响应对象给请求方<br>目的：<br>模拟数据，激活iResearcher </p>\n<ol>\n<li>多线程下载</li>\n<li>VIPER架构</li>\n</ol>\n<p>LLDB命令和断点的合用<br>变量，对象：p ，po，e 表达式，<br>流程控制：thread<br>断点管理：breakpoint<br>LLDB和Python<br>AppleScript</p>\n<p>Instruments<br>自定义工具–DTrace语法 -&gt;自动化脚本<br>终端成员DTrace<br>使用IB工具来编写DTrace脚本，并可以方便的导出DTrace脚本，可用于脚本自动化时收集APP运行状态的数据，<br>探针 （断言，动作，提供者，全部变量 ，begin，end）<br>DTrace脚本是在内核中运行中的，需要IB工具做缓冲区，来封装内核数据达到ib工具识别</p>\n<p>废除功能：<br>run Browser浏览器功能<br>UI automation功能</p>\n<h1 id=\"view属性的自动布局\"><a href=\"#view属性的自动布局\" class=\"headerlink\" title=\"view属性的自动布局\"></a>view属性的自动布局</h1>","raw":null,"categories":[{"name":"架构","path":"api/categories/架构.json"}],"tags":[]},{"title":"Xcode8插件制作替代Alcatraz","slug":"xcode/Xcode8插件制作替代Alcatraz","date":"2017-05-15T14:09:30.000Z","updated":"2017-06-23T10:51:21.000Z","comments":true,"path":"api/articles/xcode/Xcode8插件制作替代Alcatraz.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/插件架构图.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><ol>\n<li>Xcode7插件工具Alcatraz<br>开发者可以在Xcode运行的时候通过注入代码去实现插件的功能。插件可以在一个Alcatraz这个优秀的APP上面提交和分发。</li>\n<li>Xcode8编辑源码的插件Xcode source editor extensions<br>Xcode 8验证每个库和包，以防止恶意代码未经您的许可运行。苹果公司在今年的WWDC上宣布了可以通过开发<code>Xcode source editor extensions</code>来扩展现有的源代码编辑功能。<br>当Xcode启动的时候，先前通过<code>Alcatraz</code>安装的插件不会再被加载。</li>\n</ol>\n<h2 id=\"源码编辑器插件\"><a href=\"#源码编辑器插件\" class=\"headerlink\" title=\"源码编辑器插件\"></a>源码编辑器插件</h2><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/插件架构图.png?imageMogr2/2/w/800\">\n<h3 id=\"Info-plist文件\"><a href=\"#Info-plist文件\" class=\"headerlink\" title=\"Info.plist文件\"></a>Info.plist文件</h3><p>Source Editor Command是命令默认的名字。开发者可以在extension的Info.plist文件里面修改。打开之后修改为 Clean Syntax</p>\n<h3 id=\"解析插件启动类SourceEditorExtension-swift\"><a href=\"#解析插件启动类SourceEditorExtension-swift\" class=\"headerlink\" title=\"解析插件启动类SourceEditorExtension.swift\"></a>解析插件启动类SourceEditorExtension.swift</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Foundation</span><br><span class=\"line\"><span class=\"keyword\">import</span> XcodeKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SourceEditorExtension</span>: <span class=\"title\">NSObject</span>, <span class=\"title\">XCSourceEditorExtension</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1. 启动extension被调用，自定义相关操作</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">extensionDidFinishLaunching</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//commandDefinitions属性的getter方法可以动态的展示或是隐藏特定的指令</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> commandDefinitions: [[<span class=\"type\">XCSourceEditorCommandDefinitionKey</span>: <span class=\"type\">AnyObject</span>]]&#123;<span class=\"keyword\">return</span> []&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"解析插件核心类SourceEditorCommand-swift\"><a href=\"#解析插件核心类SourceEditorCommand-swift\" class=\"headerlink\" title=\"解析插件核心类SourceEditorCommand.swift\"></a>解析插件核心类SourceEditorCommand.swift</h3><p>在这个文件里面可以实现extension的相关逻辑<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SourceEditorCommand</span>: <span class=\"title\">NSObject</span>, <span class=\"title\">XCSourceEditorCommand</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//当通过Xcode菜单键调用插件时调用，实现插件功能的主体</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">perform</span><span class=\"params\">(with invocation: XCSourceEditorCommandInvocation,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               completionHandler: @escaping <span class=\"params\">(Error?)</span></span></span> -&gt; <span class=\"type\">Void</span> ) -&gt; <span class=\"type\">Void</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 正则匹配含有 闭包 的文本</span></span><br><span class=\"line\">       <span class=\"keyword\">var</span> updatedLineIndexes = [<span class=\"type\">Int</span>]()</span><br><span class=\"line\">       <span class=\"keyword\">for</span> lineIndex <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; invocation.buffer.lines.<span class=\"built_in\">count</span></span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           <span class=\"keyword\">let</span> line = invocation.buffer.lines[lineIndex] <span class=\"keyword\">as</span>! <span class=\"type\">NSString</span></span><br><span class=\"line\">           <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">let</span> results = <span class=\"keyword\">try</span> findClosureSyntax(line: line)</span><br><span class=\"line\">               <span class=\"comment\">//简化所有闭包语法格式：移除闭包里面括号</span></span><br><span class=\"line\">               <span class=\"number\">_</span> = results.<span class=\"built_in\">map</span> &#123; result <span class=\"keyword\">in</span></span><br><span class=\"line\">                   <span class=\"keyword\">let</span> cleanLine = line.remove(characters: [<span class=\"string\">\"(\"</span>, <span class=\"string\">\")\"</span>], <span class=\"keyword\">in</span>: result.range)</span><br><span class=\"line\">                   updatedLineIndexes.append(lineIndex)</span><br><span class=\"line\">                   invocation.buffer.lines[lineIndex] = cleanLine</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">               completionHandler(error <span class=\"keyword\">as</span> <span class=\"type\">NSError</span>)</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       completionHandler(<span class=\"literal\">nil</span>)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">//使用正则表达式去遍历每一行代码是否含有闭包</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findClosureSyntax</span><span class=\"params\">(line:NSString)</span></span> <span class=\"keyword\">throws</span> -&gt;[<span class=\"type\">NSTextCheckingResult</span>]</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       <span class=\"keyword\">let</span> regex =  <span class=\"keyword\">try</span> <span class=\"type\">NSRegularExpression</span>(pattern: <span class=\"string\">\"\\\\&#123;.*\\\\(.+\\\\).+in\"</span>, options: .caseInsensitive)</span><br><span class=\"line\">       <span class=\"keyword\">let</span> range = <span class=\"type\">NSRange</span>(<span class=\"number\">0</span> ..&lt; line.length)</span><br><span class=\"line\">       <span class=\"keyword\">return</span> regex.matches(<span class=\"keyword\">in</span>: line <span class=\"keyword\">as</span> <span class=\"type\">String</span>, options: .reportProgress, range: range)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"一个方法两个参数\"><a href=\"#一个方法两个参数\" class=\"headerlink\" title=\"一个方法两个参数\"></a>一个方法两个参数</h4><ol>\n<li><p>方法<br>当通过Xcode菜单键调用插件时：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perform(with:completionHandler:)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>两个参数<br><code>buffer</code>属性：访问当前选中的文件源代码，<code>XCSourceEditorCommandInvocation</code>对象的<code>buffer</code>属性；<br><code>completionhandler</code>：将会以参数为nil进行调用，否则将会给它传递一个<code>NSError</code>实例作为参数。</p>\n</li>\n</ol>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><ol>\n<li>选择scheme后编译运行自定义的extensions插件</li>\n<li>选择测试安装插件的Xcode<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/extensionsApp.png?imageMogr2/2/w/800\"></li>\n<li>点击run按钮会单独启动一个全新的Xcode<br>在新的Xcode实例中，创建一个新的工程或是打开一个存在的工程。</li>\n<li>然后执行Editor &gt; Clean Closure &gt; Source Editor Command，需要确保在当前的文件里面含有一个闭包。这样就可以看到如下的效果，刚才开发的extension工作了！<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcodeAPP.gif?imageMogr2/2/w/800\">\n</li>\n</ol>\n<h2 id=\"命令快捷键\"><a href=\"#命令快捷键\" class=\"headerlink\" title=\"命令快捷键\"></a>命令快捷键</h2><p>设置快捷键去自动调用Clean Syntax命令</p>\n<ol>\n<li>打开Xcode的Preferences，选择Key Bindings ;</li>\n<li>搜索Clean Syntax，点击右边然后输入快捷键，例如：Command-Alt-Shift-+。<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/KeyBindings.png?imageMogr2/2/w/800\">\n</li>\n</ol>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"插件","path":"api/categories/插件.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"}]},{"title":"从UIKit到AppKit","slug":"macOS/从UIKit到AppKit","date":"2017-03-03T17:55:16.000Z","updated":"2017-03-03T17:55:16.000Z","comments":true,"path":"api/articles/macOS/从UIKit到AppKit.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/ViewEffectsInspector.jpg?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h2><h3 id=\"NSWindowController\"><a href=\"#NSWindowController\" class=\"headerlink\" title=\"NSWindowController\"></a>NSWindowController</h3><p>在<code>Mac</code>上应用都支持多窗口（<code>NSWindowController</code>），<code>AppKit</code> 中都有 <code>NSWindowController</code>担当着类似在<code>iOS</code>中的<code>view controller</code>处理的任务。</p>\n<blockquote>\n<p><code>window</code>在<code>iOS</code>占据整个屏幕，几乎不怎么不用。</p>\n<h3 id=\"NSViewController\"><a href=\"#NSViewController\" class=\"headerlink\" title=\"NSViewController\"></a>NSViewController</h3><p><code>AppKit</code> 中的 <code>NSViewController</code>默认不支持交互，缺少生命周期相关方法和<code>UIKit</code>中熟悉的特性。<br>但在OS X 10.10 Yosemite之后，<code>NSViewController</code>改进很多，默认支持交互中的响应链。</p>\n</blockquote>\n<h3 id=\"NSWindow-和-UIWindow\"><a href=\"#NSWindow-和-UIWindow\" class=\"headerlink\" title=\"NSWindow 和 UIWindow\"></a>NSWindow 和 UIWindow</h3><p>在<code>UIKit</code>中<code>UIWindow</code>是一个 <code>view</code> 的子类.<br>在<code>AppKit</code>中<code>NSWindow</code>用 <code>contentView</code> 属性持有一个指向其顶层 <code>view</code> 的引用。</p>\n<h2 id=\"响应者链（responder-chain）\"><a href=\"#响应者链（responder-chain）\" class=\"headerlink\" title=\"响应者链（responder chain）\"></a>响应者链（responder chain）</h2><p>如果你在为 OS X 10.9 或者更低版本的系统开发，请注意在默认情况下<code>view controller</code> 并不是响应者链的一环。相反，事件会沿着视图树向上传递然后直接到达 <code>window</code> 和 <code>window</code> <code>controller</code>。在这种情况下，如果你想在 <code>view controller</code> 处理事件，你需要手动把它添加到响应者链中。</p>\n<h3 id=\"Target-Action消息传递方式\"><a href=\"#Target-Action消息传递方式\" class=\"headerlink\" title=\"Target-Action消息传递方式\"></a>Target-Action消息传递方式</h3><p><code>Target-Action</code> 是回应 <code>UI 事件</code>时典型的消息传递方式。<code>iOS</code> 上的 <code>UIControl</code> 和 <code>Mac</code> 上的 <code>NSControl/NSCell</code> 都支持这个机制。<br><code>Target-Action</code> 在消息的发送者和接收者之间建立了一个松散的关系。消息的接收者不知道发送者，甚至消息的发送者也不知道消息的接收者会是什么。如果 <code>target</code> 是 <code>nil</code>，<code>action</code> 会在响应链 (responder chain) 中被传递下去，直到找到一个响应它的对象。</p>\n<h4 id=\"传递机制的局限\"><a href=\"#传递机制的局限\" class=\"headerlink\" title=\"传递机制的局限\"></a>传递机制的局限</h4><p>基于 <code>target-action</code> 传递机制的一个局限是，发送的消息不能携带自定义的信息：</p>\n<ol>\n<li>在<code>iOS</code> 中，可以选择性的把发送者和触发 <code>action</code> 的事件作为参数。</li>\n<li>在 <code>Mac</code> 平台上 <code>action</code> 方法的第一个参数永远是发送者，否则将不视为无效方法。<br>在<code>AppKit</code>唯一有效的<code>action</code> 方法声明方式：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)performAction:(<span class=\"keyword\">id</span>)sender;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"控件关联Action事件的区别\"><a href=\"#控件关联Action事件的区别\" class=\"headerlink\" title=\"控件关联Action事件的区别\"></a>控件关联Action事件的区别</h4><p><code>iOS</code> 上的 <code>UIControl</code> 和 <code>Mac</code> 上的 <code>NSControl/NSCell</code> 都支持这个机制。</p>\n<ol>\n<li>在 <code>iOS</code> 中，每个控件可以通过<code>addTarget:action:forControlEvents:</code>和多个 <code>target-action</code> 关联。</li>\n<li>在<code>AppKit</code>中通常一个<code>控件</code>仅对应一个 <code>target-action</code>对。</li>\n</ol>\n<h2 id=\"View视图系统\"><a href=\"#View视图系统\" class=\"headerlink\" title=\"View视图系统\"></a>View视图系统</h2><p>因为历史遗留问题，<code>Mac</code> 的视图系统和 <code>iOS</code>的视图系统有很大区别。</p>\n<ol>\n<li>绘图处理器差异<br><code>iOS</code>由 <code>Core Animation layer</code> 驱动，使用<code>GPU</code>处理。<br><code>AppKit</code>视图系统相关的任务主要靠 <code>CPU</code> 处理，因为在<code>AppKit</code>设计之初，<code>GPU</code>还没有诞生。<br>Mac开发参考资料：<br><a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CocoaViewsGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40002978\" target=\"_blank\" rel=\"noopener\">Introduction to View Programming Guide for Cocoa</a><br><a href=\"https://developer.apple.com/videos/wwdc/2012/#217\" target=\"_blank\" rel=\"noopener\">WWDC session：Layer-Backed Views: AppKit + Core Animation</a><br><a href=\"https://developer.apple.com/videos/wwdc/2013/#215\" target=\"_blank\" rel=\"noopener\">Optimizing Drawing and Scrolling</a></li>\n</ol>\n<h3 id=\"Layer-Backed-View-iOS反哺AppKit层支持视图\"><a href=\"#Layer-Backed-View-iOS反哺AppKit层支持视图\" class=\"headerlink\" title=\"Layer-Backed View: iOS反哺AppKit层支持视图\"></a>Layer-Backed View: iOS反哺AppKit层支持视图</h3><ol>\n<li><code>iOS</code>反哺<code>AppKit</code><br>默认情况下，<code>AppKit</code> 的 <code>view</code> 不是由 <code>Core Animation layer</code> 驱动的；<code>AppKit</code> 整合 <code>layer-backing</code> 是 <code>iOS</code> 反哺的结果。</li>\n</ol>\n<h4 id=\"layer-backing启用／禁用-wantsLayer\"><a href=\"#layer-backing启用／禁用-wantsLayer\" class=\"headerlink\" title=\"layer backing启用／禁用:wantsLayer\"></a>layer backing启用／禁用:wantsLayer</h4><p><code>AppKit</code> 区分 <code>layer-backed view</code> 和 <code>layer-hosting view</code>，可以在每个视图树的根节点启用或者禁用 <code>layer backing</code>。<br>启用 <code>layer backing</code></p>\n<ol>\n<li>方法一：把窗口的 <code>contentView</code> 的 <code>wantsLayer</code> 属性设置为 <code>YES</code></li>\n<li>方法二：在 <code>Interface Builder</code> 的 <code>View Effects Inspector</code> 面板完成<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/ViewEffectsInspector.jpg?imageMogr2/2/w/800\">\n这会导致 <code>window</code> 的视图树中所有的 <code>view</code> 都启用 <code>layer backing</code>，这样就没必要反复设置每个 <code>view</code> 的 <code>wantsLayer</code> 属性了。</li>\n</ol>\n<h4 id=\"修改layer属性\"><a href=\"#修改layer属性\" class=\"headerlink\" title=\"修改layer属性\"></a>修改layer属性</h4><p>在<code>AppKit</code>上开启<code>layer backing</code>之后，<code>layer</code>的拥有者是<code>AppKit</code>，这就意味着不能直接编辑 <code>layer</code>的属性。<br>在 <code>iOS</code> 上可以直接编辑：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.layer.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor].CGColor;</span><br></pre></td></tr></table></figure><br>在 <code>AppKit</code>编辑<code>layer</code>属性需要以下步骤：</p>\n<ol>\n<li>重写 <code>NSView</code> 的 <code>wantsUpdateLayer</code> 方法并返回 <code>YES</code>,这能让你可以改变 <code>layer</code> 的属性。<br>这样以来，在<code>view</code> 更新周期中，将不会再调用 <code>view</code> 的 <code>drawRect:</code> 方法。取而代之，调用<code>updateLayer</code>方法来更新<code>Layer</code>。<br>举个例子，用这方法去实现一个非常简单的有纯色背景的 <code>view</code>（没错，<code>NSView</code> 没有<code>backgroundColor</code> 属性）：<br>这个例子的前提是这个 <code>view</code> 的<code>父 view</code> 已经为其视图树启用了 <code>layer backing</code>。<br>另一种可行的实现则只需要重写 <code>drawRect:</code> 方法并在其中绘制背景颜色。<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ColoredView</span>: <span class=\"title\">NSView</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSColor</span> *backgroundColor;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ColoredView</span></span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)wantsUpdateLayer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)updateLayer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.layer.backgroundColor = <span class=\"keyword\">self</span>.backgroundColor.CGColor;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setBackgroundColor:(<span class=\"built_in\">NSColor</span> *)backgroundColor</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _backgroundColor = backgroundColor;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setNeedsDisplay:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"合并-Layer\"><a href=\"#合并-Layer\" class=\"headerlink\" title=\"合并 Layer\"></a>合并 Layer</h4><p>当APP启动过多的<code>layer-backed view</code> 会带来巨大的内存消耗（每一个 <code>layer</code> 有其自己的 <code>backing store</code>，还有可能和其他 <code>view</code>的 <code>backing store</code> 重叠）而且会带来潜在的合成这些 <code>layer</code> 的消耗。</p>\n<h5 id=\"canDrawSubviewsIntoLayer合并Layer\"><a href=\"#canDrawSubviewsIntoLayer合并Layer\" class=\"headerlink\" title=\"canDrawSubviewsIntoLayer合并Layer\"></a>canDrawSubviewsIntoLayer合并Layer</h5><p>从 OS X 10.9 开始，如果不单独对一个 <code>view</code> 中的子 <code>view</code> 做动画，可以通过设置 <code>canDrawSubviewsIntoLayer</code> 属性来让 <code>AppKit</code> 合并一个<code>视图树</code>中所有 <code>layer</code> 的内容到一个共有的 <code>layer</code>。</p>\n<h5 id=\"隐式layer-backed合并Layer\"><a href=\"#隐式layer-backed合并Layer\" class=\"headerlink\" title=\"隐式layer-backed合并Layer\"></a>隐式layer-backed合并Layer</h5><p>所有隐式 <code>layer-backed</code> 的<code>子 view</code>（比如，没有显式地对这些<code>子 view</code> 设置 <code>wantsLayer = YES</code>）现在将会被绘制到同一个 <code>layer</code> 中。不过<code>wantsLayer</code> 设置为 <code>YES</code> 的<code>子 view</code> 仍然持有它们自己的 <code>backing layer</code>， 而且不管 <code>wantsUpdateLayer</code> 返回什么，它们的 <code>drawRect:</code> 方法仍然会被调用。</p>\n<h4 id=\"Layer-重绘策略\"><a href=\"#Layer-重绘策略\" class=\"headerlink\" title=\"Layer 重绘策略\"></a>Layer 重绘策略</h4><h5 id=\"layer-backed-view-默认的自动重绘策略\"><a href=\"#layer-backed-view-默认的自动重绘策略\" class=\"headerlink\" title=\"layer-backed view 默认的自动重绘策略\"></a>layer-backed view 默认的自动重绘策略</h5><p><code>layer-backed view</code> 会默认设置重绘策略为 <code>NSViewLayerContentsRedrawDuringViewResize</code>。在行为上，这个非 <code>layer-backed view</code> 是类似的，不过如果动画的每一帧都引入一个绘制步骤的话可能会对动画的性能造成不利影响。</p>\n<h5 id=\"设置layer-backed-view手动重绘策略\"><a href=\"#设置layer-backed-view手动重绘策略\" class=\"headerlink\" title=\"设置layer-backed view手动重绘策略\"></a>设置layer-backed view手动重绘策略</h5><ol>\n<li>设置手动重绘策略：把 <code>layerContentsRedrawPolicy</code> 属性设置为 <code>NSViewLayerContentsRedrawOnSetNeedsDisplay</code> </li>\n<li>实现手动重绘操作：调用 <code>-setNeedsDisplay:</code>方法来触发重绘操作<br>这样便由你来决定 <code>layer</code> 的内容何时需要重绘。帧的改变将不再自动触发重绘。</li>\n</ol>\n<h5 id=\"设置view的属性来重绘Layer\"><a href=\"#设置view的属性来重绘Layer\" class=\"headerlink\" title=\"设置view的属性来重绘Layer\"></a>设置view的属性来重绘Layer</h5><ol>\n<li>view中<code>layerContentsPlacement</code>属性：等价<code>layer</code>中的 <code>contentGravity</code> 属性。<br>这个属性允许你指定在调整大小的时候当前的 <code>layer</code> 内容该怎么映射到 <code>layer</code> 上。</li>\n</ol>\n<h3 id=\"Layer-Hosting-View-使用-Core-Animation-layer\"><a href=\"#Layer-Hosting-View-使用-Core-Animation-layer\" class=\"headerlink\" title=\"Layer-Hosting View:使用 Core Animation layer\"></a>Layer-Hosting View:使用 Core Animation layer</h3><p><code>layer-hosting view</code> 是视图树中的叶子节点，使用这种模式可以对<code>layer</code> 及其<code>子 layer</code> 做任何操作，代价是你再也不能给该 <code>view</code> 添加任何<code>子 view</code>。</p>\n<h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><ol>\n<li>为 <code>view</code> 的 <code>layer</code> 属性分配一个 <code>layer 对象</code>，</li>\n<li>设置<code>wantsLayer</code> 为 <code>YES</code><br>这些步骤的顺序是非常关键：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithFrame:(<span class=\"type\">NSRect</span>)frame</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> initWithFrame:frame];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.layer = [[<span class=\"type\">CALayer</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.wantsLayer = <span class=\"type\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n在你设置了自定义的 <code>layer</code> 之后，再设置 <code>wantsLayer</code> 是非常重要的。</li>\n</ol>\n<h3 id=\"其他与-View-相关的陷阱\"><a href=\"#其他与-View-相关的陷阱\" class=\"headerlink\" title=\"其他与 View 相关的陷阱\"></a>其他与 View 相关的陷阱</h3><h4 id=\"坐标系统原点设置左下／左上角\"><a href=\"#坐标系统原点设置左下／左上角\" class=\"headerlink\" title=\"坐标系统原点设置左下／左上角\"></a>坐标系统原点设置左下／左上角</h4><p>通过重写<code>isFlipped</code> 并返回 <code>YES</code> 来恢复到你熟悉的左上角。</p>\n<h4 id=\"View背景颜色属性drawsBackground\"><a href=\"#View背景颜色属性drawsBackground\" class=\"headerlink\" title=\"View背景颜色属性drawsBackground\"></a>View背景颜色属性drawsBackground</h4><p>由于 <code>AppKit</code> 中的 <code>view</code> 没有背景颜色属性可以让你直接设置为 <code>[NSColor clearColor]</code> 来让其变得透明，许多 <code>NSView</code> 的子类比如 <code>NSTextView</code> 和 <code>NSScrollView</code> 开放了一个 <code>drawsBackground</code> 属性，如果你想让这一类 <code>view</code> 透明，你必须设置该属性为 <code>NO</code>。</p>\n<h4 id=\"设置光标追踪区域\"><a href=\"#设置光标追踪区域\" class=\"headerlink\" title=\"设置光标追踪区域\"></a>设置光标追踪区域</h4><p>为了能接收光标进出一个 view 或者在 view 里面移动的事件，你需要创建一个追踪区域。你可以在 <code>NSView</code> 中指定的 <code>updateTrackingAreas</code> 方法中来做这件事情。一个通用的写法看起来是这样子的：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)updateTrackingAreas</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> removeTrackingArea:<span class=\"keyword\">self</span>.trackingArea];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.trackingArea = [[<span class=\"type\">NSTrackingArea</span> alloc] initWithRect:<span class=\"type\">CGRectZero</span> </span><br><span class=\"line\">                                                     options:<span class=\"type\">NSTrackingMouseEnteredAndExited</span>|<span class=\"type\">NSTrackingInVisibleRect</span>|<span class=\"type\">NSTrackingActiveInActiveApp</span></span><br><span class=\"line\">                                                       owner:<span class=\"keyword\">self</span> </span><br><span class=\"line\">                                                    userInfo:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> addTrackingArea:<span class=\"keyword\">self</span>.trackingArea];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"NSCell困惑\"><a href=\"#NSCell困惑\" class=\"headerlink\" title=\"NSCell困惑\"></a>NSCell困惑</h4><p><code>AppKit</code> 的控件之前是由 <code>NSCell</code> 的子类驱动的，可以被所有同类型的控件重用。<br><code>AppKit</code> 最初区分 <code>view</code> 和 <code>cell</code> 是为了节省资源 - <code>view</code> 可以把所有的绘制工作代理给更轻量级的可以被所有同类型的 <code>view</code> 重用的 <code>cell</code> 对象。<br>不要混淆这些 <code>cell</code> 和 <code>UIKit</code> 里 <code>table view</code> 的 <code>cell</code> 及 <code>collection view</code> 的 <code>cell</code>。</p>\n<h5 id=\"自定义一个按钮控件\"><a href=\"#自定义一个按钮控件\" class=\"headerlink\" title=\"自定义一个按钮控件\"></a>自定义一个按钮控件</h5><p>Apple 正在一步步地抛弃这样的实现方法了，但是你还是会时不时碰到这样的问题。<br>举个例子，如果你想创建一个自定义的按钮，</p>\n<ol>\n<li>首先要继承 <code>NSButton</code> 和 <code>NSButtonCell</code></li>\n<li>然后在这个 <code>cell 子类</code>里面进行你自定义的绘制，</li>\n<li>然后通过重写 <code>+[NSControl cellClass]</code>方法告诉自定义按钮使用你的 <code>cell 子类</code></li>\n</ol>\n<h4 id=\"获取-Core-Graphics-上下文\"><a href=\"#获取-Core-Graphics-上下文\" class=\"headerlink\" title=\"获取 Core Graphics 上下文\"></a>获取 Core Graphics 上下文</h4><p>最后，如果你想知道在你自己的 <code>drawRect:</code> 方法里怎么获取当前的 <code>Core Graphics</code> 上下文，答案是 <code>NSGraphicsContext</code> 的 <code>graphicsPort</code> 属性。详细内容请查看 <a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CocoaDrawingGuide/\" target=\"_blank\" rel=\"noopener\">Cocoa Drawing Guide</a>。</p>\n<h2 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h2><p>如果你的 <code>view</code> 不是由 <code>layer</code> 驱动的，那你的动画自然是完全由 <code>CPU</code> 处理，这意味着动画的每一步都必须相应地绘制到 <code>window-backing store</code> 上。</p>\n<h3 id=\"对-layer-backed-view做动画\"><a href=\"#对-layer-backed-view做动画\" class=\"headerlink\" title=\"对 layer-backed view做动画\"></a>对 layer-backed view做动画</h3><p>正如上面说的，在 <code>AppKit</code> 中,这些 <code>layer</code> 由 <code>AppKit</code> 管理，你不应该修改 <code>layer-backed view</code> 中的 <code>layer</code>。 </p>\n<h4 id=\"几何属性\"><a href=\"#几何属性\" class=\"headerlink\" title=\"几何属性\"></a>几何属性</h4><p>与<code>iOS</code> 相反，<code>view</code> 的几何属性并不仅仅是对应的 <code>layer</code> 的几何属性的映射，但 <code>AppKit</code> 却会把 <code>view</code> 内部的几何属性同步到 <code>layer</code>。</p>\n<h4 id=\"的animator-proxy动画\"><a href=\"#的animator-proxy动画\" class=\"headerlink\" title=\"的animator proxy动画\"></a>的animator proxy动画</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view.animator.alphaValue = <span class=\"number\">.5</span>;</span><br></pre></td></tr></table></figure>\n<p>在幕后，这句代码会启用 <code>layer</code> 的隐式动画，设置其透明度，然后再次禁用 <code>layer</code> 的隐式动画。</p>\n<h4 id=\"NSAnimationContext动画\"><a href=\"#NSAnimationContext动画\" class=\"headerlink\" title=\"NSAnimationContext动画\"></a>NSAnimationContext动画</h4><ol>\n<li>结束回调<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSAnimationContext</span> runAnimationGroup:^(<span class=\"built_in\">NSAnimationContext</span> *context)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//持续时间</span></span><br><span class=\"line\">    context.duration = <span class=\"number\">1</span>;  </span><br><span class=\"line\">    <span class=\"comment\">//缓动类型</span></span><br><span class=\"line\">    context.timingFunction = [<span class=\"built_in\">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseIn];</span><br><span class=\"line\">    view.animator.alphaValue = <span class=\"number\">.5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; completionHandler:^&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;]; </span><br></pre></td></tr></table></figure></li>\n<li>无结束回调<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSAnimationContext</span> currentContext].duration = <span class=\"number\">1</span>;</span><br><span class=\"line\">view.animator.alphaValue = <span class=\"number\">.5</span>; </span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"启用隐式动画\"><a href=\"#启用隐式动画\" class=\"headerlink\" title=\"启用隐式动画\"></a>启用隐式动画</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSAnimationContext</span> currentContext].allowsImplicitAnimations = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">view.alphaValue = <span class=\"number\">.5</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"CAAnimations控制动画\"><a href=\"#CAAnimations控制动画\" class=\"headerlink\" title=\"CAAnimations控制动画\"></a>CAAnimations控制动画</h4><p>使用 <code>CAAnimation</code> 实例更全面地控制动画。和 <code>iOS</code> 相反，你不能直接把它们加到 <code>layer</code> 上（因为 <code>layer</code> 不应该由你来修改），不过你可以使用 <code>NSAnimatablePropertyContainer</code> 协议中定义的 <code>API</code>，<code>NSView</code> 和 <code>NSWindow</code> 已经实现了该协议。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CAKeyframeAnimation</span> *animation = [<span class=\"built_in\">CAKeyframeAnimation</span> animation];</span><br><span class=\"line\">animation.values = @[@<span class=\"number\">1</span>, @<span class=\"number\">.9</span>, @<span class=\"number\">.8</span>, @<span class=\"number\">.7</span>, @<span class=\"number\">.6</span>];</span><br><span class=\"line\">view.animations = @&#123;<span class=\"string\">@\"alphaValue\"</span>: animation&#125;;</span><br><span class=\"line\">view.animator.alphaValue = <span class=\"number\">.5</span>;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"帧动画\"><a href=\"#帧动画\" class=\"headerlink\" title=\"帧动画\"></a>帧动画</h5><p>对于帧动画来说，把 <code>view</code> 的 <code>layerContentsRedrawPolicy</code> 设置为 <code>NSViewLayerContentsRedrawOnSetNeedsDisplay</code> 是非常重要的，不然的话 <code>view</code> 的内容在每一帧都会被重绘。</p>\n<p>很遗憾，<code>NSView</code> 没有开放 <code>Core Animation layer</code> 所有可以进行动画的属性，<code>transform</code> 是其中最重要的例子。看看 Jonathan Willings 的这篇文章，它描述了你可以如何解决这些限制。不过注意，文章中的解决方案是不受官方支持的。</p>\n<p>上面提到的所有东西都适用于 <code>layer-backed view</code>。对于 l<code>ayer-hosting view</code> 来说，你可以直接对 <code>view</code> 的 <code>layer</code> 或者<code>子 layer</code> 使用 <code>CAAnimations</code>，因为你拥有它们的控制权。</p>\n<h3 id=\"文字系统\"><a href=\"#文字系统\" class=\"headerlink\" title=\"文字系统\"></a>文字系统</h3><p>有了 <code>TextKit</code>，<code>iOS 7</code> 终于有了和 <code>Mac</code> 上早就有了的 <code>Cocoa Text System</code> 等效的东西。但 Apple 并不仅仅是把文字系统从 Mac 上转移到 <code>iOS</code>；相反，Apple 对其做了些显著的改变。<br>举个例子，<code>AppKit</code> 开放 <code>NSTypesetter</code> 和 <code>NSGlyphGenerator</code>，你可以通过继承这两者来自定义它们的一些特性。<code>iOS</code> 并不开放这些类，但是你可以通过 <code>NSLayoutManagerDelegate</code> 协议达到定制的目的。<br>总体来说，两个平台的文字系统还是非常相似的，所有你在 <code>iOS</code> 上能做的在 <code>Mac</code> 上都可以做（甚至更多），但对于一些东西，你必须从不同的地方寻找合适的方法实现。</p>\n<h3 id=\"沙盒\"><a href=\"#沙盒\" class=\"headerlink\" title=\"沙盒\"></a>沙盒</h3><p>符合沙盒机制的 <code>Mac 应用</code>才能通过 <code>Mac App Store</code> 销售。然而，我们已经习惯了沙盒机制还没出现之前的 <code>Mac</code> 开发环境，所以有时候会忽视一些你想要实现的功能会和沙盒的限制出现冲突。<br>管理Mac应用对沙盒支持：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/sandbox.jpg?imageMogr2/2/w/800\"></p>\n<h2 id=\"独有特性\"><a href=\"#独有特性\" class=\"headerlink\" title=\"独有特性\"></a>独有特性</h2><p>有很多事情你只能在 Mac 上做，这主要是因为它不同的交互模型和它更为宽松的安全策略。在本期话题中，我们有一些文章深入探讨了其中的一些内容：<a href=\"http://objccn.io/issue-14-4/\" target=\"_blank\" rel=\"noopener\">进程间通讯</a>，<a href=\"http://objccn.io/issue-14-1/\" target=\"_blank\" rel=\"noopener\">使 Mac 应用脚本化</a>,<a href=\"http://objccn.io/issue-14-2/\" target=\"_blank\" rel=\"noopener\">在沙盒中脚本化其他应用</a> , <a href=\"http://objccn.io/issue-14-3/\" target=\"_blank\" rel=\"noopener\">为你的应用构建插件</a>。<br>当然，这只是 Mac 独有特性中很小的一部分，但这给了你一个很好的视角看待 iOS 8 从头开始打造其可扩展性和 app 间通讯。最后，还有很多东西等待你去探索：Drag and Drop，Printing，Bindings，OpenCL 等等，这里仅仅是举几个例子。</p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"视图","path":"api/categories/视图.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"混编","path":"api/tags/混编.json"}]},{"title":"RxSwift基本概念","slug":"开源库/RxSwift基本概念","date":"2017-03-03T13:01:41.000Z","updated":"2017-09-24T09:18:26.000Z","comments":true,"path":"api/articles/开源库/RxSwift基本概念.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"FRP函数式反应型编程\"><a href=\"#FRP函数式反应型编程\" class=\"headerlink\" title=\"FRP函数式反应型编程\"></a>FRP函数式反应型编程</h2><p>Functional Reactive Programming ， 缩写为 FRP</p>\n<h2 id=\"函数编程\"><a href=\"#函数编程\" class=\"headerlink\" title=\"函数编程\"></a>函数编程</h2><h3 id=\"函数是第一等公民\"><a href=\"#函数是第一等公民\" class=\"headerlink\" title=\"函数是第一等公民\"></a>函数是第一等公民</h3><p>所谓 第一等公民 (first class) ，指的是函数与其他数据类型一样，处于平等地位。既可以赋值给其他变量，也可以作为参数传入另一个函数，或者作为别的函数的返回值。<br>将数组通过指定的函数映射成另一个数组，例如将<code>increment函数</code>作为参数传入数组的<code>map函数</code>:<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> increment = &#123; <span class=\"keyword\">return</span> $<span class=\"number\">0</span> + <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].<span class=\"built_in\">map</span>(increment)  <span class=\"comment\">// [2,3,4]</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"函数式的函数\"><a href=\"#函数式的函数\" class=\"headerlink\" title=\"函数式的函数\"></a>函数式的函数</h3><h4 id=\"map-映射函数\"><a href=\"#map-映射函数\" class=\"headerlink\" title=\"map 映射函数\"></a>map 映射函数</h4><p><code>map</code> 可以把一个数组按照一定的规则转换成另一个数组，定义如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">map</span>&lt;U&gt;<span class=\"params\">(transform: <span class=\"params\">(T)</span></span></span> -&gt; <span class=\"type\">U</span>) -&gt; <span class=\"type\">U</span>[]</span><br><span class=\"line\"><span class=\"comment\">//效果</span></span><br><span class=\"line\">[ x1, x2, ... , xn].<span class=\"built_in\">map</span>(f) -&gt; [f(x1), f(x2), ... , f(xn)]</span><br></pre></td></tr></table></figure><br><code>map</code>接受一个把 <code>T</code> 类型的转换成 <code>U</code> 类型的<code>transform</code>函数，最终返回的是 <code>U 类型的集合</code>。</p>\n<h4 id=\"filter-筛选函数\"><a href=\"#filter-筛选函数\" class=\"headerlink\" title=\"filter 筛选函数\"></a>filter 筛选函数</h4><p><code>filter</code>通过在闭包中对每个元素进行逻辑运算，来排除为<code>false</code>的元素<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">filter</span><span class=\"params\">(includeElement: <span class=\"params\">(T)</span></span></span> -&gt; <span class=\"type\">Bool</span>) -&gt; [<span class=\"type\">T</span>]</span><br><span class=\"line\"><span class=\"comment\">//实现</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oldArray = [<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">45</span>,<span class=\"number\">32</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> filteredArray  = oldArray.<span class=\"built_in\">filter</span>(&#123; <span class=\"keyword\">return</span> $<span class=\"number\">0</span> &gt; <span class=\"number\">30</span> &#125;)</span><br><span class=\"line\"><span class=\"built_in\">println</span>(filteredArray) <span class=\"comment\">// [45, 32]</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"reduce-迭代函数\"><a href=\"#reduce-迭代函数\" class=\"headerlink\" title=\"reduce 迭代函数\"></a>reduce 迭代函数</h4><p><code>reduce</code>函数把<code>U</code>类型集合中的所有元素，以<code>initial</code>为初始值，按照<code>combine</code>规则，逐个迭代并返回一个U类型的对象。<br>定义如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reduce</span>&lt;U&gt;<span class=\"params\">(initial: U, combine: <span class=\"params\">(U, T)</span></span></span> -&gt; <span class=\"type\">U</span>) -&gt; <span class=\"type\">U</span></span><br></pre></td></tr></table></figure><br>reduce 有两个参数，<code>initial</code>是初始值，<code>combine</code>定义规则闭包，闭包有两个输入的参数，一个是原始值，一个是新进来的值，闭包返回的新值作为下一轮循环中的<code>initial</code>值。<br>写几个小例子试一下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> oldArray = [<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">45</span>,<span class=\"number\">32</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"number\">0</span></span><br><span class=\"line\">sum = oldArray.<span class=\"built_in\">reduce</span>(<span class=\"number\">0</span>,&#123;$<span class=\"number\">0</span> + $<span class=\"number\">1</span>&#125;) <span class=\"comment\">// 0+10+20+45+32 = 107</span></span><br><span class=\"line\">sum = oldArray.<span class=\"built_in\">reduce</span>(<span class=\"number\">1</span>,&#123;$<span class=\"number\">0</span> + $<span class=\"number\">1</span>&#125;) <span class=\"comment\">// 1+10+20+45+32 = 108</span></span><br><span class=\"line\">sum = oldArray.<span class=\"built_in\">reduce</span>(<span class=\"number\">5</span>,&#123;$<span class=\"number\">0</span> * $<span class=\"number\">1</span>&#125;) <span class=\"comment\">// 5*10*20*45*32 = 1440000</span></span><br><span class=\"line\">sum = oldArray.<span class=\"built_in\">reduce</span>(<span class=\"number\">0</span>,+) <span class=\"comment\">// 0+10+20+45+32 = 107</span></span><br><span class=\"line\"><span class=\"built_in\">println</span>(sum)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"函数式和指令式的比较\"><a href=\"#函数式和指令式的比较\" class=\"headerlink\" title=\"函数式和指令式的比较\"></a>函数式和指令式的比较</h3><h2 id=\"响应式编程-Reactive\"><a href=\"#响应式编程-Reactive\" class=\"headerlink\" title=\"响应式编程 - Reactive\"></a>响应式编程 - Reactive</h2><p>在日常开发中，我们经常需要监听某个属性，并且针对该属性的变化做一些处理。比如以下几个场景：</p>\n<ol>\n<li>用户在输入邮箱的时候，监测输入的内容并在界面上提示是否符合邮箱规范。</li>\n<li>用户在修改用户名之后，所有显示用户名的界面都要改为新的用户名。<br>外部输入信号的变化、事件的发生，这些都是典型的外部环境变化。根据外部环境的变化进行响应处理，直观上来讲像是一种自然地反应。我们可以将这种自动对变化作出响应的能力称为反应能力 (Reactive) 。</li>\n</ol>\n<p>那么什么是反应型编程呢？</p>\n<pre><code>Reactive programming is programming with asynchronous data streams.\n反应型编程是异步数据流的编程。\n</code></pre><p>对于移动端来说，异步数据流的概念并不陌生，变量、点击事件、属性、缓存，这些就可以成为数据流。<br>我们可以通过一些简单的 ASCII 字符来演示如何将事件转换成数据流：<br>    –a—b-c—d—X—|–&gt;<br>    a, b, c, d 是具体的值，代表了某个事件<br>    X 表示发生了一个错误<br>    | 是这个流已经结束了的标记<br>    ———-&gt; 是时间轴<br>比如我们要统计用户点击鼠标的次数，那么可以这样：<br>clickStream:    —c—-c–c—-c——c–&gt;<br>                vvvvv map(c becomes 1) vvvv<br>                —1—-1–1—-1——1–&gt;<br>                vvvvvvvvv scan(+) vvvvvvvvv<br>counterStream:  —1—-2–3—-4——5–&gt;<br>反应型编程就是基于这些数据流的编程。而函数式编程则相当于提供了一个工具箱，可以方便的对数据流进行合并、创建和过滤等操作。</p>\n<h2 id=\"swift-函数式编程\"><a href=\"#swift-函数式编程\" class=\"headerlink\" title=\"swift 函数式编程\"></a>swift 函数式编程</h2><p>Swift 是苹果公司在 2014 年推出的编程语言，用于编写 iOS 和 OS X 应用程序。它吸收了很多其它语言的语法特性，例如闭包、元组、泛型、结构体等等，这使得它的语法简洁而灵活。<br>Swift 本身并不是一门函数式语言，不过有一些函数式的方法和特性</p>\n<ol>\n<li>map reduce 等函数式函数</li>\n<li>函数是一等公民</li>\n<li>模式匹配<br>我们并不能因为 Swift 中的一些函数式特性就把它归为函数式语言，但是我们可以利用这些特性进行函数式 Style 的编程。</li>\n</ol>\n<h1 id=\"RxSwift-响应式编程\"><a href=\"#RxSwift-响应式编程\" class=\"headerlink\" title=\"RxSwift 响应式编程\"></a>RxSwift 响应式编程</h1><p><a href=\"https://github.com/ReactiveX/RxSwift/tree/master/Rx.playground\" target=\"_blank\" rel=\"noopener\">Rx.playground</a></p>\n<h2 id=\"Observable观察者模式\"><a href=\"#Observable观察者模式\" class=\"headerlink\" title=\"Observable观察者模式\"></a>Observable观察者模式</h2><p>Rx 的基础：<code>Observable</code> ， <code>Observable&lt;Element&gt;</code> 是观察者模式中可观察的对象，相当于一个事件序列 (GeneratorType)。<br>支持订阅的事件序列，在下文简称为<code>订阅源</code>或<code>可观察者</code>。<br>订阅源的事件队列中包括三种事件类型：</p>\n<ol>\n<li><code>.Next(value)</code>: 表示新的事件数据。</li>\n<li><code>.Completed</code>: 表示事件序列的完结。</li>\n<li><code>.Error</code>: 同样表示完结，但是代表异常导致的完结。</li>\n</ol>\n<h3 id=\"新建订阅源几种快捷方法\"><a href=\"#新建订阅源几种快捷方法\" class=\"headerlink\" title=\"新建订阅源几种快捷方法\"></a>新建订阅源几种快捷方法</h3><ol>\n<li><code>empty</code>是一个空的序列，它只发送 <code>.Completed</code> 消息。<figure class=\"highlight swift\"><figcaption><span>Observable+Creation.swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">empty</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Observable</span>&lt;<span class=\"type\">E</span>&gt;</span><br><span class=\"line\">example(<span class=\"string\">\"empty\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> emptySequence: <span class=\"type\">Observable</span>&lt;<span class=\"type\">Int</span>&gt; = empty()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> subscription = emptySequence.subscribe &#123; event <span class=\"keyword\">in</span></span><br><span class=\"line\">                                                <span class=\"built_in\">print</span>(event)</span><br><span class=\"line\">                                            &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- empty example ---</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure></li>\n<li><code>never</code> 是没有任何元素、也不会发送任何事件的空序列。<figure class=\"highlight swift\"><figcaption><span>Observable+Creation.swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">- returns: An observable sequence whose observers will never get called.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">never</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Observable</span>&lt;<span class=\"type\">E</span>&gt;</span><br></pre></td></tr></table></figure></li>\n<li><code>just</code> 是只包含一个元素的序列，它会先发送 <code>.Next(value)</code> ，然后发送 <code>.Completed</code><figure class=\"highlight swift\"><figcaption><span>Observable+Creation.swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">Returns an observable sequence that contains a single element.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">just</span><span class=\"params\">(<span class=\"number\">_</span> element: E)</span></span> -&gt; <span class=\"type\">Observable</span>&lt;<span class=\"type\">E</span>&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"type\">Just</span>(element: element)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>sequenceOf</code> 可以把一系列元素转换成订阅源<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sequenceOfElements<span class=\"comment\">/* : Observable&lt;Int&gt; */</span> = sequenceOf(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure></li>\n<li><code>asObservable方法</code> 将遵守<code>ObservableType</code>协议的对象转为可观察者序列<figure class=\"highlight swift\"><figcaption><span>ObservableType.swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">ObservableType</span> : <span class=\"title\">ObservableConvertibleType</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//Default implementation of converting `ObservableType` to `Observable`.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">asObservable</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Observable</span>&lt;<span class=\"type\">E</span>&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> sequenceFromArray = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].asObservable()</span><br></pre></td></tr></table></figure></li>\n<li><code>failWith</code>创建一个没有元素的序列，只会发送失败 (<code>.Error</code>) 事件。<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> error = <span class=\"type\">NSError</span>(domain: <span class=\"string\">\"Test\"</span>, code: -<span class=\"number\">1</span>, userInfo: <span class=\"literal\">nil</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> erroredSequence: <span class=\"type\">Observable</span>&lt;<span class=\"type\">Int</span>&gt; = failWith(error)</span><br><span class=\"line\"><span class=\"keyword\">let</span> subscription = erroredSequence.subscribe &#123; event <span class=\"keyword\">in</span> <span class=\"built_in\">print</span>(event)&#125;</span><br><span class=\"line\">--- failWith example ---</span><br><span class=\"line\"><span class=\"type\">Error</span>(<span class=\"type\">Error</span> <span class=\"type\">Domain</span>=<span class=\"type\">Test</span> <span class=\"type\">Code</span>=-<span class=\"number\">1</span> <span class=\"string\">\"The operation couldn’t be completed. (Test error -1.)\"</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"create自定义订阅源\"><a href=\"#create自定义订阅源\" class=\"headerlink\" title=\"create自定义订阅源\"></a>create自定义订阅源</h3><p><code>create</code> 可以通过闭包创建序列，通过 <code>.on(e: Event)</code> 添加可观察者事件。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"create\"</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> myJust = &#123; (singleElement: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Observable</span>&lt;<span class=\"type\">Int</span>&gt; <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> create &#123; observer <span class=\"keyword\">in</span></span><br><span class=\"line\">                observer.on(.<span class=\"type\">Next</span>(singleElement))</span><br><span class=\"line\">                observer.on(.<span class=\"type\">Completed</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"type\">NopDisposable</span>.instance</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> subscription = myJust(<span class=\"number\">5</span>).subscribe &#123; event <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(event)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- create example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"deferred订阅源的懒加载\"><a href=\"#deferred订阅源的懒加载\" class=\"headerlink\" title=\"deferred订阅源的懒加载\"></a>deferred订阅源的懒加载</h3><p><code>deferred</code>表示当有有新增订阅者第一次订阅了该订阅源时，订阅源才会被创建，且每个订阅者订阅的对象都是内容相同而完全独立的序列。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"TestDeferred\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value: <span class=\"type\">String</span>? = <span class=\"literal\">nil</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> subscription: <span class=\"type\">Observable</span>&lt;<span class=\"type\">String</span>?&gt; = deferred &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> just(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// got value</span></span><br><span class=\"line\">    value = <span class=\"string\">\"Hello!\"</span></span><br><span class=\"line\">    subscription.subscribe &#123; event <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(event)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- <span class=\"type\">TestDeferred</span> example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">Optional</span>(<span class=\"string\">\"Hello!\"</span>))</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"几种特殊类型的订阅源\"><a href=\"#几种特殊类型的订阅源\" class=\"headerlink\" title=\"几种特殊类型的订阅源\"></a>几种特殊类型的订阅源</h2><p><code>Subject</code> 可以看做是一种代理和桥梁。它既是订阅者又是订阅源，这意味着它既可以订阅其他 <code>Observable 对象</code>，同时又可以对它的订阅者们发送事件。</p>\n<h3 id=\"PublishSubject-向所有订阅者发送事件队列\"><a href=\"#PublishSubject-向所有订阅者发送事件队列\" class=\"headerlink\" title=\"PublishSubject 向所有订阅者发送事件队列\"></a>PublishSubject 向所有订阅者发送事件队列</h3><p>当<code>PublishSubject</code>类型订阅源事件队列中<code>.on()</code>新增事件时，会触发所有订阅者，一起响应该事件。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"PublishSubject\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> subject = <span class=\"type\">PublishSubject</span>&lt;<span class=\"type\">String</span>&gt;()</span><br><span class=\"line\">    writeSequenceToConsole(<span class=\"string\">\"1\"</span>, sequence: subject)</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"a\"</span>))</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"b\"</span>))</span><br><span class=\"line\">    writeSequenceToConsole(<span class=\"string\">\"2\"</span>, sequence: subject)</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"c\"</span>))</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"d\"</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- <span class=\"type\">PublishSubject</span> example ---</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(a)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(b)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Next</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(d)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Next</span>(d)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"基于PublishSubject的几种补发式订阅源\"><a href=\"#基于PublishSubject的几种补发式订阅源\" class=\"headerlink\" title=\"基于PublishSubject的几种补发式订阅源\"></a>基于PublishSubject的几种补发式订阅源</h3><p>以下几种类型的订阅源，相较第一种仅多了补发历史事件，姑且称为<code>补发式订阅源</code>。</p>\n<h4 id=\"ReplaySubject先向最新订阅者补发所有已发生的事件\"><a href=\"#ReplaySubject先向最新订阅者补发所有已发生的事件\" class=\"headerlink\" title=\"ReplaySubject先向最新订阅者补发所有已发生的事件\"></a>ReplaySubject先向最新订阅者补发所有已发生的事件</h4><p>当<code>ReplaySubject</code>类型的订阅源，新增订阅者时，该类型的订阅源会把之前已发送过的所有事件队列重新补发给这个最新订阅者。这样就迫使订阅者会对从历史的事件队列逐一响应。<br><code>bufferSize</code> 是缓冲区的大小，决定了补发队列的最大值。如果 <code>bufferSize</code> 是1，那么新的订阅者出现的时候就会补发上一个事件，如果是2，则补两个，以此类推。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"ReplaySubject\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> subject = <span class=\"type\">ReplaySubject</span>&lt;<span class=\"type\">String</span>&gt;.create(bufferSize: <span class=\"number\">1</span>)</span><br><span class=\"line\">    writeSequenceToConsole(<span class=\"string\">\"1\"</span>, sequence: subject)</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"a\"</span>))</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"b\"</span>))</span><br><span class=\"line\">    writeSequenceToConsole(<span class=\"string\">\"2\"</span>, sequence: subject)</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"c\"</span>))</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"d\"</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- <span class=\"type\">ReplaySubject</span> example ---</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(a)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(b)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Next</span>(b) <span class=\"comment\">// 补了一个 b</span></span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Next</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(d)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Next</span>(d)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"BehaviorSubject-先向最新订阅者补发最近一次历史事件\"><a href=\"#BehaviorSubject-先向最新订阅者补发最近一次历史事件\" class=\"headerlink\" title=\"BehaviorSubject 先向最新订阅者补发最近一次历史事件\"></a>BehaviorSubject 先向最新订阅者补发最近一次历史事件</h4><p><code>BehaviorSubject</code>类型的订阅源会向最新订阅者发送最近一次的历史事件队列，如果没有则发送一个默认值。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"BehaviorSubject\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> subject = <span class=\"type\">BehaviorSubject</span>(value: <span class=\"string\">\"z\"</span>)</span><br><span class=\"line\">    writeSequenceToConsole(<span class=\"string\">\"1\"</span>, sequence: subject)</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"a\"</span>))</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"b\"</span>))</span><br><span class=\"line\">    writeSequenceToConsole(<span class=\"string\">\"2\"</span>, sequence: subject)</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"c\"</span>))</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Completed</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- <span class=\"type\">BehaviorSubject</span> example ---</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(z)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(a)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(b)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Next</span>(b)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Next</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Completed</span></span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Completed</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Variable\"><a href=\"#Variable\" class=\"headerlink\" title=\"Variable\"></a>Variable</h4><p><code>Variable</code> 是基于 <code>BehaviorSubject</code> 的一层封装，它的优势是：不会被显式终结。<br>即：不会收到 <code>.Completed</code> 和 <code>.Error</code> 这类的终结事件，它会主动在析构的时候发送 <code>.Complete</code><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"Variable\"</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> variable = <span class=\"type\">Variable</span>(<span class=\"string\">\"z\"</span>)</span><br><span class=\"line\">    writeSequenceToConsole(<span class=\"string\">\"1\"</span>, sequence: variable)</span><br><span class=\"line\">    variable.value = <span class=\"string\">\"a\"</span></span><br><span class=\"line\">    variable.value = <span class=\"string\">\"b\"</span></span><br><span class=\"line\">    writeSequenceToConsole(<span class=\"string\">\"2\"</span>, sequence: variable)</span><br><span class=\"line\">    variable.value = <span class=\"string\">\"c\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- <span class=\"type\">Variable</span> example ---</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(z)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(a)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(b)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Next</span>(b)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Next</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Completed</span></span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"支持订阅的嵌套函数\"><a href=\"#支持订阅的嵌套函数\" class=\"headerlink\" title=\"支持订阅的嵌套函数\"></a>支持订阅的嵌套函数</h2><h3 id=\"map-规则-遍历映射\"><a href=\"#map-规则-遍历映射\" class=\"headerlink\" title=\"map{规则} 遍历映射\"></a>map{规则} 遍历映射</h3><p>通过闭包中定义的规则将队列中的数据映射到新的队列中，支持订阅遍历事件。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">map</span>&lt;U&gt;<span class=\"params\">(transform: <span class=\"params\">(T)</span></span></span> -&gt; <span class=\"type\">U</span>) -&gt; <span class=\"type\">U</span>[]</span><br><span class=\"line\"><span class=\"comment\">//效果</span></span><br><span class=\"line\">[ x1, x2, ... , xn].<span class=\"built_in\">map</span>(f) -&gt; [f(x1), f(x2), ... , f(xn)]</span><br></pre></td></tr></table></figure><br><code>map</code>接受一个把 <code>T</code> 类型的转换成 <code>U</code> 类型的<code>transform</code>函数，最终返回的是 <code>U 类型的集合</code>。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"map\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> originalSequence = sequenceOf(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">    originalSequence.<span class=\"built_in\">map</span>&#123; $<span class=\"number\">0</span> * <span class=\"number\">2</span> &#125;.subscribe&#123; <span class=\"built_in\">print</span>($<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- <span class=\"built_in\">map</span> example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"flatMap-嵌套式遍历映射\"><a href=\"#flatMap-嵌套式遍历映射\" class=\"headerlink\" title=\"flatMap 嵌套式遍历映射\"></a>flatMap 嵌套式遍历映射</h3><p>嵌套式遍历描述：在遍历当前队列的过程中，每次执行闭包时都会遍历另一个嵌套队列中的所有事件。<br>可以想象嵌套for 循环来理解。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"flatMap\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sequenceInt = sequenceOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sequenceString = sequenceOf(<span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"--\"</span>)</span><br><span class=\"line\">    sequenceInt.flatMap&#123; int <span class=\"keyword\">in</span> sequenceString &#125;.subscribe&#123; <span class=\"built_in\">print</span>($<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- flatMap example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">A</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">B</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(--)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">A</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">B</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(--)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">A</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">B</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(--)</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"scan-initial-U-combine-U-T-gt-U-迭代映射\"><a href=\"#scan-initial-U-combine-U-T-gt-U-迭代映射\" class=\"headerlink\" title=\"scan(initial:U,combine:(U, T) -&gt; U)迭代映射\"></a>scan(initial:U,combine:(U, T) -&gt; U)迭代映射</h3><p>scan 有点像 reduce ，把<code>U</code>类型集合中的所有元素，以<code>initial</code>为初始值，按照<code>combine</code>规则，逐个迭代并返回一个U类型的对象。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"scan\"</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sequenceToSum = sequenceOf(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">    sequenceToSum.scan(<span class=\"number\">0</span>) &#123; acum, elem <span class=\"keyword\">in</span> acum + elem &#125;</span><br><span class=\"line\">    .subscribe &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>($<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- scan example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">15</span>)</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Filtering-支持订阅的过滤器\"><a href=\"#Filtering-支持订阅的过滤器\" class=\"headerlink\" title=\"Filtering 支持订阅的过滤器\"></a>Filtering 支持订阅的过滤器</h2><h3 id=\"filter-布尔语句-条件过滤法\"><a href=\"#filter-布尔语句-条件过滤法\" class=\"headerlink\" title=\"filter{布尔语句} 条件过滤法\"></a>filter{布尔语句} 条件过滤法</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"filter\"</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">let</span> subscription = sequenceOf(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\">.<span class=\"built_in\">filter</span> &#123; $<span class=\"number\">0</span> % <span class=\"number\">2</span> == <span class=\"number\">0</span> &#125;.subscribe &#123; <span class=\"built_in\">print</span>($<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- <span class=\"built_in\">filter</span> example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">8</span>)</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"distinctUntilChanged-去重过滤法（相邻且不重复）\"><a href=\"#distinctUntilChanged-去重过滤法（相邻且不重复）\" class=\"headerlink\" title=\"distinctUntilChanged() 去重过滤法（相邻且不重复）\"></a>distinctUntilChanged() 去重过滤法（相邻且不重复）</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"distinctUntilChanged\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> subscription = sequenceOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">    .distinctUntilChanged().subscribe&#123; <span class=\"built_in\">print</span>($<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- distinctUntilChanged example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"take-int-掐尖过滤法\"><a href=\"#take-int-掐尖过滤法\" class=\"headerlink\" title=\"take(int) 掐尖过滤法\"></a>take(int) 掐尖过滤法</h3><p><code>take</code>只获取队列中前 n 个事件，在满足数量之后会自动 <code>.Completed</code><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"take\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">let</span> subscription = sequenceOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\">.take(<span class=\"number\">3</span>).subscribe &#123; <span class=\"built_in\">print</span>($<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- take example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Combining-订阅源聚合器\"><a href=\"#Combining-订阅源聚合器\" class=\"headerlink\" title=\"Combining 订阅源聚合器\"></a>Combining 订阅源聚合器</h2><p>订阅源聚合器将多个可观察者（订阅源）合并成一个可观察者（聚合订阅源），这样更便于订阅者同时监听多个订阅源。</p>\n<h3 id=\"startWith-向可观察者队列中添加排头兵（新增的可观察者）\"><a href=\"#startWith-向可观察者队列中添加排头兵（新增的可观察者）\" class=\"headerlink\" title=\"startWith 向可观察者队列中添加排头兵（新增的可观察者）\"></a>startWith 向可观察者队列中添加排头兵（新增的可观察者）</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> subscription = sequenceOf(<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>).startWith(<span class=\"number\">3</span>).subscribe &#123; <span class=\"built_in\">print</span>($<span class=\"number\">0</span>)&#125;</span><br><span class=\"line\">--- startWith example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"combineLatest-合并聚合订阅源最后一次事件数据，生成一个聚合事件\"><a href=\"#combineLatest-合并聚合订阅源最后一次事件数据，生成一个聚合事件\" class=\"headerlink\" title=\"combineLatest 合并聚合订阅源最后一次事件数据，生成一个聚合事件\"></a>combineLatest 合并聚合订阅源最后一次事件数据，生成一个聚合事件</h3><p>便于订阅者监听聚合订阅源中每个订阅源的最后一次事件数据<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"combineLatest 1\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> intOb1 = <span class=\"type\">PublishSubject</span>&lt;<span class=\"type\">String</span>&gt;()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> intOb2 = <span class=\"type\">PublishSubject</span>&lt;<span class=\"type\">Int</span>&gt;()</span><br><span class=\"line\">    combineLatest(intOb1, intOb2) &#123;<span class=\"string\">\"\\($0) \\($1)\"</span>&#125;.subscribe &#123;  <span class=\"built_in\">print</span>($<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\">    intOb1.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"A\"</span>))</span><br><span class=\"line\">    intOb2.on(.<span class=\"type\">Next</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">    intOb1.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"B\"</span>))</span><br><span class=\"line\">    intOb2.on(.<span class=\"type\">Next</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- combineLatest <span class=\"number\">1</span> example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">A</span> <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">B</span> <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">B</span> <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"zip-intOb1-intOb2-拉链式合并\"><a href=\"#zip-intOb1-intOb2-拉链式合并\" class=\"headerlink\" title=\"zip(intOb1, intOb2) 拉链式合并\"></a>zip(intOb1, intOb2) 拉链式合并</h3><p>仅在凑齐聚合源中所有订阅源的事件时，才会聚合一次，触发订阅者的响应。可以将多达8个订阅源<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"zip 1\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> intOb1 = <span class=\"type\">PublishSubject</span>&lt;<span class=\"type\">String</span>&gt;()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> intOb2 = <span class=\"type\">PublishSubject</span>&lt;<span class=\"type\">Int</span>&gt;()</span><br><span class=\"line\">    <span class=\"built_in\">zip</span>(intOb1, intOb2) &#123; <span class=\"string\">\"\\($0) \\($1)\"</span> &#125;.subscribe &#123; <span class=\"built_in\">print</span>($<span class=\"number\">0</span>)&#125;</span><br><span class=\"line\">    intOb1.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"A\"</span>))</span><br><span class=\"line\">    intOb2.on(.<span class=\"type\">Next</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">    intOb1.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"B\"</span>))</span><br><span class=\"line\">    intOb1.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"C\"</span>))</span><br><span class=\"line\">    intOb2.on(.<span class=\"type\">Next</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- <span class=\"built_in\">zip</span> <span class=\"number\">1</span> example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">A</span> <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">B</span> <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"merge-按可观察者的新的事件次序合并队列\"><a href=\"#merge-按可观察者的新的事件次序合并队列\" class=\"headerlink\" title=\"merge() 按可观察者的新的事件次序合并队列\"></a>merge() 按可观察者的新的事件次序合并队列</h3><p>订阅者会按次序来响应聚合订阅源的每一件事件<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"merge 1\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> subject1 = <span class=\"type\">PublishSubject</span>&lt;<span class=\"type\">Int</span>&gt;()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> subject2 = <span class=\"type\">PublishSubject</span>&lt;<span class=\"type\">Int</span>&gt;()</span><br><span class=\"line\">    sequenceOf(subject1, subject2).merge().subscribeNext &#123; int <span class=\"keyword\">in</span> <span class=\"built_in\">print</span>(int)&#125;</span><br><span class=\"line\">    subject1.on(.<span class=\"type\">Next</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">    subject1.on(.<span class=\"type\">Next</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">    subject2.on(.<span class=\"type\">Next</span>(<span class=\"number\">3</span>))</span><br><span class=\"line\">    subject1.on(.<span class=\"type\">Next</span>(<span class=\"number\">4</span>))</span><br><span class=\"line\">    subject2.on(.<span class=\"type\">Next</span>(<span class=\"number\">5</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- merge <span class=\"number\">1</span> example ---</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"switchLatest订阅源切换器：用于嵌套式订阅源\"><a href=\"#switchLatest订阅源切换器：用于嵌套式订阅源\" class=\"headerlink\" title=\"switchLatest订阅源切换器：用于嵌套式订阅源\"></a>switchLatest订阅源切换器：用于嵌套式订阅源</h3><p>通过切换（var3.value）嵌套的订阅源，来切换订阅者当前监听的订阅源，以响应当前订阅源中的可观察者的事件。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"switchLatest\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> var1 = <span class=\"type\">Variable</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> var2 = <span class=\"type\">Variable</span>(<span class=\"number\">200</span>)</span><br><span class=\"line\">    <span class=\"comment\">// var3 is like an Observable&lt;Observable&lt;Int&gt;&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> var3 = <span class=\"type\">Variable</span>(var1)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> d = var3.switchLatest().subscribe&#123; <span class=\"built_in\">print</span>($<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\">    var1.value = <span class=\"number\">1</span></span><br><span class=\"line\">    var1.value = <span class=\"number\">2</span></span><br><span class=\"line\">    var1.value = <span class=\"number\">3</span></span><br><span class=\"line\">    var1.value = <span class=\"number\">4</span></span><br><span class=\"line\">    var3.value = var2</span><br><span class=\"line\">    var2.value = <span class=\"number\">201</span></span><br><span class=\"line\">    var1.value = <span class=\"number\">5</span></span><br><span class=\"line\">    var3.value = var1</span><br><span class=\"line\">    var2.value = <span class=\"number\">202</span></span><br><span class=\"line\">    var1.value = <span class=\"number\">6</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- switchLatest example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">200</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">201</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">6</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"订阅器\"><a href=\"#订阅器\" class=\"headerlink\" title=\"订阅器\"></a>订阅器</h2><ol>\n<li>订阅器：<code>subscribe</code> 用来订阅可观察者的事件队列（即订阅源），并指定响应的相关操作</li>\n<li>Next订阅器：<code>subscribeNext</code> 只订阅 <code>.Next</code> 事件</li>\n<li>Completed订阅器：<code>subscribeCompleted</code> 只订阅<code>.Completed</code> 完成事件</li>\n<li>Error订阅器：<code>subscribeError</code> 订阅 <code>.Error</code> 失败事件</li>\n<li>订阅器观察者：<code>doOn</code> 在订阅器执行之前，获得执行代码的机会。可对比理解：<code>swift中的属性观察者</code></li>\n</ol>\n<h2 id=\"控制take掐尖过滤器\"><a href=\"#控制take掐尖过滤器\" class=\"headerlink\" title=\"控制take掐尖过滤器\"></a>控制take掐尖过滤器</h2><p>过滤器通过指定的事件和状态语句来判断是否停止take</p>\n<h3 id=\"takeUntil-得到指定事件之后触发-Completed-事件\"><a href=\"#takeUntil-得到指定事件之后触发-Completed-事件\" class=\"headerlink\" title=\"takeUntil 得到指定事件之后触发 .Completed 事件\"></a>takeUntil 得到指定事件之后触发 .Completed 事件</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"takeUntil\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> originalSequence = <span class=\"type\">PublishSubject</span>&lt;<span class=\"type\">Int</span>&gt;()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> whenThisSendsNextWorldStops = <span class=\"type\">PublishSubject</span>&lt;<span class=\"type\">Int</span>&gt;()</span><br><span class=\"line\">    originalSequence.takeUntil(whenThisSendsNextWorldStops)</span><br><span class=\"line\">    .subscribe &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>($<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    originalSequence.on(.<span class=\"type\">Next</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">    originalSequence.on(.<span class=\"type\">Next</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">    whenThisSendsNextWorldStops.on(.<span class=\"type\">Next</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">    originalSequence.on(.<span class=\"type\">Next</span>(<span class=\"number\">3</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- takeUntil example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"takeWhile-判断语句\"><a href=\"#takeWhile-判断语句\" class=\"headerlink\" title=\"takeWhile 判断语句\"></a>takeWhile 判断语句</h3><p>takeWhile 则是可以通过状态语句判断是否继续 take 。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"takeWhile\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sequence = <span class=\"type\">PublishSubject</span>&lt;<span class=\"type\">Int</span>&gt;()</span><br><span class=\"line\">    sequence.takeWhile &#123; int <span class=\"keyword\">in</span> int &lt; <span class=\"number\">2</span> &#125;.subscribe &#123; <span class=\"built_in\">print</span>($<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\">    sequence.on(.<span class=\"type\">Next</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">    sequence.on(.<span class=\"type\">Next</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">    sequence.on(.<span class=\"type\">Next</span>(<span class=\"number\">3</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- takeWhile example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"开源库","path":"api/categories/开源库.json"},{"name":"RxSwift","path":"api/categories/RxSwift.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"SDK","path":"api/tags/SDK.json"}]},{"title":"互动性的教学工具XCPlayground","slug":"swift/互动性的教学工具XCPlayground","date":"2017-03-01T17:27:16.000Z","updated":"2017-03-01T17:27:16.000Z","comments":true,"path":"api/articles/swift/互动性的教学工具XCPlayground.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/xcplayground-sources.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>Playground 展示语法和实时执行真实数据的特性，为编写方法和库接口提供了很好的机会，通过实时编译我们能了解语法、写出例子以及获得方法如何使用的说明，所有这些就如一个活的文档展示在眼前。</p>\n<ol>\n<li>演习框架API，了解框架结构<br><a href=\"https://github.com/objcio/PersonalSwiftPlaygrounds\" target=\"_blank\" rel=\"noopener\">SceneKitMac.playground</a><br>是一个功能完备带动画的 3D 场景。你需要打开 Assistant Editor (在菜单上依次点击 View | Assistant Editor | Show Assistant Editor)，3D 效果和动画将会被自动渲染。这不需要编译循环，而且任何的改动，比如改变颜色、几何形状、亮度等，都能实时反映出来。使用它能在一个交互例子中很好的记录和介绍如何使用SceneKit框架。</li>\n<li>测试驱动开发<br>我们可以验证一个方法的执行是否正确，甚至在加载到 playground 的时候就能判断方法是否被正确解析。不难想象我们也可以在 playground 里添加断言，以及创建真正的单元测试。或者更进一步，创建出符合条件的测试，从而在你打字时就实现测试驱动开发。</li>\n</ol>\n<h2 id=\"Sources\"><a href=\"#Sources\" class=\"headerlink\" title=\"Sources\"></a>Sources</h2><p>打开 Project Navigator (⌘1) 并展开 Playground 文件，你就能看到”Sources”路径。<br>放到此目录下的源文件会被编译成模块(module)并自动导入到 Playground 中，并且这个编译只会进行一次(或者我们对该目录下的文件进行修改的时候)，而非每次你敲入一个字母的时候就编译一次。 这将会大大提高代码执行的效率。</p>\n<blockquote>\n<p>注意：由于此目录下的文件都是被编译成模块导入的，只有被设置成 public 的类型，属性或方法才能在 Playground 中使用。</p>\n</blockquote>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcplayground-sources.png?imageMogr2/2/w/800\">\n<h2 id=\"导入Frameworks\"><a href=\"#导入Frameworks\" class=\"headerlink\" title=\"导入Frameworks\"></a>导入Frameworks</h2><p>如果想要导入外部 framework，创建一个 Xcode Workspace 包含了 framework 项目和你的 Playground。在 Build 之后，就可以通过常规的import命令导入对应的包。</p>\n<h3 id=\"手动配置cocoa-touch-Framework来桥接playground\"><a href=\"#手动配置cocoa-touch-Framework来桥接playground\" class=\"headerlink\" title=\"手动配置cocoa touch Framework来桥接playground\"></a>手动配置cocoa touch Framework来桥接playground</h3><p>在Playgroud中使用个人项目中的类相关方法，需要借助于Custom Frameworks桥接<br>注：.swift的文件中的方法必须是public修饰。<br>参考文档：<code>Playground help -&gt; Importing Custom Frameworks into a Playground</code></p>\n<ol>\n<li>导入个人项目文件，需要借助<code>cocoa touch Framework</code>桥接<code>playground</code></li>\n<li>需要<code>workspace</code>来管理<code>Framework</code>项目和<code>playground</code>文件，典型例子：pod项目都是用workspace来管理多个项目。</li>\n<li>把个人项目的<code>swift文件</code>关联到<code>Cocoa touch Framework</code>项目的<code>target</code>中：<br> 详细设置：选中target -&gt; build phases -&gt; compiles sources -&gt;点击 + 加号，选中原项目中的swift</li>\n<li>在<code>build</code>选项中选中Framework的scheme进行编译 ,要保证framework的target配置：<code>build setting -&gt; build active architecture Only -&gt;debug</code>选项设置为<code>YES</code></li>\n<li>打开playground文件 import Framework名称，此时即可使用Framework中的提供的public API方法了。<br>Workspace相关设置，build生成的目录：xcode偏好设置要和项目中的workspace中设置要保持一致.</li>\n<li>xcode的偏好设置中 -&gt;Locations -&gt; Locations -&gt;点击打开 Advanced…在弹出框中设置Unique选项.</li>\n<li>在workspace中选中菜单 File -&gt; workspace settings… -&gt; 在弹出框中设置为Unique选项.</li>\n</ol>\n<h3 id=\"导入cocopads管理的依赖库\"><a href=\"#导入cocopads管理的依赖库\" class=\"headerlink\" title=\"导入cocopads管理的依赖库\"></a>导入cocopads管理的依赖库</h3><p>xcode7.3.1和cocoapods1.0版本导致playground无法import相关动态库<br>解决办法：<a href=\"http://stackoverflow.com/questions/38216238/xcode-playground-with-cocoapods#\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/38216238/xcode-playground-with-cocoapods#</a><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#在写入磁盘之前，修改一些工程的配置:</span></span><br><span class=\"line\">post_install <span class=\"keyword\">do</span> |installer|</span><br><span class=\"line\">    installer.pods_project.targets.each <span class=\"keyword\">do</span> |target|</span><br><span class=\"line\">        <span class=\"keyword\">if</span> target.name != <span class=\"string\">'CocoaAsyncSocket'</span></span><br><span class=\"line\">            <span class=\"comment\">#playground相关配置，会导致'GCDAsyncSocket.h' file not found</span></span><br><span class=\"line\">            target.build_configurations.each <span class=\"keyword\">do</span> |config|</span><br><span class=\"line\">                config.build_settings[<span class=\"string\">'CONFIGURATION_BUILD_DIR'</span>] = <span class=\"string\">'$PODS_CONFIGURATION_BUILD_DIR'</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">#Use Legacy Swift Language Version” (SWIFT_VERSION):</span></span><br><span class=\"line\">                <span class=\"comment\">#   https://github.com/CocoaPods/CocoaPods/issues/5864#issuecomment-247109685</span></span><br><span class=\"line\">                puts <span class=\"string\">\"SWIFT_VERSIION:\"</span></span><br><span class=\"line\">                config.build_settings[<span class=\"string\">'SWIFT_VERSION'</span>] = <span class=\"string\">\"3.0.1\"</span></span><br><span class=\"line\">                puts config.build_settings[<span class=\"string\">'SWIFT_VERSION'</span>]</span><br><span class=\"line\">            end</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"comment\">#输出操作</span></span><br><span class=\"line\">            puts <span class=\"string\">\"以下不能在playground中使用的库名：\"</span></span><br><span class=\"line\">            puts target.name</span><br><span class=\"line\">        end</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Playground沙盒Resources\"><a href=\"#Playground沙盒Resources\" class=\"headerlink\" title=\"Playground沙盒Resources\"></a>Playground沙盒Resources</h2><p>Playgrounds 有两个与相关的Resources关联起来：一个是每一个独立的 playground 本地的，另一个则是 playground 之间共享的。在你的实验过程中，Playgrounds 能够支持 XML，JSON 数据，XIB，和图像文件。这也增加了其使用可用性。</p>\n<h2 id=\"本地-bundle访问本地资源\"><a href=\"#本地-bundle访问本地资源\" class=\"headerlink\" title=\"本地 bundle访问本地资源\"></a>本地 bundle访问本地资源</h2><p>Resources 文件夹, 与 Sources 文件夹一样在 Playground 的包路径中, 通过 Project Navigator 就可见了——只需要简单的拖拽图像和数据文件，就可以在 Playground 中使用了。对应的内容在 main bundle 中也是可见的。比如，我们可以像这样非常快捷的加载一个包含天气数据的 JSON 文件：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> jsonPath = <span class=\"type\">NSBundle</span>.mainBundle().bundlePath.stringByAppendingPathComponent(<span class=\"string\">\"weather.json\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span></span><br><span class=\"line\">jsonData = <span class=\"type\">NSData</span>(contentsOfFile: jsonPath),</span><br><span class=\"line\">json = <span class=\"type\">NSJSONSerialization</span>.<span class=\"type\">JSONObjectWithData</span>(jsonData, options: <span class=\"literal\">nil</span>, error: <span class=\"literal\">nil</span>) <span class=\"keyword\">as</span>? [<span class=\"type\">String</span>: <span class=\"type\">AnyObject</span>] </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"共享-访问Documents共享目录\"><a href=\"#共享-访问Documents共享目录\" class=\"headerlink\" title=\"共享 访问Documents共享目录\"></a>共享 访问Documents共享目录</h2><p>“共享 Playground 数据”的内容在你的”Documents”文件夹路径下，也同样对于你创建的任何 Playground 都可见。我们通过XCPSharedDataDirectoryPath常量来访问该共享文件夹。</p>\n<p>如果你自习想尝试，需要在 “~/Documents/Shared Playground Data” 下简历一个文件夹。 这里我们尝试载入一个名字叫做 “image.png” 的图片文件:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sharedImagePath = <span class=\"type\">XCPSharedDataDirectoryPath</span>.stringByAppendingPathComponent(<span class=\"string\">\"image.png\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> image = <span class=\"type\">UIImage</span>(contentsOfFile: sharedImagePath) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"PlaygroundSupport\"><a href=\"#PlaygroundSupport\" class=\"headerlink\" title=\"PlaygroundSupport\"></a>PlaygroundSupport</h2><h3 id=\"liveView视图代理\"><a href=\"#liveView视图代理\" class=\"headerlink\" title=\"liveView视图代理\"></a>liveView视图代理</h3><p>实现在playground中实现UI显示及交互操作<br>liveView定义：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> liveView: <span class=\"type\">XCPlaygroundLiveViewable</span>?</span><br></pre></td></tr></table></figure><br>遵循了<code>XCPlaygroundLiveViewable</code>协议即可在playground中可视化显示：</p>\n<ol>\n<li>在iOS 和 tvOS中<code>UIView</code> and <code>UIViewController</code>遵循该协议</li>\n<li>在OS X中<code>NSView</code> and <code>NSViewController</code>遵循该协议</li>\n<li>用户自定类型，须遵守XCPlaygroundLiveViewable协议<br>总之，只要遵守改协议并实现代理方法，都可以在playground中可视化显示。<br>用法：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.liveView = <span class=\"type\">UIView</span>()／<span class=\"type\">NSViewController</span>()</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"捕获值（XCPCaptureValue在XCPlayground中过时）\"><a href=\"#捕获值（XCPCaptureValue在XCPlayground中过时）\" class=\"headerlink\" title=\"捕获值（XCPCaptureValue在XCPlayground中过时）\"></a>捕获值（XCPCaptureValue在XCPlayground中过时）</h3><p><a href=\"http://swifter.tips/playground-capture/\" target=\"_blank\" rel=\"noopener\">冒泡排序可视化预览</a><br><figure class=\"highlight swift\"><figcaption><span>XCPlayground Module</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// This function has been deprecated.</span></span><br><span class=\"line\"><span class=\"meta\">@available</span>(*, deprecated)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">XCPCaptureValue</span>&lt;T&gt;<span class=\"params\">(identifier: String, value: T)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>简介：可以多次调用该方法来做图，相同的 identifier 的数据将会出现在同一张图上，而 value 将根据输入的次序进行排列,将一组数据轻而易举地绘制到时间轴上，从而让我们能看到每一步的结果。这不仅对我们直观且及时地了解算法内部的变化很有帮助，也会是教学或者演示时候的神兵利器。</p>\n<ol>\n<li>使用：导入框架<code>import XCPlayground</code></li>\n<li>扩展：XCPCaptureValue 的数据输入是任意类型的，所以不论是传什么进去都是可以表示的。它们将以 QuickLook 预览的方式被表现出来，一些像 UIImage，UIColor 或者 UIBezierPath 这样的类型已经实现了 QuickLook。当然对于那些没有实现快速预览的 NSObject 子类，也可以通过重写</li>\n</ol>\n<p>一个 Playground 通常立即显示简单表达式的结果。数组，字符串，数字等等，会在结果面板把计算后的结果显示出来。那么，随着时间改变的值是如何处理的呢？</p>\n<p>通过使用 XCPCaptureValue() 函数，我们可以随着一系列的迭代建立一个变动值的图。回到我们上面提到的天气例子，让我们来看看按小时计的温度数据，使用 XCPCaptureValue 来在辅助编辑界面以时间线的方式显示 温度的值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> XCPlayground</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> forecast <span class=\"keyword\">in</span> forecasts </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> tempString = forecast[<span class=\"string\">\"temp\"</span>]?[<span class=\"string\">\"english\"</span>] <span class=\"keyword\">as</span>? <span class=\"type\">String</span>, temperature = tempString.toInt()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">XCPCaptureValue</span>(<span class=\"string\">\"Temperature\"</span>, temperature)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另一种可选的方式是, 选择 Editor → Show Result For Current Line 就会捕获当前线的数值并且直接以图表的形势显示在 Playground 流中：</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcplayground-capture.png?imageMogr2/2/w/800\">\n<h3 id=\"异步执行（Asynchronous-Execution）\"><a href=\"#异步执行（Asynchronous-Execution）\" class=\"headerlink\" title=\"异步执行（Asynchronous Execution）\"></a>异步执行（Asynchronous Execution）</h3><p>不同于大部分 Swift 代码，是作为框架或者应用的一部分，Playgrounds 被当做是 高级代码。Playground 中的高级代码是按照指令接着指令的顺序从上到下执行的。<br>这种无容器风格的代码执行提供了立即反馈，但是存在着一个问题：在执行到了 Playground 底部后，会立即停止。网络请求，计时器，以及长时间运行的后台队列都会在提供反馈成功或者失败之前被立即终止。<br><code>PlaygroundSupport</code> 模块包含一个能够延长该过程的函数：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> needsIndefiniteExecution: <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>开启异步：默认值为<code>false</code>,当使用liveView代理时，会自动设置为<code>true</code>。当为<code>true</code>时，在高级代码执行完成后，会告诉Xcode继续运行Playground页面。为<code>false</code>时，当代码执行完直接终止。</li>\n<li>手动终止：还可以使用<code>PlaygroundPage.finishExecution()</code>手动终止正在运行的Playground。</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> PlaygroundSupport</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.needsIndefiniteExecution = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> url = <span class=\"type\">NSURL</span>(string: <span class=\"string\">\"http://httpbin.org/image/png\"</span>)!</span><br><span class=\"line\"><span class=\"keyword\">let</span> task = <span class=\"type\">NSURLSession</span>.sharedSession().dataTaskWithURL(url) &#123;</span><br><span class=\"line\">    data, <span class=\"number\">_</span>, <span class=\"number\">_</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> image = <span class=\"type\">UIImage</span>(data: data)</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//手动终止</span></span><br><span class=\"line\">        <span class=\"type\">PlaygroundPage</span>.current.currentPage.finishExecution()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">task.resume()</span><br></pre></td></tr></table></figure>\n<h2 id=\"支持Markdown格式的文档\"><a href=\"#支持Markdown格式的文档\" class=\"headerlink\" title=\"支持Markdown格式的文档\"></a>支持Markdown格式的文档</h2><p><a href=\"https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>除了实验用途，Playgrounds 在展示 Swift 语言的工具和框架中也一样强大。特别文档部分可以作为丰富格式的方式展示出来，以提供对于代码的清晰解释从而展示某个技术或者正确使用某个 Library 的方式。</p>\n<p>不同于<a href=\"http://nshipster.cn/swift-documentation/\" target=\"_blank\" rel=\"noopener\">Swift代码中的注释文档语法</a>, <code>Swift Playgrounds</code> 使用 <code>Markdown</code> 来显示多格式的文档。<br>例如：<br><code>//:</code>：可以指定单行文本说明<br><code>/*: Markdown格式内容... */</code>：可以用<code>Markdown</code>格式来显示丰富的文档内容</p>\n<p><code>xcode</code>切换备注以<code>Markdown</code>格式显示：</p>\n<ol>\n<li>选择<code>Editor → Show Rendered Markup</code> 菜单</li>\n<li>在 <code>File Inspector (⌘⌥1)</code> 选中 <code>Render Documentation</code> 复选框。<blockquote>\n<p>在xcode8中打开之前版本时，菜单上的<code>Show Rendered Markup</code>会显示为<code>Upgrade playgound...</code>升级菜单项，这样就需要先点击升级菜单项之后，才能激活上述（1）（2）设置项。</p>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//: This line will have **bold** and *italic* text.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*:</span></span><br><span class=\"line\"><span class=\"comment\">## Headers of All Sizes</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">### Lists of Links</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">- [NSHipster](http://nshipster.com)</span></span><br><span class=\"line\"><span class=\"comment\">- [ASCIIwwdc](http://asciiwwdc.com)</span></span><br><span class=\"line\"><span class=\"comment\">- [SwiftDoc](http://swiftdoc.org)</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">### Images, Too</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">![Remote Image](http://nshipster.s3.amazonaws.com/alert.gif)</span></span><br><span class=\"line\"><span class=\"comment\">![Local Image](bomb.gif) </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*Images in the Resources directory can be referenced locally*</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcplayground-documentation.png?imageMogr2/2/w/800\">\n<p>Playgrounds 提供了一个我们关于分享和学习 OS X 和 iOS 相关工具的方式的重大改变。Playground 可以展示每一个特性，并且为将来的用户探索和发现你创建的库提供了空间。丢掉你的静态README.md， 换成可互动的README.playground吧，再玩起来！</p>\n","raw":null,"categories":[{"name":"swift","path":"api/categories/swift.json"},{"name":"playground","path":"api/categories/playground.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"测试","path":"api/tags/测试.json"}]},{"title":"使用Cocoapods创建私有podspec","slug":"工具/使用Cocoapods创建私有podspec","date":"2017-02-28T15:46:16.000Z","updated":"2018-06-21T21:43:37.000Z","comments":true,"path":"api/articles/工具/使用Cocoapods创建私有podspec.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/repo目录.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"创建一个版本库来托管pod索引-pod-repo-add命令\"><a href=\"#创建一个版本库来托管pod索引-pod-repo-add命令\" class=\"headerlink\" title=\"创建一个版本库来托管pod索引:pod repo add命令\"></a>创建一个版本库来托管pod索引:pod repo add命令</h2><p>第一步：在github登录个人账号，创建一个库作为pod索引托管库。也可根据具体情况可以选择：<code>github</code>、<code>CODING</code>、<code>开源中国</code>、<code>Bitbucket</code>以及<code>CSDN</code>等，代码托管平台。<br>当索引库托管在github私有的仓库时，如果有其他同事共同开发维护，则需要配置Git仓库的权限。<br>第二步：pod化版本库，使其专门用户管理个人的<code>*podspec</code>索引文件<br><figure class=\"highlight ruby\"><figcaption><span>repo add命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># pod repo add [Private Repo Name] [GitHub HTTPS clone URL]</span></span><br><span class=\"line\">$ pod repo add PodRepo <span class=\"symbol\">https:</span>/<span class=\"regexp\">/github.com/huos</span>3203/PodRepo.git</span><br><span class=\"line\"><span class=\"comment\">#输出：</span></span><br><span class=\"line\">&gt; Cloning spec repo <span class=\"string\">`PodRepo`</span> from <span class=\"string\">`https://github.com/huos3203/PodRepo.git`</span></span><br></pre></td></tr></table></figure><br>此时在本地会生成<code>~/.cocoapods/repos/PodRepo</code>目录，这个目录就可以用来存储你所有的开源包。<br>每当一个或多个<code>*.podspec</code>文件测试无误时，就可以使用<code>pod repo push</code>命令向私有索引库中提交该文件。<br><figure class=\"highlight ruby\"><figcaption><span>lib create命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod repo push PodRepo LogSwift.podspec  <span class=\"comment\">#PodRepo是本地Repo名字 后面是podspec名字</span></span><br></pre></td></tr></table></figure><br>完成之后这个组件库就添加到私有索引库中，自动生成的<code>pod 库</code>标准结构：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/repo目录.png?imageMogr2/2/w/800\"><br>同时<code>push命令</code>会将新增的索引目录推送至自己的远程仓库中，即索引托管库<code>PodRepo.git</code>中。</p>\n<p>下面详述<code>podspec文件</code>的配置，检测，使用的过程。</p>\n<h2 id=\"使用模板命令创建Pod工程项目-lib-create\"><a href=\"#使用模板命令创建Pod工程项目-lib-create\" class=\"headerlink\" title=\"使用模板命令创建Pod工程项目 lib create\"></a>使用模板命令创建Pod工程项目 lib create</h2><p>初始化Pod模板项目：<br><figure class=\"highlight ruby\"><figcaption><span>lib create命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod lib create LogSwift</span><br></pre></td></tr></table></figure><br>有以下五步命令行交互：<br><figure class=\"highlight ruby\"><figcaption><span>交互</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">What is your email?</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">What language <span class=\"keyword\">do</span> you want to use?? [ Swift / ObjC ]</span><br><span class=\"line\">&gt;Swift</span><br><span class=\"line\">Would you like to <span class=\"keyword\">include</span> a demo application with your library? [ Yes / No ]</span><br><span class=\"line\">&gt;Yes</span><br><span class=\"line\">Which testing frameworks will you use? [ Quick / None ]</span><br><span class=\"line\">&gt;Quick</span><br><span class=\"line\">Would you like to <span class=\"keyword\">do</span> view based testing? [ Yes / No ]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure><br>会自动执行<code>pod install</code>命令创建项目并生成依赖。</p>\n<h3 id=\"添加库文件和资源\"><a href=\"#添加库文件和资源\" class=\"headerlink\" title=\"添加库文件和资源\"></a>添加库文件和资源</h3><p>例如：把一个网络模块的共有组件放入<code>Pod/Classes</code>中，然后进入<code>Example</code>文件夹执行<code>pod update</code>命令，再打开项目工程可以看到，刚刚添加的组件已经在<code>Pods</code>子工程下<code>Development Pods/PodTestLibrary</code>中了，然后编辑demo工程，测试组件。<br>测试无误后需要将该项目添加并推送到远端仓库，并编辑podspec文件。</p>\n<h3 id=\"配置podspec文件及验证命令lib-lint\"><a href=\"#配置podspec文件及验证命令lib-lint\" class=\"headerlink\" title=\"配置podspec文件及验证命令lib lint\"></a>配置podspec文件及验证命令lib lint</h3><h4 id=\"打tag号作为podspec版本号\"><a href=\"#打tag号作为podspec版本号\" class=\"headerlink\" title=\"打tag号作为podspec版本号\"></a>打tag号作为podspec版本号</h4><p>因为<code>podspec文件</code>中获取<code>Git版本控制</code>的项目还需要<code>tag号</code>，所以我们要打上一个<code>tag</code><br><figure class=\"highlight ruby\"><figcaption><span>打标签</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -m <span class=\"string\">\"first release\"</span> <span class=\"number\">0</span>.<span class=\"number\">1.0</span></span><br><span class=\"line\">$ git push --tags     <span class=\"comment\">#推送tag到远端仓库</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"编辑podspec文件\"><a href=\"#编辑podspec文件\" class=\"headerlink\" title=\"编辑podspec文件\"></a>编辑podspec文件</h4><p><code>podspec文件</code>是一个Ruby格式：<br><figure class=\"highlight ruby\"><figcaption><span>podspec文件</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pod::Spec.new <span class=\"keyword\">do</span> <span class=\"params\">|s|</span></span><br><span class=\"line\">s.name             = <span class=\"string\">\"PodTestLibrary\"</span>    <span class=\"comment\">#名称</span></span><br><span class=\"line\">s.version          = <span class=\"string\">\"0.1.0\"</span>             <span class=\"comment\">#版本号</span></span><br><span class=\"line\">s.summary          = <span class=\"string\">\"Just Testing.\"</span>     <span class=\"comment\">#简短介绍，下面是详细介绍</span></span><br><span class=\"line\">s.description      = <span class=\"string\">&lt;&lt;-DESC</span></span><br><span class=\"line\"><span class=\"string\">Testing Private Podspec.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* Markdown format.</span></span><br><span class=\"line\"><span class=\"string\">* Don't worry about the indent, we strip it!</span></span><br><span class=\"line\"><span class=\"string\">DESC</span></span><br><span class=\"line\">s.homepage         = <span class=\"string\">\"https://coding.net/u/boyers/p/podTestLibrary\"</span>                           <span class=\"comment\">#主页,这里要填写可以访问到的地址，不然验证不通过</span></span><br><span class=\"line\"><span class=\"comment\"># s.screenshots     = \"www.example.com/screenshots_1\", \"www.example.com/screenshots_2\"           #截图</span></span><br><span class=\"line\">s.license          = <span class=\"string\">'MIT'</span>              <span class=\"comment\">#开源协议</span></span><br><span class=\"line\">s.author           = &#123; <span class=\"string\">\"boyers\"</span> =&gt; <span class=\"string\">\"boyers@foxmail.com\"</span> &#125;  <span class=\"comment\">#作者信息</span></span><br><span class=\"line\">s.source           = &#123; <span class=\"symbol\">:git</span> =&gt; <span class=\"string\">\"https://coding.net/boyers/podTestLibrary.git\"</span>, <span class=\"symbol\">:tag</span> =&gt; <span class=\"string\">\"0.1.0\"</span> &#125;      <span class=\"comment\">#项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS</span></span><br><span class=\"line\"><span class=\"comment\"># s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;'                       #多媒体介绍地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.platform     = <span class=\"symbol\">:ios</span>, <span class=\"string\">'7.0'</span>            <span class=\"comment\">#支持的平台及版本</span></span><br><span class=\"line\">s.requires_arc = <span class=\"literal\">true</span>                   <span class=\"comment\">#是否使用ARC，如果指定具体文件，则具体的问题使用ARC</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.source_files = <span class=\"string\">'Pod/Classes/**/*'</span>     <span class=\"comment\">#代码源文件地址，**/*表示Classes目录及其子目录下所有文件，如果有多个目录下则用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置</span></span><br><span class=\"line\">s.resource_bundles = &#123;</span><br><span class=\"line\"><span class=\"string\">'PodTestLibrary'</span> =&gt; [<span class=\"string\">'Pod/Assets/*.png'</span>]</span><br><span class=\"line\">&#125;                                       <span class=\"comment\">#资源文件地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.public_header_files = <span class=\"string\">'Pod/Classes/**/*.h'</span>   <span class=\"comment\">#公开头文件地址</span></span><br><span class=\"line\">s.frameworks = <span class=\"string\">'UIKit'</span>                  <span class=\"comment\">#所需的framework，多个用逗号隔开</span></span><br><span class=\"line\">s.dependency <span class=\"string\">'AFNetworking'</span>, <span class=\"string\">'~&gt; 2.3'</span>   <span class=\"comment\">#依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependency</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"验证podspec文件可用性\"><a href=\"#验证podspec文件可用性\" class=\"headerlink\" title=\"验证podspec文件可用性\"></a>验证podspec文件可用性</h4><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod lib lint</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">-&gt; PodTestLibrary (<span class=\"number\">0</span>.<span class=\"number\">1.0</span>)</span><br><span class=\"line\">PodTestLibrary passed validation.</span><br></pre></td></tr></table></figure>\n<p>说明验证通过了，不过这只是这个<code>podspec文件</code>是合格的，不一定说明这个Pod是可以用的，Pod需要在本地做一下验证。</p>\n<h3 id=\"将源码托管到远程仓库\"><a href=\"#将源码托管到远程仓库\" class=\"headerlink\" title=\"将源码托管到远程仓库\"></a>将源码托管到远程仓库</h3><p>通过<code>Cocoapods</code>创建出来的目录本身就在本地的<code>Git</code>管理下，我们需要做的就是给它添加远端仓库，同样去<code>GitHub</code>或其他的Git服务提供商那里创建一个<code>私有的仓库</code>，拿到<code>SSH地址</code>，然后<code>cd</code>到<code>LogSwift</code>目录<br><figure class=\"highlight ruby\"><figcaption><span>添加到远程仓库</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -s -m <span class=\"string\">\"Initial Commit of Library\"</span></span><br><span class=\"line\">$ git remote add origin <span class=\"symbol\">https:</span>/<span class=\"regexp\">/coding.net/git</span><span class=\"regexp\">/LogSwift.git   #添加远端仓库</span></span><br><span class=\"line\"><span class=\"regexp\">$ git push origin master        #提交到远端仓库</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"手动配置Pod私库项目支持：spec-create\"><a href=\"#手动配置Pod私库项目支持：spec-create\" class=\"headerlink\" title=\"手动配置Pod私库项目支持：spec create\"></a>手动配置Pod私库项目支持：spec create</h2><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod spec create LogSwift git@coding.<span class=\"symbol\">net:</span>boyers/LogSwift.git</span><br></pre></td></tr></table></figure>\n<p>执行完之后，就创建了一个<code>podspec文件</code>，他其中会包含很多内容，可以按照我之前介绍的进行编辑，没用的删掉。编辑完成之后使用验证命令<code>pod lib lint</code>验证一下。</p>\n<h2 id=\"path-gt-在新项目配置检测podspec文件\"><a href=\"#path-gt-在新项目配置检测podspec文件\" class=\"headerlink\" title=\":path =&gt; 在新项目配置检测podspec文件\"></a>:path =&gt; 在新项目配置检测podspec文件</h2><p>在这个项目的<code>Podfile</code>文件中直接指定刚才创建编辑好的<code>podspec文件</code>，看是否可用。</p>\n<ol>\n<li>指定本地依赖的两种方式:<figure class=\"highlight ruby\"><figcaption><span>Podfile</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">platform <span class=\"symbol\">:ios</span>, <span class=\"string\">'7.0'</span></span><br><span class=\"line\">pod <span class=\"string\">'LogSwift'</span>, <span class=\"symbol\">:path</span> =&gt; <span class=\"string\">'~/code/Cocoapods/podTest/LogSwift'</span>      <span class=\"comment\"># 指定路径</span></span><br><span class=\"line\">pod <span class=\"string\">'LogSwift'</span>, <span class=\"symbol\">:podspec</span> =&gt; <span class=\"string\">'~/code/Cocoapods/podTest/LogSwift/LogSwift.podspec'</span>  <span class=\"comment\"># 指定podspec文件</span></span><br></pre></td></tr></table></figure></li>\n<li>指定源码的远程仓库作为依赖<br>前提时索引文件中指定的tag版本的源码必须推送到远程仓库<figure class=\"highlight ruby\"><figcaption><span>Podfile</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">platform <span class=\"symbol\">:ios</span>, <span class=\"string\">'7.0'</span></span><br><span class=\"line\">pod <span class=\"string\">'MusicLrc'</span>, <span class=\"symbol\">:git</span> =&gt; <span class=\"string\">'https://github.com/huos3203/MusicLrcTest.git'</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>然后执行<code>pod install</code>命令安装依赖，打开项目工程，可以看到<code>库文件</code>和<code>资源</code>都被加载到<code>Pods子项目</code>中了，不过它们并没有在<code>Pods目录</code>下，而是跟测试项目一样存在于<code>Development Pods/LogSwift</code>中，这是因为我们是在本地测试，而没有把<code>podspec文件</code>添加到<code>Spec Repo</code>中的缘故。</p>\n<h2 id=\"万事具备，向私有索引库中提交podspec文件：repo-push\"><a href=\"#万事具备，向私有索引库中提交podspec文件：repo-push\" class=\"headerlink\" title=\"万事具备，向私有索引库中提交podspec文件：repo push\"></a>万事具备，向私有索引库中提交podspec文件：repo push</h2><p>每当一个或多个<code>*.podspec</code>文件测试无误时，就可以使用<code>pod repo push</code>命令向私有索引库中提交该文件。<br><figure class=\"highlight ruby\"><figcaption><span>lib create命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod repo push PodRepo LogSwift.podspec  <span class=\"comment\">#PodRepo是本地Repo名字 后面是podspec名字</span></span><br></pre></td></tr></table></figure><br>完成之后这个组件库就添加到私有索引库中，自动生成的<code>pod 库</code>标准结构：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/repo目录.png?imageMogr2/2/w/800\"><br>同时<code>push命令</code>会将新增的索引目录推送至自己的远程仓库中，即索引托管库<code>PodRepo.git</code>中。</p>\n<h2 id=\"trunk-push-添加到Cocoapods的官方索引库\"><a href=\"#trunk-push-添加到Cocoapods的官方索引库\" class=\"headerlink\" title=\"trunk push 添加到Cocoapods的官方索引库\"></a>trunk push 添加到Cocoapods的官方索引库</h2><h3 id=\"注册trunk，邮箱验证\"><a href=\"#注册trunk，邮箱验证\" class=\"headerlink\" title=\"注册trunk，邮箱验证\"></a>注册trunk，邮箱验证</h3><p>在注册trunk之前，我们需要确认当前的CocoaPods版本是否足够新:<br>sudo gem install cocoapods<br>开始注册trunk：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod trunk register boyer@163.com <span class=\"string\">'boyers1250'</span>  --verbose</span><br></pre></td></tr></table></figure><br><code>-verbose</code>参数是为了便于输出注册过程中的调试信息。<br>执行上面的语句后，你的邮箱将会受到一封带有验证链接的邮件，如果没有请去垃圾箱找找，有可能被屏蔽了。点击邮件的链接就完成了trunk注册流程。<br>使用下面的命令可以向trunk服务器查询自己的注册信息：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod trunk me</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"通过trunk推送podspec文件\"><a href=\"#通过trunk推送podspec文件\" class=\"headerlink\" title=\"通过trunk推送podspec文件\"></a>通过trunk推送podspec文件</h3><p>现在我们已经有了自己的podspec文件，但是在推送podspec文件之前你需要确认以下几点：</p>\n<ol>\n<li>确保你的源码已经push到Github上。</li>\n<li>确保你所push的代码已经打上”version tag”版本号标签：<br>只有确保了以上两点，CocoaPods才能更准确地找到你的repo。<br>现在我们开始通过trunk上传你的podspec文件。先cd到podspec文件所在目录，执行：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod trunk push WZLBadge.podspec</span><br></pre></td></tr></table></figure>\n执行上面的push操作，就相当于你把你的源代码提交给CocoaPods团队审核了，CocoaPods审核只需要几秒钟或者几分钟就可以完成。</li>\n</ol>\n<h2 id=\"使用远程的私有Pod库\"><a href=\"#使用远程的私有Pod库\" class=\"headerlink\" title=\"使用远程的私有Pod库\"></a>使用远程的私有Pod库</h2><p>我们的这个组件库就已经制作添加完成了，现在可以<code>pod search</code>命令查到这个库，当使用时配置Podfile依赖文件即可。</p>\n<ol>\n<li>pod search 查找库<figure class=\"highlight ruby\"><figcaption><span>查找库</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod search PodTestLibrary</span><br><span class=\"line\"></span><br><span class=\"line\">-&gt; PodTestLibrary (<span class=\"number\">0</span>.<span class=\"number\">1.0</span>)</span><br><span class=\"line\">Just Testing.</span><br><span class=\"line\">pod <span class=\"string\">'PodTestLibrary'</span>, <span class=\"string\">'~&gt; 0.1.0'</span></span><br><span class=\"line\">- <span class=\"symbol\">Homepage:</span> <span class=\"symbol\">https:</span>/<span class=\"regexp\">/coding.net/u</span><span class=\"regexp\">/boyers/p</span><span class=\"regexp\">/podTestLibrary</span></span><br><span class=\"line\"><span class=\"regexp\">- Source:   https:/</span><span class=\"regexp\">/coding.net/boyers</span><span class=\"regexp\">/podTestLibrary.git</span></span><br><span class=\"line\"><span class=\"regexp\">- Versions: 0.1.0 [WTSpecs repo]</span></span><br></pre></td></tr></table></figure></li>\n<li>在Podfile文件中配置库依赖<figure class=\"highlight ruby\"><figcaption><span>配置库依赖</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod <span class=\"string\">'PodTestLibrary'</span>, <span class=\"string\">'~&gt; 0.1.0'</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"更新维护podspec文件配置，升级库版本\"><a href=\"#更新维护podspec文件配置，升级库版本\" class=\"headerlink\" title=\"更新维护podspec文件配置，升级库版本\"></a>更新维护podspec文件配置，升级库版本</h2><p><code>subspec</code>特性，可以在库原有基础上，添加更多的模块，相应创建了多个子目录。现在尝试添加包括<code>工具类</code>，底层<code>Model</code>及<code>UIKit</code>扩展等。</p>\n<h3 id=\"添加模块库文件和资源\"><a href=\"#添加模块库文件和资源\" class=\"headerlink\" title=\"添加模块库文件和资源\"></a>添加模块库文件和资源</h3><p>具体做法是先将源文件添加到<code>Pod/Classes</code>中，然后按照不同的模块对文件目录进行整理，因为我有四个模块，所以在<code>Pod/Classes</code>下有创建了四个子目录</p>\n<h3 id=\"打tag号作为podspec版本号-1\"><a href=\"#打tag号作为podspec版本号-1\" class=\"headerlink\" title=\"打tag号作为podspec版本号\"></a>打tag号作为podspec版本号</h3><p>因为<code>podspec文件</code>中获取<code>Git版本控制</code>的项目还需要<code>tag号</code>，所以我们要打上一个<code>tag</code><br><figure class=\"highlight ruby\"><figcaption><span>打标签</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -m <span class=\"string\">\"first release\"</span> <span class=\"number\">0</span>.<span class=\"number\">1.0</span></span><br><span class=\"line\">$ git push --tags     <span class=\"comment\">#推送tag到远端仓库</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"更新podspec配置文件\"><a href=\"#更新podspec配置文件\" class=\"headerlink\" title=\"更新podspec配置文件\"></a>更新podspec配置文件</h3><p>当创建了<code>subspec</code>，之前项目整体的依赖<code>dependency</code>:</p>\n<ol>\n<li>源文件:<code>source_files</code></li>\n<li>头文件:<code>public_header_files</code></li>\n<li>资源文件:<code>resource</code><br>都移动到了各自的<code>subspec</code>中，每个<code>subspec</code>之间也可以有相互的依赖关系，比如<code>UIKitAdditio</code>n就依赖于<code>CommonTools</code>。<figure class=\"highlight ruby\"><figcaption><span>更新podspec配置文件</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pod::Spec.new <span class=\"keyword\">do</span> <span class=\"params\">|s|</span></span><br><span class=\"line\">s.name             = <span class=\"string\">\"PodTestLibrary\"</span></span><br><span class=\"line\">s.version          = <span class=\"string\">\"1.0.0\"</span></span><br><span class=\"line\">s.summary          = <span class=\"string\">\"Just Testing.\"</span></span><br><span class=\"line\">s.description      = <span class=\"string\">&lt;&lt;-DESC</span></span><br><span class=\"line\"><span class=\"string\">                         Testing Private Podspec.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">                        * Markdown format.</span></span><br><span class=\"line\"><span class=\"string\">                        * Don't worry about the indent, we strip it!</span></span><br><span class=\"line\"><span class=\"string\">                    DESC</span></span><br><span class=\"line\">s.homepage         = <span class=\"string\">\"https://coding.net/u/boyers/p/podTestLibrary\"</span></span><br><span class=\"line\"><span class=\"comment\"># s.screenshots     = \"www.example.com/screenshots_1\", \"www.example.com/screenshots_2\"</span></span><br><span class=\"line\">s.license          = <span class=\"string\">'MIT'</span></span><br><span class=\"line\">s.author           = &#123; <span class=\"string\">\"boyers\"</span> =&gt; <span class=\"string\">\"boyers@foxmail.com\"</span> &#125;</span><br><span class=\"line\">s.source           = &#123; <span class=\"symbol\">:git</span> =&gt; <span class=\"string\">\"https://coding.net/boyers/podTestLibrary.git\"</span>, <span class=\"symbol\">:tag</span> =&gt; <span class=\"string\">\"1.0.0\"</span> &#125;</span><br><span class=\"line\"><span class=\"comment\"># s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;'</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.platform     = <span class=\"symbol\">:ios</span>, <span class=\"string\">'7.0'</span></span><br><span class=\"line\">s.requires_arc = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#s.source_files = 'Pod/Classes/**/*'</span></span><br><span class=\"line\"><span class=\"comment\">#s.resource_bundles = &#123; 'PodTestLibrary' =&gt; ['Pod/Assets/*.png'] &#125;</span></span><br><span class=\"line\"><span class=\"comment\">#s.public_header_files = 'Pod/Classes/**/*.h'</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.subspec <span class=\"string\">'NetWorkEngine'</span> <span class=\"keyword\">do</span> <span class=\"params\">|networkEngine|</span></span><br><span class=\"line\">    networkEngine.source_files = <span class=\"string\">'Pod/Classes/NetworkEngine/**/*'</span></span><br><span class=\"line\">    networkEngine.public_header_files = <span class=\"string\">'Pod/Classes/NetworkEngine/**/*.h'</span></span><br><span class=\"line\">    networkEngine.dependency <span class=\"string\">'AFNetworking'</span>, <span class=\"string\">'~&gt; 2.3'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.subspec <span class=\"string\">'DataModel'</span> <span class=\"keyword\">do</span> <span class=\"params\">|dataModel|</span></span><br><span class=\"line\">    dataModel.source_files = <span class=\"string\">'Pod/Classes/DataModel/**/*'</span></span><br><span class=\"line\">    dataModel.public_header_files = <span class=\"string\">'Pod/Classes/DataModel/**/*.h'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.subspec <span class=\"string\">'CommonTools'</span> <span class=\"keyword\">do</span> <span class=\"params\">|commonTools|</span></span><br><span class=\"line\">    commonTools.source_files = <span class=\"string\">'Pod/Classes/CommonTools/**/*'</span></span><br><span class=\"line\">    commonTools.public_header_files = <span class=\"string\">'Pod/Classes/CommonTools/**/*.h'</span></span><br><span class=\"line\">    commonTools.dependency <span class=\"string\">'OpenUDID'</span>, <span class=\"string\">'~&gt; 1.0.0'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.subspec <span class=\"string\">'UIKitAddition'</span> <span class=\"keyword\">do</span> <span class=\"params\">|ui|</span></span><br><span class=\"line\">    ui.source_files = <span class=\"string\">'Pod/Classes/UIKitAddition/**/*'</span></span><br><span class=\"line\">    ui.public_header_files = <span class=\"string\">'Pod/Classes/UIKitAddition/**/*.h'</span></span><br><span class=\"line\">    ui.resource = <span class=\"string\">\"Pod/Assets/MLSUIKitResource.bundle\"</span></span><br><span class=\"line\">    ui.dependency <span class=\"string\">'PodTestLibrary/CommonTools'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.frameworks = <span class=\"string\">'UIKit'</span></span><br><span class=\"line\">    <span class=\"comment\">#s.dependency 'AFNetworking', '~&gt; 2.3'</span></span><br><span class=\"line\">    <span class=\"comment\">#s.dependency 'OpenUDID', '~&gt; 1.0.0'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n编辑完成之后，在测试项目里<code>pod update</code>一下，几个子项目都被加进项目工程了，写代码验证无误之后，就可以将这个工程push到远端仓库，并打上新的<code>tag-&gt;1.0.0</code>。<blockquote>\n<p>但是如果你的代码版本号没变(podspec里的version自然也没变)就会提示push失败，即使你更改了podspec的其他地方，pod也会认为这两个文件是同一个。 我目前为止找不到trunk的相关update接口，所以只能顺水推舟，更新源代码版本号（如：1.1.1-&gt;1.1.2），重新push version tag，然后再执行pod trunk push操作。</p>\n</blockquote>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"工具","path":"api/categories/工具.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"pod","path":"api/tags/pod.json"},{"name":"私库","path":"api/tags/私库.json"}]},{"title":"UIStackView教程：了解Stack View","slug":"iOS/UIStackView教程了解StackView","date":"2017-02-24T18:12:14.000Z","updated":"2017-02-25T14:33:14.000Z","comments":true,"path":"api/articles/iOS/UIStackView教程了解StackView.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><a href=\"http://blog.csdn.net/kmyhy/article/details/50456444\" target=\"_blank\" rel=\"noopener\">原地址</a></p>\n<h2 id=\"UIStackView简单介绍\"><a href=\"#UIStackView简单介绍\" class=\"headerlink\" title=\"UIStackView简单介绍\"></a>UIStackView简单介绍</h2><p>一个Stack View能够将它所含的View以各种方式沿其轴向进行分布，同时也可以将View沿某个方向等距分布，要隐藏<code>Stack View</code>中的视图，你只需要设置该View的<code>Hidden</code>属性为<code>true</code>，剩下的工作Stack View会自己完成。。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0.png?imageMogr2/2/w/800\"><br>坐标（Axis）、间隔（Spacing）、对齐（Alignment）以及分布（Distribution ）等。<br>distribution属性：决定Stack View如何沿它轴向的水平方向摆放它的subview，当属性值是Fill，这表示subview会沿轴向完全占据Stack View。因此，Stack View会拉伸其中一个subview使其填充剩余空间，尤其是水平内容优先级最低的那个，如果所有subview优先级相同，则拉伸第一个subview。<br>Alignment属性：决定了Stack View如何沿它轴向的垂直方向摆放它的subview，对于一个垂直的Stack View，这个属性可以设置为Fill、Leading、Center和Trailing。<br>对于水平的Stack View，这个属性则稍有不同：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack006.png?imageMogr2/2/w/800\"><br>.Top取代了.Leading，.Bottom取代了.Trailing。此外，水平Stack View还多出了两个属性值：.FirstBaseLine和.LastBaseLine。<br>对于水平的Stack View，这个属性则稍有不同：<br>Fill:<br><img title=\"Fill\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack007.png?imageMogr2/2/w/800\"><br>Leading:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack008.png?imageMogr2/2/w/800\"><br>Center:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack009.png?imageMogr2/2/w/800\"><br>Trailing:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack000.png?imageMogr2/2/w/800\"></p>\n<p>布局方式对比<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack01.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"添加一个新的Stack-View\"><a href=\"#添加一个新的Stack-View\" class=\"headerlink\" title=\"添加一个新的Stack View\"></a>添加一个新的Stack View</h3><p>点击故事板画布左下角<code>Auto Layout工具栏</code>中的<code>Stack按钮</code>：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack3.png?imageMogr2/2/w/800\"><br>另一种解散的方法是选中Stack View，然后点击<code>Editor\\Emebed in\\stack view</code>菜单。</p>\n<h3 id=\"解散一个废弃的Stack-View\"><a href=\"#解散一个废弃的Stack-View\" class=\"headerlink\" title=\"解散一个废弃的Stack View\"></a>解散一个废弃的Stack View</h3><p>首先，选定想解散的Stack View。按下<code>Option键</code>，点击<code>Stack 按钮</code>。这将弹出一个上下文菜单，然后点击Unembed：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack001.png?imageMogr2/2/w/800\"><br>另一种解散的方法是选中Stack View，然后点击<code>Editor\\Unemebed</code>菜单。</p>\n<h2 id=\"使用场景描述\"><a href=\"#使用场景描述\" class=\"headerlink\" title=\"使用场景描述\"></a>使用场景描述</h2><p>当APP运行中增加或删除一个<code>view</code>时，需要重新调整邻近<code>view</code>的位置布局。<br>预见困境：</p>\n<ol>\n<li>在故事板中新建一些布局约束连接，以便能够安装或卸载其中的一些约束</li>\n<li>使用第三方库来实现</li>\n<li>根据任务复杂程度完全用代码实现<br>也许这个在视图附近的视图树中的所有View都不需要在运行时改变，但当你将新视图添加到故事板时，仍然要想方设法为它挤出空间来。</li>\n</ol>\n<p><code>UIStackView</code>提供了一个对多个视图进行水平或垂直布局的方法。通过对几个属性进行简单设置，比如对齐、分布和间距，可以让我们让其所包含的视图适应于其有效空间。</p>\n<h2 id=\"实现需求\"><a href=\"#实现需求\" class=\"headerlink\" title=\"实现需求\"></a>实现需求</h2><p>存在着这几方面的问题:</p>\n<h3 id=\"问题一：自适应横竖屏\"><a href=\"#问题一：自适应横竖屏\" class=\"headerlink\" title=\"问题一：自适应横竖屏\"></a>问题一：自适应横竖屏</h3><p>在横屏状态下（command+左箭头旋转为横屏），发现截图中的一排按钮位置无法适应屏幕宽度的变化。这时可以使用<code>UIStackView</code>来帮助实现自动适应横竖屏的效果。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/UIStackView.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"问题二：控件间留白不紧凑\"><a href=\"#问题二：控件间留白不紧凑\" class=\"headerlink\" title=\"问题二：控件间留白不紧凑\"></a>问题二：控件间留白不紧凑</h3><p>点击WEATHER旁边的Hide按钮。隐藏了下面的文本内容后，留下了一大块的空白区域。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/WEATHERhide.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"Storyboard引入界面\"><a href=\"#Storyboard引入界面\" class=\"headerlink\" title=\"Storyboard引入界面\"></a>Storyboard引入界面</h3><p>打开<code>Main.storyboard</code>，找到<code>Spot Info View Controller</code>这个Scene。将这些标签和按钮设为不同的背景色，是为了在运行时效果更直观。就是在故事板中，这也有助于看到<code>Stack View</code>属性的改变导致其内部视图的变化。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack1.png?imageMogr2/2/w/800\"><br>如果想在运行App时看见这些颜色，在<code>SpotInfoViewController</code>的<code>viewDidLoad()</code>方法中将下列语句注释：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 清空标签和按钮的背景色</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> view <span class=\"keyword\">in</span> backgroundColoredViews </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    view.backgroundColor = <span class=\"type\">UIColor</span>.clearColor()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Size类便于使用storyboard\"><a href=\"#Size类便于使用storyboard\" class=\"headerlink\" title=\"Size类便于使用storyboard\"></a>Size类便于使用storyboard</h3><p>在本案例中，故事板中Scene大小不是默认<code>600x600</code>，在这里Simulated Metrics下的Size属性被设置成iPhone 4-inch。Simulated Metrics属性在运行时并没有任何影响——不同设备上视图的大小仍然会自动改变。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/05-simulated-metrics-iphone-4-inch_639x173.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"创建水平UIStackView\"><a href=\"#创建水平UIStackView\" class=\"headerlink\" title=\"创建水平UIStackView\"></a>创建水平<code>UIStackView</code></h2><h3 id=\"按钮模块\"><a href=\"#按钮模块\" class=\"headerlink\" title=\"按钮模块\"></a>按钮模块</h3><ol>\n<li>选中按钮<br>用<code>Command+左键</code>同时选中<code>Spot Info View Controller</code>底下一排的所有按钮：<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack2.png?imageMogr2/2/w/800\"></li>\n<li>Stack按钮添加一个新的Stack View<br>点击故事板画布左下角<code>Auto Layout工具栏</code>中新增的<code>Stack按钮</code>：    </li>\n</ol>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/Stack按钮?imageMogr2/2/w/800\">\n<p>这些按钮被嵌到一个新的Stack View中：</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack4.png?imageMogr2/2/w/800\">\n<h4 id=\"给新的Stack-View添加布局约束\"><a href=\"#给新的Stack-View添加布局约束\" class=\"headerlink\" title=\"给新的Stack View添加布局约束\"></a>给新的Stack View添加布局约束</h4><p>要在故事板选取一个充满了子视图的Stack View还是比较难的，介绍两种选择技巧。<br>3.1 在<code>Outline视图</code>中选取Stack View</p>\n<img title=\"Outline视图\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack5.png?imageMogr2/2/w/800\">\n<p>3.2 Shift+右键调出View树<br>在Stack View 的任意地方按下<code>Shift+右键</code>或者<code>Control+Shift+左键</code>（如果你正在用触控板的话）。这时将弹出一个上下文菜单，列出了位于所点击的地方的View树，你可以在这个菜单中选择Stack View。</p>\n<img title=\"Shift+右键\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack6.png?imageMogr2/2/w/800\">\n<ol>\n<li>自动布局工具栏中的Pin按钮,添加一个约束<img title=\"自动布局工具栏中的Pin按钮\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack7.png?imageMogr2/2/w/800\">\n</li>\n</ol>\n<p>首先勾选Constrain to margins。然后在Stack View四周添加下列约束：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Top</span>: <span class=\"number\">20</span>, <span class=\"type\">Leading</span>: <span class=\"number\">0</span>, <span class=\"type\">Trailing</span>: <span class=\"number\">0</span>, <span class=\"type\">Bottom</span>: <span class=\"number\">0</span></span><br></pre></td></tr></table></figure><br>仔细检查top、leading、trailing、bottom中的数字并确保它们的I型柱都被选中。然后点击Add 4 Constraints：<br><img title=\"Add4Constraints\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack8.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"按钮等间距分布\"><a href=\"#按钮等间距分布\" class=\"headerlink\" title=\"按钮等间距分布\"></a>按钮等间距分布</h4><p>添加约束后，导致第一个按钮被拉伸：<br><img title=\"第一个按钮被拉伸填充所有剩余空间\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack9.png?imageMogr2/2/w/800\"></p>\n<h5 id=\"使用等宽约束的Spacer-View实现\"><a href=\"#使用等宽约束的Spacer-View实现\" class=\"headerlink\" title=\"使用等宽约束的Spacer View实现\"></a>使用等宽约束的<code>Spacer View</code>实现</h5><p>解决这个问题只能使用空白的View来分隔这些按钮，在按钮之间摆放上一些用于分隔空间的 Spacer View。所有的Spacer View都要添加等宽约束，以及许多额外的约束，才能将这些Spacer View布局正确。<br>这看起来如下图所示。为了直观起见，这些Spacer View的背景色设置成了浅灰色：<br><img title=\"SpacerView添加等宽约束实现\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack04.png?imageMogr2/2/w/800\"><br>如果要在运行时添加一个按钮或者隐藏/删除一个按钮时，要想调整这些Spacer View和约束就要命了。</p>\n<h5 id=\"Distribution属性：沿轴向水平分布\"><a href=\"#Distribution属性：沿轴向水平分布\" class=\"headerlink\" title=\"Distribution属性：沿轴向水平分布\"></a><code>Distribution</code>属性：沿轴向水平分布</h5><p>distribution属性：决定Stack View如何将它的subview沿轴向分布，当属性值是Fill，这表示subview会沿轴向完全占据Stack View。因此，Stack View会拉伸其中一个subview使其填充剩余空间，尤其是水平内容优先级最低的那个，如果所有subview优先级相同，则拉伸第一个subview。<br>打开Stack View属性面板。将<code>Distribution</code>属性由<code>Fill</code>修改为<code>Equal Spacing</code>：<br><img title=\"`Fill`修改为`Equal\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack02.png?imageMogr2/2/w/800\"><br>编译运行，点击某个单元格，旋转模拟器（⌘→）。你将看到最下一排按钮现在按照等间距排列了！<br><img title=\"`Distribution`属性值`Equal\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack03.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"Rating版块\"><a href=\"#Rating版块\" class=\"headerlink\" title=\"Rating版块\"></a>Rating版块</h3><p>选中RATING标签，以及旁边的显示为几个星形图标的标签：<br><img title=\"选中RATING标签\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack05.png?imageMogr2/2/w/800\"><br>然后点击Stack按钮将它们嵌到一个Stack View中：<br><img title=\"Stack按钮\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack3.png?imageMogr2/2/w/800\"><br><img title=\"RATING标签嵌到一个StackView中\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack06.png?imageMogr2/2/w/800\"><br>然后点击Pin按钮。勾选Constrain to margins，并添加如下约束：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Top</span>: <span class=\"number\">20</span>, <span class=\"type\">Leading</span>: <span class=\"number\">0</span>, <span class=\"type\">Bottom</span>: <span class=\"number\">20</span></span><br></pre></td></tr></table></figure><br><img title=\"添加约束\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack07.png?imageMogr2/2/w/800\"><br>打开属性面板，将间距设置为8：<br><img title=\"间距设置为8\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack08.png?imageMogr2/2/w/800\"><br>你可能会看到一个 Misplaced Views的布局约束警告，同时星星标签会显示将会被拉伸到视图之外：<br><img title=\"MisplacedViews的布局约束警告\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack09.png?imageMogr2/2/w/800\"><br>有时候Xcode会临时提示一些警告，或者显示Stack View的位置不正确，这些警告会在你添加其他约束后消失。你完全可以忽略这些警告。<br>要解决这个警告，我们可以修改一下Stack View的Frame然后又改回，或者临时修改它的一条布局约束。<br>让我们试一下。先将Alignment 属性从Fill修改为Top，然后又改回原来的Fill。你将看到这下星星标签显示正常了：<br><img title=\"布局约束警告消失\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack00.png?imageMogr2/2/w/800\"><br>编译运行，进行测试</p>\n<h2 id=\"创建垂直的Stack-View\"><a href=\"#创建垂直的Stack-View\" class=\"headerlink\" title=\"创建垂直的Stack View\"></a>创建垂直的Stack View</h2><p>Xcode会自动根据这两者的位置推断出这将是一个垂直的Stack View，Stack View没有添加任何约束时，会自动适应了两个标签中的最宽的一个的宽度。</p>\n<h3 id=\"WHY-VISIT模块\"><a href=\"#WHY-VISIT模块\" class=\"headerlink\" title=\"WHY VISIT模块\"></a>WHY VISIT模块</h3><p>选中WHY VISIT标签及下面的标签,创建一个垂直的Stack View：<br><img title=\"选中WHY\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack002.png?imageMogr2/2/w/800\"><br>点击Stack 按钮将二者嵌到一个Stack View：<br><img title=\"嵌到一个垂直的StackView\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack003.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"添加约束\"><a href=\"#添加约束\" class=\"headerlink\" title=\"添加约束\"></a>添加约束</h4><p>默认，约束是相对于距离最近的对象，对于Bottom约束来说就是距离它15像素的Hide按钮。但我们其实是想让约束相对于WEATHER标签。<br>选中Stack View，点击Pin按钮。勾选Constrain to margins，设置Top、Leading、Trainling为0。<br>然后，点击Bottom右边的下拉按钮，从列表中选择WEATHER（curent distance =20）：<br><img title=\"Top、Leading、Trainling为0\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack004.png?imageMogr2/2/w/800\"><br>最后点击Add 4 Constraints按钮。显示结果如下图所示：<br><img title=\"Top、Leading、Trainling为0\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack005.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"alignment属性：轴向的垂直方向\"><a href=\"#alignment属性：轴向的垂直方向\" class=\"headerlink\" title=\"alignment属性：轴向的垂直方向\"></a>alignment属性：轴向的垂直方向</h4><p>Stack View问题，它的右边对齐于View的右边。但是底下的标签仍然是原来的宽度。需要使用alignment属性解决这个问题。<br>当你测试完所有Alignment值的布局效果后，将Alignment修改为Fill：<br><img title=\"Top、Leading、Trainling为0\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0001.png?imageMogr2/2/w/800\"><br>将<code>Alignment</code>设置为<code>Fill</code>，表示所有View将沿与Stack View轴向垂直的方向进行全占式分布。这会让WHY VISIT标签扩展它的宽度到100%.</p>\n<p>如果我们只想让底下的标签将宽度扩展到100%怎么办？</p>\n<p>这个问题现在看来还不是多大的问题，因为两个标签在运行时的背景色都是透明的。但对于Weather版块来说就不同了。</p>\n<p>我们将用另外一个Stack View来说明这个问题。</p>\n<h2 id=\"垂直／水平Stack-View嵌套使用\"><a href=\"#垂直／水平Stack-View嵌套使用\" class=\"headerlink\" title=\"垂直／水平Stack View嵌套使用\"></a>垂直／水平Stack View嵌套使用</h2><h3 id=\"Weather版块\"><a href=\"#Weather版块\" class=\"headerlink\" title=\"Weather版块\"></a>Weather版块</h3><p>在Weather版块相对复杂一些，因为它多了一个Hide按钮。<br>要隐藏<code>Stack View</code>中的视图，你只需要设置该View的<code>Hidden</code>属性为<code>true</code>，剩下的工作Stack View会自己完成。这也是我们解决用户隐藏WEATHER标签下文本的主要思路。<br>一种方法是使用嵌套的Stack View，先将WEATHER标签和Hide按钮嵌到一个水平StackView，再将这个Stack View和标签嵌到一个垂直Stack View。<br><img title=\"垂直/水平StackView嵌套使用\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0002.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"垂直stackView\"><a href=\"#垂直stackView\" class=\"headerlink\" title=\"垂直stackView\"></a>垂直stackView</h4><p>注意Alignment属性负责Stack View轴向垂直的方向上的布局。所以，我们需要将Alignment属性设置为 Bottom：<br><img title=\"垂直/水平StackView嵌套使用\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0003.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"水平StackView中出现按钮拉伸标签的问题\"><a href=\"#水平StackView中出现按钮拉伸标签的问题\" class=\"headerlink\" title=\"水平StackView中出现按钮拉伸标签的问题\"></a>水平StackView中出现按钮拉伸标签的问题</h4><p>注意，WEATHER标签被拉伸为和Hide按钮一样高了。这并不合适，因为这会导致WEATHER标签和下面的文本之间多出了一些空间。<br>正确的方法是让 Hide 按钮不要和 Weather 版块呆在同一个Stack View中，或者任何别的Stack View中。<br>这样，在顶层View中还会保留一个subview，你将为它添加一个相对于WEATHER标签的约束——WEATHER标签嵌在Stack View里的。也就是说，你要为位于Stack View之外的按钮加一个约束，这个约束是相对于Stack View内的一个标签！</p>\n<h4 id=\"垂直stack-View1-嵌套WEATHER标签和标签\"><a href=\"#垂直stack-View1-嵌套WEATHER标签和标签\" class=\"headerlink\" title=\"垂直stack View1:嵌套WEATHER标签和标签\"></a>垂直stack View1:嵌套WEATHER标签和标签</h4><p>选中WEATHER标签和标签：<br><img title=\"选中嵌套标签\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0004.png?imageMogr2/2/w/800\"><br>点击 Stack 按钮：<br><img title=\"Stack按钮创建stackView\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0005.png?imageMogr2/2/w/800\"><br>点击Pin 按钮，勾上Constrain to margins，然后添加如下约束：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Top</span>: <span class=\"number\">20</span>, <span class=\"type\">Leading</span>: <span class=\"number\">0</span>, <span class=\"type\">Trailing</span>: <span class=\"number\">0</span>, <span class=\"type\">Bottom</span>: <span class=\"number\">20</span></span><br></pre></td></tr></table></figure><br>将Stack View的Alignment设为Fill：<br><img title=\"Alignment设为Fill\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0006.png?imageMogr2/2/w/800\"><br>我们需要在 Hide 按钮左边和WEATHER标签右边加一条约束，这样WEATHER 标签的宽度就不会拉满整个Stack View了。</p>\n<p>当然，底下的标签宽度还是需要100%占满的。</p>\n<p>我们是通过将WEATHER标签嵌到一个垂直Stack View 来实现的。注意，垂直Stack View的Alignment 属性可以设置为 .Leading，如果将Stack View拉宽，则它里面的View 会保持左对齐。</p>\n<h4 id=\"垂直stack-View2-仅嵌套WEATHER标签\"><a href=\"#垂直stack-View2-仅嵌套WEATHER标签\" class=\"headerlink\" title=\"垂直stack View2: 仅嵌套WEATHER标签\"></a>垂直stack View2: 仅嵌套WEATHER标签</h4><p>从Outline视图中选取WEATHER 标签，或者用Control+Shift+左键的方式选取WEATHER 标签：<br><img title=\"Stack按钮创建stackView\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0006.png?imageMogr2/2/w/800\"><br>然后点击Stack 按钮：<br><img title=\"Stack按钮创建stackView\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0007.png?imageMogr2/2/w/800\"><br>确保Axis 为 Vertical 的情况下，将Alignment 设置为 Leading：<br><img title=\"Alignment设置为Leading\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0008.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"按钮和WEATHER标签两个约束\"><a href=\"#按钮和WEATHER标签两个约束\" class=\"headerlink\" title=\"按钮和WEATHER标签两个约束\"></a>按钮和WEATHER标签两个约束</h4><p>从Hide 按钮用右键拖一条新的约束到 WEATHER 标签：<br><img title=\"AddConstraints\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0009.png?imageMogr2/2/w/800\"><br>按下Shift键，同时选择Horizontal Spacing 和 Baseline。然后点击 Add Constraints：<br><img title=\"AddConstraints\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0000.png?imageMogr2/2/w/800\"><br>编译运行。Hide 按钮的位置现在对了，而且当按下Hide 按钮，位于Stack View 中的标签被隐藏后，下面的视图也会被调整——根本不需要我们进行手动调整。<br><img title=\"编译运行\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack010.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"顶级-Stack-View\"><a href=\"#顶级-Stack-View\" class=\"headerlink\" title=\"顶级 Stack View\"></a>顶级 Stack View</h2><p>在Outline 视图中，用Command+左键选择5个最顶级的 Stack View：<br><img title=\"选中视图\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack011.png?imageMogr2/2/w/800\"><br>然后点击 Stack 按钮：<br><img title=\"Stack按钮\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack012.png?imageMogr2/2/w/800\"><br>点击Pin 按钮，勾上 Constrain to margins，将 4 个边的约束都设为0。然后将Spacing 设置为20，Alignment 设为 Fill。现在故事板会是这个样子：<br><img title=\"添加约束\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack013.png?imageMogr2/2/w/800\"><br>编译运行：<br><img title=\"编译运行\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack014.png?imageMogr2/2/w/800\"><br>噢！这个 Hide 按钮又失去了它 的约束！因为包含 WEATHER 标签的Stack View的外边又套了一层 Stack View。这不是什么大问题，就像之前你做过的那样，再重新为它添加约束就是了。</p>\n<p>右键从Hide 按钮拖一条约束到 WEATHER标签，按下 Shift 键，同时选择 Horizontal Spacing 和 Baseline。然后点击 Add Constraints：<br><img title=\"AddConstraints\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack015.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"重新调整视图位置\"><a href=\"#重新调整视图位置\" class=\"headerlink\" title=\"重新调整视图位置\"></a>重新调整视图位置</h2><p>现在，所有的版块都被嵌到一个顶级的 Stack View中了，我们想修改一下 what to see版块的位置，让它位于 weather 版块之后。</p>\n<p>从 Outline 视图中选择中间的的 Stack View，然后将它拖到第一、二个 Stack View 之间。<br>注意：让箭头稍微偏向你正在拖的Stack View左边一点，以便它能够作为外层 Stack View 的 subview 添加。蓝色的小圆圈应当位于两个 Stack View 之间的左端而不是右端：<br><img title=\"调整视图位置\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack016.png?imageMogr2/2/w/800\"></p>\n<p>现在，weather版块是从上到下的第三个版块，由于 Hide 按钮它并不是 Stack View的subview，所以它不会参与移动，它的frame当前是不正确的。</p>\n<p>点击 Hide 按钮，选中它：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack017.png?imageMogr2/2/w/800\"></p>\n<p>然后点击自动布局工具栏中的 Resolve Auto Layout Issues 按钮，选择 Update Frames：<br><img title=\"Update\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack018.png?imageMogr2/2/w/800\"><br>现在 Hide 按钮将回到正确的位置：<br><img title=\"UpdateHide按钮\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack019.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"基于配置的-Size-类\"><a href=\"#基于配置的-Size-类\" class=\"headerlink\" title=\"基于配置的 Size 类\"></a>基于配置的 Size 类</h2><p>最后还有一个任务没有完成。在横屏模式，垂直空间是比较珍贵的，你想将这些版块之间靠得更近一些。要实现这个，你需要判断当垂直Size类为compact时，将顶层 Stack View的 Spacing属性由 20 改成 10.</p>\n<p>选择顶层 Stack View，点击 Spacing 前面的+按钮：<br><img title=\"前面的+按钮Spacing\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack020.png?imageMogr2/2/w/800\"></p>\n<p>选择 Any Width &gt; Compact Height：<br><img title=\"CompactHeight\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack021.png?imageMogr2/2/w/800\"></p>\n<p>在新出现的 wAny hC 一栏中，将 Spacing 设为 10：<br><img title=\"Spacing设为10\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack022.png?imageMogr2/2/w/800\"><br>编译运行。在竖屏模式下Spacing不会改变。旋转模拟器（⌘←），你会看到各版块之间的间距减少了，现在底部按钮之间的空间也变大了：<br><img title=\"编译运行\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack023.png?imageMogr2/2/w/800\"><br>如果你没有添加最外层的 Stack View，你仍然可以使用 Size 类将每个版块之间的垂直间距设置为 10，但这就不是仅仅设置一个地方就能够办到的了。</p>\n<h2 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h2><p>现在，在隐藏和显示天气信息时仍然会觉得有一些突兀。你将增加一个动画使这个转换变得更平滑。</p>\n<p>Stack View完全支持 <code>UIView 动画</code>。也就是说要以动画方式显示/隐藏它所包含的subview，只需要简单地在一个动画块中切换它的 hidden 属性。</p>\n<p>让我们来看看代码怎么实现。打开 <code>SpotInfoViewController.Swift</code>，找到<br><code>updateWeatherInfoViews(hideWeatherInfo:animated:)</code>方法。</p>\n<p>将方法的最后一行：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br></pre></td></tr></table></figure><br>替换为：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> animated </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">UIView</span>.animateWithDuration(<span class=\"number\">0.3</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">else</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>编译运行，点击Hide 按钮或 Show 按钮。是不是加入动画之后看起来要好得多呢？</p>\n<p>除了对 Stack View 中的视图以动画的方式设置 hidden 属性，你也可以对 Stack View 自身的属性使用 UIView 动画，例如 Alignment 属性、 Distribution 属性、 Spacing 属性和 Axis 属性。<br><a href=\"http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Starter.zip\" target=\"_blank\" rel=\"noopener\">开始项目源码</a><br><a href=\"http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Complete.zip\" target=\"_blank\" rel=\"noopener\">完整项目源码</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2>","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"控件","path":"api/categories/控件.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"}]}]}