{"name":"git","postlist":[{"title":"使用tag管理多个相关组件的版本发布","slug":"git/使用tag管理多个相关组件的版本发布","date":"2018-06-20T17:22:37.000Z","updated":"2018-06-21T21:43:37.000Z","comments":true,"path":"api/articles/git/使用tag管理多个相关组件的版本发布.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"tag标签自增新建脚本\"><a href=\"#tag标签自增新建脚本\" class=\"headerlink\" title=\"tag标签自增新建脚本\"></a>tag标签自增新建脚本</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\">tag=$(git describe --tags `git rev-list --tags --max-count=1`)</span><br><span class=\"line\">version=<span class=\"variable\">$&#123;tag##*.&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">let</span> <span class=\"string\">\"version+=1\"</span></span><br><span class=\"line\">newTag=<span class=\"variable\">$&#123;tag%.*&#125;</span>.<span class=\"variable\">$&#123;version&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'Create New Tag '</span><span class=\"variable\">$newTag</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"修改tag版本号的方法\"><a href=\"#修改tag版本号的方法\" class=\"headerlink\" title=\"修改tag版本号的方法\"></a>修改tag版本号的方法</h2><h3 id=\"方法一：覆盖\"><a href=\"#方法一：覆盖\" class=\"headerlink\" title=\"方法一：覆盖\"></a>方法一：覆盖</h3><ol>\n<li><p>已有v1.0.2.8要覆盖该版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag -f v1.0.2.8</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>服务器已有v1.0.2.8，强制推到服务器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin -f v1.0.2.8</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>同步服务器：获取服务器刚刚的v1.0.2.8</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch -–tag</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"方法：删除分支\"><a href=\"#方法：删除分支\" class=\"headerlink\" title=\"方法：删除分支\"></a>方法：删除分支</h3><ol>\n<li><p>删除本地版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag -d v1.0.2.8</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除服务器上的分支(用空版本覆盖)</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin <span class=\"symbol\">:v1</span>.<span class=\"number\">0</span>.<span class=\"number\">2.8</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>服务器获取刚刚的v1.0.2.8</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch –-tag</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"}],"tags":[]},{"title":"使用local命令行新建remote库","slug":"git/使用local命令行新建remote库","date":"2018-06-20T11:14:00.000Z","updated":"2018-06-20T14:49:37.000Z","comments":true,"path":"api/articles/git/使用local命令行新建remote库.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>使用命令行直接生成github中的项目</p>\n<h2 id=\"新建远程仓库\"><a href=\"#新建远程仓库\" class=\"headerlink\" title=\"新建远程仓库\"></a>新建远程仓库</h2><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -u username <span class=\"symbol\">https:</span>/<span class=\"regexp\">/api.github.com/user</span><span class=\"regexp\">/repos -d '&#123; \"name\": \"repo-name\" &#125;'</span></span><br></pre></td></tr></table></figure>\n<p>执行打印结果，是json格式：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"attr\">\"name\"</span>: <span class=\"string\">\"ArcProgressUI\"</span>,</span><br><span class=\"line\"><span class=\"attr\">\"full_name\"</span>: <span class=\"string\">\"huos3203/ArcProgressUI\"</span>,</span><br><span class=\"line\"><span class=\"attr\">\"owner\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"url\"</span>: <span class=\"string\">\"https://api.github.com/users/huos3203\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"repos_url\"</span>: <span class=\"string\">\"https://api.github.com/users/huos3203/repos\"</span>,</span><br><span class=\"line\">    ---</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\"git_url\": \"git://github.com/huos3203/ArcProgressUI.git\",</span><br><span class=\"line\">\"ssh_url\": \"git@github.com:huos3203/ArcProgressUI.git\",</span><br><span class=\"line\">\"clone_url\": \"https://github.com/huos3203/ArcProgressUI.git\",</span><br><span class=\"line\">\"svn_url\": \"https://github.com/huos3203/ArcProgressUI\",</span><br><span class=\"line\">\"default_branch\": \"master\",</span><br><span class=\"line\">\"permissions\": &#123;</span><br><span class=\"line\">    \"admin\": true,</span><br><span class=\"line\">    \"push\": true,</span><br><span class=\"line\">    \"pull\": true</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"初始化远程仓库\"><a href=\"#初始化远程仓库\" class=\"headerlink\" title=\"初始化远程仓库\"></a>初始化远程仓库</h2><p>找到仓库路径的字段<code>clone_url</code>或者``<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin clone_url</span><br><span class=\"line\">//或者使用ssh,避免输入密码</span><br><span class=\"line\">//git remote add origin ssh_url</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"删除远程仓库\"><a href=\"#删除远程仓库\" class=\"headerlink\" title=\"删除远程仓库\"></a>删除远程仓库</h2><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">githubDelRepo()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> [[ $# != <span class=\"number\">2</span> ]] ; <span class=\"keyword\">then</span></span><br><span class=\"line\">        echo <span class=\"string\">\"Needs username and repo-name as args 1 and 2 respectively.\"</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        curl -X DELETE -u <span class=\"string\">\"$&#123;1&#125;\"</span> <span class=\"symbol\">https:</span>/<span class=\"regexp\">/api.github.com/repos</span><span class=\"regexp\">/\"$&#123;1&#125;\"/</span><span class=\"string\">\"$&#123;2&#125;\"</span></span><br><span class=\"line\">    fi</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"}],"tags":[]},{"title":"Git如何永久删除文件(包括历史记录)","slug":"git/Git如何永久删除文件(包括历史记录)","date":"2018-06-11T20:32:02.000Z","updated":"2018-06-11T20:32:02.000Z","comments":true,"path":"api/articles/git/Git如何永久删除文件(包括历史记录).json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>有些时候不小心上传了一些敏感文件(例如密码), 或者不想上传的文件(没及时或忘了加到.gitignore里的),</p>\n<p>而且上传的文件又特别大的时候, 这将导致别人clone你的代码或下载zip包的时候也必须更新或下载这些无用的文件,</p>\n<p>因此, 我们需要一个方法, 永久的删除这些文件(包括该文件的历史记录).</p>\n<p>首先, 可以参考 <a href=\"https://help.github.com/articles/remove-sensitive-data\" target=\"_blank\" rel=\"noopener\">github帮助</a></p>\n<h2 id=\"步骤一-从资料库中清除文件\"><a href=\"#步骤一-从资料库中清除文件\" class=\"headerlink\" title=\"步骤一: 从资料库中清除文件\"></a>步骤一: 从资料库中清除文件</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git filter-branch --force --index-filter <span class=\"string\">'git rm --cached --ignore-unmatch path-to-your-remove-file'</span> --prune-empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure>\n<p>其中, <code>path-to-your-remove-file</code> 是要删除的文件的相对路径(相对于git仓库的跟目录), 替换成你要删除的文件即可.</p>\n<blockquote>\n<p>这里的文件或文件夹，都不能以 ‘/‘ 开头，否则文件或文件夹会被认为是从 git 的安装目录开始。</p>\n<h3 id=\"删除文件夹\"><a href=\"#删除文件夹\" class=\"headerlink\" title=\"删除文件夹\"></a>删除文件夹</h3><p>在 <code>git rm --cached</code> 命令后面添加 <code>-r</code> 命令，表示递归的删除（子）文件夹和文件夹下的文件，类似于 <code>rm -rf</code> 命令:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git filter-branch --force --index-filter <span class=\"string\">'git rm --cached -r --ignore-unmatch path-to-your-remove-folder'</span> --prune-empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"支持通配符\"><a href=\"#支持通配符\" class=\"headerlink\" title=\"支持通配符\"></a>支持通配符</h3><p>如果当要删除的文件很多, 文件或路径里有中文, 由于MinGW或CygWin对中文路径设置比较麻烦, 你可以使用通配符<em>号, 例如: `sound/music_</em>.mp3<code>, 这样就把</code>sound<code>目录下以</code>music_<code>开头的mp3文件都删除了.\n使用通配符</code>*`删除目录下的所有文件：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git filter-branch --force --index-filter <span class=\"string\">'git rm --cached -r --ignore-unmatch path-to-your-remove-folder/*'</span> --prune-empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure></p>\n<p>成功的日志：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ref <span class=\"string\">'refs/heads/master'</span> was rewritten</span><br><span class=\"line\">Ref <span class=\"string\">'refs/remotes/origin/master'</span> was rewritten</span><br><span class=\"line\">WARNING: Ref <span class=\"string\">'refs/remotes/origin/master'</span> is unchanged</span><br><span class=\"line\">WARNING: Ref <span class=\"string\">'refs/tags/v0.9.0'</span> is unchanged</span><br><span class=\"line\">v0.9.0 -&gt; v0.9.0 (2694a7834dada67cf8768ef27e2d7c3d777f5472 -&gt; 2694a7834dada67cf8768ef27e2d7c3d777f5472)</span><br></pre></td></tr></table></figure></p>\n<p><code>Ref &#39;refs/heads/master&#39; was rewritten</code>:表示成功；<br><code>xxxxx unchanged</code>: 说明在当前分支里没有找到该文件.</p>\n<h2 id=\"步骤二-推送我们修改后的repo\"><a href=\"#步骤二-推送我们修改后的repo\" class=\"headerlink\" title=\"步骤二: 推送我们修改后的repo\"></a>步骤二: 推送我们修改后的repo</h2><h3 id=\"分支同步\"><a href=\"#分支同步\" class=\"headerlink\" title=\"分支同步\"></a>分支同步</h3><p>通过步骤一，需要以强制覆盖的方式推送你的repo, 命令如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push --force origin master</span><br></pre></td></tr></table></figure></p>\n<p>这个过程其实是重新上传我们的repo, 比较耗时, 虽然跟删掉重新建一个repo有些类似, 但是好处是保留了原有的更新记录, 所以还是有些不同的. 如果你实在不在意这些更新记录, 也可以删掉重建, 两者也差不太多, 也许后者还更直观些.</p>\n<h3 id=\"tag同步\"><a href=\"#tag同步\" class=\"headerlink\" title=\"tag同步\"></a>tag同步</h3><p>为了能从打了 tag 的版本中也删除你所指定的文件或文件夹，您可以使用这样的命令来强制推送您的 Git tags：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin master --force --tags</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"步骤三-清理和回收空间\"><a href=\"#步骤三-清理和回收空间\" class=\"headerlink\" title=\"步骤三: 清理和回收空间\"></a>步骤三: 清理和回收空间</h2><p>虽然上面我们已经删除了文件, 但是我们的repo里面仍然保留了这些objects, 等待垃圾回收(GC), 所以我们要用命令彻底清除它, 并收回空间.</p>\n<p>执行命令，再查看<code>.git</code>目录空间会明显变小:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm -rf .git/refs/original/</span><br><span class=\"line\"></span><br><span class=\"line\">$ git reflog expire --expire=now --all</span><br><span class=\"line\"></span><br><span class=\"line\">$ git gc --prune=now</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Counting objects: 2437, <span class=\"keyword\">done</span>.</span><br><span class=\"line\"><span class=\"comment\"># Delta compression using up to 4 threads.</span></span><br><span class=\"line\"><span class=\"comment\"># Compressing objects: 100% (1378/1378), done.</span></span><br><span class=\"line\"><span class=\"comment\"># Writing objects: 100% (2437/2437), done.</span></span><br><span class=\"line\"><span class=\"comment\"># Total 2437 (delta 1461), reused 1802 (delta 1048)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$ git gc --aggressive --prune=now</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Counting objects: 2437, <span class=\"keyword\">done</span>.</span><br><span class=\"line\"><span class=\"comment\"># Delta compression using up to 4 threads.</span></span><br><span class=\"line\"><span class=\"comment\"># Compressing objects: 100% (2426/2426), done.</span></span><br><span class=\"line\"><span class=\"comment\"># Writing objects: 100% (2437/2437), done.</span></span><br><span class=\"line\"><span class=\"comment\"># Total 2437 (delta 1483), reused 0 (delta 0)</span></span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"}],"tags":[]},{"title":"Git工具交互式暂存","slug":"git/Git工具交互式暂存","date":"2018-04-12T19:41:46.000Z","updated":"2018-04-12T19:41:46.000Z","comments":true,"path":"api/articles/git/Git工具交互式暂存.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"交互式暂存\"><a href=\"#交互式暂存\" class=\"headerlink\" title=\"交互式暂存\"></a>交互式暂存</h2><p>Git 自带的一些脚本可以使在命令行下工作更容易。 本节的几个互交命令可以帮助你将文件的特定部分组合成提交。 当你修改一组文件后，希望这些改动能放到若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 git add 时使用 -i 或者 –interactive 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add -i</span><br><span class=\"line\">staged     unstaged path</span><br><span class=\"line\">1:    unchanged        +0/-1 TODO</span><br><span class=\"line\">2:    unchanged        +1/-1 index.html</span><br><span class=\"line\">3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class=\"line\"></span><br><span class=\"line\">*** Commands ***</span><br><span class=\"line\">1: status     2: update      3: revert     4: add untracked</span><br><span class=\"line\">5: patch      6: diff        7: quit       8: help</span><br><span class=\"line\">What now&gt;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到这个命令以非常不同的视图显示了暂存区 - 基本上与 <code>git status</code> 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。</p>\n<p>在这块区域后是命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、查看暂存内容的区别。</p>\n<h2 id=\"暂存与取消暂存文件\"><a href=\"#暂存与取消暂存文件\" class=\"headerlink\" title=\"暂存与取消暂存文件\"></a>暂存与取消暂存文件</h2><p>如果在 What now&gt; 提示符后键入 2 或 u，脚本将会提示想要暂存哪个文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">What now&gt; 2</span><br><span class=\"line\">staged     unstaged path</span><br><span class=\"line\">1:    unchanged        +0/-1 TODO</span><br><span class=\"line\">2:    unchanged        +1/-1 index.html</span><br><span class=\"line\">3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class=\"line\">Update&gt;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>要暂存 TODO 与 index.html 文件，可以输入数字：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Update&gt;&gt; 1,2</span><br><span class=\"line\">staged     unstaged path</span><br><span class=\"line\">* 1:    unchanged        +0/-1 TODO</span><br><span class=\"line\">* 2:    unchanged        +1/-1 index.html</span><br><span class=\"line\">3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class=\"line\">Update&gt;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>每个文件前面的 * 意味着选中的文件将会被暂存。 如果在 Update&gt;&gt; 提示符后不输入任何东西并直接按回车，Git 将会暂存之前选择的文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Update&gt;&gt;</span><br><span class=\"line\">updated 2 paths</span><br><span class=\"line\"></span><br><span class=\"line\">*** Commands ***</span><br><span class=\"line\">1: status     2: update      3: revert     4: add untracked</span><br><span class=\"line\">5: patch      6: diff        7: quit       8: help</span><br><span class=\"line\">What now&gt; 1</span><br><span class=\"line\">staged     unstaged path</span><br><span class=\"line\">1:        +0/-1      nothing TODO</span><br><span class=\"line\">2:        +1/-1      nothing index.html</span><br><span class=\"line\">3:    unchanged        +5/-1 lib/simplegit.rb</span><br></pre></td></tr></table></figure></p>\n<p>现在可以看到 TODO 与 index.html 文件已经被暂存而 simplegit.rb 文件还未被暂存。 如果这时想要取消暂存 TODO 文件，使用 3 或 r（撤消）选项：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*** Commands ***</span><br><span class=\"line\">1: status     2: update      3: revert     4: add untracked</span><br><span class=\"line\">5: patch      6: diff        7: quit       8: help</span><br><span class=\"line\">What now&gt; 3</span><br><span class=\"line\">staged     unstaged path</span><br><span class=\"line\">1:        +0/-1      nothing TODO</span><br><span class=\"line\">2:        +1/-1      nothing index.html</span><br><span class=\"line\">3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class=\"line\">Revert&gt;&gt; 1</span><br><span class=\"line\">staged     unstaged path</span><br><span class=\"line\">* 1:        +0/-1      nothing TODO</span><br><span class=\"line\">2:        +1/-1      nothing index.html</span><br><span class=\"line\">3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class=\"line\">Revert&gt;&gt; [enter]</span><br><span class=\"line\">reverted one path</span><br></pre></td></tr></table></figure></p>\n<p>再次查看 Git 状态，可以看到已经取消暂存 TODO 文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*** Commands ***</span><br><span class=\"line\">1: status     2: update      3: revert     4: add untracked</span><br><span class=\"line\">5: patch      6: diff        7: quit       8: help</span><br><span class=\"line\">What now&gt; 1</span><br><span class=\"line\">staged     unstaged path</span><br><span class=\"line\">1:    unchanged        +0/-1 TODO</span><br><span class=\"line\">2:        +1/-1      nothing index.html</span><br><span class=\"line\">3:    unchanged        +5/-1 lib/simplegit.rb</span><br></pre></td></tr></table></figure></p>\n<p>如果想要查看已暂存内容的区别，可以使用 6 或 d（区别）命令。 它会显示暂存文件的一个列表，可以从中选择想要查看的暂存区别。 这跟你在命令行指定 git diff –cached 非常相似：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*** Commands ***</span><br><span class=\"line\">1: status     2: update      3: revert     4: add untracked</span><br><span class=\"line\">5: patch      6: diff        7: quit       8: help</span><br><span class=\"line\">What now&gt; 6</span><br><span class=\"line\">staged     unstaged path</span><br><span class=\"line\">1:        +1/-1      nothing index.html</span><br><span class=\"line\">Review diff&gt;&gt; 1</span><br><span class=\"line\">diff --git a/index.html b/index.html</span><br><span class=\"line\">index 4d07108..4335f49 100644</span><br><span class=\"line\">--- a/index.html</span><br><span class=\"line\">+++ b/index.html</span><br><span class=\"line\">@@ -16,7 +16,7 @@ Date Finder</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p id=&quot;out&quot;&gt;...&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">-&lt;div id=&quot;footer&quot;&gt;contact : support@github.com&lt;/div&gt;</span><br><span class=\"line\">+&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。</p>\n<h2 id=\"暂存补丁\"><a href=\"#暂存补丁\" class=\"headerlink\" title=\"暂存补丁\"></a>暂存补丁</h2><p>Git 也可以暂存文件的特定部分。 例如，如果在 simplegit.rb 文件中做了两处修改，但只想要暂存其中的一个而不是另一个，Git 会帮你轻松地完成。 从交互式提示符中，输入 5 或 p（补丁）。 Git 会询问你想要部分暂存哪些文件；然后，对已选择文件的每一个部分，它都会一个个地显示文件区别并询问你是否想要暂存它们：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class=\"line\">index dd5ecc4..57399e0 100644</span><br><span class=\"line\">--- a/lib/simplegit.rb</span><br><span class=\"line\">+++ b/lib/simplegit.rb</span><br><span class=\"line\">@@ -22,7 +22,7 @@ class SimpleGit</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">def log(treeish = &apos;master&apos;)</span><br><span class=\"line\">-    command(&quot;git log -n 25 #&#123;treeish&#125;&quot;)</span><br><span class=\"line\">+    command(&quot;git log -n 30 #&#123;treeish&#125;&quot;)</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">def blame(path)</span><br><span class=\"line\">Stage this hunk [y,n,a,d,/,j,J,g,e,?]?</span><br></pre></td></tr></table></figure></p>\n<p>这时有很多选项。 输入 ? 显示所有可以使用的命令列表：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?</span><br><span class=\"line\">y - stage this hunk</span><br><span class=\"line\">n - do not stage this hunk</span><br><span class=\"line\">a - stage this and all the remaining hunks in the file</span><br><span class=\"line\">d - do not stage this hunk nor any of the remaining hunks in the file</span><br><span class=\"line\">g - select a hunk to go to</span><br><span class=\"line\">/ - search for a hunk matching the given regex</span><br><span class=\"line\">j - leave this hunk undecided, see next undecided hunk</span><br><span class=\"line\">J - leave this hunk undecided, see next hunk</span><br><span class=\"line\">k - leave this hunk undecided, see previous undecided hunk</span><br><span class=\"line\">K - leave this hunk undecided, see previous hunk</span><br><span class=\"line\">s - split the current hunk into smaller hunks</span><br><span class=\"line\">e - manually edit the current hunk</span><br><span class=\"line\">? - print help</span><br></pre></td></tr></table></figure></p>\n<p>通常情况下可以输入 y 或 n 来选择是否要暂存每一个区块，当然，暂存特定文件中的所有部分或为之后的选择跳过一个区块也是非常有用的。 如果你只暂存文件的一部分，状态输出可能会像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">What now&gt; 1</span><br><span class=\"line\">staged     unstaged path</span><br><span class=\"line\">1:    unchanged        +0/-1 TODO</span><br><span class=\"line\">2:        +1/-1      nothing index.html</span><br><span class=\"line\">3:        +1/-1        +4/-0 lib/simplegit.rb</span><br></pre></td></tr></table></figure></p>\n<p>simplegit.rb 文件的状态很有趣。 它显示出若干行被暂存与若干行未被暂存。 已经部分地暂存了这个文件。 在这时，可以退出交互式添加脚本并且运行 git commit 来提交部分暂存的文件。</p>\n<p>也可以不必在交互式添加模式中做部分文件暂存 - 可以在命令行中使用 git add -p 或 git add –patch 来启动同样的脚本。</p>\n<p>更进一步地，可以使用 reset –patch 命令的补丁模式来部分重置文件，通过 checkout –patch 命令来部分检出文件与 stash save –patch 命令来部分暂存文件。 我们将会在接触这些命令的高级使用方法时了解更多详细信息。</p>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"}],"tags":[]},{"title":"当项目过大需要通过SSH方式Clone","slug":"git/当项目过大需要通过SSH方式Clone","date":"2018-04-04T17:44:24.000Z","updated":"2018-04-04T17:44:24.000Z","comments":true,"path":"api/articles/git/当项目过大需要通过SSH方式Clone.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"设置全局提交信息\"><a href=\"#设置全局提交信息\" class=\"headerlink\" title=\"设置全局提交信息\"></a>设置全局提交信息</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.email &quot;you@example.com&quot;</span><br><span class=\"line\">git config --global user.name &quot;Your Name&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"修改最后一次提交的用户名信息\"><a href=\"#修改最后一次提交的用户名信息\" class=\"headerlink\" title=\"修改最后一次提交的用户名信息\"></a>修改最后一次提交的用户名信息</h3><p>``git<br>  git config user.name ‘wangz’<br>  git config user.email ‘wangz@alib.com’<br>  git commit  –amend –author=wangz<br>```</p>\n<h3 id=\"项目过大问题\"><a href=\"#项目过大问题\" class=\"headerlink\" title=\"项目过大问题\"></a>项目过大问题</h3><blockquote>\n<p>git clone 主工程出现 fatal: The remote end hung up unexpectedly3)</p>\n</blockquote>\n<p>通常的解决办法：</p>\n<ol>\n<li><p>设置提交缓存的大小为 1G：1048576000<br> git config http.postBuffer 1048576000</p>\n</li>\n<li><p>否则，需要配置github/gitlab的公钥<br> 生成：<code>ssh-keygen -t rsa -C &quot;$your_email&quot;</code><br> 拷贝：<code>pbcopy &lt; ~/.ssh/id_rsa.pub</code><br> 创建SSHKey：<br> 在github/gitlab新建公钥<code>add SSH Key</code>：粘贴到密钥文本框中即可。</p>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"}],"tags":[]},{"title":"iOS和OSX集成gitAPI","slug":"开源库/iOS和OSX集成gitAPI","date":"2017-05-17T17:33:46.000Z","updated":"2017-09-24T09:18:26.000Z","comments":true,"path":"api/articles/开源库/iOS和OSX集成gitAPI.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/ObjectiveGitxiaoguo.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>在项目中使用git submodule工具集成子项目ObjectiveGit</p>\n<h4 id=\"在新项目中使用git-submodule集成gitAPI\"><a href=\"#在新项目中使用git-submodule集成gitAPI\" class=\"headerlink\" title=\"在新项目中使用git submodule集成gitAPI\"></a>在新项目中使用git submodule集成gitAPI</h4><p>参考官方提供的两个demo</p>\n<ul>\n<li><p>OS X: <a href=\"https://github.com/Abizern/CommitViewer\" target=\"_blank\" rel=\"noopener\">CommitViewer</a>   </p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/ObjectiveGitxiaoguo.png?imageMogr2/2/w/800\">\n</li>\n<li><p>iOS: <a href=\"https://github.com/Raekye/ObjectiveGit-iOS-Example\" target=\"_blank\" rel=\"noopener\">ObjectiveGit iOS Example</a></p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule add https://github.com/libgit2/objective-git.git External/ObjectiveGit</span><br><span class=\"line\">如果之前配置过，直接更新：</span><br><span class=\"line\">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>cd External/ObjectiveGit</code>，然后执行<code>./script/bootstrap</code>安装相关依赖.</li>\n<li>拖动 <code>ObjectiveGitFramework.xcodeproj</code> 文件 到iOS/OSX项目导航窗口 .</li>\n<li>在build Phases中配置APP的依赖，根据平台添加<code>ObjectiveGit-Mac</code> or <code>ObjectiveGit-iOS</code>.</li>\n<li>APP通过连接器链接 <code>ObjectiveGit.framework</code>.</li>\n<li>在build setting中“Header Search Paths” (<code>HEADER_SEARCH_PATHS</code>)设置<code>libgit2</code>头文件在项目的路径，例如：<code>External/ObjectiveGit/External/libgit2/include</code>. </li>\n<li>Add a new “Copy Files” build phase, set the destination to “Frameworks” and add <code>ObjectiveGit.framework</code> to the list. This will package the framework with your application as an embedded private framework.</li>\n</ol>\n<ul>\n<li>It’s hard to tell the difference between the platforms, but the Mac framework is in <code>build/Debug</code> whereas the iOS framework is in <code>build/Debug-iphoneos</code></li>\n</ul>\n<ol>\n<li>Don’t forget to <code>#import &lt;ObjectiveGit/ObjectiveGit.h&gt;</code> or <code>@import ObjectiveGit;</code> as you would with any other framework.</li>\n</ol>\n<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ul>\n<li>类变量关联.xib控件text值    </li>\n<li>字体样式菜单来改变字体样式    <h4 id=\"在OSX中设置控件的Bindings代替IBOutlet\"><a href=\"#在OSX中设置控件的Bindings代替IBOutlet\" class=\"headerlink\" title=\"在OSX中设置控件的Bindings代替IBOutlet\"></a>在OSX中设置控件的Bindings代替IBOutlet</h4></li>\n</ul>\n<p>先关联再使用属性依赖特性来同步数据</p>\n<h5 id=\"类变量关联-xib控件text值\"><a href=\"#类变量关联-xib控件text值\" class=\"headerlink\" title=\"类变量关联.xib控件text值\"></a>类变量关联.xib控件text值</h5><p><a href=\"http://stackoverflow.com/questions/8161012/referencing-bindings-in-connections-inspector\" target=\"_blank\" rel=\"noopener\">相关参考</a>      </p>\n<ol>\n<li>选中NSTextField的bindings检查器面板   </li>\n<li>在<code>value</code>单元内设置bind to 的值，通过下拉框选中 <code>Delegate</code>      </li>\n<li>Model key Path:输入类变量的名称。    <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/NSTextFieldBindings.png?imageMogr2/2/w/800\">   </li>\n<li>切换到 NSTextField／Delegate的Connections检查器面板,就会看到已经建立了关联：     <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/textFieldConections.png?imageMogr2/2/w/800\">   <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/delegatebinding.png?imageMogr2/2/w/800\">   \n</li>\n</ol>\n<h5 id=\"依赖属性\"><a href=\"#依赖属性\" class=\"headerlink\" title=\"依赖属性\"></a>依赖属性</h5><p>Foundation 框架提供的表示属性依赖的机制如下：<br>参考<a href=\"https://github.com/huos3203/BookObjc/blob/master/publish/issue7/issue-7-3-DJBen.md#依赖的属性\" target=\"_blank\" rel=\"noopener\">属性的依赖</a><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class=\"built_in\">NSString</span> *)key</span><br><span class=\"line\"></span><br><span class=\"line\">或</span><br><span class=\"line\">+ (<span class=\"built_in\">NSSet</span> *)keyPathsForValuesAffecting&lt;键名&gt;</span><br></pre></td></tr></table></figure></p>\n<p>将属性关联起来，这样就可以将类变量的值同步至UI控件中了：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class=\"built_in\">NSString</span> *)key </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSSet</span> *keySet = [<span class=\"built_in\">NSSet</span> setWithObjects:<span class=\"string\">@\"commit\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([key isEqualToString:<span class=\"string\">@\"messageTitle\"</span>] ||</span><br><span class=\"line\">        [key isEqualToString:<span class=\"string\">@\"messageDetails\"</span>] ||</span><br><span class=\"line\">        [key isEqualToString:<span class=\"string\">@\"author\"</span>] ||</span><br><span class=\"line\">        [key isEqualToString:<span class=\"string\">@\"date\"</span>])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> keySet;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"实现字体样式菜单来改变字体样式\"><a href=\"#实现字体样式菜单来改变字体样式\" class=\"headerlink\" title=\"实现字体样式菜单来改变字体样式\"></a>实现字体样式菜单来改变字体样式</h4><ol>\n<li>在xib中拖一个Object并设置为NSFontManager.h类的实现。   </li>\n<li>选中NSFontManager.h的connections面板，将Received Actions关联到对应的菜单项即可  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/fontManage.png?imageMogr2/2/w/800\">\n</li>\n</ol>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"API","path":"api/categories/API.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"}]},{"title":"使用sourceTree与git-subtree工具","slug":"git/使用sourceTree与git-subtree工具","date":"2017-05-17T11:23:22.000Z","updated":"2017-05-17T17:52:28.000Z","comments":true,"path":"api/articles/git/使用sourceTree与git-subtree工具.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/gittree.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"git-subtree-合并\"><a href=\"#git-subtree-合并\" class=\"headerlink\" title=\"git subtree 合并\"></a>git subtree 合并</h3><p>git subtree：合并策略，通过git subtree命令能将依赖库某分支合并到主项目的分支中，在开发过程中，只需对主项目分支进行统一管理。</p>\n<h4 id=\"创建合并subtree-add命令\"><a href=\"#创建合并subtree-add命令\" class=\"headerlink\" title=\"创建合并subtree add命令\"></a>创建合并subtree add命令</h4><p>命令如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;git subtree&apos; add -P &lt;prefix&gt; &lt;commit&gt;</span><br><span class=\"line\">&apos;git subtree&apos; add -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"两步走\"><a href=\"#两步走\" class=\"headerlink\" title=\"两步走\"></a>两步走</h5><p>先fetch库再subtree add合并</p>\n<ol>\n<li><p>先将依赖库fetch到本地仓库中</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建lib的远程版本库: </span><br><span class=\"line\">git init --bare lib-rep</span><br><span class=\"line\"><span class=\"comment\">#-f：远端库添加后立即执行fetch操作</span></span><br><span class=\"line\">git remote add -f librepo ../lib-rep</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过git subtree命令将依赖库合并到主项目中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git subtree add -P lib librepo master</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"squash合并法\"><a href=\"#squash合并法\" class=\"headerlink\" title=\"squash合并法\"></a>squash合并法</h5><p><code>--squash</code>: 适用于add/pull/merge子命令。先合并引用库的更新记录，将合并结果并到主项目中。<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git subtree add --prefix=themes/jacman --squash https://huos3203@github.com/huos3203/jacman.git master</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"subtree其他命令\"><a href=\"#subtree其他命令\" class=\"headerlink\" title=\"subtree其他命令\"></a>subtree其他命令</h4><p>git subtree支持创建(add)之外,还支持更新(pull),推送(push),合并(merge),抽离(split)以下命令:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'git subtree'</span> pull -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br><span class=\"line\"><span class=\"string\">'git subtree'</span> push -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br><span class=\"line\"><span class=\"string\">'git subtree'</span> merge -P &lt;prefix&gt; &lt;commit&gt;</span><br><span class=\"line\"><span class=\"string\">'git subtree'</span> split -P &lt;prefix&gt; [OPTIONS] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure></p>\n<p>从子树库中拉取最新代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git subtree pull --prefix=themes/jacman --squash https://huos3203@github.com/huos3203/jacman.git master</span><br></pre></td></tr></table></figure></p>\n<p>将自己的代码发布到子树库:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git subtree push --prefix=themes/jacman --squash https://huos3203@github.com/huos3203/jacman.git master</span><br></pre></td></tr></table></figure></p>\n<p>相关参数：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-q | --quiet</span><br><span class=\"line\">-d | --debug</span><br><span class=\"line\">-P &lt;prefix&gt; | --prefix=&lt;prefix&gt;      引用库对应的本地目录</span><br><span class=\"line\">-m &lt;message&gt; | --message=&lt;message&gt;   适用于add/pull/merge子命令。设置产生的合并提交的说明文本</span><br><span class=\"line\">--squash                             适用于add/pull/merge子命令。先合并引用库的更新记录，将合并结果并到主项目中。</span><br><span class=\"line\">使用此选项时，subtree add/pull会产生两个提交版本：一个是子项目的历史记录，一个是Merge操作。好处是可以让主项目历史记录很规整，缺点是子项目更新时常常需要解决冲突。一个更好的解决方案是：单独建一个分支进行--no-squash的subtree更新，然后再--squash合并到主分支。每次在此分支做操作前都需要先把主分支合并进来。参考：http://www.fwolf.com/blog/post/246</span><br></pre></td></tr></table></figure></p>\n<p>split子命令选项：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--annotate=&lt;annotation&gt;              创建合成历史时有可能形成内容不同但提交信息完全相同的提交版本，使用这个选项在每个提交消息前加上此前缀用来区分。</span><br><span class=\"line\">-b &lt;branch&gt; | --branch=&lt;branch&gt;      创建合成的提交历史时，创建此参数指定的新分支包含生成的合成历史。&lt;branch&gt;必须是还不存在的。</span><br><span class=\"line\">--onto=&lt;onto&gt;</span><br><span class=\"line\">--rejoin</span><br><span class=\"line\">--ignore-joins</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用sourcetree管理\"><a href=\"#使用sourcetree管理\" class=\"headerlink\" title=\"使用sourcetree管理\"></a>使用sourcetree管理</h4><ol>\n<li>配置 subtree<br>菜单：Repository -&gt; Add/Link subtree…(添加／链接子树…)<br>在左边栏的SUBTREES(子树)中显示：<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/gittree.png?imageMogr2/2/w/800\"></li>\n<li>拉取依赖库的最新代码<br>在右边栏右击已存在的subtree，并选择 pull subtree…菜单项：<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/gitsubtreepull.png?imageMogr2/2/w/800\">\n第二步的功能代码如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git -c subtree pull -P themes/.jacman --squash https://huos3203@github.com/huos3203/jacman.git master</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"submodule嵌套\"><a href=\"#submodule嵌套\" class=\"headerlink\" title=\"submodule嵌套\"></a>submodule嵌套</h3><p>git submodule：嵌套策略，将依赖库直接clone到主项目目录中，通过配置.submodule文件来隔离管理主项目／子依赖库的版本。<br>添加子模块：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule add https://github.com/libgit2/objective-git.git External/ObjectiveGit</span><br></pre></td></tr></table></figure></p>\n<p>更新子模块：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>submodule那样每次子项目修改了后要init和update.万一哪次没update就直接”commit -a” 或者 “add .” 全commit上去就悲剧了。</p>\n</blockquote>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"IDE","path":"api/categories/IDE.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"}]},{"title":"用Git将代码恢复到一个历史的版本","slug":"git/用Git将代码恢复到一个历史的版本","date":"2017-02-10T18:19:48.000Z","updated":"2017-02-10T18:29:19.000Z","comments":true,"path":"api/articles/git/用Git将代码恢复到一个历史的版本.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>经历：将代码全提交到默认的head分支中，切换分支后，无法找到分支的严重后果：<br>目的：在当前分支上，将代码恢复到一个历史的提交版本上。</p>\n<h2 id=\"暴力的方式\"><a href=\"#暴力的方式\" class=\"headerlink\" title=\"暴力的方式\"></a>暴力的方式</h2><p>如果仓库是自己在用（不影响别人），那么可以使用<code>git reset --hard &lt;target_commit_id&gt;</code> 来恢复到指定的提交，再用 git push -f 来强制更新远程的分支指针。为了保证万一需要找回历史提交，我们可以先打一个 tag 来备份。</p>\n<ol>\n<li>第一步：查看本地的索引的提交日志：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git reflog \t\t</span></span><br><span class=\"line\">a1d09fd HEAD@&#123;0&#125;: checkout: moving from all to master</span><br><span class=\"line\">a1d09fd HEAD@&#123;1&#125;: checkout: moving from master to all</span><br><span class=\"line\">a1d09fd HEAD@&#123;2&#125;: checkout: moving from HEAD to master</span><br><span class=\"line\">a1d09fd HEAD@&#123;3&#125;: checkout: moving from all to HEAD</span><br></pre></td></tr></table></figure></li>\n<li>第二步：根据上面的sh2值，回滚：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset  —hard  a1d09fd</span><br></pre></td></tr></table></figure>\n这样就可以找回代码.</li>\n</ol>\n<h2 id=\"温柔的方式\"><a href=\"#温柔的方式\" class=\"headerlink\" title=\"温柔的方式\"></a>温柔的方式</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">回滚</span></span><br><span class=\"line\">git reset  —hard  a1d09fd</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">将当前代码切换回最新的提交</span></span><br><span class=\"line\">git reset --soft origin/source</span><br></pre></td></tr></table></figure>\n<p>此时工作区变成了历史的提交内容，这个时候用 <code>git add</code> 和 <code>git commit</code> 即可.</p>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"恢复","path":"api/categories/恢复.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"git","path":"api/tags/git.json"}]},{"title":"迁移SVN库到git库保留branchs和tags","slug":"git/迁移SVN库到git库保留branchs和tags","date":"2017-01-18T12:21:46.000Z","updated":"2017-02-17T16:28:51.000Z","comments":true,"path":"api/articles/git/迁移SVN库到git库保留branchs和tags.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>SVN was a great advance in its day, but it’s now clear that distributed version control systems are the way forward and that Git is the de facto standard. Having helped many clients migrate from SVN to Git, here are my notes for a pain-free transition that will preserve the tags and branches in your SVN repository.</p>\n<h2 id=\"首先导入一个本地存储库\"><a href=\"#首先导入一个本地存储库\" class=\"headerlink\" title=\"首先导入一个本地存储库\"></a>首先导入一个本地存储库</h2><h3 id=\"在本地创建一个存储库的目录\"><a href=\"#在本地创建一个存储库的目录\" class=\"headerlink\" title=\"在本地创建一个存储库的目录\"></a>在本地创建一个存储库的目录</h3><figure class=\"highlight bash\"><figcaption><span>新建目录</span><a href=\"http://www.sailmaker.co.uk/blog/2013/05/05/migrating-from-svn-to-git-preserving-branches-and-tags-3/#import-staging\" target=\"_blank\" rel=\"noopener\">Create a local staging directory</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">mkdir staging</span><br><span class=\"line\"><span class=\"built_in\">cd</span> staging</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：staging 可以用任何你喜欢的字符串命名，也可以放在本地的任何目录中。</p>\n</blockquote>\n<h3 id=\"初始化git-svn\"><a href=\"#初始化git-svn\" class=\"headerlink\" title=\"初始化git svn\"></a>初始化git svn</h3><h4 id=\"使用SVN标准库结构初始化\"><a href=\"#使用SVN标准库结构初始化\" class=\"headerlink\" title=\"使用SVN标准库结构初始化\"></a>使用SVN标准库结构初始化</h4><figure class=\"highlight bash\"><figcaption><span>标准初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git svn init SVNRepo_ROOT_URL --stdlayout --prefix=svn/</span><br></pre></td></tr></table></figure>\n<p><code>SVNRepo_ROOT_URL</code>: 这里svn_url是完全限定的URL下的标准目录，其目录下包括三个目录：<code>trunk</code>，<code>branches</code>， <code>tags</code>。<br><code>--prefix</code>: 强烈建议使用<code>svn/</code>作为分支和标签的前缀：设置为 <code>--prefix=svn/</code>. 这样有助于防止Git用户混淆原声的Git分支和标签。</p>\n<h4 id=\"使用SVN自定义库结构初始化\"><a href=\"#使用SVN自定义库结构初始化\" class=\"headerlink\" title=\"使用SVN自定义库结构初始化\"></a>使用SVN自定义库结构初始化</h4><p>使用非标准的svn layout 来新建svn库，即可以根据自己喜好来自定义分支，标签目录：<br><figure class=\"highlight bash\"><figcaption><span>非标准化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git svn init SVN_URL -T Trunk -b Branches -t Tags --prefix=svn/</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"查看配置信息\"><a href=\"#查看配置信息\" class=\"headerlink\" title=\"查看配置信息\"></a>查看配置信息</h3><ol>\n<li><code>review</code>命令<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">review the config</span><br></pre></td></tr></table></figure>\n会有以下信息输出：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn-remote.svn.url=svn://svn.example.com</span><br><span class=\"line\">svn-remote.svn.fetch=some/path/trunk:refs/remotes/svn/trunk</span><br><span class=\"line\">svn-remote.svn.tags=some/path/tags/*:refs/remotes/svn/tags/*</span><br></pre></td></tr></table></figure>\n高级用户可以在执行之前，修改相关配置。</li>\n<li><code>git config</code>命令<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --local --list </span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">core.repositoryformatversion=0</span><br><span class=\"line\">core.filemode=true</span><br><span class=\"line\">core.bare=false</span><br><span class=\"line\">core.logallrefupdates=true</span><br><span class=\"line\">core.ignorecase=true</span><br><span class=\"line\">core.precomposeunicode=true</span><br><span class=\"line\">svn-remote.svn.url=https://huoshuguang@192.168.85.6/svn/PBBReader_Mac</span><br><span class=\"line\">svn-remote.svn.fetch=trunk:refs/remotes/origin/trunk</span><br><span class=\"line\">svn-remote.svn.branches=branches/*:refs/remotes/origin/*</span><br><span class=\"line\">svn-remote.svn.tags=tags/*:refs/remotes/origin/tags/*</span><br><span class=\"line\">remote.PBBReader.url=https://git.oschina.net/huosan/PBBReader.git</span><br><span class=\"line\">remote.PBBReader.fetch=+refs/heads/*:refs/remotes/PBBReader/*</span><br><span class=\"line\">branch.master.remote=PBBReader</span><br><span class=\"line\">branch.master.merge=refs/heads/master</span><br><span class=\"line\">remote.server.url=https://server.local/git/PBBReader.git</span><br><span class=\"line\">remote.server.fetch=+refs/heads/*:refs/remotes/server/*</span><br><span class=\"line\">branch.v34.remote=PBBReader</span><br><span class=\"line\">branch.v34.merge=refs/heads/v28</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"从远程SVN服务器拉取代码到新建的本地存储库\"><a href=\"#从远程SVN服务器拉取代码到新建的本地存储库\" class=\"headerlink\" title=\"从远程SVN服务器拉取代码到新建的本地存储库\"></a>从远程SVN服务器拉取代码到新建的本地存储库</h3><figure class=\"highlight bash\"><figcaption><span>拉取</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git svn fetch</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看本地库状态\"><a href=\"#查看本地库状态\" class=\"headerlink\" title=\"查看本地库状态\"></a>查看本地库状态</h2><h3 id=\"status\"><a href=\"#status\" class=\"headerlink\" title=\"status\"></a>status</h3><figure class=\"highlight bash\"><figcaption><span>status</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight bash\"><figcaption><span>内容</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"查看分支信息\"><a href=\"#查看分支信息\" class=\"headerlink\" title=\"查看分支信息\"></a>查看分支信息</h3><figure class=\"highlight bash\"><figcaption><span>branch</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -a</span><br></pre></td></tr></table></figure>\n<p>输出:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* master</span><br><span class=\"line\">remotes/svn/tags/0.1.0</span><br><span class=\"line\">remotes/svn/trunk</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意：SVN标记和分支（在这种情况下，没有任何分支机构）仅作为远程引用存在。</p>\n</blockquote>\n<h2 id=\"SVN分支和标签转为本地git仓库中的标签和分支\"><a href=\"#SVN分支和标签转为本地git仓库中的标签和分支\" class=\"headerlink\" title=\"SVN分支和标签转为本地git仓库中的标签和分支\"></a>SVN分支和标签转为本地git仓库中的标签和分支</h2><h3 id=\"SVN分支迁移\"><a href=\"#SVN分支迁移\" class=\"headerlink\" title=\"SVN分支迁移\"></a>SVN分支迁移</h3><p>把远程svn分支转换为本地git仓库中的分支：<br><figure class=\"highlight bash\"><figcaption><span>分支转分支</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> branch <span class=\"keyword\">in</span> `git branch -r | grep <span class=\"string\">\"branches/\"</span> | sed <span class=\"string\">'s/ branches\\///'</span>`; <span class=\"keyword\">do</span></span><br><span class=\"line\">git branch <span class=\"variable\">$branch</span> refs/remotes/<span class=\"variable\">$branch</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"SVN标签迁移\"><a href=\"#SVN标签迁移\" class=\"headerlink\" title=\"SVN标签迁移\"></a>SVN标签迁移</h3><ol>\n<li>把远程svn标签转换为本地git仓库中的标签 :<figure class=\"highlight bash\"><figcaption><span>tags转换tags</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> tag <span class=\"keyword\">in</span> `git branch -r | grep <span class=\"string\">\"tags/\"</span> | sed <span class=\"string\">'s/ tags\\///'</span>`; <span class=\"keyword\">do</span></span><br><span class=\"line\">git tag -a -m<span class=\"string\">\"Converting SVN tags\"</span> <span class=\"variable\">$tag</span> refs/remotes/<span class=\"variable\">$tag</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"SVN标签转为本地git分支\"><a href=\"#SVN标签转为本地git分支\" class=\"headerlink\" title=\"SVN标签转为本地git分支\"></a>SVN标签转为本地git分支</h3><ol>\n<li>把远程svn标签转换为本地git仓库中的分支:<figure class=\"highlight bash\"><figcaption><span>标签转分支</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> tag <span class=\"keyword\">in</span> `git branch -r | grep <span class=\"string\">\"tags/\"</span> | sed <span class=\"string\">'s/ tags\\///'</span>`; <span class=\"keyword\">do</span></span><br><span class=\"line\">git branch <span class=\"variable\">$tag</span> refs/remotes/<span class=\"variable\">$tag</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"在本地测试git命令push和clone操作\"><a href=\"#在本地测试git命令push和clone操作\" class=\"headerlink\" title=\"在本地测试git命令push和clone操作\"></a>在本地测试git命令push和clone操作</h2><p>在推送到正式远程库之前，可以通过向本地git库中推送和clone操作。</p>\n<h3 id=\"创建一个临时的git库，用于测试push和clone测试\"><a href=\"#创建一个临时的git库，用于测试push和clone测试\" class=\"headerlink\" title=\"创建一个临时的git库，用于测试push和clone测试\"></a>创建一个临时的git库，用于测试push和clone测试</h3><p>在git中的说法，<code>bare</code>库是一个不存在工作空间备份的库。<br><figure class=\"highlight bash\"><figcaption><span>bare创建</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">mkdir <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"built_in\">test</span></span><br><span class=\"line\">git init --bare</span><br></pre></td></tr></table></figure><br>这样，在<code>~/test</code>就生成了一个<code>bare</code>git库。</p>\n<h3 id=\"push-测试\"><a href=\"#push-测试\" class=\"headerlink\" title=\"push 测试\"></a>push 测试</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~/staging</span><br><span class=\"line\">git remote add <span class=\"built_in\">test</span> `~/<span class=\"built_in\">test</span>`</span><br><span class=\"line\">git push --all <span class=\"built_in\">test</span></span><br><span class=\"line\">git push --tags <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<p>把<code>~/test</code>的放在反引号中，反引号在命令行中会<code>~</code>自动补全为一个绝对路径。如果你给一个绝对路径或URL，可以省略反引号。<br>尽管它的名字，<code>--all</code>选项不推送<code>tags</code>，所以需要对标签单独push操作。</p>\n<h3 id=\"clone-测试\"><a href=\"#clone-测试\" class=\"headerlink\" title=\"clone 测试\"></a>clone 测试</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">mkdir aclone</span><br><span class=\"line\"><span class=\"built_in\">cd</span> aclone</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> ~/<span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<p>There should now be a clone with a working copy in ~/aclone/test.<br>在<code>~/aclone/test</code>目录中将会clone出一个工作空间备份，检查确保一切OK，这样就可以向正式服务器上推送。</p>\n<h3 id=\"Push到正式git库中\"><a href=\"#Push到正式git库中\" class=\"headerlink\" title=\"Push到正式git库中\"></a>Push到正式git库中</h3><p>如果你是正式库服务器（github，coding）的管理员，为本地git库设置一个空的git库。<br>以<code>Unfuddle</code>为例,路径如下：<br><code>git@example.unfuddle.com:example/blah.git</code><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~/staging</span><br><span class=\"line\">git remote add unfuddle REAL_HOST_URL</span><br><span class=\"line\">git push --all unfuddle</span><br><span class=\"line\">git push --tags unfuddle</span><br></pre></td></tr></table></figure><br>在上面的例子中，制定了远程名：<code>unfuddle</code>而不是默认的<code>origin</code>。当然，你可以使用任何你喜欢的名字。</p>\n<h2 id=\"清理操作\"><a href=\"#清理操作\" class=\"headerlink\" title=\"清理操作\"></a>清理操作</h2><h3 id=\"删除临时git库\"><a href=\"#删除临时git库\" class=\"headerlink\" title=\"删除临时git库\"></a>删除临时git库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~/staging</span><br><span class=\"line\">git remote rm <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<p><code>staging</code>库忽略<code>test</code>远程仓库.</p>\n<h3 id=\"清除clone生成的库\"><a href=\"#清除clone生成的库\" class=\"headerlink\" title=\"清除clone生成的库\"></a>清除clone生成的库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">rm -rf aclone</span><br><span class=\"line\">rm -rf <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Either-keep-or-delete-the-staging-repo\"><a href=\"#Either-keep-or-delete-the-staging-repo\" class=\"headerlink\" title=\"Either keep or delete the staging repo\"></a>Either keep or delete the staging repo</h3><ol>\n<li>如果需要Git和SVN之间频繁交互，建议保留<code>staging</code>库这会节省你非常耗时的初始化：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git svn fetch</span><br></pre></td></tr></table></figure></li>\n<li>如果你确信svn是报废的，你可以删除：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">rm -rf staging</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"题外小贴士\"><a href=\"#题外小贴士\" class=\"headerlink\" title=\"题外小贴士\"></a>题外小贴士</h1><p>在局域网内访问server搭建服务器提供的git服务：<br><figure class=\"highlight bash\"><figcaption><span>小贴士</span><a href=\"https://confluence.atlassian.com/fishkb/unable-to-clone-git-repository-due-to-self-signed-certificate-376838977.html\" target=\"_blank\" rel=\"noopener\">SSL证书问题</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://.../git/mupdf.git</span><br><span class=\"line\">错误：fatal: unable to access <span class=\"string\">'https://..../git/mupdf.git/'</span>: SSL certificate problem: Invalid certificate chain</span><br></pre></td></tr></table></figure><br>解决：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global http.sslVerify <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"svn","path":"api/categories/svn.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"git","path":"api/tags/git.json"},{"name":"svn","path":"api/tags/svn.json"},{"name":"git-svn","path":"api/tags/git-svn.json"}]},{"title":"git svn桥接命令的基础","slug":"git/gitsvn桥接命令的基础","date":"2016-01-05T14:18:00.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/gitsvn桥接命令的基础.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><a href=\"http://git-scm.com/book/zh/v1/Git-与其他系统-Git-与-Subversion#git-svn\" target=\"_blank\" rel=\"noopener\">git svn</a></p>\n<p>通过几个简单的工作流程了解到<code>git svn</code>常见命令：<br>值得警戒的是，在使用 git svn 的时候，你实际是在与 Subversion 交互，Git 比它要高级复杂的多。尽管可以在本地随意的进行分支和合并，最好还是通过衍合保持线性的提交历史，</p>\n<ol>\n<li>尽量避免类似与远程 Git 仓库动态交互这样的操作。</li>\n<li>避免修改历史再重新推送的做法，也不要同时推送到并行的 Git 仓库来试图与其他 Git 用户合作。</li>\n<li>Subersion 只能保存单一的线性提交历史，一不小心就会被搞糊涂。</li>\n<li>合作团队中同时有人用 SVN 和 Git，一定要确保所有人都使用 SVN 服务来协作——这会让生活轻松很多。</li>\n</ol>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"svn","path":"api/categories/svn.json"}],"tags":[{"name":"命令","path":"api/tags/命令.json"}]},{"title":"清除git历史记录大文件bfg","slug":"git/清除git历史记录大文件bfg","date":"2015-10-20T11:17:27.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/清除git历史记录大文件bfg.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><ol>\n<li><a href=\"https://search.maven.org/remote_content?g=com.madgag&amp;a=bfg&amp;v=LATEST\" target=\"_blank\" rel=\"noopener\">下载bfg</a> 到本地soft/bfg目录下。</li>\n<li>sudo vi ~/.bash_profile  添加如下：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias bfg=&quot;java -jar ~/Downloads/soft/bfg/bfg.jar&quot;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>cd 到库目录，执行bfg命令： <a href=\"https://rtyley.github.io/bfg-repo-cleaner/\" target=\"_blank\" rel=\"noopener\">bfg官网</a> </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd PBB_SSH所属目录下</span><br><span class=\"line\">$ bfg --delete-folders universal --no-blob-protection  PBB_SSH</span><br><span class=\"line\">$ cd PBB_SSH</span><br><span class=\"line\">$ git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</span><br><span class=\"line\">$ git push</span><br></pre></td></tr></table></figure>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"工具","path":"api/categories/工具.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"git","path":"api/tags/git.json"},{"name":"坑","path":"api/tags/坑.json"}]},{"title":"使用SmartSVN创建版本库","slug":"git/使用SmartSVN创建版本库","date":"2015-10-05T19:16:47.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/使用SmartSVN创建版本库.json","excerpt":null,"keywords":null,"cover":"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/adeb039a-b429-481a-ac25-2044b871e45e/screenshot.png?resizeSmall&amp;width=832","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>SmartSVN有以下版本：</p>\n<ol>\n<li>SmartSVN enterprise 9 企业版</li>\n<li>SmartSVN foundation 8 基础版</li>\n</ol>\n<p>由于企业版只能建立本地的版本库，无法创建&amp;使用svn://localhost方式。</p>\n<h4 id=\"用基础版来说明创建版本库。\"><a href=\"#用基础版来说明创建版本库。\" class=\"headerlink\" title=\"用基础版来说明创建版本库。\"></a>用基础版来说明创建版本库。</h4><p>参考：<a href=\"http://hammadk.com/how-to-create-repository-in-smartsvn-tutorial/\" target=\"_blank\" rel=\"noopener\">Create Repository in SmartSVN – Tutorial</a>  </p>\n<ol>\n<li>启动SmartSVN SmartSVN foundation 8 基础版  </li>\n<li>菜单栏Project-&gt; set up Local Repository…<br>需要设置如下两个参数：  <ol>\n<li>svnadmin 在终端执行： whereis svnadmin  </li>\n<li>svnserve 在终端执行： whereis svnserve<br>￼<img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/adeb039a-b429-481a-ac25-2044b871e45e/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\">  </li>\n</ol>\n</li>\n<li>指定版本库的目录位置：<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/a3f00903-101c-4848-a10a-3479643baea7/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\">  </li>\n<li>初始化账户密码：<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/140f257e-e452-47ea-8317-34a5ed8d6c7f/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\">  </li>\n<li>完成。<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/ed975623-72bb-4132-8d04-ac9a7b1d2fc9/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\"><br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/53306789-9d97-485c-a54d-a143e7b078f1/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\"><a id=\"more\"></a>    \n<h5 id=\"开始导入项目源码，来跟踪版本变化，实现版本控制。\"><a href=\"#开始导入项目源码，来跟踪版本变化，实现版本控制。\" class=\"headerlink\" title=\"开始导入项目源码，来跟踪版本变化，实现版本控制。\"></a>开始导入项目源码，来跟踪版本变化，实现版本控制。</h5></li>\n<li>新建SmartSVNRepos目录，存放APP源码，用于导入版本库的原始目录。导入后，该目录源码就被版本跟踪了，在开发时，不用再从版本库导出，可以用该目录的代码直接在版本上开发了。<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/ee02bf65-27e3-435a-8300-8189bc087eb8/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\"></li>\n<li>菜单栏Project -&gt; Import Into Repository…<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/eccc10f0-4c5a-435c-8397-062028d0d4f4.png?resizeSmall&amp;width=832\" alt=\"image\"></li>\n<li>选择以上新建的SmartSVN版本库：svn://localhost<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/ecfe16b4-17ac-4fc1-a64f-1ce259d77b3b/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\"> </li>\n</ol>\n<p>查看是否安装SVN服务：</p>\n<pre><code>svnserve —version\n</code></pre><p>SVN随系统一起启动：</p>\n<pre><code>vi /etc/rc.local   //(此文件Mac系统中默认是不存在的，需手动创建)\n\n添加启动SVN服务： \nsvnserve -d -r /data/svn/repos  \n</code></pre><p>关闭svn服务:</p>\n<pre><code>直接ps aux | grep svn，然后kill -9 进程号\n</code></pre><ol>\n<li><p>创建库:<br> 打印应用目录命令：</p>\n<pre><code>whereis svn\n</code></pre><p> 新建版本库目录：</p>\n<pre><code>sudo mkdir -p /data/svn/repos/local    \nchmod u+w 文件名\n</code></pre><p> 创建：</p>\n<pre><code>sudo svnadmin create /data/svn/repos/local\n查看文件权限： ls -l\n</code></pre></li>\n<li><p>配置版本库的访问权限</p>\n<pre><code>cd conf/ \n</code></pre><ol>\n<li><p>开启密码权限，普通用户/匿名用户</p>\n<pre><code>sudo vi svnserve.conf\n</code></pre></li>\n<li><p>设置用户：密码</p>\n<pre><code>sudo vi passwd\n</code></pre></li>\n<li><p>分组设置，组权限</p>\n<pre><code>sudo vi authz\n</code></pre></li>\n</ol>\n</li>\n<li><p>启动svnserve服务  </p>\n<pre><code>sudo svnserve -d -r /data/svn/repos —log-file=/var/log/svn.log\n</code></pre></li>\n<li><p>测试端口：</p>\n<pre><code>telnet localhost 3690\n</code></pre></li>\n<li><p>重启必先kill ：</p>\n<pre><code>sudo kill PID\n</code></pre></li>\n<li><p>版本库路径：</p>\n<pre><code>svn://localhost/local\n</code></pre><p>其他：</p>\n<pre><code>svn ls svn://svnpath 可以查询snv仓库内容  \nlsof -i :3690 查看svn是否启动  \nps aux | grep ‘svn’ 查找所有svn启动的进程id  \nkill -9 pid 将pid替换为上面查到的进程id可以杀掉svn进程  \n</code></pre></li>\n</ol>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"svn","path":"api/categories/svn.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"svn","path":"api/tags/svn.json"}]},{"title":"Mac安装gitLab服务器","slug":"git/Mac安装gitLab服务器","date":"2015-09-27T19:25:38.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/Mac安装gitLab服务器.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"必要配置\"><a href=\"#必要配置\" class=\"headerlink\" title=\"必要配置\"></a>必要配置</h4><pre><code>*创建一个名称为&quot;gitlab&quot;管理员用户，然后再创建一个名称为&quot;gitlab&quot;的群组\n*开启gitlab用户的远程登录\n</code></pre><p>在系统启动界面:<br>隐藏gitlab用户 </p>\n<pre><code>sudo defaults write /Library/Preferences/com.apple.loginwindow HiddenUsersList -array-add gitlab\n</code></pre><p>显示git用户</p>\n<pre><code>sudo defaults delete /Library/Preferences/com.apple.loginwindow HiddenUsersList\n</code></pre><h4 id=\"添加系统账户gitlab\"><a href=\"#添加系统账户gitlab\" class=\"headerlink\" title=\"添加系统账户gitlab\"></a>添加系统账户gitlab</h4><h6 id=\"生成gitlab服务器目录，即用户根目录\"><a href=\"#生成gitlab服务器目录，即用户根目录\" class=\"headerlink\" title=\"生成gitlab服务器目录，即用户根目录\"></a>生成gitlab服务器目录，即用户根目录</h6><p>进入<strong>系统偏好设置…</strong>,在管理<strong>用户与群组</strong>中，添加其他用户，暂时定为：gitlab ，登录密码假设为：gitlab，添加完成后，会自动在/Users目录下，生成用户根目录gitlab.</p>\n<h6 id=\"安装-Gitlab-Shell\"><a href=\"#安装-Gitlab-Shell\" class=\"headerlink\" title=\"安装 Gitlab Shell\"></a>安装 Gitlab Shell</h6><pre><code>cd /Users/gitlab\nsudo -u gitlab git clone https://github.com/gitlabhq/gitlab-shell.git\ncd gitlab-shell\nsudo -u gitlab git checkout v1.9.1\nsudo -u gitlab cp config.yml.example config.yml\n</code></pre><p>打开 config.yml,然后进行编辑<br>设置  gitlab_url. 把 gitlab.example.com 替换成你自己的域名 （如果本地就不用了）<br>把所有的/home 替换成 /Users</p>\n<pre><code>sudo -u gitlab sed -i &quot;&quot; &quot;s/\\/home\\//\\/Users\\//g&quot; config.yml\nsudo -u gitlab sed -i &quot;&quot; &quot;s/\\/usr\\/bin\\/redis-cli/\\/usr\\/local\\/bin\\/redis-cli/&quot; config.yml\n</code></pre><p>然后执行安装脚本：<code>sudo -u gitlab -H ./bin/install</code>  <strong>//需在gitlab-shell目录下载执行</strong></p>\n<h6 id=\"安装gitlab\"><a href=\"#安装gitlab\" class=\"headerlink\" title=\"安装gitlab\"></a>安装gitlab</h6><p>先下载gitlab</p>\n<pre><code>cd /Users/gitlab\nsudo -u gitlab git clone https://github.com/gitlabhq/gitlabhq.git\ncd gitlab\nsudo -u gitlab git checkout 6-7-stable\n</code></pre><p>配置gitlab</p>\n<pre><code>sudo -u gitlab cp config/gitlab.yml.example config/gitlab.yml\nsudo -u gitlab sed -i &quot;&quot; &quot;s/\\/usr\\/bin\\/git/\\/usr\\/local\\/bin\\/git/g&quot; config/gitlab.yml\nsudo -u gitlab sed -i &quot;&quot; &quot;s/\\/home/\\/Users/g&quot; config/gitlab.yml\nsudo -u gitlab sed -i &quot;&quot; &quot;s/localhost/domain.com/g&quot; config/gitlab.yml\n</code></pre><p>配置MySQL数据库，创建gitlab用户，数据库，和gitlab用户的管理权限</p>\n<pre><code># Login to MySQL\n$ mysql -u root -p\n\n# Create the GitLab production database\nmysql&gt; CREATE DATABASE IF NOT EXISTS `gitlabhq_production` DEFAULT CHARACTER SET `utf8` COLLATE `utf8_unicode_ci`;\n\n# Create the MySQL User change $password to a real password\nmysql&gt; CREATE USER &apos;gitlab&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;$password&apos;;\n\n# Grant proper permissions to the MySQL User\nmysql&gt; GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER ON `gitlabhq_production`.* TO &apos;gitlab&apos;@&apos;localhost&apos;;\n</code></pre><h6 id=\"安装-Gitolite帮助管理git内部用户\"><a href=\"#安装-Gitolite帮助管理git内部用户\" class=\"headerlink\" title=\"安装 Gitolite帮助管理git内部用户\"></a>安装 Gitolite帮助管理git内部用户</h6><p>克隆gitlab的gitolite分支源代码：</p>\n<pre><code>sudo -H -u gitlab git clone -b gl-v304 https://github.com/gitlabhq/gitolite.git /Users/gitlab/gitolite\n</code></pre><p>安装：</p>\n<pre><code>cd /Users/gitlab\nsudo -u gitlab -H mkdir bin\nsudo -u gitlab sh -c &apos;echo -e &quot;PATH=\\$PATH:/Users/gitlab/bin\\nexport PATH&quot; &gt;&gt; /Users/gitlab/.profile&apos;\nsudo -u gitlab sh -c &apos;gitolite/install -ln /Users/gitlab/bin&apos;\n\nsudo cp ~/.ssh/id_rsa.pub /Users/gitlab/gitlab.pub\nsudo chmod 0444 /Users/gitlab/gitlab.pub\n\nsudo -u gitlab -H sh -c &quot;PATH=/Users/gitlab/bin:$PATH; gitolite setup -pk /Users/gitlab/gitlab.pub&quot;\n</code></pre><p>为 Git 创建用户：    </p>\n<pre><code>sudo adduser \\\n  --system \\\n  --shell /bin/sh \\\n  --gecos &apos;git version control&apos; \\\n  --group \\\n  --disabled-password \\\n  --home /home/git \\\n  git\n</code></pre><p>若干问题解决办法：<a href=\"http://www.cnblogs.com/whj198579/archive/2013/04/09/3009350.html\" target=\"_blank\" rel=\"noopener\">Mac搭建Git服务器—开启SSH</a></p>\n<pre><code>Cloning into &apos;/tmp/gitolite-admin&apos;...\nssh: connect to host localhost port 22: Connection refused\nfatal: Could not read from remote repository.\n</code></pre><p>SSH无密码登陆设置：</p>\n<pre><code>$ cd /etc\n$ chmod 666 sshd_config\n$ vim sshd_config\n\n#PermitRootLogin yes  改为：PermitRootLogin no\n#UsePAM yes             改为: UsePAM no\n</code></pre><p>Remove the # from the following</p>\n<pre><code>#RSAAuthentication yes\n#PubkeyAuthentication yes\n#AuthorizedKeysFile     .ssh/authorized_keys    \n#PasswordAuthentication no\n#PermitEmptyPasswords no\n</code></pre>","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"gitLab","path":"api/categories/gitLab.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"git","path":"api/tags/git.json"},{"name":"gitLab","path":"api/tags/gitLab.json"}]},{"title":"如何使用gitBook协作Octopress同时完成博客和书籍","slug":"git/如何使用gitBook协作Octopress同时完成博客和书籍","date":"2015-08-11T14:41:40.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/如何使用gitBook协作Octopress同时完成博客和书籍.json","excerpt":null,"keywords":null,"cover":"https://raw.githubusercontent.com/huos3203/IOSDev/master/EAC7C104-FCE1-40CF-9766-F14C4F271FCF.png","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"将gitbook添加到github库中\"><a href=\"#将gitbook添加到github库中\" class=\"headerlink\" title=\"将gitbook添加到github库中\"></a>将gitbook添加到github库中</h4><ul>\n<li>使用gitbook新建New book，即在~/GitBook/Library/Import/yourbookName/下，创建了git库</li>\n<li>菜单：Book -&gt; Repository setting… -&gt; <img src=\"https://raw.githubusercontent.com/huos3203/IOSDev/master/EAC7C104-FCE1-40CF-9766-F14C4F271FCF.png\" alt=\"设置库路径\"></li>\n<li>使用SourceTree版本工具，添加本地的yourbookName版本库，来协助gitbook管理版本。</li>\n</ul>\n<h4 id=\"协助Octopress\"><a href=\"#协助Octopress\" class=\"headerlink\" title=\"协助Octopress\"></a>协助Octopress</h4><ul>\n<li>必须在yourBlog目录下，执行rake newe_post[‘’]创建.MarkDown文件。</li>\n<li>将第一步新建的文件，通过Gitbook的Files tree 树形栏，导入yourbookname版本库中。</li>\n<li>在gitbook的Table of Contents中新建章节，命名为第一步创建时的文件名。</li>\n<li>编辑yourbookName 版本库中的SUMMARY.md，将文件与目录关联起来，并保存SUMMARY.md。</li>\n<li>点击目录节点名，即可在编辑框内，对该md文件编辑。</li>\n</ul>\n<h4 id=\"如何将gitbook编辑的md文件内容同步到Octopress中\"><a href=\"#如何将gitbook编辑的md文件内容同步到Octopress中\" class=\"headerlink\" title=\"如何将gitbook编辑的md文件内容同步到Octopress中\"></a>如何将gitbook编辑的md文件内容同步到Octopress中</h4><ul>\n<li>方法一：拷贝gitbook编辑的md文件，覆盖到octpress的_post目录下。</li>\n<li>方法二：通过github，公用一个版本库，来管理同步。</li>\n</ul>\n<p><font color=\"red\">更新：</font>gitbook 4.2.2之后，默认将rake new_post生成的文件目录导入到~/gitbook目录中，至此，以上方法作废了。</p>\n<p>使用GitBook（<strong>版本限于4.0之前的版本</strong>） 来编写Octopress博客的步骤：  </p>\n<ol>\n<li><code>cd ~/MyBlog</code>  </li>\n<li><strong><code>rake new_post[&#39;文章名&#39;]</code></strong>或 <strong><code>rake new_page[&#39;404&#39;]</code></strong>新建md文档.  </li>\n<li><strong><code>mv *.markdown *.md</code></strong> mv命令修改后缀为md，便于gitbook在Preview website识别该文档。  </li>\n<li>配置SUMMARY.md 关联 gitbook，通过目录访问Octopress文档。  </li>\n<li>打开gitbook客户端，对新建的文档进行编写即可。</li>\n</ol>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"IDE","path":"api/categories/IDE.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"gitBook","path":"api/tags/gitBook.json"}]},{"title":"Git中的储藏工具stash","slug":"git/Git中的储藏工具stash","date":"2015-01-19T19:57:04.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/Git中的储藏工具stash.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><ol>\n<li><a href=\"#Stashing\">Stashing</a></li>\n<li><a href=\"#work\">储藏工作</a></li>\n<li><a href=\"#apply\">应用储藏</a></li>\n<li><a href=\"#applyIndex\">被暂存的文件重新暂存</a></li>\n<li><a href=\"#drop\">应用后，移除储藏的内容</a></li>\n<li><a href=\"#unapply\">取消储藏(Un-applying a Stash)</a></li>\n<li><a href=\"#stash-unapply\">新建stash-unapply别名</a></li>\n<li><a href=\"#stashBranch\">从储藏中创建分支</a></li>\n</ol>\n<h3 id=\"Git工具-储藏（Stashing）git\"><a href=\"#Git工具-储藏（Stashing）git\" class=\"headerlink\" title=\"Git工具 - 储藏（Stashing）git\"></a><a name=\"Stashing\">Git工具 - 储藏（Stashing）</a>git</h3><hr>\n<p><a href=\"https://git-scm.com/book/zh/v2/Git-工具-储藏与清理\" target=\"_blank\" rel=\"noopener\">原文</a><br>场景：当项目中某一部分正在编码中，突然接到新任务，又必须换至其他分支去完成。</p>\n<p>问题：你不想提交进行了一半的工作，否则以后你无法回到这个工作点。</p>\n<p>解决：<strong><font color=\"red\">git stash </font></strong>命令。</p>\n<p>“Stashing”可以获取工作目录的中间状态，即：将修改过的被追踪的文件和暂存的变更，保存到一个未完结变更的堆栈中，随时可以重新应用。</p>\n<h3 id=\"储藏工作\"><a href=\"#储藏工作\" class=\"headerlink\" title=\"储藏工作\"></a><a name=\"work\">储藏工作</a></h3><hr>\n<ol>\n<li>进入项目目录，修改某个文件，有可能还暂存其中的一个变更。</li>\n<li><strong><font color=\"red\">git status </font></strong>命令,查看中间状态：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\"># Changes to be committed:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   index.html</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   lib/simplegit.rb</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure></li>\n<li>切换分支，但不提交step 1 中的变更，所以储藏这些变更。<br>执行<strong><font color=\"red\">git stash </font></strong>命令，往堆栈中推送一个新的储藏：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash</span><br><span class=\"line\">Saved working directory and index state \\</span><br><span class=\"line\">  <span class=\"string\">\"WIP on master: 049d078 added the index file\"</span></span><br><span class=\"line\">HEAD is now at 049d078 added the index file</span><br><span class=\"line\">(To restore them <span class=\"built_in\">type</span> <span class=\"string\">\"git stash apply\"</span>)</span><br></pre></td></tr></table></figure></li>\n<li>执行step 2查看目录库，中间状态就不见了：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\"><span class=\"comment\">#######On branch master</span></span><br><span class=\"line\">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>\n这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。</li>\n<li>使用<strong><font color=\"red\">git stash list</font></strong>要查看现有的储藏：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash list</span><br><span class=\"line\">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class=\"line\">stash@&#123;1&#125;: WIP on master: c264051 Revert <span class=\"string\">\"added file_size\"</span></span><br><span class=\"line\">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to <span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n在这个案例中，之前已经进行了两次储藏，所以你可以访问到三个不同的储藏。<h3 id=\"应用储藏\"><a href=\"#应用储藏\" class=\"headerlink\" title=\"应用储藏\"></a><a name=\"apply\">应用储藏</a></h3></li>\n</ol>\n<hr>\n<p>执行<strong><font color=\"red\">git stash apply</font></strong>命令, 可以重新应用最近的一次储藏；<br>执行<strong><font color=\"red\">git stash apply stash@{2}</font></strong>命令，即通过指定储藏的名字，来应用更早的储藏。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash apply</span><br><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   index.html</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   lib/simplegit.rb</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure><br><a id=\"more\"></a><br>可以看到 Git 重新修改了你所储藏的那些当时尚未提交的文件。在这个案例里，你尝试应用储藏的工作目录是干净的，并且属于同一分支；但是一个干净的工作目录和应用到相同的分支上并不是应用储藏的必要条件。你可以在其中一个分支上保留一份储藏，随后切换到另外一个分支，再重新应用这些变更。在工作目录里包含已修改和未提交的文件时，你也可以应用储藏——Git 会给出归并冲突如果有任何变更无法干净地被应用。</p>\n<h3 id=\"被暂存的文件重新暂存\"><a href=\"#被暂存的文件重新暂存\" class=\"headerlink\" title=\"被暂存的文件重新暂存\"></a><a name=\"applyIndex\">被暂存的文件重新暂存</a></h3><hr>\n<p>执行<strong><font color=\"red\">git stash apply</font></strong>命令,虽然对文件的变更被重新应用，但是被暂存的文件没有重新被暂存。<br>执行<strong><font color=\"red\">git stash apply –index</font></strong>命令,即可让被暂存的文件重新暂存。<br><strong>–index</strong>选项告诉命令重新应用被暂存的变更：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash apply --index</span><br><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\"># Changes to be committed:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   index.html</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   lib/simplegit.rb</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"应用后，移除储藏的内容\"><a href=\"#应用后，移除储藏的内容\" class=\"headerlink\" title=\"应用后，移除储藏的内容\"></a><a name=\"drop\">应用后，移除储藏的内容</a></h3><hr>\n<p><strong>apply </strong>选项只尝试应用储藏的工作——储藏的内容仍然在栈上。<br>执行<strong><font color=\"red\">git stash drop 储藏的名字</font></strong>命令，，即可从栈中彻底移除储藏内容：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash list</span><br><span class=\"line\">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class=\"line\">stash@&#123;1&#125;: WIP on master: c264051 Revert <span class=\"string\">\"added file_size\"</span></span><br><span class=\"line\">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to <span class=\"built_in\">log</span></span><br><span class=\"line\">$ git stash drop stash@&#123;0&#125;</span><br><span class=\"line\">Dropped stash@&#123;0&#125; (364e91f3f268f0900bc3ee613f9f733e82aaed43)</span><br></pre></td></tr></table></figure><br>你也可以运行 <strong><font color=\"red\">git stash pop</font></strong>命令，来重新应用储藏，同时立刻将其从堆栈中移走。</p>\n<h3 id=\"取消储藏-Un-applying-a-Stash\"><a href=\"#取消储藏-Un-applying-a-Stash\" class=\"headerlink\" title=\"取消储藏(Un-applying a Stash)\"></a><a name=\"unapply\">取消储藏(Un-applying a Stash)</a></h3><hr>\n<p>在某些情况下，重新应用了之前的储藏的变更，进行了一些其他的修改后，又想要取消之前所应用储藏的修改。<br>Git没有提供类似于 <strong><font color=\"red\">stash unapply</font></strong>的命令，但是可以通过取消该储藏的补丁达到同样的效果：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash show -p stash@&#123;0&#125; | git apply -R</span><br></pre></td></tr></table></figure><br>同样的，如果你沒有指定具体的某个储藏，Git 会选择最近的储藏：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash show -p | git apply -R</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"新建stash-unapply别名\"><a href=\"#新建stash-unapply别名\" class=\"headerlink\" title=\"新建stash-unapply别名\"></a><a name=\"stash-unapply\">新建stash-unapply别名</a></h4><hr>\n<p>你可能会想要新建一个別名，在你的 Git 里增加一个<strong><font color=\"red\">stash-unapply</font></strong> 命，这样更有效率。例如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global alias.stash-unapply <span class=\"string\">'!git stash show -p | git apply -R'</span></span><br><span class=\"line\">$ git stash apply</span><br><span class=\"line\">$ <span class=\"comment\">#... work work work</span></span><br><span class=\"line\">$ git stash-unapply</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"从储藏中创建分支\"><a href=\"#从储藏中创建分支\" class=\"headerlink\" title=\"从储藏中创建分支\"></a><a name=\"stashBranch\">从储藏中创建分支</a></h3><hr>\n<p>如果你储藏了一些工作，暂时不去理会，然后继续在你储藏工作的分支上工作，你在重新应用工作时可能会碰到一些问题。如果尝试应用的变更是针对一个你那之后修改过的文件，你会碰到一个归并冲突并且必须去化解它。如果你想用更方便的方法来重新检验你储藏的变更，你可以运行 git stash branch，这会创建一个新的分支，检出你储藏工作时的所处的提交，重新应用你的工作，如果成功，将会丢弃储藏。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash branch testchanges</span><br><span class=\"line\">Switched to a new branch <span class=\"string\">\"testchanges\"</span></span><br><span class=\"line\"><span class=\"comment\"># On branch testchanges</span></span><br><span class=\"line\"><span class=\"comment\"># Changes to be committed:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   index.html</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   lib/simplegit.rb</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">Dropped refs/stash@&#123;0&#125; (f0dfc4d5dc332d1cee34a634182e168c4efc3359)</span><br></pre></td></tr></table></figure><br>这是一个很棒的捷径来恢复储藏的工作然后在新的分支上继续当时的工作。</p>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"工具","path":"api/categories/工具.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"git","path":"api/tags/git.json"},{"name":"坑","path":"api/tags/坑.json"}]}]}