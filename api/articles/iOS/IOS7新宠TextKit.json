{"title":"IOS7新宠Text Kit","slug":"iOS/IOS7新宠TextKit","date":"2014-06-16T22:24:48.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/IOS7新宠TextKit.json","excerpt":"Text KitText Kit：是个庞大的framework，继承了Core Text的全部功能，构建了快速、先进的文本排版和渲染引擎，更让开发者们高兴的是，设计者把它封装在了一个面向对象的API中。并且与UIKit框架很好的集成，它让程序能够通过NSTextStorage对象存储文本排版和显示文本等主要信息，并支持排版所需要的所有特性，包括字距调整、连写、换行和对齐等。  更直观的理解，UITextView，UITextField、UILabel等UIKit控件都已经基于Text Kit重新构建，是为UIKit框架提供高质量排版服务而扩展的一些类和协议.<br>例如：NSTextStorage对象，它本身是NSMutableAttributedString的子类，支持分批编辑，这就意味着在改变一个范围内的字符样式时，不用整体替换文本内容，就能完成排版效果。其中支持分页文本、文本包装、富文本编辑、交互式文本着色、文本折叠和自定义截取等特性。  IOS6之前，想实现一些丰富的文本排版，例如在textView中显示不同样式的文本，或者图片和文字混排等，就需要借助于UIWebView或者深入研究一下Core Text。后来iOS6，增加一个很棒的属性:NSAttributedString，主要用于支持UILabel、UITextField、UITextView等UIKit控件自主排版的功能。很显然，IOS7并没有满足于这一改进，同时推出一款功能更为齐全，易用的Text Kit新宠。<br>在iOS 6中, 用于文本的UIKit控件是基于WebKit和Core Graphics的字符串绘制方法来实现的。如下面层级体系图所示：<br> [Figure] ","covers":["http://p27uwfdhv.bkt.clouddn.com/static/images/TextRenderingArchitecture-iOS6.png?imageMogr2/2/w/800","http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit_obj.jpg?imageMogr2/2/w/800","http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit_obj1.jpg?imageMogr2/2/w/800","http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit_obj2.jpg?imageMogr2/2/w/800","http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit_obj3.jpg?imageMogr2/2/w/800","http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit.jpg?imageMogr2/2/w/800","http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit_gif.gif)</li>?imageMogr2/2/w/800"],"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><script src=\"/assets/js/APlayer.min.js\"> </script><h2 id=\"Text-Kit\"><a href=\"#Text-Kit\" class=\"headerlink\" title=\"Text Kit\"></a>Text Kit</h2><p><strong><code>Text Kit</code></strong>：是个庞大的framework，继承了<code>Core Text</code>的全部功能，构建了快速、先进的文本排版和渲染引擎，更让开发者们高兴的是，设计者把它封装在了一个面向对象的API中。并且与UIKit框架很好的集成，它让程序能够通过<strong>NSTextStorage</strong>对象存储文本排版和显示文本等主要信息，并支持排版所需要的所有特性，包括字距调整、连写、换行和对齐等。  </p>\n<blockquote>\n<font size=\"3\">更直观的理解，<strong>UITextView</strong>，<strong>UITextField</strong>、<strong>UILabel</strong>等UIKit控件都已经基于<strong>Text Kit</strong>重新构建，是为UIKit框架提供高质量排版服务而扩展的一些类和协议.<br>例如：NSTextStorage对象，它本身是<strong>NSMutableAttributedString</strong>的子类，支持分批编辑，这就意味着在改变一个范围内的字符样式时，不用整体替换文本内容，就能完成排版效果。其中支持分页文本、文本包装、富文本编辑、交互式文本着色、文本折叠和自定义截取等特性。</font>  \n\n</blockquote>\n<p>IOS6之前，想实现一些丰富的文本排版，例如在textView中显示不同样式的文本，或者图片和文字混排等，就需要借助于UIWebView或者深入研究一下<code>Core Text</code>。后来iOS6，增加一个很棒的属性:<code>NSAttributedString</code>，主要用于支持UILabel、UITextField、UITextView等UIKit控件自主排版的功能。很显然，IOS7并没有满足于这一改进，同时推出一款功能更为齐全，易用的<code>Text Kit</code>新宠。<br>在iOS 6中, 用于文本的UIKit控件是基于WebKit和Core Graphics的字符串绘制方法来实现的。如下面层级体系图所示：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextRenderingArchitecture-iOS6.png?imageMogr2/2/w/800\"><br>iOS 7的整体构架要更清晰，所有基于文本的UIKit控件（除了UIWebView）现在都可以使用Text Kit，如下图所示：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextRenderingArchitecture-iOS7.png?imageMogr2/2/w/800\"></p>\n<a id=\"more\"></a>\n<h2 id=\"Text-Kit中4个重要的角色\"><a href=\"#Text-Kit中4个重要的角色\" class=\"headerlink\" title=\"Text Kit中4个重要的角色\"></a>Text Kit中4个重要的角色</h2><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit_obj.jpg?imageMogr2/2/w/800\">\n<ul>\n<li><ul>\n<li><strong><code>Text Views</code></strong>: 用来显示文本内容的控件，主要包括<code>UILabel</code>、<code>UITextView</code>和<code>UITextField</code>。  </li>\n</ul>\n</li>\n<li><ul>\n<li><strong><code>Text containers</code></strong>: 对应着<code>NSTextContainer</code>类。<code>NSTextContainer</code>定义了文本可以排版的区域。一般来说，都是矩形区域，当然，也可以根据需求，通过子类化<code>NSTextContainer</code>来创建别的一些形状，例如圆形、不规则的形状等。<code>NSTextContainer</code>不仅可以创建文本可以填充的区域，它还维护着一个数组——该数组定义了一个区域，排版的时候文字不会填充该区域，因此，我们可以在排版文字的时候，填充非文本元素。    </li>\n</ul>\n</li>\n<li><ul>\n<li><strong><code>Layout manager</code></strong>: 对应着<code>NSLayoutManager</code>类。该类负责对文字进行编辑排版处理——通过将存储在<code>NSTextStorage</code>中的数据转换为可以在视图控件中显示的文本内容，并把统一的字符编码映射到对应的字形(<code>glyphs</code>)上，然后将字形排版到<code>NSTextContainer</code>定义的区域中。  </li>\n</ul>\n</li>\n<li><ul>\n<li><strong><code>Text storage</code></strong>: 对应着<code>NSTextStorage</code>类。该类定义了<code>Text Kit</code>扩展文本处理系统中的基本存储机制。<code>NSTextStorage</code>继承自<code>NSmutableAttributedString</code>，主要用来存储文本的字符和相关属性。另外，当<code>NSTextStorage</code>中的字符或属性发生了改变，会通知<code>NSLayoutManager</code>，进而做到文本内容的显示更新。<br>通常情况下，<strong><code>NSTextStorage</code></strong>、<strong><code>NSLayoutManager</code></strong>和<strong><code>NSTextContainer</code></strong>是一一对应关系:  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit_obj1.jpg?imageMogr2/2/w/800\">\n如果将文字显示为多列，或多页，可以按照下图关系，使用多个<strong><code>NSTextContainer</code></strong>:<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit_obj2.jpg?imageMogr2/2/w/800\">\n如果针对不同的排版方式，可以按照下图关系，使用多个<strong><code>NSLayoutManager</code></strong>:<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit_obj3.jpg?imageMogr2/2/w/800\">\n通常由<strong><code>NSLayoutManager</code></strong>从<strong><code>NSTextStorage</code></strong>中读取出文本数据，然后根据一定的排版方式，将文本排版到<strong><code>NSTextContainer</code></strong>中，再由<strong><code>NSTextContainer</code></strong>结合<code>UITextView</code>将最终效果显示出来。<br>如下图，为了更直观理解，对<code>UITextView</code>的组成做了分解: <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit.jpg?imageMogr2/2/w/800\">\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Text-Kit示例\"><a href=\"#Text-Kit示例\" class=\"headerlink\" title=\"Text Kit示例\"></a>Text Kit示例</h2><ol>\n<li>打开Xcode 5，新建一个Single View Application模板的程序，将工程命名为ExclusionPath。</li>\n<li>打开Main.storyboard文件，然后再默认View Controller的View里面分别添加一个UITextView和UIImageView。并将这两个控件连接到ViewController.h中(名称分别为textView何imageView)。然后给textView设置一些字符串，imageView设置一个图片。</li>\n<li><ol>\n<li>打开ViewController.m文件，找到viewDidLoad方法，用如下代码替换该方法：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建一个平移手势对象，该对象可以调用imagePanned：方法</span></span><br><span class=\"line\">    <span class=\"built_in\">UIPanGestureRecognizer</span> *panGes = [[<span class=\"built_in\">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(imagePanned:)];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.imageView addGestureRecognizer:panGes];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.textView.textContainer.exclusionPaths = @[[<span class=\"keyword\">self</span> translatedBezierPath]];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n在上面的代码中，给imageView添加了一个平移手势。另外通过调用translatedBezierPath方法，给textView的textContainer设置exclusionPaths属性值。表示需要排除的区域（也就是图片在排版中显示的位置）。  </li>\n</ol>\n</li>\n<li><ol>\n<li><strong>translatedBezierPath</strong>方法实现如下：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIBezierPath</span> *)translatedBezierPath</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGRect</span> butterflyImageRect = [<span class=\"keyword\">self</span>.textView convertRect:<span class=\"keyword\">self</span>.imageView.frame fromView:<span class=\"keyword\">self</span>.view];</span><br><span class=\"line\">    <span class=\"built_in\">UIBezierPath</span> *newButterflyPath = [<span class=\"built_in\">UIBezierPath</span> bezierPathWithRect:butterflyImageRect];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> newButterflyPath;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n在上面的代码中，利用imageView的frame属性创建了一个UIBezierPath，然后将该值返回。  </li>\n</ol>\n</li>\n<li><ol>\n<li><strong>imagePanned:</strong>方法实现如下：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)imagePanned:(<span class=\"keyword\">id</span>)sender</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([sender isKindOfClass:[<span class=\"built_in\">UIPanGestureRecognizer</span> <span class=\"keyword\">class</span>]]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">UIPanGestureRecognizer</span> *localSender = sender;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (localSender.state == <span class=\"built_in\">UIGestureRecognizerStateBegan</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.gestureStartingPoint = [localSender translationInView:<span class=\"keyword\">self</span>.textView];</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.gestureStartingCenter = <span class=\"keyword\">self</span>.imageView.center;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (localSender.state == <span class=\"built_in\">UIGestureRecognizerStateChanged</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">CGPoint</span> currentPoint = [localSender translationInView:<span class=\"keyword\">self</span>.textView];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">CGFloat</span> distanceX = currentPoint.x - <span class=\"keyword\">self</span>.gestureStartingPoint.x;</span><br><span class=\"line\">            <span class=\"built_in\">CGFloat</span> distanceY = currentPoint.y - <span class=\"keyword\">self</span>.gestureStartingPoint.y;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">CGPoint</span> newCenter = <span class=\"keyword\">self</span>.gestureStartingCenter;</span><br><span class=\"line\"></span><br><span class=\"line\">            newCenter.x += distanceX;</span><br><span class=\"line\">            newCenter.y += distanceY;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.imageView.center = newCenter;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.textView.textContainer.exclusionPaths = @[[<span class=\"keyword\">self</span> translatedBezierPath]];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (localSender.state == <span class=\"built_in\">UIGestureRecognizerStateEnded</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.gestureStartingPoint = <span class=\"built_in\">CGPointZero</span>;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.gestureStartingCenter = <span class=\"built_in\">CGPointZero</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n在上面的代码中首先根据平移的距离来设置imageView的位置，然后利用<code>translatedBezierPath</code>方法重新计算了一下排除区域。<br>示例效果:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit_gif.gif)</li>?imageMogr2/2/w/800\"></li></ol></li></ol>","categories":[{"name":"iOS","path":"api/categories/iOS.json"}],"tags":[{"name":"TextKit","path":"api/tags/TextKit.json"},{"name":"概念","path":"api/tags/概念.json"}]}