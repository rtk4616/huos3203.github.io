{"name":"协议","postlist":[{"title":"小米路由常用操作","slug":"小米路由常用操作","date":"2015-09-25T23:59:16.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/小米路由常用操作.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h4><ol>\n<li><p>ssh登录</p>\n<pre><code>局域网登录:\nssh [user@]hostname [command]\n 例如：ssh root@192.168.31.1  或  远程登录：ssh root@222.35.145.28 -p 2195\n回车\n输入密码\n\n**修改密码：**\nroot@xiaoqiang:~#passwd   \n回车\n输入新密码\n回车\n再次输入新密码\n</code></pre></li>\n<li><p>远程拷贝数据</p>\n<pre><code>scp Desktop/ar71xx/* root@192.168.31.1:/userdisk/myWorkspace/ar71xx\n</code></pre></li>\n<li><p>每次重启路由获取IP:</p>\n<pre><code>vi /etc/rc.local\nsh /etc/getIP.sh\n</code></pre><p>//启动后，等待20秒，然后，获取当前时间作为文件名称<br>//使用ifconfig 获取路由器的ip信息<br>//使用 | grep 通道，和grep正则来过滤出，wan口的ip所在行<br>// &gt; 使用重定向，将过滤的ip行，写入路由硬盘/userdisk/data/my/ip目录中<br>//通过小米路由手机客户端，找到该txt文件，并下载到手机sd卡中<br>//查看该文件，既有路由重启后的当前IP  </p>\n<a id=\"more\"></a>\n<p> 详见getIP.sh</p>\n<pre><code>#!/bin/sh\nsleep 20\ncurrent_date=`date +%Y_%m_%d`\ncurrent_time=`date +%H_%M_%S`\necho $current_date\necho $current_time\n#local_ip=`ifconfig |grep &apos;[0-9]\\{1,3\\}.*P-t-P&apos;`\nlocal_ip=`ifconfig | grep P-t-P`\necho $local_ip &gt; /userdisk/data/my/ip/$current_date:$current_time.txt\n</code></pre></li>\n<li><p>修改防火墙设置<strong>/etc/config</strong>目录下的<strong>dropbear</strong>和<strong>firewall</strong>  </p>\n<pre><code>cd /etc/config  //把备份文件内容覆盖新文件即可\n1.cat dropbear.bak &gt; dropbear  \n    增加如下内容：\n    config dropbear\n    option PasswordAuth &apos;on&apos;\n    option RootPasswordAuth &apos;on&apos;\n    option Interface &apos;wan&apos;\n    option Port &apos;2195&apos;\n2.保存文件修改后，再重启dropbear服务，一次输入下面两行命令：\n    /etc/init.d/dropbear reload\n    /etc/init.d/dropbear restart\n1.cat firewall.bak &gt; firewall\n    增加如下内容： \n    config rule\n    option name &apos;Allow-wan-ssh&apos;\n    option src &apos;wan&apos;\n    option proto &apos;tcp&apos;\n    option dest_port &apos;2195&apos;\n    option target &apos;ACCEPT&apos;\n2.保存文档的更改后，重启防火墙服务，依次输入以下两条命令：\n    /etc/init.d/firewall reload\n    /etc/init.d/firewall restart\n</code></pre></li>\n</ol>\n<p>5.由于铁通机制，分配的独立iP，并不能被外网访问</p>\n<h4 id=\"ssh登录数据库-转\"><a href=\"#ssh登录数据库-转\" class=\"headerlink\" title=\"ssh登录数据库    转\"></a>ssh登录数据库    <a href=\"http://bbs.xiaomi.cn/thread-10339070-1-1.html\" target=\"_blank\" rel=\"noopener\">转</a></h4><p>先确保能访问<a href=\"http://192.168.31.1:8088/phpinfo.php\" target=\"_blank\" rel=\"noopener\">LLMP搭建的个人网站地址</a>  </p>\n<p>修复教程：  </p>\n<ol>\n<li>登录路由： <code>ssh root@192.168.31.1</code>  mm:admin</li>\n<li>执行命令：<code>/userdisk/data/lamp.sh fix</code>  </li>\n<li><p>再次访问个人网站地址。  <a href=\"http://192.168.31.1:8088/phpinfo.php\" target=\"_blank\" rel=\"noopener\">LLMP搭建的个人网站地址</a> 。 </p>\n<pre><code>1./userdisk/data/lamp.sh  (安装本插件，一键开启llmp，具体安装过程可见前面的安装步骤）       \n2./userdisk/data/lamp.sh a（卸载本插件，恢复安装前，注：卸载本插件时路由器会自动重启一次，自动断网几分钟）\n3./userdisk/data/lamp.sh fix（升级小米路由器固件后，能瞬间恢复自己搭建的网站功能，另外，如果在极特殊的情况的情况下，本功能无效，可使用如下方法恢复自建网站的功能：先尝试重新安装本插件，如果提示不能重复安装，可先卸载本插件，再重新安装本插件，并按说明3对数据库执行修改密码命令，改回原来的密码，原来自己搭建网站就可恢复使用）\n4./userdisk/data/lamp.sh help  (插件用法的帮助信息）\n</code></pre></li>\n</ol>\n<p>登录数据库：<code>ssh mysql@192.168.31.1 -p 2222</code></p>\n<p>正确日志：</p>\n<pre><code>AdmindeMacBook-Air:~ admin$ ssh mysql@192.168.31.1 -p 2222\nThe authenticity of host &apos;[192.168.31.1]:2222 ([192.168.31.1]:2222)&apos; can&apos;t be established.\nRSA key fingerprint is SHA256:bLH9smUb7sD9CZLWCsT6t9YqPy2jciznepkscFNd59M.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added &apos;[192.168.31.1]:2222&apos; (RSA) to the list of known hosts.\nmysql@192.168.31.1&apos;s password:admin\n\nBusyBox v1.19.4 (2015-05-08 18:41:26 CST) built-in shell (ash)\nEnter &apos;help&apos; for a list of built-in commands.\n\n    ~ $\n</code></pre><p>错误日志：<br>需要修改本地的ssh配置。</p>\n<ol>\n<li>vi /Users/admin/.ssh/known_hosts文件</li>\n<li>删除包含[192.168.31.1]:2222的一行内容。</li>\n<li><p>重新登录数据库：ssh mysql@192.168.31.1 -p 2222。  </p>\n<pre><code>AdmindeMacBook-Air:~ admin$ ssh mysql@192.168.31.1 -p 2222\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nSHA256:bLH9smUb7sD9CZLWCsT6t9YqPy2jciznepkscFNd59M.\nPlease contact your system administrator.\nAdd correct host key in /Users/admin/.ssh/known_hosts to get rid of this message.\nOffending RSA key in /Users/admin/.ssh/known_hosts:10\nRSA host key for [192.168.31.1]:2222 has changed and you have requested strict checking.\nHost key verification failed.\n</code></pre></li>\n</ol>\n<h5 id=\"客户端MySQLWorkbench无法连接LLMP个人网站的MySql数据库\"><a href=\"#客户端MySQLWorkbench无法连接LLMP个人网站的MySql数据库\" class=\"headerlink\" title=\"客户端MySQLWorkbench无法连接LLMP个人网站的MySql数据库\"></a>客户端MySQLWorkbench无法连接LLMP个人网站的MySql数据库</h5>","raw":null,"categories":[{"name":"shell","path":"api/categories/shell.json"},{"name":"路由器","path":"api/categories/路由器.json"}],"tags":[{"name":"小米路由","path":"api/tags/小米路由.json"},{"name":"SSH","path":"api/tags/SSH.json"},{"name":"协议","path":"api/tags/协议.json"}]},{"title":"XMPP简单研究[转]","slug":"开源库/XMPP简单研究[转]","date":"2015-01-06T14:36:06.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/开源库/XMPP简单研究[转].json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>最近想做一个游戏服务器和 IM 互通的服务。最初的想法是可以增进游戏帐号的安全，比如游戏用户可以通过绑定一个 IM 帐号，从而不用登陆游戏就向游戏服务器发一些指令。这些指定通常是用来冻结一些帐号的功能。而游戏服务器也可以通过 IM 帐号向离线用户发送一些关键消息。这样，只需要解除绑定 IM 帐号需要一定的时间，或使用更安全的途径，即可以让游戏帐号更加安全。（至少，游戏用户可以从 IM 上获知他的游戏帐号每次登陆登出的时间、IP 等等）</p>\n<p>后来细想，这里面可以做的东西还有许多。玩家会因为多一个信息通道，而更轻松的去玩那些需要长期驻留的游戏。游戏厂商也可以多一个挽留玩家的渠道，甚至用来宣传新游戏或游戏的增值服务，等等。好处不再列举。</p>\n<p>其实、绑定 IM 帐号和绑定手机号本质上区别不大。只不过，IM 帐号几乎是零费用，又不像 SMS ，控制权掌控在移动手里。IM 更适合做双向交流（SMS 的双向交流不那么方便，而且对用户和游戏运营商都有经济负担）。独立提供一个 Game2IM 的服务供众多游戏运营商使用也是个有趣的主意。和 SMS 一样，只要给出一个简单接口让游戏运营商调用，把游戏网络和 IM 网络互联就可以了。</p>\n<p>实现这个想法有两个方案。其一是制作各种 IM 的机器人，通过机器人和用户 IM 沟通。这个方案技术门槛稍低，有许多现成的机器人可以使用。缺点是，受 IM 提供商的限制（比如好友数量限制）。无法使用机器人的签名针对性的向用户传递特有的消息。除非你为每个游戏用户定制一个机器人，但那样，每个机器人都需要单独一个连接，对资源消耗过大。<br>￼<!--显示文章缩略部分的标记方法--><br><a id=\"more\"></a><br>第二个方案就是使用已有的 IM 互通方案，自己提供一个特有的 Game-IM 网络，跟已有的 IM 网络互通。比较流行的 IM 互通协议用基于 SIP 的 SIMPLE 和起源于 Jabber 的 XMPP 。</p>\n<p>我最常用的 IM 是 google talk ，本身就实现了标准的 XMPP Client 和 XMPP Server 协议；而我们的 网易 popo 也实现了 XMPP 的 s2s 网关。我想研究一下 XMPP 是个不错的选择。</p>\n<p>花了一整天的时间，把 XMPP 核心协议 仔细通读了一遍，收获颇多。原来以为 XMPP 是个可怕的巨无霸。我对 XML 原本也没有太多好感。最后，看法有所改变。</p>\n<p>其实，XMPP 仅仅是定义了一个网络服务间相互通讯的协议。它已经把服务间需要关心的东西减少到了最少。具体的应用每家服务提供商可以随意扩展。popo 在制作新版本时，我曾多次建议采用已有的标准协议，再此基础上开发自己的东西。当时或许大家都认为标准协议容易促手促脚，我当时也没啥研究，没有多言。今天看来，我更觉得这是一个决策失误。本来我们有一个很好的机会，利用 popo 联系起网易的各种服务，现在这条路将走的更为艰辛。其实，XMPP 定义的东西，即使自己去设计也会定义出类似的一套来。而把各种网络服务互通本该是发展的重点，为 IM Client 增添专有花哨的特性就有些舍本逐末了。更为恼火的是，popo 到现在也没有一个很好的非 Windows 平台解决方案。怎能让诸多把握着互联网上部分话语权的技术人士接受？（或者，同在杭州的 IT 圈子，popo 的开发人员是不是应该看看支付宝的同行们做了些什么？）</p>\n<p>谈谈我对 XMPP 的粗浅理解。这些仅仅建立在我对 RFC3920 的一天阅读的基础上，难免会有错误，不足以做技术参考。</p>\n<p>XMPP 抽象出一个在互联网上唯一的对象实体，用 JID 来表达。通常一个 JID 由三部分组成，node@domain/resource 。比 email 的表达形式多了一个 /resource 。这是因为 email 地址本身虽然可以表达一个实体，都是往往不够表达这个实体下的具体服务。就好比一个 ip 地址可以表示一台机器，但是我们还需要 port 号来表达这台机器具体提供的服务一样。</p>\n<p>用过 gtalk 的人应该很喜欢 gtalk 可以在不同的地方同时登陆这个不错的特性。用过以后，才能体会，无论是 qq 还是 msn 还是 popo ，只允许一个登陆是多么愚蠢的设定。gtalk 其实遵守了标准的 XMPP 协议，它用来区别一个帐号（一般是一个 gmail 邮件地址）的多处登陆，正是利用了不同的 resource 标识。</p>\n<p>XMPP 规范的最重要的一条通信协议就是，如何把消息从一个 JID 发送到另一个 JID (message)。这有点像 email 协议，但不同的是，它强调了实时性和安全性（虽然不是必须的）。因为 JID 可以在不同的 domain 下，这就需要 domain 间相互协作。对于 IM 网络来说（XMPP 远不只用于 IM 协议），就是不同的 IM 服务间互通。</p>\n<p>对于 domain 下的 xmpp 服务的发现，利用了 DNS 协议的一些功能。xmpp 的 s2s 服务提供位置，放在了 DNS 的 SRV 记录里。你可以用 nslookup 做个试验，启动 nslookup ，输入 set type=SRV</p>\n<p>然后查询 _xmpp-server._tcp.gmail.com 你会发现 gmail.com 的 xmpp s2s 服务地址已经端口号 5269 。同样，也可以查询 _xmpp-server._tcp.163.com 或 _xmpp-server._tcp.popo.163.com 查到网易 popo 的 xmpp 中转服务器地址。</p>\n<p>btw, 查询 _xmpp-client._tcp.gmail.com 可以查到 gtalk 的 client 登陆地址，而网易 popo 则没有提供 xmpp client 登陆点。</p>\n<p>按 RFC3920 所述，在 xmpp server 互联的时候，会优先尝试获取 domain 的 SRV 记录，如果失败就直接去连默认的 6259 端口。然后就可以开始握手协议。</p>\n<p>xmpp 比较强调 s2s 的安全性，所以推荐的握手都是建立在 TLS 层之上，使用 SASL 认证。TLS 层需要服务器有一个数字证书，为了安全可信，建议是找个根证书签名。不过自己签名也行，只需要服务器缓存证书即可。握手过程在 RFC3920 中描述的非常细致，可以按照其编码，问题不大。需要注意的是，这里的 XML 流格式要求很精确，不允许传输多余的东西。我一度认为采用 XML 会导致协议的实现上非常臃肿，其实不然。采用 XML 只是一个表象，适合人阅读和调错而已。RFC 中特别要求不去实现 XML 中的某某特性就是一例。我们不应该为了 XML 而去 XML 。</p>\n<p>其实 XMPP 的 c2s 和 s2s 并无太大区别，s2s 做的人手我想是因为开源项目和开源库比较少吧。而开源的 client 实现则是一大堆。c2s 和 s2s 的通讯都是基于那几条协议而已，s2s 的实现难点在于握手比较复杂（其实 c2s 也一样，只是很多库帮你做好了）。c2s 是共享一个 tcp 连接做双向通讯；而 s2s 则是用两条 TCP 连接。两条连接也一定程度上避免了 s2s 的欺骗，当然真正的安全来至于 TLS 和 SASL 的保障。DNS 毕竟是一个很脆弱的东西。</p>\n<p>除了点对点消息外，XMPP 定义了消息的组播。也就是一个 JID 可以以自己的名义发布消息 (presence)。而服务器来决定该发给谁。发送目标是由订阅消息决定的。其它多个 JID 可以订阅某个 JID 的消息。对于 IM 来说，最常用的就是上线下线等状态变化消息了。</p>\n<p>第三条即是对某个 JID 的状态进行设置和获取 (iq)。于 IM 应用来说，设置签名，昵称，状态等都依赖于它。</p>\n<p>XMPP 的核心协议无非规定了以上三种通讯协议，此外规范了服务器间互连的握手认证方案。然后给出了一些错误信息的表述方法。稍微了解过之后，很容易编写。如果希望重造轮子的话，对于 C 语言开发者来说，最繁琐的可能是 XML 的解析于生成。我自己稍微考察了一下，有个叫 LoudMouth 的库还不错。</p>\n<p>如果实现 s2s 网关的话，有些细节做起来可能很麻烦，比如查询 DNS 的 SRV 记录。这个在 jabberd 1.x 里其实有独立的模块实现好了，取来用即可 (见 dnsrv) 。而 TLS SASL 层的实现则早就有现成的开源库了。</p>\n<p>实现一个 jabber server 或许比你想象的还简单。in.jabberd 居然只用 600 多行 C 代码就从零实现了一个 jabber 服务器。当然功能非常的简陋了。</p>\n<p>至于我想做的东西，我希望一个在名为 xyz 的梦幻西游服务器上的 12345 号玩家，一旦选择绑定他的 popo 帐号 player@popo.163.com ，他在他的 popo 上就会收到名叫 12345.xyz@xyq.163.com 的好友请求。当他通过好友认证后，就可以从这个通道获取游戏里的信息，也可以对游戏帐号做有限的操作。我想有了这样一项服务，对玩家对运营商都会有极大的好处的。<br>其他资源：<br><a href=\"http://www.ibm.com/developerworks/cn/xml/tutorials/x-realtimeXMPPtut/\" target=\"_blank\" rel=\"noopener\">使用 XMPP 构建一个基于 web 的通知工具\n</a></p>\n","raw":null,"categories":[{"name":"开源库","path":"api/categories/开源库.json"}],"tags":[{"name":"协议","path":"api/tags/协议.json"},{"name":"socket","path":"api/tags/socket.json"}]},{"title":"在IOS中自定义URL Schemes 教程","slug":"iOS/在IOS中自定义URLSchemes教程","date":"2014-08-28T20:32:48.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/在IOS中自定义URLSchemes教程.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2.gif?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"URL-Schemes\"><a href=\"#URL-Schemes\" class=\"headerlink\" title=\"URL Schemes\"></a>URL Schemes</h4><p>iPhone SDK中最酷的功能之一是一个应用程序能够把自己和自定义的URL协议绑定，这个URL协议可用于启动该应用程序（通过浏览器或者iPhone上的另一个程序）。创建这样的绑定并不难，难得的是你忍不住要在你的程序里用它！</p>\n<p>首先，你需要说明你想如何在程序中响应这个URL。最简单的自定义协议的方法是“唤醒”，而且可以通过URL把数据信息传递给程序，这样，程序被唤醒后能做更多的事情。</p>\n<h4 id=\"注册自定义URL协议\"><a href=\"#注册自定义URL协议\" class=\"headerlink\" title=\"注册自定义URL协议\"></a>注册自定义URL协议</h4><p>首先需要向iPhone注册一个自定义URL协议。这是在你的项目文件夹的info.plist文件进行的（就是你改变应用程序图标的同一个文件）。</p>\n<p>默认，Xcode在图形窗口中打开info.pllist，当然也可以直接用文本模式打开——对有的人来说这反而更简单。</p>\n<h6 id=\"Step1-右键，选择“Add-Row”-在下拉选框中选择“URL-types”，类型为Array\"><a href=\"#Step1-右键，选择“Add-Row”-在下拉选框中选择“URL-types”，类型为Array\" class=\"headerlink\" title=\"Step1. 右键，选择“Add Row”,在下拉选框中选择“URL types”，类型为Array:\"></a>Step1. 右键，选择“Add Row”,在下拉选框中选择“<strong>URL types</strong>”，类型为Array:</h6><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2.gif?imageMogr2/2/w/800\">\n<h6 id=\"Step2-打开“Item-0″类型为Dic-添加新key为”URL-identifier”-类型为String。可以是任何值，但建议用“反域名”-例如-“com-myapp”-。\"><a href=\"#Step2-打开“Item-0″类型为Dic-添加新key为”URL-identifier”-类型为String。可以是任何值，但建议用“反域名”-例如-“com-myapp”-。\" class=\"headerlink\" title=\"Step2. 打开“Item 0″类型为Dic,添加新key为”URL identifier”,类型为String。可以是任何值，但建议用“反域名”(例如 “com.myapp”)。\"></a>Step2. 打开“Item 0″类型为Dic,添加新key为”URL identifier”,类型为String。可以是任何值，但建议用“反域名”(例如 “com.myapp”)。</h6><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2a.gif?imageMogr2/2/w/800\">\n<h5 id=\"Step3-打开“Item-0″类型为Dic-添加新key为“URL-Schemes”-类型为Array\"><a href=\"#Step3-打开“Item-0″类型为Dic-添加新key为“URL-Schemes”-类型为Array\" class=\"headerlink\" title=\"Step3. 打开“Item 0″类型为Dic,添加新key为“URL Schemes”,类型为Array:\"></a>Step3. 打开“Item 0″类型为Dic,添加新key为“URL Schemes”,类型为Array:</h5><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2b.gif?imageMogr2/2/w/800\">\n<a id=\"more\"></a>\n<ul>\n<li><p>类型为Array:  </p>\n  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2c.gif?imageMogr2/2/w/800\">\n</li>\n</ul>\n<h5 id=\"Step4-在URL-Schemes数组中添加Value，输入你的URL协议名-例如“myapp-”-应写做“myapp”-。如果有必要，你可以在这里加入多个协议。\"><a href=\"#Step4-在URL-Schemes数组中添加Value，输入你的URL协议名-例如“myapp-”-应写做“myapp”-。如果有必要，你可以在这里加入多个协议。\" class=\"headerlink\" title=\"Step4. 在URL Schemes数组中添加Value，输入你的URL协议名 (例如“myapp://” 应写做“myapp”)。如果有必要，你可以在这里加入多个协议。\"></a>Step4. 在URL Schemes数组中添加Value，输入你的URL协议名 (例如“myapp://” 应写做“myapp”)。如果有必要，你可以在这里加入多个协议。</h5><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2d.gif?imageMogr2/2/w/800\">\n<h6 id=\"完成后如图所示：\"><a href=\"#完成后如图所示：\" class=\"headerlink\" title=\"完成后如图所示：\"></a>完成后如图所示：</h6><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2e.gif?imageMogr2/2/w/800\">\n<ul>\n<li><h6 id=\"另两种视图浏览方式：\"><a href=\"#另两种视图浏览方式：\" class=\"headerlink\" title=\"另两种视图浏览方式：\"></a>另两种视图浏览方式：</h6>在info.plist页面上右击，选择<strong>Raw Keys/Values</strong>显示如下：  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2f.png?imageMogr2/2/w/800\">\n<h6 id=\"xml\"><a href=\"#xml\" class=\"headerlink\" title=\"xml\"></a>xml</h6><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2g.gif?imageMogr2/2/w/800\">\n<!--more-->\n<h4 id=\"处理URL\"><a href=\"#处理URL\" class=\"headerlink\" title=\"处理URL\"></a>处理URL</h4></li>\n</ul>\n<p>现在，URL已经注册好了。任何人都可以用打开URL的方式通过你的协议去启动一个应用程序。</p>\n<ul>\n<li><h5 id=\"使用Safari-方式启动-app-Calling-Custom-URL-Scheme-from-Safari【下载】\"><a href=\"#使用Safari-方式启动-app-Calling-Custom-URL-Scheme-from-Safari【下载】\" class=\"headerlink\" title=\"使用Safari 方式启动 app:Calling Custom URL Scheme from Safari【下载】\"></a>使用Safari 方式启动 app:Calling Custom URL Scheme from Safari【<a href=\"http://iosdevelopertips.com/downloads/#customURLScheme\" target=\"_blank\" rel=\"noopener\">下载</a>】</h5></li>\n</ul>\n<p>Using the simulator, here’s how to call the app:</p>\n<ul>\n<li>Run the application from within Xcode  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme4a.png?imageMogr2/2/w/800\"></li>\n<li>Once installed, the custom URL scheme will now be registered</li>\n<li>Close the app via the Hardware menu in simulator and choose Home</li>\n<li>Start Safari</li>\n<li>Enter the URL scheme defined previously in the browser address bar (see below)  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme32.png?imageMogr2/2/w/800\">\n</li>\n</ul>\n<ul>\n<li><h5 id=\"通过其他应用启动：Calling-Custom-URL-Scheme-from-Another-iPhone-App【下载】\"><a href=\"#通过其他应用启动：Calling-Custom-URL-Scheme-from-Another-iPhone-App【下载】\" class=\"headerlink\" title=\"通过其他应用启动：Calling Custom URL Scheme from Another iPhone App【下载】\"></a>通过其他应用启动：Calling Custom URL Scheme from Another iPhone App【<a href=\"http://iosdevelopertips.com/downloads/#customURLScheme\" target=\"_blank\" rel=\"noopener\">下载</a>】</h5><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme4b.png?imageMogr2/2/w/800\">  \n</li>\n</ul>\n<p>按钮的实现：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> - (<span class=\"keyword\">void</span>)buttonPressed:(<span class=\"built_in\">UIButton</span> *)button</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSString</span> *customURL = <span class=\"string\">@\"iOSDevTips://\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ([[<span class=\"built_in\">UIApplication</span> sharedApplication] </span><br><span class=\"line\">    canOpenURL:[<span class=\"built_in\">NSURL</span> URLWithString:customURL]])</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    [[<span class=\"built_in\">UIApplication</span> sharedApplication] openURL:[<span class=\"built_in\">NSURL</span> URLWithString:customURL]];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIAlertView</span> *alert = [[<span class=\"built_in\">UIAlertView</span> alloc] initWithTitle:<span class=\"string\">@\"URL error\"</span></span><br><span class=\"line\">                          message:[<span class=\"built_in\">NSString</span> stringWithFormat:</span><br><span class=\"line\">                            <span class=\"string\">@\"No custom URL defined for %@\"</span>, customURL]</span><br><span class=\"line\">                          delegate:<span class=\"keyword\">self</span> cancelButtonTitle:<span class=\"string\">@\"Ok\"</span> </span><br><span class=\"line\">                          otherButtonTitles:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [alert show];</span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>Line 5 we check to see if the custom URL is defined, and if so, use the shared application instance to open the URL (line 8).<br>The <strong><code>openURL:</code></strong>method starts the application and passes the URL into the app. The current application is exited during this process.  </p>\n<ul>\n<li><h5 id=\"通过URL-Schemes-传递参数启动应用：Passing-Parameters-To-App-Via-Custom-URL-Scheme\"><a href=\"#通过URL-Schemes-传递参数启动应用：Passing-Parameters-To-App-Via-Custom-URL-Scheme\" class=\"headerlink\" title=\"通过URL Schemes 传递参数启动应用：Passing Parameters To App Via Custom URL Scheme\"></a>通过URL Schemes 传递参数启动应用：Passing Parameters To App Via Custom URL Scheme</h5>Chances are you’ll need to pass parameters into the application with the custom URL definition. Let’s look at how we can do this with.</li>\n</ul>\n<p>The <strong><code>NSURL</code></strong>class which is the basis for calling from one app to another conforms to the <code>RFC 1808</code> (Relative Uniform Resource Locators). Therefore the same URL formatting you may be familiar with for web-based content will apply here as well.</p>\n<p>In the application with the custom <code>URL scheme</code>, the app delegate must implement the method with the signature below:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application  openURL:(<span class=\"built_in\">NSURL</span> *)url </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t  sourceApplication:(<span class=\"built_in\">NSString</span> *)sourceApplication </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t         annotation:(<span class=\"keyword\">id</span>)annotation</span><br></pre></td></tr></table></figure><br>The trick to passing in parameters from one app to another is via the URL.<br>For example, assume we are using the following custom <code>URL scheme</code>and want to pass in a value for a ‘<strong>token</strong>’ and a flag indicating registration state, we could create URL as follows:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *customURL = <span class=\"string\">@\"iOSDevTips://?token=123abct&amp;registered=1\"</span>;</span><br></pre></td></tr></table></figure><br>As in web development, the string <strong><code>?token=123abct&amp;registered=1</code></strong> is known as the <code>query</code> string.</p>\n<p>Inside the app delegate of the app being called (the app with the custom URL), the code to retrieve the parameters would be as follows:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application openURL:(<span class=\"built_in\">NSURL</span> *)url</span><br><span class=\"line\">        sourceApplication:(<span class=\"built_in\">NSString</span> *)sourceApplication annotation:(<span class=\"keyword\">id</span>)annotation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Calling Application Bundle ID: %@\"</span>, sourceApplication);</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"URL scheme:%@\"</span>, [url scheme]);</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"URL query: %@\"</span>, [url query]);</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>The output from the app with the custom URL (using my Bundle ID), when called from another app, is as follows:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Calling Application Bundle ID: com<span class=\"number\">.3</span>Sixty.CallCustomURL</span><br><span class=\"line\">URL scheme:iOSDevTips</span><br><span class=\"line\">URL query: token=<span class=\"number\">123</span>abct&amp;registered=<span class=\"number\">1</span></span><br></pre></td></tr></table></figure><br>Take note of the ‘<strong>Calling Application Bundle ID</strong>’ as you could use this to ensure that only an application that you define can interact directly with your app.</p>\n<p>Let’s change up the delegate method to verify the calling application Bundle ID is known:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application openURL:(<span class=\"built_in\">NSURL</span> *)url</span><br><span class=\"line\">        sourceApplication:(<span class=\"built_in\">NSString</span> *)sourceApplication annotation:(<span class=\"keyword\">id</span>)annotation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Check the calling application Bundle ID</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ([sourceApplication isEqualToString:<span class=\"string\">@\"com.3Sixty.CallCustomURL\"</span>])</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Calling Application Bundle ID: %@\"</span>, sourceApplication);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"URL scheme:%@\"</span>, [url scheme]);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"URL query: %@\"</span>, [url query]);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>It’s important to note that you cannot prevent another application from calling your app via custom <strong><code>URL scheme</code></strong>, however you can skip any further processing and <code>return NO</code> as shown above. With that said, if you desire to keep other apps from calling your app, create a unique (non-obvious) <code>URL scheme</code>. Although this will guarantee you app won’t be called, it will make it more unlikely.</p>\n<p>Custom URL Scheme Example Projects</p>\n<p>I realize it can be a little tricky to follow all the steps above. I’ve included two (very basic) iOS apps, one that has the custom URL scheme defined and one that calls the app, passing in a short parameter list (query string). These are good starting points to experiment with custom URL’s.</p>\n<p><a href=\"http://iosdevelopertips.com/downloads/#customURLScheme\" target=\"_blank\" rel=\"noopener\">Download Xcode project for app with Custom URL scheme</a><br><a href=\"http://iosdevelopertips.com/downloads/#customURLScheme\" target=\"_blank\" rel=\"noopener\">Download Xcode project for app to call custom URL scheme</a></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"schemes","path":"api/categories/schemes.json"}],"tags":[{"name":"协议","path":"api/tags/协议.json"},{"name":"scheme","path":"api/tags/scheme.json"}]}]}