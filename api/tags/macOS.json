{"name":"macOS","postlist":[{"title":"Fabric对macOS系统的支持","slug":"macOS/Fabric对macOS系统的支持调研","date":"2017-02-14T11:14:35.000Z","updated":"2017-02-14T14:33:17.000Z","comments":true,"path":"api/articles/macOS/Fabric对macOS系统的支持调研.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"Fabric\"><a href=\"#Fabric\" class=\"headerlink\" title=\"Fabric\"></a>Fabric</h2><p><code>Fabric</code> 是Twitter的移动应用开发平台，一个模块化、跨平台的移动开发套件，该博文主要研究<code>crashlytics</code>在app中的运用。<br><a href=\"https://try.crashlytics.com/\" target=\"_blank\" rel=\"noopener\">注册新的账户</a>登录，审核通过时间为几个小时或者1到2天不等。然后注册时候输入的邮箱就会收到如下的邀请涵<br><a href=\"https://docs.fabric.io/apple/crashlytics/os-x.html#macos-support\" target=\"_blank\" rel=\"noopener\">浏览官方文档</a></p>\n<h3 id=\"crashlytics支持macOS\"><a href=\"#crashlytics支持macOS\" class=\"headerlink\" title=\"crashlytics支持macOS\"></a>crashlytics支持macOS</h3><p>对<code>macOS</code>的支持中出现的问题<br>问题：<code>NSApplicationCrashOnExceptions</code> is not set. This will result in poor <code>top-level</code> uncaught exception reporting<br>官方解释：<br><blockquote><p>Uncaught Exceptions<br>Intercepting and reporting uncaught exceptions on macOS is more complex than it is on iOS. On macOS, AppKit will catch exceptions thrown on the main thread, preventing the application from crashing, but also preventing Crashlytics from reporting them. To make matters worse, Apple’s frameworks are not exception safe. This means that while AppKit will prevent your app from crashing, it will also likely corrupt your process’s state, often including AppKit itself. Typically, once an exception involving UI interaction is thrown, it will prevent your app from working correctly from that moment on.<br>Thankfully, AppKit has a little-known feature you can turn on to make the behavior much more predictable. We strongly recommend that you do the following in your application, right before you initialize Crashlytics.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] registerDefaults:@&#123; <span class=\"string\">@”NSApplicationCrashOnExceptions”</span>: @YES &#125;];</span><br></pre></td></tr></table></figure>\n\n<p>This will make your application’s behavior much closer to iOS. It will mean that your app will crash on uncaught exceptions, and will also allow Crashlytics to report them with useful stack traces. It will also give you the ability to override this behavior with the user defaults system, even on per-user basis.<br>Of course, this is all optional. Crashlytics will warn about NSApplicationCrashOnExceptions not being set, but will otherwise preserve normal AppKit behavior by default.</p>\n<footer><strong>官方文档</strong><cite><a href=\"https://docs.fabric.io/apple/crashlytics/os-x.html#macos-support\" target=\"_blank\" rel=\"noopener\">macOS Support</a></cite></footer></blockquote><br>拦截和报告未捕获的异常在MacOS比iOS更复杂。在MacOS，AppKit会抓住扔在主线程异常，防止应用程序崩溃，也防止crashlytics报告他们。更糟糕的是，Apple’s frameworks也不例外。这意味着AppKit可以防止你的应用程序崩溃，也可能破坏你的进程的状态，包括AppKit本身。通常情况下，一旦涉及到用户界面交互的异常被抛出，它将阻止您的应用程序从正确的工作从那一刻起。<br>以上情况，可以通过设置：<code>NSApplicationCrashOnExceptions</code> 改变系统默认的值，达到像iOS端一样抓去异常。如果没有设置会提示：NSApplicationCrashOnExceptions not set</p>\n<h3 id=\"Cause-a-Test-Crash教程\"><a href=\"#Cause-a-Test-Crash教程\" class=\"headerlink\" title=\"Cause a Test Crash教程\"></a><a href=\"https://docs.fabric.io/apple/crashlytics/test-crash.html\" target=\"_blank\" rel=\"noopener\">Cause a Test Crash教程</a></h3><p>崩溃日志是在重启APP程序的同时进行的，要确保程序在前台全屏显示。<br>Xcode调试器会阻止我们捕捉崩溃报告，所以在抓取崩溃报告时，要保证在非调试状态下进行。如果你的移动设备连接到Mac机上，Xcode仍然可以进入调试状态。</p>\n<ol>\n<li><code>run</code>在模拟器上安装运行APP</li>\n<li>点击<code>Stop</code>断开Xcode和模拟器，确保在非调试状态</li>\n<li>在模拟器上启动APP，并执行崩溃操作</li>\n<li>在Xcode上点击<code>run</code><br>在Xcode的控制台console中输出显示奔溃报告，以及上传日志的相关提示。<br>macOS系统中的日志目录：<br>运行日志目录：/private/var/log/system.log<br>奔溃日志目录：/Users/pyc/Library/Logs/DiagnosticReports/APPNAME_2016-11-10-165115.crash</li>\n</ol>\n<blockquote><p>It’s possible, but rare, that we are missing a dSYM to symbolicate any crash reports. There will be an alert on your dashboard if this is the case. Click through to upload the missing dSYM. Keep in mind that exceptions are not guaranteed to crash. The full code path, including code in system libraries, matters here. If you aren’t seeing the dSYM alert, you can go to your app’s settings page, and append “/mappings” to the URL to reach it, e.g. <a href=\"https://fabric.io/settings/apps/some_app_id/mappings\" target=\"_blank\" rel=\"noopener\">https://fabric.io/settings/apps/some_app_id/mappings</a></p>\n<footer><strong>官方文档</strong><cite><a href=\"https://docs.fabric.io/apple/crashlytics/test-crash.html\" target=\"_blank\" rel=\"noopener\">Cause a Test Crash教程</a></cite></footer></blockquote>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"调试","path":"api/categories/调试.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"SDK","path":"api/tags/SDK.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"发布","path":"api/tags/发布.json"},{"name":"macOS","path":"api/tags/macOS.json"}]},{"title":"使用JavaScript把JSON数据转为对象","slug":"swift/使用JavaScript把JSON数据定义对象","date":"2017-02-12T14:41:35.000Z","updated":"2017-02-16T13:43:01.000Z","comments":true,"path":"api/articles/swift/使用JavaScript把JSON数据定义对象.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"将JSON数据序列化为代码实例\"><a href=\"#将JSON数据序列化为代码实例\" class=\"headerlink\" title=\"将JSON数据序列化为代码实例\"></a>将JSON数据序列化为代码实例</h2><ol>\n<li>定义一个继承自 <code>JSExport</code> 子协议 <code>PersonJSExports</code></li>\n<li>定义一个遵守<code>PersonJSExports</code>协议的<code>Person</code>数据模</li>\n<li>使用 <code>JavaScript</code> 把<code>JSON</code>转为<code>类</code>并实例化<code>对象</code><br>都有一个完整的 <code>JVM</code> 在那儿了，谁还需要 <code>NSJSONSerialization</code>？</li>\n</ol>\n<h2 id=\"JSExport语言互通协议\"><a href=\"#JSExport语言互通协议\" class=\"headerlink\" title=\"JSExport语言互通协议\"></a>JSExport语言互通协议</h2><p><code>JavaScript</code>可以脱离<code>prototype继承</code>完全用<code>JSON</code>来定义对象，但是<code>Objective-C</code>编程不能脱离<code>类</code>和<code>继承</code>。所以<code>JavaScriptCore</code>就提供了<code>JSExport</code>作为两种语言的互通协议。<br><code>JSExport</code>中没有预定义任何方法，但是所有继承<code>JSExport</code>的协议中定义的方法即协议方法，都可以在<code>JSContext</code>中被调用。</p>\n<h2 id=\"JSExportAs-宏-指定方法在JS中调用的名称\"><a href=\"#JSExportAs-宏-指定方法在JS中调用的名称\" class=\"headerlink\" title=\"JSExportAs 宏: 指定方法在JS中调用的名称\"></a>JSExportAs 宏: 指定方法在JS中调用的名称</h2><p>对于多参数的方法，<code>JavaScriptCore</code>的转换方式将<code>Objective-C</code>的方法每个部分都合并在一起，冒号后的字母变为大写并移除冒号。比如下边协议中的方法，在JavaScript调用就是：doFooWithBar(foo, bar);<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">MultiArgs</span> &lt;<span class=\"title\">JSExport</span>&gt;</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doFoo:(<span class=\"keyword\">id</span>)foo withBar:(<span class=\"keyword\">id</span>)bar;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure><br>如果希望方法在JavaScript中有一个比较短的名字，就需要用的JSExport.h中提供的宏：<br><figure class=\"highlight objc\"><figcaption><span>JSExport.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSExportAs(PropertyName, Selector)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight objc\"><figcaption><span>JSExportAs的官方宏定义 xcdoc://?url=developer.apple.com/library/etc/redirect/xcode/ios/1151/documentation/JavaScriptCore/Reference/JSExport_Ref/index.html</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define JSExportAs(PropertyName, Selector) \\</span></span><br><span class=\"line\"><span class=\"keyword\">@optional</span> Selector __JS_EXPORT_AS__<span class=\"meta\">##PropertyName:(id)argument; @required Selector</span></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>如 <code>setX:Y:Z</code>方法，我们可以给他重命名，让 JS 中通过 <code>set3D(x,y,z)</code> 来调用<br><figure class=\"highlight objc\"><figcaption><span>使用方法</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSExportAs(set3D,</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setX:(<span class=\"keyword\">id</span>)x Y:(<span class=\"keyword\">id</span>)y Z:(<span class=\"keyword\">id</span>)z</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">//调用</span></span><br><span class=\"line\">set3D(x,y,z)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"定义PersonJSExports协议和create协议方法（类方法）\"><a href=\"#定义PersonJSExports协议和create协议方法（类方法）\" class=\"headerlink\" title=\"定义PersonJSExports协议和create协议方法（类方法）\"></a>定义PersonJSExports协议和create协议方法（类方法）</h3><p><code>Person 类</code>实现了<code>PersonJSExports 协议</code>，该协议规定哪些属性可以在 <code>JavaScript</code>中可用。<br>在<code>JavaScript</code>语境中，不能像：<code>var person = new Person()</code>来初始化实例，可以在定义<code>PersonJSExports</code>协议方法时，添加一个协议方法来弥补这一点。见下例<code>create...</code>类方法：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Custom protocol must be declared with `@objc`</span></span><br><span class=\"line\"><span class=\"meta\">@objc</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">PersonJSExports</span> : <span class=\"title\">JSExport</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> firstName: <span class=\"type\">String</span> &#123; <span class=\"keyword\">get</span> <span class=\"keyword\">set</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> lastName: <span class=\"type\">String</span> &#123; <span class=\"keyword\">get</span> <span class=\"keyword\">set</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> birthYear: <span class=\"type\">NSNumber</span>? &#123; <span class=\"keyword\">get</span> <span class=\"keyword\">set</span> &#125;</span><br><span class=\"line\">    <span class=\"comment\">//方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getFullName</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 在JavaScript中调用这个类方法</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">func</span> <span class=\"title\">createWithFirstName</span>(<span class=\"title\">firstName</span>: <span class=\"title\">String</span>, <span class=\"title\">lastName</span>: <span class=\"title\">String</span>) -&gt; <span class=\"title\">Person</span></span></span><br><span class=\"line\"><span class=\"class\">&#125;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">### 定义<span class=\"title\">Person</span>模型</span></span><br><span class=\"line\"><span class=\"class\">定义一个遵守`<span class=\"title\">PersonJSExports</span>`协议的`<span class=\"title\">Person</span>`数据模</span></span><br><span class=\"line\"><span class=\"class\">// <span class=\"title\">Custom</span> <span class=\"title\">class</span> <span class=\"title\">must</span> <span class=\"title\">inherit</span> <span class=\"title\">from</span> `<span class=\"title\">NSObject</span>`</span></span><br><span class=\"line\"><span class=\"class\">@<span class=\"title\">objc</span> <span class=\"title\">class</span> <span class=\"title\">Person</span> : <span class=\"title\">NSObject</span>, <span class=\"title\">PersonJSExports</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// JS协议属性必须声明为`dynamic`</span></span><br><span class=\"line\">    <span class=\"keyword\">dynamic</span> <span class=\"keyword\">var</span> firstName: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">dynamic</span> <span class=\"keyword\">var</span> lastName: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">dynamic</span> <span class=\"keyword\">var</span> birthYear: <span class=\"type\">NSNumber</span>?</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(firstName: <span class=\"type\">String</span>, lastName: <span class=\"type\">String</span>)   </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.firstName = firstName</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.lastName = lastName</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//JS协议类方法</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">func</span> <span class=\"title\">createWithFirstName</span>(<span class=\"title\">firstName</span>: <span class=\"title\">String</span>, <span class=\"title\">lastName</span>: <span class=\"title\">String</span>) -&gt; <span class=\"title\">Person</span> </span></span><br><span class=\"line\"><span class=\"class\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Person</span>(firstName: firstName, lastName: lastName)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//JS协议方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getFullName</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\\(firstName) \\(lastName)\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"JSContext-配置\"><a href=\"#JSContext-配置\" class=\"headerlink\" title=\"JSContext 配置\"></a>JSContext 配置</h3><p>之前，我们可以用我们已经创建的 Person 类，我们需要将其导出到 <code>JavaScript</code> 环境。我们也将借此导入<a href=\"http://mustache.github.io\" target=\"_blank\" rel=\"noopener\">Mustache JS library</a>，我们将应用模板到我们的 Person 对象。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// export Person class，JS中以该`Person标示符`作为类名使用</span></span><br><span class=\"line\">context.setObject(<span class=\"type\">Person</span>.<span class=\"keyword\">self</span>, forKeyedSubscript: <span class=\"string\">\"Person\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// load Mustache.js</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> mustacheJSString = <span class=\"type\">String</span>(contentsOfFile:..., encoding:<span class=\"type\">NSUTF8StringEncoding</span>, error:<span class=\"literal\">nil</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    context.evaluateScript(mustacheJSString)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"JavaScript-数据和进程\"><a href=\"#JavaScript-数据和进程\" class=\"headerlink\" title=\"JavaScript 数据和进程\"></a>JavaScript 数据和进程</h3><p>下面就来看看我们简单的 JSON 例子，这段代码将创建新的 Person 实例。<br>数据：<br><figure class=\"highlight json\"><figcaption><span>Persons.json</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    &#123; <span class=\"attr\">\"first\"</span>: <span class=\"string\">\"Grace\"</span>,     <span class=\"attr\">\"last\"</span>: <span class=\"string\">\"Hopper\"</span>,   <span class=\"attr\">\"year\"</span>: <span class=\"number\">1906</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">\"first\"</span>: <span class=\"string\">\"Ada\"</span>,       <span class=\"attr\">\"last\"</span>: <span class=\"string\">\"Lovelace\"</span>, <span class=\"attr\">\"year\"</span>: <span class=\"number\">1815</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">\"first\"</span>: <span class=\"string\">\"Margaret\"</span>,  <span class=\"attr\">\"last\"</span>: <span class=\"string\">\"Hamilton\"</span>, <span class=\"attr\">\"year\"</span>: <span class=\"number\">1936</span> &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure><br>创建新的 Person 实例：<br><figure class=\"highlight js\"><figcaption><span>loadPeople.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> loadPeopleFromJSON = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jsonString</span>) </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(jsonString);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> people = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; data.length; i++) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//在swift中的js协议方法：`createWithFirstName:lastName:`</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> person = Person.createWithFirstNameLastName(data[i].first, data[i].last);</span><br><span class=\"line\">        person.birthYear = data[i].year;</span><br><span class=\"line\">        <span class=\"comment\">//`push:`添加到数组中</span></span><br><span class=\"line\">        people.push(person);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//返回该对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> people;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><code>JSContext</code>加载装换<code>loadPeople.js</code>脚本<br>加载js脚本之后，<code>loadPeopleFromJSON</code>即可作为下标被<code>context</code>调用该方法:<br><figure class=\"highlight swift\"><figcaption><span>加载loadPeople.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// load loadPeople.js</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> loadPeople = <span class=\"type\">String</span>(contentsOfFile:..., encoding:<span class=\"type\">NSUTF8StringEncoding</span>, error:<span class=\"literal\">nil</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//加载js脚本之后，`loadPeopleFromJSON`即可作为下标被context调用该方法</span></span><br><span class=\"line\">    context.evaluateScript(loadPeople)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意：JavaScriptCore 转换的 Objective-C / Swift 方法名是 JavaScript 兼容的。由于 JavaScript 没有参数 名称，任何外部参数名称都会被转换为驼峰形式并且附加到函数名后。在这个例子中，Objective-C 的方法 createWithFirstName:lastName: 变成了在JavaScript中的 createWithFirstNameLastName()。</p>\n</blockquote>\n<h3 id=\"使用Mustache-模板-渲染\"><a href=\"#使用Mustache-模板-渲染\" class=\"headerlink\" title=\"使用Mustache 模板 渲染\"></a>使用Mustache 模板 渲染</h3><p>Mustache 是一个很强大的 template 引擎，可以通过解析 json 来绑定并渲染占位符。如果你做过一些前端开发的话，会知道这是一种很常用的 HTML 绑定 Model 的做法，GRMustache.swift 是这个框架的 Swift 实现。<br><a href=\"http://blog.csdn.net/kevin_luan/article/details/46485561\" target=\"_blank\" rel=\"noopener\">mustache模板引擎</a><br><a href=\"https://github.com/BjornRuud/Swiftache\" target=\"_blank\" rel=\"noopener\">Mustache 的 Swift 语言实现版本</a><br>mustache的特点就是很语法很简单，主要语法如下:</p>\n<pre><code>1. {{ name }} 打印变量，默认是escape过的，如果不要escape,用3个分隔符 {{{ name }}}，或者用 {{ &name }}，这个和分隔符无关\n2. {{#person}}…{{/person}} 区块，4种方式\n    person 是真假值，决定是否输出\n    person 是list of array，会循环展开 for x in person:section.render(&apos;xxx)\n    person 是匿名函数/object, 区块包裹的html 会作为参数传递进去\n    person 是dict，直接打印 dict[key]\n3. {{^person}}…{{/person}，反向区块\n    4. {{！name }} 注释\n5. {{> box }} 载入子模块\n</code></pre><p>加载 <code>JSON 数据</code>，调用 <code>JSContext</code> 将数据解析成 <code>Person 对象</code>的数组，并用 <code>Mustache 模板</code>呈现每个<code>Person</code>：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从文件`Persons.json`中加载json数据</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> peopleJSON = <span class=\"type\">NSString</span>(contentsOfFile:..., encoding: <span class=\"type\">NSUTF8StringEncoding</span>, error: <span class=\"literal\">nil</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取js中定义的`loadPeopleFromJSON`的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> load = context.objectForKeyedSubscript(<span class=\"string\">\"loadPeopleFromJSON\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 通过调用load方法将`JSON 数据`解析成`Person 对象`的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> people = load.callWithArguments([peopleJSON]).toArray() <span class=\"keyword\">as</span>? [<span class=\"type\">Person</span>] </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// get rendering function and create template</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> mustacheRender = context.objectForKeyedSubscript(<span class=\"string\">\"Mustache\"</span>).objectForKeyedSubscript(<span class=\"string\">\"render\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> template = <span class=\"string\">\", born \"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// loop through people and render Person object as string</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> person <span class=\"keyword\">in</span> people </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">println</span>(mustacheRender.callWithArguments([template, person]))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// Grace Hopper, born 1906</span></span><br><span class=\"line\"><span class=\"comment\">// Ada Lovelace, born 1815</span></span><br><span class=\"line\"><span class=\"comment\">// Margaret Hamilton, born 1936</span></span><br></pre></td></tr></table></figure><br>JavaScript 代码段可能是附带应用一起发布的基本的用户定义的插件。</p>\n","raw":null,"categories":[{"name":"swift","path":"api/categories/swift.json"},{"name":"JS混编","path":"api/categories/JS混编.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"iOS","path":"api/tags/iOS.json"},{"name":"swift","path":"api/tags/swift.json"},{"name":"macOS","path":"api/tags/macOS.json"},{"name":"混编","path":"api/tags/混编.json"},{"name":"Java​Script​Core","path":"api/tags/Java​Script​Core.json"},{"name":"json","path":"api/tags/json.json"}]},{"title":"Java​Script​Core实现swift混编","slug":"swift/Java​Script​Core实现swift混编","date":"2017-02-12T13:34:06.000Z","updated":"2017-02-16T13:43:01.000Z","comments":true,"path":"api/articles/swift/Java​Script​Core实现swift混编.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/JSValueType.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>OS X Mavericks 和 iOS 7 引入了 <code>JavaScriptCore</code> 库，它把 <code>WebKit 的 JavaScript</code> 引擎用 <code>Objective-C</code> 封装，提供了简单，快速以及安全的方式接入世界上最流行的语言。不管你爱它还是恨它，<code>JavaScript</code> 的普遍存在使得程序员、工具以及融合到 OS X 和 iOS 里这样超快的虚拟机中资源的使用都大幅增长。</p>\n<ol>\n<li>如何从 <code>JavaScript 环境</code>中提取值以及如何调用其中定义的函数?</li>\n<li>那么反向呢？怎样从 <code>JavaScript</code> 访问我们在 <code>Objective-C</code>或 <code>Swift</code> 定义的对象和方法？</li>\n</ol>\n<h2 id=\"swift通过JSContext调用JavaScript\"><a href=\"#swift通过JSContext调用JavaScript\" class=\"headerlink\" title=\"swift通过JSContext调用JavaScript\"></a>swift通过JSContext调用JavaScript</h2><p>如何从<code>JavaScript 环境</code>中提取值以及如何调用其中定义的函数?</p>\n<h3 id=\"全局实例JSContext：运行JavaScript代码的环境\"><a href=\"#全局实例JSContext：运行JavaScript代码的环境\" class=\"headerlink\" title=\"全局实例JSContext：运行JavaScript代码的环境\"></a>全局实例JSContext：运行JavaScript代码的环境</h3><p>全局实例<code>JSContext</code>作用就像在浏览器内运行的一个<code>JavaScript</code>脚本，<code>JSContext</code> 类似于 <code>window</code>。<br>通过<code>JSContext</code>实例运行<code>JavaScript</code>代码<code>创建变量</code>，<code>做计算</code>，<code>定义方法</code>：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> context = <span class=\"type\">JSContext</span>()    <span class=\"comment\">//创建全局环境</span></span><br><span class=\"line\">context.evaluateScript(<span class=\"string\">\"var num = 5 + 5\"</span>) <span class=\"comment\">//计算</span></span><br><span class=\"line\">context.evaluateScript(<span class=\"string\">\"var names = ['Grace', 'Ada', 'Margaret']\"</span>) <span class=\"comment\">//定义变量</span></span><br><span class=\"line\">context.evaluateScript(<span class=\"string\">\"var triple = function(value) &#123; return value * 3 &#125;\"</span>) <span class=\"comment\">//定义方法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> tripleNum: <span class=\"type\">JSValue</span> = context.evaluateScript(<span class=\"string\">\"triple(num)\"</span>)  </span><br></pre></td></tr></table></figure></p>\n<h3 id=\"动态类型JSValue-包裹JSContext环境下每一个可能的JS值\"><a href=\"#动态类型JSValue-包裹JSContext环境下每一个可能的JS值\" class=\"headerlink\" title=\"动态类型JSValue:包裹JSContext环境下每一个可能的JS值\"></a>动态类型JSValue:包裹JSContext环境下每一个可能的JS值</h3><p><code>JavaScript</code> 是动态语言，所以动态类型<code>JSValue</code>包裹JSContext环境中任何可能的JS值，字符串和数字；数组、对象和方法；甚至错误和特殊的 JavaScript 值诸如 <code>null</code> 和 <code>undefined</code>。<br>获取<code>tripleNum</code>值：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">println</span>(<span class=\"string\">\"Tripled: \\(tripleNum.toInt32())\"</span>)</span><br></pre></td></tr></table></figure><br><code>JSValue</code> 包括一系列方法用于访问其可能的值以保证有正确的 <code>Foundation 基本类型</code><br>包括：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/JSValueType.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"下标取值：访问JSContext环境下的任何值\"><a href=\"#下标取值：访问JSContext环境下的任何值\" class=\"headerlink\" title=\"下标取值：访问JSContext环境下的任何值\"></a>下标取值：访问JSContext环境下的任何值</h3><p><code>JSContext</code> 和 <code>JSValue</code> 实例可以使用下标的方式访问之前创建的 <code>context</code> 的任何值。</p>\n<ul>\n<li><code>JSContext</code>：需要一个字符串下标</li>\n<li><code>JSValue</code>：允许使用<code>字符串</code>或<code>整数</code>标来得到里面的对象和数组</li>\n</ul>\n<h4 id=\"JSContext下标取值\"><a href=\"#JSContext下标取值\" class=\"headerlink\" title=\"JSContext下标取值\"></a>JSContext下标取值</h4><ol>\n<li><code>swift</code>语法<figure class=\"highlight swift\"><figcaption><span>未映射成[]的原始方法</span><a href=\"http://nshipster.cn/object-subscripting/\" target=\"_blank\" rel=\"noopener\">objectAtKeyedSubscript()和objectAtIndexedSubscript()</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> names = context.objectForKeyedSubscript(<span class=\"string\">\"names\"</span>)  <span class=\"comment\">//JSContext字符串下标原始方法</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"JSValue整数下标原始方法\"><a href=\"#JSValue整数下标原始方法\" class=\"headerlink\" title=\"JSValue整数下标原始方法\"></a>JSValue整数下标原始方法</h4><figure class=\"highlight swift\"><figcaption><span>未映射成[]的原始方法</span><a href=\"http://nshipster.cn/object-subscripting/\" target=\"_blank\" rel=\"noopener\">objectAtKeyedSubscript()和objectAtIndexedSubscript()</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> initialName = names.objectAtIndexedSubscript(<span class=\"number\">0</span>)   <span class=\"comment\">//JSValue整数下标原始方法</span></span><br><span class=\"line\"><span class=\"built_in\">println</span>(<span class=\"string\">\"The first name: \\(initialName.toString())\"</span>)  <span class=\"comment\">//JSValue method</span></span><br><span class=\"line\"><span class=\"comment\">// The first name: Grace</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在这里，Objective-C 代码可以利用下标表示法，如下例：context[@”names”]，names[0]，[initialName toString]，Swift 目前只公开<a href=\"http://nshipster.cn/object-subscripting/\" target=\"_blank\" rel=\"noopener\">原始方法</a>:<code>objectAtKeyedSubscript()</code> 和 <code>objectAtIndexedSubscript()</code>来让下标成为可能。</p>\n</blockquote>\n<h3 id=\"callWithArguments调用JS方法：只需传入Foundation基本类型参数\"><a href=\"#callWithArguments调用JS方法：只需传入Foundation基本类型参数\" class=\"headerlink\" title=\"callWithArguments调用JS方法：只需传入Foundation基本类型参数\"></a>callWithArguments调用JS方法：只需传入Foundation基本类型参数</h3><p>上述<code>JavaScript</code>代码中，<code>JSValue</code>包装了一个<code>triple函数</code>，在<code>Objective-C / Swift</code> 代码中可以使用 <code>Foundation基本类型</code>作为参数来直接调用该函数。再次，<code>JavaScriptCore</code> 很轻松的处理了这个桥接：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> tripleFunction = context.objectForKeyedSubscript(<span class=\"string\">\"triple\"</span>) <span class=\"comment\">//下标取值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = tripleFunction.callWithArguments([<span class=\"number\">5</span>]) <span class=\"comment\">//传入基本类型参数直接调用</span></span><br><span class=\"line\"><span class=\"built_in\">println</span>(<span class=\"string\">\"Five tripled: \\(result.toInt32())\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"exceptionHandler错误处理\"><a href=\"#exceptionHandler错误处理\" class=\"headerlink\" title=\"exceptionHandler错误处理\"></a><code>exceptionHandler</code>错误处理</h3><p><code>exceptionHandler</code> 是一个接收<code>JSContext 引用</code>和<code>异常本身</code>的回调处理的闭包。<br>通过设置上下文的 <code>exceptionHandler</code> 属性，可以观察和记录<code>语法</code>，<code>类型</code>以及<code>运行时错误</code>:<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.exceptionHandler = &#123; context, exception <span class=\"keyword\">in</span></span><br><span class=\"line\"><span class=\"built_in\">println</span>(<span class=\"string\">\"JS Error: \\(exception)\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">context.evaluateScript(<span class=\"string\">\"function multiply(value1, value2) &#123; return value1 * value2 \"</span>)</span><br><span class=\"line\"><span class=\"comment\">// JS Error: SyntaxError: Unexpected end of script</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"JS Error: %@\"</span>, exception);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">[context evaluateScript:<span class=\"string\">@\"function multiply(value1, value2) &#123; return value1 * value2 \"</span>];</span><br><span class=\"line\"><span class=\"comment\">// JS Error: SyntaxError: Unexpected end of script</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"JavaScript-通过JSContext调用-swift／OC\"><a href=\"#JavaScript-通过JSContext调用-swift／OC\" class=\"headerlink\" title=\"JavaScript 通过JSContext调用 swift／OC\"></a>JavaScript 通过JSContext调用 swift／OC</h2><p>怎样从 <code>JavaScript</code> 访问我们在 <code>Objective-C</code>或 <code>Swift</code> 定义的对象和方法？<br>让 <code>JSContext</code> 访问我们的本地客户端代码的方式主要有两种：</p>\n<ol>\n<li><code>block块</code>键值对：把OC中的<code>block块</code>赋值给<code>JSContext</code>的一个标示键，该标识键的<code>JSValue</code>可以通过<code>callWithArguments</code>调用.</li>\n<li><code>JSExport 协议</code>。</li>\n</ol>\n<h3 id=\"block块-键值对-该block键的JSValue通过callWithArguments调用\"><a href=\"#block块-键值对-该block键的JSValue通过callWithArguments调用\" class=\"headerlink\" title=\"block块 键值对:该block键的JSValue通过callWithArguments调用\"></a>block块 键值对:该block键的<code>JSValue</code>通过<code>callWithArguments</code>调用</h3><p>当一个 <code>Objective-C block</code> 被赋给 <code>JSContext</code> 里的一个标识符，<code>JavaScriptCore</code> 会自动的把 <code>block</code> 封装在 <code>JavaScript 函数</code>里，并以该标示符作为函数名来调用该block的实现。这使得在 <code>JavaScript</code> 中可以简单的使用 <code>Foundation</code> 和 <code>Cocoa</code>类，所有的桥接都为你做好了。<br><a href=\"http://nshipster.cn/cfstringtransform/\" target=\"_blank\" rel=\"noopener\">CFStringTransform</a>处理语言的强大威力</p>\n<p>在 <code>JSContext</code> 中使用 <code>Swift 闭包</code>需要注意两点:</p>\n<ol>\n<li>与 <code>@objc_block</code> 属性一起声明</li>\n<li>使用Swift中的<code>unsafeBitCast()</code>函数，把对象转换为<code>AnyObject</code></li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> simplifyString: <span class=\"meta\">@objc</span>_block <span class=\"type\">String</span> -&gt; <span class=\"type\">String</span> = &#123; input <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> mutableString = <span class=\"type\">NSMutableString</span>(string: input) <span class=\"keyword\">as</span> <span class=\"type\">CFMutableStringRef</span></span><br><span class=\"line\">    <span class=\"type\">CFStringTransform</span>(mutableString, <span class=\"literal\">nil</span>, kCFStringTransformToLatin, <span class=\"type\">Boolean</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">    <span class=\"type\">CFStringTransform</span>(mutableString, <span class=\"literal\">nil</span>, kCFStringTransformStripCombiningMarks, <span class=\"type\">Boolean</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mutableString</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">context.setObject(<span class=\"built_in\">unsafeBitCast</span>(simplifyString, <span class=\"type\">AnyObject</span>.<span class=\"keyword\">self</span>), forKeyedSubscript: <span class=\"string\">\"simplifyString\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//通过simplifyString标示符来调用block的实现</span></span><br><span class=\"line\"><span class=\"built_in\">println</span>(context.evaluateScript(<span class=\"string\">\"simplifyString('안녕하새요!')\"</span>))</span><br><span class=\"line\"><span class=\"comment\">// annyeonghasaeyo!</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//给标示符赋值一个oc-block，该标示符会被自动装换为JavaScript函数</span></span><br><span class=\"line\">context[<span class=\"string\">@\"simplifyString\"</span>] = ^(<span class=\"built_in\">NSString</span> *input) &#123;</span><br><span class=\"line\"><span class=\"built_in\">NSMutableString</span> *mutableString = [input mutableCopy];</span><br><span class=\"line\"><span class=\"built_in\">CFStringTransform</span>((__bridge <span class=\"built_in\">CFMutableStringRef</span>)mutableString, <span class=\"literal\">NULL</span>, kCFStringTransformToLatin, <span class=\"literal\">NO</span>);</span><br><span class=\"line\"><span class=\"built_in\">CFStringTransform</span>((__bridge <span class=\"built_in\">CFMutableStringRef</span>)mutableString, <span class=\"literal\">NULL</span>, kCFStringTransformStripCombiningMarks, <span class=\"literal\">NO</span>);</span><br><span class=\"line\"><span class=\"keyword\">return</span> mutableString;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过simplifyString标示符来调用block的实现</span></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [context evaluateScript:<span class=\"string\">@\"simplifyString('안녕하새요!')\"</span>]);</span><br></pre></td></tr></table></figure>\n<h4 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h4><p>由于 <code>block</code> 可以保有变量引用，而且 <code>JSContext</code> 也强引用它所有的变量，为了避免强引用循环需要特别小心。<br>避免保有<code>JSContext</code> 或<code>一个 block</code> 里的任何 <code>JSValue</code>。相反，使用 <code>[JSContext currentContext]</code> 得到当前上下文，并把你需要的任何值用参数传递。</p>\n<h3 id=\"JSExport-协议\"><a href=\"#JSExport-协议\" class=\"headerlink\" title=\"JSExport 协议\"></a>JSExport 协议</h3><p>在继承<code>JSExport 协议</code>的子协议里声明的属性，实例方法还是类方法，都会自动暴漏给<code>JavaScript</code>代码来调用。</p>\n","raw":null,"categories":[{"name":"swift","path":"api/categories/swift.json"},{"name":"JS混编","path":"api/categories/JS混编.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"iOS","path":"api/tags/iOS.json"},{"name":"swift","path":"api/tags/swift.json"},{"name":"macOS","path":"api/tags/macOS.json"},{"name":"混编","path":"api/tags/混编.json"},{"name":"Java​Script​Core","path":"api/tags/Java​Script​Core.json"}]},{"title":"OSX 应用插件","slug":"macOS/OSX应用插件开发","date":"2017-02-07T12:38:58.000Z","updated":"2017-02-07T13:47:53.000Z","comments":true,"path":"api/articles/macOS/OSX应用插件开发.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/xcode8.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>在以前的 OS X 系统中，给你的 App 在运行时动态载入可执行代码比较困难。现在可以通过<code>NSBundle</code>和 <code>plug-ins</code>插件,可以很方便的向原有APP中添加新功能点。</p>\n<p>目的：在一个修改过的 TextEdit 里面加入加载 bundle 的功能</p>\n<h2 id=\"包-Bundles-和接口-Interfaces\"><a href=\"#包-Bundles-和接口-Interfaces\" class=\"headerlink\" title=\"包 (Bundles) 和接口 (Interfaces)\"></a>包 (Bundles) 和接口 (Interfaces)</h2><p>如果你打开 Xcode8 创建一个新项目，会看见 OS X 所有可以编写APP插件的模版，例如： <code>Screen Savers</code> 到 <code>Image Units</code>等。<br>在<code>Framework &amp; Library</code>中的 <code>Bundle</code> 条目。我会在今天探索一个非常简单的的项目，那就是在一个修改过的 TextEdit 里面加入加载 bundle 的功能。<br><img title=\"项目模版\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcode8.png?imageMogr2/2/w/800\"><br><code>bundle 模版</code>项目与APP项目比较：</p>\n<ol>\n<li>一个 <code>Contents</code> 目录，里面包含了 <code>Info.plist</code> 和 <code>Resource</code> 目录。</li>\n<li>如果你在你的项目下加入了新的类，你可以看见包含一个可执行文件的 <code>MacOS</code> 目录。</li>\n<li><code>Bundle</code> 工程里缺少的一个东西是 <code>main()</code> 函数。它是被宿主<code>App</code> 调用执行的。</li>\n</ol>\n<h2 id=\"为-TextEdit-加入-Plugin-支持\"><a href=\"#为-TextEdit-加入-Plugin-支持\" class=\"headerlink\" title=\"为 TextEdit 加入 Plugin 支持\"></a>为 TextEdit 加入 Plugin 支持</h2><p>两种插件的方式:<br>    第一个:用最少的工作来为你的 app 加入插件支持，希望让你知道实现这个有多简单。<br>    第二个:技术有点复杂，它展现来一个为你的 app 加入插件的合理的方式，这可以使你不会在未来陷入到被锁死在某一种实现的窘境中。<br>本文章的项目文件仍然会放在 <a href=\"https://github.com/objcio/issue-14-plugins\" target=\"_blank\" rel=\"noopener\">GitHub</a> 供大家参考。</p>\n<h3 id=\"在-TextEdit-中扫描-Bundle\"><a href=\"#在-TextEdit-中扫描-Bundle\" class=\"headerlink\" title=\"在 TextEdit 中扫描 Bundle\"></a>在 TextEdit 中扫描 Bundle</h3><p>请打开 “01 TextEdit” 目录下面的 <code>TextEdit.xcodeproj</code> 工程，同时浏览它里面包含的代码。<br><code>TextEdit</code> 里面有三个简单的组成部分：扫描 <code>bundle</code>，加载 <code>bundle</code>，调用 <code>bundle 的 UI</code><br><code>loadPlugins</code> 方法：<br>打开 <code>Controller.m</code>，你可以看见 <code>-(void)loadPlugins</code> 方法 (它在 <code>applicationDidFinishLaunching:</code> 中被调用)。</p>\n<ol>\n<li>扩展插件菜单：在界面菜单右侧加入了一个新的 <code>NSMenuItem</code>，为调用插件提供一个入口（通常你会在 <code>MainMenu.xib</code> 做这件事情并且链接 <code>outlets</code>，但是我们这次偷下懒）。</li>\n<li>扫描插件目录：获得插件目录（在 <code>~/Library/Application Support/Text Edit/Plug-Ins/</code> ）下，并且扫描这个目录。<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *pluginsFolder = [<span class=\"keyword\">self</span> pluginsFolder];</span><br><span class=\"line\"><span class=\"built_in\">NSFileManager</span> *fm = [<span class=\"built_in\">NSFileManager</span> defaultManager];</span><br><span class=\"line\"><span class=\"built_in\">NSError</span> *outErr;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *item <span class=\"keyword\">in</span> [fm contentsOfDirectoryAtPath:pluginsFolder error:&amp;outErr]) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (![item hasSuffix:<span class=\"string\">@\".bundle\"</span>])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *bundlePath = [pluginsFolder stringByAppendingPathComponent:item];</span><br><span class=\"line\">    <span class=\"built_in\">NSBundle</span> *b = [<span class=\"built_in\">NSBundle</span> bundleWithPath:bundlePath];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!b) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Could not make a bundle from %@\"</span>, bundlePath);</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取实现插件代理协议方法的类</span></span><br><span class=\"line\">    <span class=\"keyword\">id</span> &lt;TextEditPlugin&gt; plugin = [[b principalClass] new];</span><br><span class=\"line\">    <span class=\"built_in\">NSMenuItem</span> *item = [pluginsMenu addItemWithTitle:[plugin menuItemTitle] action:<span class=\"keyword\">@selector</span>(pluginMenuItemCalledAction:) keyEquivalent:<span class=\"string\">@\"\"</span>];</span><br><span class=\"line\">    [item setRepresentedObject:plugin];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：扫描插件目录，确保得到的是一个 <code>.bundle</code> 文件，然后用 <code>NSBundle</code> 载入你找到的 <code>bundle</code> 并且实例化里面的类。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"插件代理\"><a href=\"#插件代理\" class=\"headerlink\" title=\"插件代理\"></a>插件代理</h3><p>你会注意到一个 <code>TextEditPlugin</code> 的 <code>protocol</code> 的引用。在 <code>TextEditMisc.h</code> 能找它的定义:<br><figure class=\"highlight objc\"><figcaption><span>声明代理协议</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">TextEditPlugin</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span>*)menuItemTitle;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)actionCalledWithTextView:(<span class=\"built_in\">NSTextView</span>*)textView inDocument:(<span class=\"keyword\">id</span>)document;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure><br>这说明你实例化的类需要响应这两个方法。你可以验证这个类是否响应这两个方法。</p>\n<h3 id=\"NSPrincipalClass键-值–实现插件代理协议方法的类名称\"><a href=\"#NSPrincipalClass键-值–实现插件代理协议方法的类名称\" class=\"headerlink\" title=\"NSPrincipalClass键:值–实现插件代理协议方法的类名称\"></a>NSPrincipalClass键:值–实现插件代理协议方法的类名称</h3><p>在 <code>bundle</code> 里面调用的 <code>principalClass</code> 方法是什么呢？<br>当你创建一个 <code>Bundle</code> 的时候，你可以在里面创建一个或者多个类，同时你需要让 <code>TextEdit</code> 知道哪一个类需要被实例化。为了帮助宿主 App 调用，你可以在 <code>Info.plist</code> 文件加入一个 <code>NSPrincipalClass</code> 的键，同时设置它的值为实现插件方法的类的名字。你可以用 <code>[NSBundle principalClass]</code> 方便地从 <code>NSPrincipalClass</code> 的值里面寻找并创建这个类。</p>\n<h3 id=\"添加扩展插件菜单的响应事件\"><a href=\"#添加扩展插件菜单的响应事件\" class=\"headerlink\" title=\"添加扩展插件菜单的响应事件\"></a>添加扩展插件菜单的响应事件</h3><p>在 <code>Plug-Ins</code> 菜单加入一个新的按钮，设置 <code>action</code> 为 <code>pluginMenuItemCalledAction:</code>，并且设置它表示你已经实例化的对象。</p>\n<blockquote>\n<p>如果在 <code>menu item</code> 里面没有设置一个<code>target</code>，即目标是<code>nil</code>，那么它会寻找响应链，来寻找第一个实现 <code>pluginMenuItemCalledAction:</code> 方法的对象。如果它找不到，那么这个菜单选项将会不能用。<br>举一个例子，实现 <code>pluginMenuItemCalledAction</code> 的最好的地方是在 <code>Document</code> 的 <code>window controller</code> 类中。打开 <code>DocumentWindowController.m</code>，然后定位到<code>pluginMenuItemCalledAction</code><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)pluginMenuItemCalledAction:(<span class=\"keyword\">id</span>)sender </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">id</span> &lt;TextEditPlugin&gt;plugin = [sender representedObject];</span><br><span class=\"line\">    [plugin actionCalledWithTextView:[<span class=\"keyword\">self</span> firstTextView] inDocument:[<span class=\"keyword\">self</span> document]];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>代码本身很清晰，搜集插件实例，调用 <code>actionCalledWithTextView:inDocument:</code> 方法（被定义在 <code>protocol</code> 里面的），运行你插件里面的代码。</p>\n<h2 id=\"制作插件\"><a href=\"#制作插件\" class=\"headerlink\" title=\"制作插件\"></a>制作插件</h2><ol>\n<li>新建模版项目<br>打开 “01 MarkYellow” 工程看一下。这是一个 Xcode (通过<code>OS X ▸ Framework &amp; Library ▸ Bundle template</code> 建立) 的标准工程，里面只添加了一个类：<code>TEMarkYellow</code>。</li>\n<li>设置NSPrincipalClass键值<br>如果你打开<code>MarkYellow-Info.plist</code>，你可以看到 <code>NSPrincipalClass</code> 的值设置成了上面提到的 <code>TEMarkYellow</code>。</li>\n<li>实现协议代理<br>接着，打开 <code>TEMarkYellow.m</code>，你将会看见定义在协议里面的方法。<ul>\n<li>第一个方法（<code>menuItemTitle</code>）返回插件的名字，最为入口名显示在 <code>menu</code> 里面。</li>\n<li>第二个方法 (<code>actionCalledWithTextView:inDocument:</code>)，把所有选中的文字变成黄色的背景。<figure class=\"highlight objc\"><figcaption><span>改变字体颜色</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)actionCalledWithTextView:(<span class=\"built_in\">NSTextView</span>*)textView inDocument:(<span class=\"keyword\">id</span>)document </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([textView selectedRange].length) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableAttributedString</span> *ats = [[[textView textStorage] attributedSubstringFromRange:[textView selectedRange]] mutableCopy];</span><br><span class=\"line\">        [ats addAttribute:<span class=\"built_in\">NSBackgroundColorAttributeName</span> value:[<span class=\"built_in\">NSColor</span> yellowColor] range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, [ats length])];</span><br><span class=\"line\">        <span class=\"comment\">//  先测试text view是否能改变文字内容，这样可以自动做正确的撤销操作。</span></span><br><span class=\"line\">        By asking the text view <span class=\"keyword\">if</span> you can change the text first, it will automatically <span class=\"keyword\">do</span> the right thing to enable undoing of attribute changes</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([textView shouldChangeTextInRange:[textView selectedRange] replacementString:[ats string]])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            [[textView textStorage] replaceCharactersInRange:[textView selectedRange] withAttributedString:ats];</span><br><span class=\"line\">            [textView didChangeText];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"集成插件\"><a href=\"#集成插件\" class=\"headerlink\" title=\"集成插件\"></a>集成插件</h2><p>运行 <code>TextEdit</code> （它会创建<code>Plug-Ins</code>目录），然后构建 <code>MarkYellow</code> 工程。把 <code>MarkYellow.bundle</code> 丢到你的 <code>~/Library/Application Support/Text Edit/Plug-Ins/</code> 目录下面，重启你的 <code>TextEdit</code> 应用。<br>一切看起来都很好，扫描，加载，插入一个菜单，然后，当你使用菜单项的时候，传递到参数到插件里面。试一试，点击 <code>Plug-Ins ▸ Mark Selected Text Yellow</code>，选择的文字的背景颜色就变成黄色的了。</p>\n<h2 id=\"XCode8版本问题\"><a href=\"#XCode8版本问题\" class=\"headerlink\" title=\"XCode8版本问题\"></a>XCode8版本问题</h2><p>Xcode8 不再支持<code>Application Plug-in</code>插件<br><img title=\"项目创建模版\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcode6.jpg?imageMogr2/2/w/800\"><br><a href=\"http://www.jianshu.com/p/39443429f71d\" target=\"_blank\" rel=\"noopener\">XCode8.2.1继续使用xcode插件</a><br>这个是因为苹果解决xcode ghost，把插件屏蔽了。<br>解决方法<br><code>sudo /usr/libexec/xpccachectl</code><br>然后必须重启电脑后生效.</p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"}],"tags":[{"name":"macOS","path":"api/tags/macOS.json"},{"name":"插件","path":"api/tags/插件.json"},{"name":"objc","path":"api/tags/objc.json"}]}]}