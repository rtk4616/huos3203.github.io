{"total":157,"pageSize":10,"pageCount":16,"data":[{"title":"iOS视图渲染","slug":"iOS/iOS视图渲染","date":"2017-09-23T14:51:07.000Z","updated":"2017-09-23T17:28:45.000Z","comments":true,"path":"api/articles/iOS/iOS视图渲染.json","excerpt":null,"keywords":null,"cover":"https://objccn.io/images/issue-3/pixels-software-stack.png","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"图形堆栈\"><a href=\"#图形堆栈\" class=\"headerlink\" title=\"图形堆栈\"></a>图形堆栈</h2><p>当像素映射到屏幕上的时候，后台发生了很多事情。但一旦他们显示到屏幕上，每一个像素均由三个颜色组件构成：红，绿，蓝。三个独立的颜色单元会根据给定的颜色显示到一个像素上。在 iPhone5 的<a href=\"https://zh.wikipedia.org/wiki/%E6%A9%AB%E5%90%91%E9%9B%BB%E5%A0%B4%E6%95%88%E6%87%89%E9%A1%AF%E7%A4%BA%E6%8A%80%E8%A1%93\" target=\"_blank\" rel=\"noopener\">液晶显示器</a>上有1,136×640=727,040个像素，因此有2,181,120个颜色单元。在15寸视网膜屏的 MacBook Pro 上，这一数字达到15.5百万以上。所有的图形堆栈一起工作以确保每次正确的显示。当你滚动整个屏幕的时候，数以百万计的颜色单元必须以每秒60次的速度刷新，这是一个很大的工作量。</p>\n<h3 id=\"软件堆栈组成\"><a href=\"#软件堆栈组成\" class=\"headerlink\" title=\"软件堆栈组成\"></a>软件堆栈组成</h3><p>从简单的角度来看，软件堆栈看起来有点像这样：</p>\n<p><img src=\"https://objccn.io/images/issue-3/pixels-software-stack.png\" alt=\"软件堆栈\"></p>\n<h4 id=\"GPU强大的图形硬件\"><a href=\"#GPU强大的图形硬件\" class=\"headerlink\" title=\"GPU强大的图形硬件\"></a>GPU强大的图形硬件</h4><p><code>Display</code>的上一层便是图形处理单元 GPU，<code>GPU</code> 是一个专门为图形高并发计算而量身定做的处理单元。这也是为什么它能同时更新所有的像素，并呈现到显示器上。它并发的本性让它能高效的将不同纹理合成起来。我们将有一小块内容来更详细的讨论图形合成。关键的是，GPU 是非常专业的，因此在某些工作上非常高效。比如，GPU 非常快，并且比 CPU 使用更少的电来完成工作。通常 CPU 都有一个普遍的目的，它可以做很多不同的事情，但是合成图像在 CPU 上却显得比较慢。</p>\n<p>GPU 是一个非常强大的图形硬件，并且在显示像素方面起着核心作用。它连接到 CPU。从硬件上讲两者之间存在某种类型的<a href=\"https://zh.wikipedia.org/wiki/I/O%E6%80%BB%E7%BA%BF\" target=\"_blank\" rel=\"noopener\">总线</a>，并且有像 OpenGL，Core Animation 和 Core Graphics 这样的框架来在 GPU 和 CPU 之间精心安排数据的传输。为了将像素显示到屏幕上，一些处理将在 CPU 上进行。然后数据将会传送到 GPU，这也需要做一些相应的操作，最终像素显示到屏幕上。</p>\n<p><code>GPU Driver</code>是直接和 GPU 交流的代码块。不同的GPU是不同的性能怪兽，但是驱动使他们在下一个层级上显示的更为统一，典型的下一层级有 OpenGL/OpenGL ES.</p>\n<h4 id=\"OpenGL的扩展API\"><a href=\"#OpenGL的扩展API\" class=\"headerlink\" title=\"OpenGL的扩展API\"></a>OpenGL的扩展API</h4><p>OpenGL(<a href=\"http://zh.wikipedia.org/wiki/OpenGL\" target=\"_blank\" rel=\"noopener\">Open Graphics Library</a>) 是一个提供了 2D 和 3D 图形渲染的 API。GPU 是一块非常特殊的硬件，OpenGL  和 GPU 密切的工作以提高GPU的能力，并实现硬件加速渲染。</p>\n<p>在 iOS 上，几乎所有的东西都是通过 Core Animation 绘制出来，因为 Core Animation 使用 Core Graphics 来做一些渲染。像 AVFoundation，Core Image 框架，和其他一些混合的入口。<br>在OS X 上，绕过 Core Animation 直接使用 Core Graphics 绘制的情况并不少见。对于一些专门的应用，尤其是游戏，程序可能直接和 OpenGL/OpenGL ES 交流。</p>\n<h2 id=\"GPU纹理合成渲染流程\"><a href=\"#GPU纹理合成渲染流程\" class=\"headerlink\" title=\"GPU纹理合成渲染流程\"></a>GPU纹理合成渲染流程</h2><p><img src=\"https://objccn.io/images/issue-3/pixels%2C%20hardware.png\" alt=\"挑战\"></p>\n<p>合成挑战：GPU 需要将每一个 frame 的纹理(位图)合成在一起(一秒60次)。每一个纹理会占用 VRAM(video RAM)，所以需要给 GPU 同时保持纹理的数量做一个限制。GPU 在合成方面非常高效，但是某些合成任务却比其他更复杂，并且 GPU在 16.7ms(1/60s)内能做的工作也是有限的。</p>\n<p>耗时挑战：下一个挑战就是将数据传输到 GPU 上。为了让 GPU 访问数据，需要将数据从 RAM 移动到 VRAM 上。这就是提及到的上传数据到 GPU。这看起来貌似微不足道，但是一些大型的纹理却会非常耗时。</p>\n<p>最终，CPU 开始运行你的程序。你可能会让 CPU 从 bundle 加载一张 PNG 的图片并且解压它。这所有的事情都在 CPU 上进行。然后当你需要显示解压缩后的图片时，它需要以某种方式上传到 GPU。一些看似平凡的，比如显示文本，对 CPU 来说却是一件非常复杂的事情，这会促使 Core Text 和 Core Graphics 框架更紧密的集成来根据文本生成一个位图。一旦准备好，它将会被作为一个纹理上传到 GPU 并准备显示出来。当你滚动或者在屏幕上移动文本时，不管怎么样，同样的纹理能够被复用，CPU 只需简单的告诉 GPU 新的位置就行了,所以 GPU 就可以重用存在的纹理了。CPU 并不需要重新渲染文本，并且位图也不需要重新上传到 GPU。</p>\n<p>这张图涉及到一些错综复杂的方面，我们将会把这些方面提取出来并深一步了解。</p>\n<h3 id=\"合成-纹理概念\"><a href=\"#合成-纹理概念\" class=\"headerlink\" title=\"合成/纹理概念\"></a>合成/纹理概念</h3><p>合成：在图形世界中，合成是一个描述不同位图如何放到一起来创建你最终在屏幕上看到图像的过程。</p>\n<p>纹理：屏幕上一切事物皆纹理。一个纹理就是一个包含 RGBA 值的长方形，比如，每一个像素里面都包含红、绿、蓝和透明度的值。在 Core Animation 世界中的纹理就是 CALayer。</p>\n<p>纹理合成：在这个简化的设置中，每一个 layer 是一个纹理，所有的纹理都以某种方式堆叠在彼此的顶部。对于屏幕上的每一个像素，GPU 需要算出怎么混合这些纹理来得到像素 RGB 的值。</p>\n<h3 id=\"纹理合成像素的计算公式\"><a href=\"#纹理合成像素的计算公式\" class=\"headerlink\" title=\"纹理合成像素的计算公式\"></a>纹理合成像素的计算公式</h3><p>如果我们所拥有的是一个和屏幕大小一样并且和屏幕像素对齐的单一纹理，那么屏幕上每一个像素相当于纹理中的一个像素，纹理的最后一个像素也就是屏幕的最后一个像素。</p>\n<p>如果我们有第二个纹理放在第一个纹理之上，然后GPU将会把第二个纹理合成到第一个纹理中。有很多种不同的合成方法，但是如果我们假定两个纹理的像素对齐，并且使用正常的混合模式，我们便可以用下面这个公式来计算每一个像素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R = S + D * ( 1 – Sa )</span><br></pre></td></tr></table></figure></p>\n<p>结果的颜色是源色彩(顶端纹理)+目标颜色(低一层的纹理)*(1-源颜色的透明度)。在这个公式中所有的颜色都假定已经预先乘以了他们的透明度。</p>\n<p>显然相当多的事情在这发生了。让我们进行第二个假定，两个纹理都完全不透明，比如 alpha=1.如果目标纹理(低一层的纹理)是蓝色(RGB=0,0,1)，并且源纹理(顶层的纹理)颜色是红色(RGB=1,0,0)，因为 Sa 为1，所以结果为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R = S</span><br></pre></td></tr></table></figure></p>\n<p>结果是源颜色的红色。这正是我们所期待的(红色覆盖了蓝色)。</p>\n<p>如果源颜色层为50%的透明，比如 alpha=0.5，既然 alpha 组成部分需要预先乘进 RGB 的值中，那么 S 的 RGB 值为(0.5, 0, 0)，公式看起来便会像这样:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0.5   0               0.5</span><br><span class=\"line\">R = S + D * (1 - Sa) = 0   + 0 * (1 - 0.5) = 0</span><br><span class=\"line\">0     1               0.5</span><br></pre></td></tr></table></figure></p>\n<p>我们最终得到RGB值为(0.5, 0, 0.5),是一个紫色。这正是我们所期望将透明红色合成到蓝色背景上所得到的。</p>\n<p>记住我们刚刚只是将纹理中的一个像素合成到另一个纹理的像素上。当两个纹理覆盖在一起的时候，GPU需要为所有像素做这种操作。正如你所知道的一样，许多程序都有很多层，因此所有的纹理都需要合成到一起。尽管GPU是一块高度优化的硬件来做这种事情，但这还是会让它非常忙碌。</p>\n<h4 id=\"opaque-的属性：不透明-VS-透明\"><a href=\"#opaque-的属性：不透明-VS-透明\" class=\"headerlink\" title=\"opaque 的属性：不透明 VS 透明\"></a>opaque 的属性：不透明 VS 透明</h4><p>当源纹理是完全不透明的时候，目标像素就等于源纹理。这可以省下 GPU 很大的工作量，这样只需简单的拷贝源纹理而不需要合成所有的像素值。<br> CALayer 有一个叫做 opaque 的属性会告诉 GPU 纹理上的像素是透明还是不透明的。如果这个属性为 YES，GPU 将不会做任何合成，而是简单从这个层拷贝，不需要考虑它下方的任何东西(因为都被它遮挡住了)。这节省了 GPU 相当大的工作量。这也正是 Instruments 中 color blended layers 选项中所涉及的。(这在模拟器中的Debug菜单中也可用).它允许你看到哪一个 layers(纹理) 被标注为透明的，比如 GPU 正在为哪一个 layers 做合成。合成不透明的 layers 因为需要更少的数学计算而更廉价。<br> 所以如果你知道你的 layer 是不透明的，最好确定设置它的 opaque 为 YES。如果你加载一个没有 alpha 通道的图片，并且将它显示在 UIImageView 上，这将会自动发生。但是要记住如果一个图片没有 alpha 通道和一个图片每个地方的 alpha 都是100%，这将会产生很大的不同。在后一种情况下，Core Animation 需要假定是否存在像素的 alpha 值不为100%。在 Finder 中，你可以使用 Get Info 并且检查 More Info 部分。它将告诉你这张图片是否拥有 alpha 通道。</p>\n<h4 id=\"像素对齐-VS-不重合在一起\"><a href=\"#像素对齐-VS-不重合在一起\" class=\"headerlink\" title=\"像素对齐 VS 不重合在一起\"></a>像素对齐 VS 不重合在一起</h4><ol>\n<li>像素对齐<br>到现在我们都在考虑像素完美重合在一起的 layers。当所有的像素是对齐的时候我们得到相对简单的计算公式。每当 GPU 需要计算出屏幕上一个像素是什么颜色的时候，它只需要考虑在这个像素之上的所有 layer 中对应的单个像素，并把这些像素合并到一起。或者，如果最顶层的纹理是不透明的(即图层树的最底层)，这时候 GPU 就可以简单的拷贝它的像素到屏幕上。</li>\n<li>滚动/错位<br>当一个 layer 上所有的像素和屏幕上的像素完美的对应整齐，那这个 layer 就是像素对齐的。主要有两个原因可能会造成不对齐。<br>第一个便是滚动：当一个纹理上下滚动的时候，纹理的像素便不会和屏幕的像素排列对齐。<br>另一个原因便是：当纹理的起点不在一个像素的边界上。</li>\n</ol>\n<p>在这两种情况下，GPU 需要再做额外的计算。它需要将源纹理上多个像素混合起来，生成一个用来合成的值。当所有的像素都是对齐的时候，GPU 只剩下很少的工作要做。</p>\n<p>Core Animation 工具和模拟器有一个叫做 color misaligned images 的选项，当这些在你的 CALayer 实例中发生的时候，这个功能便可向你展示。</p>\n<h3 id=\"Masks位图蒙板\"><a href=\"#Masks位图蒙板\" class=\"headerlink\" title=\"Masks位图蒙板\"></a>Masks位图蒙板</h3><p>一个图层可以有一个和它相关联的 mask(蒙板)，mask 是一个拥有 alpha 值的位图，当像素要和蒙板下面包含的像素合并之前都会把 mask 应用到图层的像素上去，最终只有在 mask 中显示出来的(即图层中的部分)才会被渲染出来。<br>例如：当你要设置一个图层的圆角半径时，你可以有效的在图层上面设置一个 mask。但是也可以指定任意一个蒙板。比如，一个字母 A 形状的 mask。</p>\n<h3 id=\"离屏渲染-Offscreen-Rendering\"><a href=\"#离屏渲染-Offscreen-Rendering\" class=\"headerlink\" title=\"离屏渲染(Offscreen Rendering)\"></a>离屏渲染(Offscreen Rendering)</h3><p>离屏渲染：即在屏幕外对图层树的合并/渲染，此时会有一个屏幕外缓冲区缓存图层树，然后该缓冲区会被渲染到屏幕上。离屏渲染可以被 Core Animation 自动触发，或者被应用程序强制触发。</p>\n<p>离屏渲染合成计算是非常昂贵的, 但有时你也许希望强制这种操作。一种好的方法就是缓存合成的纹理/图层。如果你的渲染树非常复杂(所有的纹理，以及如何组合在一起)，你可以强制离屏渲染缓存那些图层，然后可以用缓存作为合成的结果放到屏幕上。<br>Instrument 的 Core Animation 工具有一个叫做 <em>Color Offscreen-Rendered Yellow</em> 的选项，它会将已经被渲染到屏幕外缓冲区的区域标注为黄色(这个选项在模拟器中也可以用)。同时记得检查 <em>Color Hits Green and Misses Red</em> 选项。绿色代表无论何时一个屏幕外缓冲区被复用，而红色代表当缓冲区被重新创建。</p>\n<h4 id=\"GPU离屏渲染多图层动画\"><a href=\"#GPU离屏渲染多图层动画\" class=\"headerlink\" title=\"GPU离屏渲染多图层动画\"></a>GPU离屏渲染多图层动画</h4><p>如果你的程序混合了很多图层，并且想要他们一起做动画，GPU 通常会为每一帧(1/60s)重复合成所有的图层。当使用离屏渲染时，GPU 第一次会混合所有图层到一个基于新的纹理的位图缓存上，然后使用这个纹理来绘制到屏幕上。现在，当这些图层一起移动的时候，GPU 便可以复用这个位图缓存，并且只需要做很少的工作。需要注意的是，只有当那些图层不改变时，这才可以用。如果那些图层改变了，GPU 需要重新创建位图缓存。你可以通过设置 shouldRasterize 为 YES 来触发这个行为。</p>\n<ol>\n<li>两个权衡点<br>第一，这可能会使事情变得更慢。创建额外的屏幕外缓冲区是 GPU 需要多做的一步操作，特殊情况下这个位图可能再也不需要被复用，这便是一个无用功了。<br>第二，可以被复用的位图，GPU 也有可能将它卸载了。所以你需要计算 GPU 的利用率和帧的速率来判断这个位图是否有用。</li>\n<li><p>副作用：mask蒙板渲染至缓冲区<br>离屏渲染也可能产生副作用。如果你正在直接或者间接的将mask应用到一个图层上，Core Animation 为了应用这个 mask，会强制进行屏幕外渲染。这会对 GPU 产生重负。通常情况下 mask 只能被直接渲染到帧的缓冲区中(在屏幕内)。</p>\n</li>\n<li><p>避免使用离屏渲染<br>因为直接将图层合成到帧的缓冲区中(在屏幕上)比先创建屏幕外缓冲区，然后渲染到纹理中，最后将结果渲染到帧的缓冲区中要廉价很多。这其中涉及两次昂贵的环境转换(转换环境到屏幕外缓冲区，然后转换环境到帧缓冲区)。<br>layer的几种触发离屏渲染<br>为 layer 使用蒙板或者设置圆角半径会造成屏幕外渲染，产生阴影也会如此。<br>至于 mask，圆角半径(特殊的mask)和 clipsToBounds/masksToBounds，你可以简单的为一个已经拥有 mask 的 layer 创建内容，比如，已经应用了 mask 的 layer 使用一张图片。如果你想根据 layer 的内容为其应用一个长方形 mask，你可以使用 contentsRect 来代替蒙板。<br>如果你最后设置了 shouldRasterize 为 YES，那也要记住设置 rasterizationScale 为 contentsScale。<br>所以当你打开 <em>Color Offscreen-Rendered Yellow</em> 后看到黄色，这便是一个警告，但这不一定是不好的。如果 Core Animation 能够复用屏幕外渲染的结果，这便能够提升性能。</p>\n</li>\n<li>离屏渲染空间限制<br>同时还要注意，rasterized layer 的空间是有限的。苹果暗示大概有屏幕大小两倍的空间来存储 rasterized layer/屏幕外缓冲区。</li>\n</ol>\n<h2 id=\"更多的关于合成\"><a href=\"#更多的关于合成\" class=\"headerlink\" title=\"更多的关于合成\"></a>更多的关于合成</h2><p>像往常一样，维基百科上有更多关于<a href=\"https://en.wikipedia.org/wiki/Alpha_compositing\" target=\"_blank\" rel=\"noopener\">透明合成</a>的基础公式。当我们谈完像素后，我们将更深入一点的谈论红，绿，蓝和 alpha 是怎么在内存中表现的。</p>\n<h2 id=\"OS-X\"><a href=\"#OS-X\" class=\"headerlink\" title=\"OS X\"></a>OS X</h2><p>如果你是在 OS X 上工作，你将会发现大多数 debugging 选项在一个叫做 <em>Quartz Debug</em> 的独立程序中，而不是在 Instruments 中。Quartz Debug 是 Graphics Tools 中的一部分，这可以在苹果的 <a href=\"https://developer.apple.com/downloads/\" target=\"_blank\" rel=\"noopener\">developer portal</a> 中下载到。</p>\n<h2 id=\"Core-Animation-OpenGL-ES\"><a href=\"#Core-Animation-OpenGL-ES\" class=\"headerlink\" title=\"Core Animation  OpenGL ES\"></a>Core Animation  OpenGL ES</h2><p>正如名字所建议的那样，Core Animation 让你在屏幕上实现动画。我们将跳过动画部分，而集中在绘图上。需要注意的是，Core Animation 允许你做非常高效的渲染。这也是为什么当你使用 Core Animation 时可以实现每秒 60 帧的动画。</p>\n<p>Core Animation 的核心是 OpenGL ES 的一个抽象物，简而言之，它让你直接使用 OpenGL ES 的功能，却不需要处理 OpenGL ES 做的复杂的事情。当我们上面谈论合成的时候，我们把 layer 和 texture 当做等价的，但是他们不是同一物体，可又是如此的类似。</p>\n<p>Core Animation 的 layer 可以有子 layer，所以最终你得到的是一个图层树。Core Animation 所需要做的最繁重的任务便是判断出哪些图层需要被(重新)绘制，而 OpenGL ES 需要做的便是将图层合并、显示到屏幕上。</p>\n<p>举个例子，当你设置一个 layer 的内容为 CGImageRef 时，Core Animation 会创建一个 OpenGL 纹理，并确保在这个图层中的位图被上传到对应的纹理中。以及当你重写 <code>-drawInContext</code> 方法时，Core Animation 会请求分配一个纹理，同时确保 Core Graphics 会将你所做的(即你在<code>drawInContext</code>中绘制的东西)放入到纹理的位图数据中。一个图层的性质和 CALayer 的子类会影响到 OpenGL 的渲染结果，许多低等级的 OpenGL ES 行为被简单易懂地封装到 CALayer 概念中。</p>\n<p>Core Animation 通过 Core Graphics 的一端和 OpenGL ES 的另一端，精心策划基于 CPU 的位图绘制。因为 Core Animation 处在渲染过程中的重要位置上，所以你如何使用 Core Animation 将会对性能产生极大的影响。</p>\n<h2 id=\"CPU限制-VS-GPU限制\"><a href=\"#CPU限制-VS-GPU限制\" class=\"headerlink\" title=\"CPU限制 VS GPU限制\"></a>CPU限制 VS GPU限制</h2><p>当你在屏幕上显示东西的时候，有许多组件参与了其中的工作。其中，CPU 和 GPU 在硬件中扮演了重要的角色。在他们命名中 P 和 U 分别代表了”处理”和”单元”，当需要在屏幕上进行绘制时，他们都需要做处理，同时他们都有资源限制(即 CPU 和 GPU 的硬件资源)。</p>\n<p>为了每秒达到 60 帧，你需要确定 CPU 和 GPU 不能过载。此外，即使你当前能达到 60fps(frame per second),你还是要把尽可能多的绘制工作交给 GPU 做，而让 CPU 尽可能的来执行应用程序。通常，GPU 的渲染性能要比 CPU 高效很多，同时对系统的负载和消耗也更低一些。</p>\n<p>既然绘图性能是基于 CPU 和 GPU 的，那么你需要找出是哪一个限制你绘图性能的。如果你用尽了 GPU 所有的资源，也就是说，是 GPU 限制了你的性能，同样的，如果你用尽了 CPU，那就是 CPU 限制了你的性能。</p>\n<p>要告诉你，如果是 GPU 限制了你的性能，你可以使用 OpenGL ES Driver instrument。点击上面那个小的 i 按钮，配置一下，同时注意勾选 Device Utilization %。现在，当你运行你的 app 时，你可以看到你 GPU 的负荷。如果这个值靠近 100%，那么你就需要把你工作的重心放在GPU方面了。</p>\n<h2 id=\"Core-Graphics-Quartz-2D\"><a href=\"#Core-Graphics-Quartz-2D\" class=\"headerlink\" title=\"Core Graphics / Quartz 2D\"></a>Core Graphics / Quartz 2D</h2><p>通过 Core Graphics 这个框架，Quartz 2D 被更为广泛的知道。</p>\n<p>Quartz 2D 拥有比我们这里谈到更多的装饰。我们这里不会过多的讨论关于 PDF 的创建，渲染，解析，或者打印。只需要注意的是，PDF 的打印、创建和在屏幕上绘制位图的操作是差不多的。因为他们都是基于 Quartz 2D。</p>\n<p>让我们简单的了解一下 <a href=\"https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html\" target=\"_blank\" rel=\"noopener\">Quartz 2D</a> 主要的概念。有关详细信息可以到苹果的官方文档中了解。</p>\n<p>放心，当 Quartz 2D 涉及到 2D 绘制的时候，它是非常强大的。有基于路径的绘制，反锯齿渲染，透明图层，分辨率，并且设备独立，可以说出很多特色。这可能会让人产生畏惧，主要因为这是一个低级并且基于 C 的 API。</p>\n<p>主要的概念相对简单，UIKit 和 AppKit 都包含了 Quartz 2D 的一些简单 API，一旦你熟练了，一些简单 C 的 API 也是很容易理解的。最终你学会了一个能实现 Photoshop 和 Illustrator 大部分功能的绘图引擎。苹果把 iOS 程序里面的<a href=\"https://developer.apple.com/videos/wwdc/2011/?id=129\" target=\"_blank\" rel=\"noopener\">股票应用</a>作为讲解 Quartz 2D 在代码中实现动态渲染的一个例子。</p>\n<p>当你的程序进行位图绘制时，不管使用哪种方式，都是基于 Quartz 2D 的。也就是说，CPU 部分实现的绘制是通过 Quartz 2D 实现的。尽管 Quartz 可以做其它的事情，但是我们这里还是集中于位图绘制，在缓冲区(一块内存)绘制位图会包括 RGBA 数据。</p>\n<p>比方说，我们要画一个<a href=\"https://zh.wikipedia.org/wiki/%E5%85%AB%E8%BE%B9%E5%BD%A2\" target=\"_blank\" rel=\"noopener\">八角形</a>，我们通过 UIKit 能做到这一点<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIBezierPath</span> *path = [<span class=\"built_in\">UIBezierPath</span> bezierPath];</span><br><span class=\"line\">[path moveToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">16.72</span>, <span class=\"number\">7.22</span>)];</span><br><span class=\"line\">[path addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">3.29</span>, <span class=\"number\">20.83</span>)];</span><br><span class=\"line\">[path addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">0.4</span>, <span class=\"number\">18.05</span>)];</span><br><span class=\"line\">[path addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">18.8</span>, <span class=\"number\">-0.47</span>)];</span><br><span class=\"line\">[path addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">37.21</span>, <span class=\"number\">18.05</span>)];</span><br><span class=\"line\">[path addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">34.31</span>, <span class=\"number\">20.83</span>)];</span><br><span class=\"line\">[path addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">20.88</span>, <span class=\"number\">7.22</span>)];</span><br><span class=\"line\">[path addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">20.88</span>, <span class=\"number\">42.18</span>)];</span><br><span class=\"line\">[path addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">16.72</span>, <span class=\"number\">42.18</span>)];</span><br><span class=\"line\">[path addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">16.72</span>, <span class=\"number\">7.22</span>)];</span><br><span class=\"line\">[path closePath];</span><br><span class=\"line\">path.lineWidth = <span class=\"number\">1</span>;</span><br><span class=\"line\">[[<span class=\"built_in\">UIColor</span> redColor] setStroke];</span><br><span class=\"line\">[path stroke];</span><br></pre></td></tr></table></figure></p>\n<p>相对应的 Core Graphics 代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGContextBeginPath</span>(ctx);</span><br><span class=\"line\"><span class=\"built_in\">CGContextMoveToPoint</span>(ctx, <span class=\"number\">16.72</span>, <span class=\"number\">7.22</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">3.29</span>, <span class=\"number\">20.83</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">0.4</span>, <span class=\"number\">18.05</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">18.8</span>, <span class=\"number\">-0.47</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">37.21</span>, <span class=\"number\">18.05</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">34.31</span>, <span class=\"number\">20.83</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">20.88</span>, <span class=\"number\">7.22</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">20.88</span>, <span class=\"number\">42.18</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">16.72</span>, <span class=\"number\">42.18</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">16.72</span>, <span class=\"number\">7.22</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextClosePath</span>(ctx);</span><br><span class=\"line\"><span class=\"built_in\">CGContextSetLineWidth</span>(ctx, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextSetStrokeColorWithColor</span>(ctx, [<span class=\"built_in\">UIColor</span> redColor].CGColor);</span><br><span class=\"line\"><span class=\"built_in\">CGContextStrokePath</span>(ctx);</span><br></pre></td></tr></table></figure></p>\n<p>需要问的问题是:这个绘制到哪儿去了？这正好引出所谓的 CGContext 登场。我们传过去的ctx参数正是在那个上下文中。而这个上下文定义了我们需要绘制的地方。如果我们实现了 CALayer 的 <code>-drawInContext:</code> 这时已经传过来一个上下文。绘制到这个上下文中的内容将会被绘制到图层的备份区(图层的缓冲区).但是我们也可以创建我们自己的上下文，叫做基于位图的上下文，比如 <code>CGBitmapContextCreate()</code>.这个方法返回一个我们可以传给 CGContext 方法来绘制的上下文。</p>\n<p>注意 UIKit 版本的代码为何不传入一个上下文参数到方法中？这是因为当使用 UIKit 或者 AppKit 时，上下文是唯一的。UIkit 维护着一个上下文堆栈，UIKit 方法总是绘制到最顶层的上下文中。你可以使用 <code>UIGraphicsGetCurrentContext()</code> 来得到最顶层的上下文。你可以使用 <code>UIGraphicsPushContext()</code> 和 <code>UIGraphicsPopContext()</code> 在 UIKit 的堆栈中推进或取出上下文。</p>\n<p>最为突出的是，UIKit 使用 <code>UIGraphicsBeginImageContextWithOptions()</code> 和 <code>UIGraphicsEndImageContext()</code> 方便的创建类似于 <code>CGBitmapContextCreate()</code> 的位图上下文。混合调用 UIKit 和 Core Graphics 非常简单：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIGraphicsBeginImageContextWithOptions</span>(<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">45</span>, <span class=\"number\">45</span>), <span class=\"literal\">YES</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextRef</span> ctx = <span class=\"built_in\">UIGraphicsGetCurrentContext</span>();</span><br><span class=\"line\"><span class=\"built_in\">CGContextBeginPath</span>(ctx);</span><br><span class=\"line\"><span class=\"built_in\">CGContextMoveToPoint</span>(ctx, <span class=\"number\">16.72</span>, <span class=\"number\">7.22</span>);</span><br><span class=\"line\"><span class=\"built_in\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">3.29</span>, <span class=\"number\">20.83</span>);</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"built_in\">CGContextStrokePath</span>(ctx);</span><br><span class=\"line\"><span class=\"built_in\">UIGraphicsEndImageContext</span>();</span><br></pre></td></tr></table></figure></p>\n<p>或者另外一种方法:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGContextRef</span> ctx = <span class=\"built_in\">CGBitmapContextCreate</span>(<span class=\"literal\">NULL</span>, <span class=\"number\">90</span>, <span class=\"number\">90</span>, <span class=\"number\">8</span>, <span class=\"number\">90</span> * <span class=\"number\">4</span>, space, bitmapInfo);</span><br><span class=\"line\"><span class=\"built_in\">CGContextScaleCTM</span>(ctx, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>);</span><br><span class=\"line\"><span class=\"built_in\">UIGraphicsPushContext</span>(ctx);</span><br><span class=\"line\"><span class=\"built_in\">UIBezierPath</span> *path = [<span class=\"built_in\">UIBezierPath</span> bezierPath];</span><br><span class=\"line\">[path moveToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">16.72</span>, <span class=\"number\">7.22</span>)];</span><br><span class=\"line\">[path addLineToPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">3.29</span>, <span class=\"number\">20.83</span>)];</span><br><span class=\"line\">...</span><br><span class=\"line\">[path stroke];</span><br><span class=\"line\"><span class=\"built_in\">UIGraphicsPopContext</span>(ctx);</span><br><span class=\"line\"><span class=\"built_in\">CGContextRelease</span>(ctx);</span><br></pre></td></tr></table></figure></p>\n<p>你可以使用 Core Graphics 创建大量的非常酷的东西。一个很好的理由就是，苹果的文档有很多例子。我们不能得到所有的细节，但是 Core Graphics 有一个非常接近 <a href=\"https://zh.wikipedia.org/wiki/Adobe_Illustrator\" target=\"_blank\" rel=\"noopener\">Adobe Illustrator</a> 和 <a href=\"https://zh.wikipedia.org/wiki/Adobe_Photoshop\" target=\"_blank\" rel=\"noopener\">Adobe Photoshop</a> 如何工作的绘图模型，并且大多数工具的理念翻译成 Core Graphics 了。终究，他是起源于 <a href=\"https://zh.wikipedia.org/wiki/NEXTSTEP\" target=\"_blank\" rel=\"noopener\">NeXTSTEP</a> 。(原来也是乔老爷的作品)。</p>\n<h2 id=\"CGLayer\"><a href=\"#CGLayer\" class=\"headerlink\" title=\"CGLayer\"></a>CGLayer</h2><p>我们最初指出 CGLayer 可以用来提升重复绘制相同元素的速度。正如 <a href=\"http://iosptl.com/posts/cglayer-no-longer-recommended/\" target=\"_blank\" rel=\"noopener\">Dave Hayden指出</a>，这些<a href=\"http://iosptl.com/posts/cglayer-no-longer-recommended/\" target=\"_blank\" rel=\"noopener\">小道消息</a>不再可靠。</p>\n<h2 id=\"像素\"><a href=\"#像素\" class=\"headerlink\" title=\"像素\"></a>像素</h2><p>屏幕上的像素是由红，绿，蓝三种颜色组件构成的。因此，位图数据有时也被叫做 RGB 数据。你可能会对数据如何组织在内存中感到好奇。而事实是，有很多种不同的方式在内存中展现RGB位图数据。</p>\n<p>稍后我们将会谈到压缩数据，这又是一个完全不同的概念。现在，我们先看一下RGB位图数据，我们可以从颜色组件:红，绿，蓝中得到一个值。而大多数情况下，我们有第四个组件:透明度。最终我们从每个像素中得到四个单独的值。</p>\n<h3 id=\"默认的像素布局\"><a href=\"#默认的像素布局\" class=\"headerlink\" title=\"默认的像素布局\"></a>默认的像素布局</h3><p>在 iOS 和 OS X 上最常见的格式就是大家所熟知的 32bits-per-pixel(bpp), 8bits-per-componet(bpc),透明度会首先被乘以到像素值上(就像上文中提到的那个公式一样),在内存中，像下面这样:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A   R   G   B   A   R   G   B   A   R   G   B</span><br><span class=\"line\">| pixel 0       | pixel 1       | pixel 2</span><br><span class=\"line\">0   1   2   3   4   5   6   7   8   9   10  11 ...</span><br></pre></td></tr></table></figure></p>\n<p>这个格式经常被叫做 ARGB。每个像素占用 4 字节(32bpp),每一个颜色组件是1字节(8bpc).每个像素有一个 alpha 值，这个值总是最先得到的(在RGB值之前)，最终红、绿、蓝的值都会被预先乘以 alpha 的值。预乘的意思就是 alpha 值被烘烤到红、绿、蓝的组件中。如果我们有一个橙色，他们各自的 8bpc 就像这样: <code>240,99,24</code>.一个完全不透明的橙色像素拥有的 ARGB 值为:<code>255，240，99，24</code>，它在内存中的布局就像上面图示那样。如果我们有一个相同颜色的像素，但是 alpha 值为 33%，那么他的像素值便是:<code>84，80，33，8.</code></p>\n<p>另一个常见的格式便是 32bpp，8bpc，跳过第一个 alpha 值，看起来像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x   R   G   B   x   R   G   B   x   R   G   B</span><br><span class=\"line\">| pixel 0       | pixel 1       | pixel 2</span><br><span class=\"line\">0   1   2   3   4   5   6   7   8   9   10  11 ...</span><br></pre></td></tr></table></figure></p>\n<p>这常被叫做 xRGB。像素并没有任何 alpha 值(他们都被假定为100%不透明)，但是内存布局是一样的。你应该想知道为什么这种格式很流行，当我们每一个像素中都有一个不用字节时，我们将会省下 25% 的空间。事实证明，这种格式更容易被现代的 CPU 和绘图算法消化，因为每一个独立的像素都对齐到 32-bit 的边界。现代的 CPU 不喜欢装载(读取)不对齐的数据，特别是当将这种数据和上面没有 alpha 值格式的数据混合时，算法需要做很多挪动和蒙板操作。</p>\n<p>当处理 RGB 数据时，Core Graphics 也需要支持把alpha 值放到最后(另外还要支持跳过)。有时候也分别称为 RGBA 和 RGBx，假定是 8bpc，并且预乘了 alpha 值。</p>\n<h3 id=\"深奥的布局\"><a href=\"#深奥的布局\" class=\"headerlink\" title=\"深奥的布局\"></a>深奥的布局</h3><p>大多数时候，当处理位图数据时，我们也需要处理 Core Graphics/Quartz 2D。有一个非常详细的列表列出了他支持的混合组合。但是让我们首先看一下剩下的 RGB 格式：</p>\n<p>另一个选择是 16bpp，5bpc，不包含 alpha 值。这个格式相比之前一个仅占用 50% 的存储大小(每个像素2字节)，但将使你存储它的 RGB 数据到内存或磁盘中变得困难。既然这种格式中，每个颜色组件只有 5bits(原文中写的是每个像素是5bits，但根据上下文可知应该是每个组件)，这样图形(特别是平滑渐变的)会造成重叠在一起的假象。</p>\n<p>还有一个是 64bpp，16bpc，最终为 128bpp，32bpc，浮点数组件(有或没有 alpha 值)。它们分别使用 8 字节和 16 字节，并且允许更高的精度。当然，这会造成更多的内存使用和昂贵的计算。</p>\n<p>整件事件中，Core Graphics 也支持一些像灰度模式和 <a href=\"https://zh.wikipedia.org/wiki/%E5%8D%B0%E5%88%B7%E5%9B%9B%E5%88%86%E8%89%B2%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">CMYK</a> 格式，这些格式类似于仅有 alpha 值的格式(蒙板)。</p>\n<h3 id=\"二维数据\"><a href=\"#二维数据\" class=\"headerlink\" title=\"二维数据\"></a>二维数据</h3><p>当颜色组件(红、绿、蓝、alpha)混杂在一起的时候，大多数框架(包括 Core Graphics )使用像素数据。正是这种情况下我们称之为二维数据，或者二维组件。这个意思是：每一个颜色组件都在它自己的内存区域，也就是说它是二维的。比如 RGB 数据，我们有三个独立的内存区域，一个大的区域包含了所有像素的红颜色的值，一个包含了所有绿颜色的值，一个包含了所有蓝颜色的值。</p>\n<p>在某些情况下，一些视频框架便会使用二维数据。</p>\n<h3 id=\"YCbCr\"><a href=\"#YCbCr\" class=\"headerlink\" title=\"YCbCr\"></a>YCbCr</h3><p>当我们处理视频数据时，<a href=\"https://zh.wikipedia.org/wiki/YCbCr\" target=\"_blank\" rel=\"noopener\">YCbCr</a> 是一种常见的格式。它也是包含了三种(Y,Cb和Cr)代表颜色数据的组件。但是简单的讲，它更类似于通过人眼看到的颜色。人眼对 Cb 和 Cr 这两种组件的色彩度不太能精确的辨认出来，但是能很准确的识别出 Y 的亮度。当数据使用 YCbCr 格式时，在同等的条件下，Cb 和 Cr 组件比 Y 组件压缩的更紧密。</p>\n<p>出于同样的原因，JPEG 图像有时会将像素数据从 RGB 转换到 YCbCr。JPEG 单独的压缩每一个二维颜色。当压缩基于 YCbCr 的平面时，Cb 和 Cr 能比 Y 压缩得更完全。</p>\n<h2 id=\"图片格式\"><a href=\"#图片格式\" class=\"headerlink\" title=\"图片格式\"></a>图片格式</h2><p>当你在 iOS 或者 OS X 上处理图片时，他们大多数为 JPEG 和 PNG。让我们更进一步观察。</p>\n<h3 id=\"JPEG\"><a href=\"#JPEG\" class=\"headerlink\" title=\"JPEG\"></a>JPEG</h3><p>每个人都知道 JPEG。它是相机的产物。它代表着照片如何存储在电脑上。甚至你妈妈都听说过 JPEG。</p>\n<p>一个很好的理由，很多人都认为 JPEG 文件仅是另一种像素数据的格式，就像我们刚刚谈到的 RGB 像素布局那样。这样理解离真相真是差十万八千里了。</p>\n<p>将 JPEG 数据转换成像素数据是一个非常复杂的过程，你通过一个周末的计划都不能完成，甚至是一个非常漫长的周末(原文的意思好像就是为了表达这个过程非常复杂，不过老外的比喻总让人拎不清)。对于每一个二维颜色，JPEG 使用一种基于<a href=\"https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E4%BD%99%E5%BC%A6%E5%8F%98%E6%8D%A2\" target=\"_blank\" rel=\"noopener\">离散余弦变换</a>(简称 DCT 变换)的算法，将空间信息转变到频域.这个信息然后被量子化，排好序，并且用一种<a href=\"https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81\" target=\"_blank\" rel=\"noopener\">哈夫曼编码</a>的变种来压缩。很多时候，首先数据会被从 RGB 转换到二维 YCbCr，当解码 JPEG 的时候，这一切都将变得可逆。</p>\n<p>这也是为什么当你通过 JPEG 文件创建一个 UIImage 并且绘制到屏幕上时，将会有一个延时，因为 CPU 这时候忙于解压这个 JPEG。如果你需要为每一个 tableviewcell 解压 JPEG，那么你的滚动当然不会平滑(原来 tableviewcell 里面最要不要用 JPEG 的图片)。</p>\n<p>那究竟为什么我们还要用 JPEG 呢？答案就是 JPEG 可以非常非常好的压缩图片。一个通过 iPhone5 拍摄的，未经压缩的图片占用接近 24M。但是通过默认压缩设置，你的照片通常只会在 2-3M 左右。JPEG 压缩这么好是因为它是失真的，它去除了人眼很难察觉的信息，并且这样做可以超出像 gzip 这样压缩算法的限制。但这仅仅在图片上有效的，因为 JPEG 依赖于图片上有很多人类不能察觉出的数据。如果你从一个基本显示文本的网页上截取一张图，JPEG 将不会这么高效。压缩效率将会变得低下，你甚至能看出来图片已经压缩变形了。</p>\n<h3 id=\"PNG\"><a href=\"#PNG\" class=\"headerlink\" title=\"PNG\"></a>PNG</h3><p><a href=\"https://zh.wikipedia.org/wiki/PNG\" target=\"_blank\" rel=\"noopener\">PNG</a>读作”ping”。和 JPEG 相反，它的压缩对格式是无损的。当你将一张图片保存为 PNG，并且打开它(或解压)，所有的像素数据会和最初一模一样，因为这个限制，PNG 不能像 JPEG 一样压缩图片，但是对于像程序中的原图(如buttons，icons)，它工作的非常好。更重要的是，解码 PNG 数据比解码 JPEG 简单的多。</p>\n<p>在现实世界中，事情从来没有那么简单，目前存在了大量不同的 PNG 格式。可以通过维基百科查看详情。但是简言之，PNG 支持压缩带或不带 alpha 通道的颜色像素(RGB)，这也是为什么它在程序原图中表现良好的另一个原因。</p>\n<h3 id=\"挑选一个格式\"><a href=\"#挑选一个格式\" class=\"headerlink\" title=\"挑选一个格式\"></a>挑选一个格式</h3><p>当你在你的程序中使用图片时，你需要坚持这两种格式: JPEG 或者 PNG。读写这种格式文件的压缩和解压文件能表现出很高的性能，另外，还支持并行操作。同时 Apple 正在改进解压缩并可能出现在将来的新操作系统中，届时你将会得到持续的性能提升。如果尝试使用另一种格式，你需要注意到，这可能对你程序的性能会产生影响，同时可能会打开安全漏洞，经常，图像解压缩算法是黑客最喜欢的攻击目标。</p>\n<p>已经写了很多关于优化 PNGs，如果你想要了解更多，请到互联网上查询。非常重要的一点，注意 Xcode 优化 PNG 选项和优化其他引擎有很大的不同。</p>\n<p>当 Xcode 优化一个 PNG 文件的时候，它将 PNG 文件变成一个从技术上讲不再是<a href=\"https://developer.apple.com/library/ios/qa/qa1681/_index.html\" target=\"_blank\" rel=\"noopener\">有效的PNG文件</a>。但是 iOS 可以读取这种文件，并且这比解压缩正常的 PNG 文件更快。Xcode 改变他们，让 iOS 通过一种对正常 PNG 不起作用的算法来对他们解压缩。值得注意的重点是，这改变了像素的布局。正如我们所提到的一样，在像素之下有很多种方式来描绘 RGB 数据，如果这不是 iOS 绘制系统所需要的格式，它需要将每一个像素的数据替换，而不需要加速来做这件事。</p>\n<p>让我们再强调一遍，如果你可以，你需要为原图设置 resizable images。你的文件将变得更小，因此你只需要从文件系统装载更少的数据。</p>\n<h2 id=\"图层后备存储的渲染\"><a href=\"#图层后备存储的渲染\" class=\"headerlink\" title=\"图层后备存储的渲染\"></a>图层后备存储的渲染</h2><h3 id=\"UIKit-和-Pixels\"><a href=\"#UIKit-和-Pixels\" class=\"headerlink\" title=\"UIKit 和 Pixels\"></a>UIKit 和 Pixels</h3><p>每一个在 UIKit 中的 view 都有它自己的 CALayer。依次，这些图层都有一个叫像素位图的后备存储，有点像一个图像。这个后备存储正是被渲染到显示器上的。</p>\n<h3 id=\"With-–drawRect\"><a href=\"#With-–drawRect\" class=\"headerlink\" title=\"With –drawRect:\"></a>With –drawRect:</h3><p>如果你的视图类实现了 <code>-drawRect:</code>，他们将像这样工作:</p>\n<ol>\n<li>设置一个标示<br>当你调用 <code>-setNeedsDisplay</code>，UIKit 将会在这个视图的图层上调用 <code>-setNeedsDisplay</code>。这为图层设置了一个标识，标记为 dirty(直译是脏的意思，想不出用什么词比较贴切,污染？)，但还显示原来的内容。它实际上没做任何工作，所以多次调用 <code>-setNeedsDisplay</code>并不会造成性能损失。</li>\n<li>装备后备存储<br>当渲染系统准备好，它会调用视图图层的<code>-display</code>方法.此时，图层会装配它的后备存储。然后建立一个 Core Graphics 上下文(CGContextRef)，将后备存储对应内存中的数据恢复出来，绘图会进入对应的内存区域，并使用 CGContextRef 绘制。<br>2.1 使用 UIKit 的绘制方法<br>当你使用 UIKit 的绘制方法，例如: <code>UIRectFill()</code> 或者 <code>-[UIBezierPath fill]</code> 代替你的 <code>-drawRect:</code> 方法，他们将会使用这个上下文。<br>使用方法是，UIKit 将后备存储的 CGContextRef 推进他的 graphics context stack，也就是说，它会将那个上下文设置为当前的。因此 <code>UIGraphicsGetCurrent()</code> 将会返回那个对应的上下文。既然 UIKit 使用 <code>UIGraphicsGetCurrent()</code> 绘制方法，绘图将会进入到图层的后备存储。<br>2.2  直接使用 Core Graphics 方法<br>通过调用 <code>UIGraphicsGetCurrent()</code> 得到相同的上下文，并将这个上下文传给 Core Graphics 方法。</li>\n</ol>\n<p>从现在开始，图层的后备存储将会被不断的渲染到屏幕上。直到下次再次调用视图的 <code>-setNeedsDisplay</code> ，将会依次将图层的后备存储更新到视图上。</p>\n<h3 id=\"不使用-drawRect\"><a href=\"#不使用-drawRect\" class=\"headerlink\" title=\"不使用 -drawRect:\"></a>不使用 -drawRect:</h3><p>当你用一个 UIImageView 时，事情略有不同，这个视图仍然有一个 CALayer，但是图层却没有申请一个后备存储。取而代之的是使用一个 CGImageRef 作为他的内容，并且渲染服务将会把图片的数据绘制到帧的缓冲区，比如，绘制到显示屏。</p>\n<p>在这种情况下，将不会继续重新绘制。我们只是简单的将位图数据以图片的形式传给了 UIImageView，然后 UIImageView 传给了 Core Animation，然后轮流传给渲染服务。</p>\n<h2 id=\"实现-drawRect-还是不实现-drawRect\"><a href=\"#实现-drawRect-还是不实现-drawRect\" class=\"headerlink\" title=\"实现-drawRect: 还是不实现 -drawRect:\"></a>实现-drawRect: 还是不实现 -drawRect:</h2><p>最快的绘制就是你不要做任何绘制。<br>大多数时间，你可以不要合成你在其他视图(图层)上定制的视图(图层)，这正是我们推荐的，因为 UIKit 的视图类是非常优化的 (就是让我们不要闲着没事做,自己去合并视图或图层) 。</p>\n<p>当你需要自定义绘图代码时，Apple 在<a href=\"https://developer.apple.com/videos/wwdc/2012/?id=506\" target=\"_blank\" rel=\"noopener\">WWDC 2012’s session 506</a>:Optimizing 2D Graphics and Animation Performance 中展示了一个很好的例子:”finger painting”。</p>\n<p>另一个地方需要自定义绘图的就是 iOS 的股票软件。股票是直接用 Core Graphics 在设备上绘制的，注意，这仅仅是你需要自定义绘图，你并不需要实现 <code>-drawRect:</code> 方法。有时，通过 <code>UIGraphicsBeginImageContextWithOptions()</code> 或者 <code>CGBitmapContextCeate()</code> 创建位图会显得更有意义，从位图上面抓取图像，并设置为 <code>CALayer</code> 的内容。下面我们将给出一个例子来测试，检验。</p>\n<h3 id=\"单一颜色\"><a href=\"#单一颜色\" class=\"headerlink\" title=\"单一颜色\"></a>单一颜色</h3><p>如果我们看这个例子：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Don't do this</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)drawRect:(<span class=\"built_in\">CGRect</span>)rect</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">[[<span class=\"built_in\">UIColor</span> redColor] setFill];</span><br><span class=\"line\"><span class=\"built_in\">UIRectFill</span>([<span class=\"keyword\">self</span> bounds]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在我们知道这为什么不好:我们促使 Core Animation 来为我们创建一个后备存储，并让它使用单一颜色填充后备存储，然后上传给 GPU。</p>\n<p>我们跟本不需要实现 <code>-drawRect:</code>，并节省这些代码工作量，只需简单的设置这个视图图层的背景颜色。如果这个视图有一个 CAGradientLayer 作为图层，那么这个技术也同样适用于此（渐变图层）。</p>\n<h3 id=\"可变尺寸的图像\"><a href=\"#可变尺寸的图像\" class=\"headerlink\" title=\"可变尺寸的图像\"></a>可变尺寸的图像</h3><p>类似的，你可以使用可变尺寸的图像来降低绘图系统的压力。让我们假设你需要一个 300×50 点的按钮插图，这将是 600×100=60k 像素或者 60kx4=240kB 内存大小需要上传到 GPU，并且占用 VRAM。如果我们使用所谓的可变尺寸的图像，我们只需要一个 54×12 点的图像，这将占用低于 2.6k 的像素或者 10kB 的内存，这样就变得更快了。</p>\n<p>Core Animation 可以通过 CALayer 的 <a href=\"https://developer.apple.com/library/mac/documentation/graphicsimaging/reference/CALayer_class/Introduction/Introduction.html#//apple_ref/occ/instp/CALayer/contentsCenter\" target=\"_blank\" rel=\"noopener\"><code>contentsCenter</code></a> 属性来改变图像，大多数情况下，你可能更倾向于使用，<a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImage_Class/Reference/Reference.html#//apple_ref/occ/instm/UIImage/resizableImageWithCapInsets:resizingMode:\" target=\"_blank\" rel=\"noopener\"><code>-[UIImage resizableImageWithCapInsets:resizingMode:]</code></a>。</p>\n<p>同时注意，在第一次渲染这个按钮之前，我们并不需要从文件系统读取一个 60k 像素的 PNG 并解码，解码一个小的 PNG 将会更快。通过这种方式，你的程序在每一步的调用中都将做更少的工作，并且你的视图将会加载的更快。</p>\n<h3 id=\"并发绘图\"><a href=\"#并发绘图\" class=\"headerlink\" title=\"并发绘图\"></a>并发绘图</h3><p>上一次 <a href=\"http://objccn.io/issue-2/\" target=\"_blank\" rel=\"noopener\">objc.io</a> 的话题是关于并发的讨论。正如你所知道的一样，UIKit 的线程模型是非常简单的：你仅可以从主队列(比如主线程)中调用 UIKit 类(比如视图),那么并发绘图又是什么呢？</p>\n<p>如果你必须实现 <code>-drawRect:</code>，并且你必须绘制大量的东西，这将占用时间。由于你希望动画变得更平滑，除了在主队列中，你还希望在其他队列中做一些工作。同时发生的绘图是复杂的，但是除了几个警告，同时发生的绘图还是比较容易实现的。</p>\n<p>我们除了在主队列中可以向 CALayer 的后备存储中绘制一些东西，其他方法都将不可行。可怕的事情将会发生。我们能做的就是向一个完全断开链接的位图上下文中进行绘制。<br>为了同时绘制，我们需要做下面的操作:</p>\n<ol>\n<li>正如我们上面所提到的一样，在 Core Graphics 下，所有 Core Graphics 绘制方法都需要一个上下文参数来指定绘制到那个上下文中。UIKit 有一个当前上下文的概念(也就是绘制到哪儿去)。这个当前的上下文就是 per-thread.</li>\n<li>我们需要在另一个队列创建一个图像，一旦我们拥有了图像，我们可以切换回主队列，并且设置这个图像为 UIImageView 的图像。这个技术在 <a href=\"https://developer.apple.com/videos/wwdc/2012/?id=211\" target=\"_blank\" rel=\"noopener\">WWDC 2012 session 211</a> 中讨论过。(异步下载图片经常用到这个)</li>\n</ol>\n<p>增加一个你可以在其中绘制的新方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIImage</span> *)renderInImageOfSize:(<span class=\"built_in\">CGSize</span>)size</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIGraphicsBeginImageContextWithOptions</span>(size, <span class=\"literal\">NO</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 绘制代码块</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">UIImage</span> *result = <span class=\"built_in\">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class=\"line\">    <span class=\"built_in\">UIGraphicsEndImageContext</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法通过 <code>UIGraphicsBeginImageContextWithOptions()</code> 方法，并根据给定的大小创建一个新的 CGContextRef 位图上下文。这个方法也会将这个上下文设置为<em>当前UIKit</em>的上下文。现在你可以在这里做你想在 <code>-drawRect:</code> 中做的事了。然后通过 <code>UIGraphicsGetImageFromCurrentImageContext()</code>,获得的这个上下文位图数据作为一个 UIImage，最终移除这个上下文。</p>\n<p>很重要的一点就是，你在这个方法中所做的所有绘图的代码都是线程安全的，也就是说，当你访问属性等等，他们需要线程安全。因为你是在另一个队列中调用这个方法的。如果这个方法在你的视图类中，那就需要注意一点了。<br>另一个选择就是创建一个单独的渲染类，并设置所有需要的属性，然后通过触发来渲染图片。如果这样，你可以通过使用简单的 UIImageView 或者 UITableViewCell。</p>\n<p>要知道，所有 UIKit 的绘制 API 在使用另一个队列时，都是安全的。只需要确定是在同一个操作中调用他们的，这个操作需要以 <code>UIGraphicsBeginImageContextWithOptions()</code> 开始，以 <code>UIGraphicsEndIamgeContext()</code> 结束。</p>\n<p>你需要像下面这样触发渲染代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIImageView</span> *view; <span class=\"comment\">// assume we have this</span></span><br><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span> *renderQueue; <span class=\"comment\">// assume we have this</span></span><br><span class=\"line\"><span class=\"built_in\">CGSize</span> size = view.bounds.size;</span><br><span class=\"line\">[renderQueue addOperationWithBlock:^()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIImage</span> *image = [renderer renderInImageOfSize:size];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^()&#123;</span><br><span class=\"line\">        view.image = image;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></p>\n<p>要注意，我们是在主队列中调用 <code>view.image = image</code>.这是一个非常重要的细节。你不可以在任何其他队列中调用这个代码。</p>\n<p>像往常一样，同时绘制会伴随很多问题，你现在需要取消后台渲染。并且在渲染队列中设置合理的同时绘制的最大限度。为了支持这一切，最简单的就是在一个 NSOperation 子类内部实现 <code>-renderInImageOfSize:</code>。</p>\n<p>最终，需要指出，设置 UITableViewCell 内容为异步是非常困难的。单元格很有可能在完成异步渲染前已经被复用了。尽管单元格已经被其他地方复用，但你只需要设置内容就行了。</p>\n<h2 id=\"CALayer\"><a href=\"#CALayer\" class=\"headerlink\" title=\"CALayer\"></a>CALayer</h2><p>到现在为止，你需要知道在 GPU 内，一个 CALayer 在某种方式上和一个纹理类似。图层有一个后备存储，这便是被用来绘制到屏幕上的位图。</p>\n<p>通常，当你使用 CALayer 时，你会设置它的内容为一个图片。这到底做了什么？这样做会告诉 Core Animation 使用图片的位图数据作为纹理。如果这个图片(JPEG或PNG)被压缩了，Core Animation 将会这个图片解压缩，然后上传像素数据到 GPU。</p>\n<p>尽管还有很多其他种类的图层，如果你是用一个简单的没有设置上下文的 CALayer，并为这个 CALayer 设置一个背景颜色，Core Animation 并不会上传任何数据到 GPU，但却能够不用任何像素数据而在 GPU 上完成所有的工作，类似的，对于渐变的图层，GPU 是能创建渐变的，而且不需要 CPU 做任何工作，并且不需要上传任何数据到 GPU。</p>\n<h3 id=\"自定义绘制的图层\"><a href=\"#自定义绘制的图层\" class=\"headerlink\" title=\"自定义绘制的图层\"></a>自定义绘制的图层</h3><p>如果一个 CALayer 的子类实现了 <code>-drawInContext:</code> 或者它的代理，类似于 <code>-drawLayer:inContest:</code>, Core Animation 将会为这个图层申请一个后备存储，用来保存那些方法绘制进来的位图。那些方法内的代码将会运行在 CPU 上，结果将会被上传到 GPU。</p>\n<h3 id=\"形状和文本图层\"><a href=\"#形状和文本图层\" class=\"headerlink\" title=\"形状和文本图层\"></a>形状和文本图层</h3><p>形状和文本图层还是有些不同的。开始时，Core Animation 为这些图层申请一个后备存储来保存那些需要为上下文生成的位图数据。然后 Core Animation 会讲这些图形或文本绘制到后备存储上。这在概念上非常类似于，当你实现 <code>-drawInContext:</code> 方法，然后在方法内绘制形状或文本，他们的性能也很接近。</p>\n<p>在某种程度上，当你需要改变形状或者文本图层时，这需要更新它的后备存储，Core Animation 将会重新渲染后备存储。例如，当动态改变形状图层的大小时，Core Animation 需要为动画中的每一帧重新绘制形状。</p>\n<h3 id=\"异步绘图\"><a href=\"#异步绘图\" class=\"headerlink\" title=\"异步绘图\"></a>异步绘图</h3><p>CALayer 有一个叫做 drawsAsynchronously 的属性，这似乎是一个解决所有问题的高招。注意，尽管这可能提升性能，但也可能让事情变慢。</p>\n<p>当你设置 drawsAsynchronously 为 YES 时，发生了什么？你的 <code>-drawRect:/-drawInContext:</code> 方法仍然会被在主线程上调用。但是所有调用 Core Graphics 的操作都不会被执行。取而代之的是，绘制命令被推迟，并且在后台线程中异步执行。</p>\n<p>这种方式就是先记录绘图命令，然后在后台线程中重现。为了这个过程的顺利进行，更多的工作需要被做，更多的内存需要被申请。但是主队列中的一些工作便被移出来了(大概意思就是让我们把一些能在后台实现的工作放到后台实现，让主线程更顺畅)。</p>\n<p>对于昂贵的绘图方法，这是最有可能提升性能的，但对于那些绘图方法来说，也不会节省太多资源。</p>\n<hr>\n<p><a href=\"http://objccn.io/issue-3/\" target=\"_blank\" rel=\"noopener\">话题 #3 下的更多文章</a></p>\n<p>原文 <a href=\"http://www.objc.io/issue-3/moving-pixels-onto-the-screen.html\" target=\"_blank\" rel=\"noopener\">Getting Pixels onto the Screen</a></p>\n<p>译文 <a href=\"http://answerhuang.duapp.com/index.php/2013/09/04/pixels-get-onto-the-screen/\" target=\"_blank\" rel=\"noopener\">将像素绘制到屏幕上去 - answer-huang</a></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"视图","path":"api/categories/视图.json"}],"tags":[]},{"title":"iResearcher简介","slug":"个人项目/iResearcher简介","date":"2017-09-10T14:09:39.000Z","updated":"2017-09-11T10:20:43.000Z","comments":true,"path":"api/articles/个人项目/iResearcher简介.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/个人中心.jpg?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>iResearcher是一款科研/研发领域大数据分析系统+应用。旨在为科研/技术研发工作者提供 资源直达服务。iResearcher计划提供的资源服务既包括论文，方法，数据集，也包括人，资金等。最终建立，人与人，人与资金，人与技术方法之间的互联。为科研/研发工作者，提供一站式科研服务平台。</p>\n<h3 id=\"APP截图\"><a href=\"#APP截图\" class=\"headerlink\" title=\"APP截图\"></a>APP截图</h3><p>由于运营方已停止服务器访问，暂时只能截图呈现APP相关功能。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/个人中心.jpg?imageMogr2/2/w/800\"><br><img title=\"个人资料\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/个人资料.jpg?imageMogr2/2/w/800\"><br><img title=\"历史下载\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/历史下载.jpg?imageMogr2/2/w/800\"><br><img title=\"历史搜索\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/历史搜索.jpg?imageMogr2/2/w/800\"><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/推荐.jpg?imageMogr2/2/w/800\"><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/推荐3.jpg?imageMogr2/2/w/800\"><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/搜索.jpg?imageMogr2/2/w/800\"><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/搜索输入状态.jpg?imageMogr2/2/w/800\"><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/收藏.jpg?imageMogr2/2/w/800\"><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/收藏（删除）.jpg?imageMogr2/2/w/800\"><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/热门搜索.jpg?imageMogr2/2/w/800\"><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/论文界面.jpg?imageMogr2/2/w/800\"><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/评论界面.jpg?imageMogr2/2/w/800\"></p>\n","raw":null,"categories":[{"name":"项目","path":"api/categories/项目.json"},{"name":"预览","path":"api/categories/预览.json"}],"tags":[]},{"title":"NSURLSession的使用说明","slug":"iOS/NSURLSession的使用说明","date":"2017-09-08T18:48:43.000Z","updated":"2017-09-08T18:50:27.000Z","comments":true,"path":"api/articles/iOS/NSURLSession的使用说明.json","excerpt":null,"keywords":null,"cover":"https://www.objccn.io/images/issues/issue-5/NSURLSession.png","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>iOS 7 和 Mac OS X 10.9 Mavericks 中一个显著的变化就是对 Foundation URL 加载系统的彻底重构。</p>\n<p>现在已经有人在深入苹果的网络层基础架构的地方做研究了，所以我想是时候来分享一些对于我对于这些新的 API 的看法和心得了，新的 API 将如何影响我们编写程序，以及它们对于 API 设计理念的影响。</p>\n<h2 id=\"NSURLConnection机制\"><a href=\"#NSURLConnection机制\" class=\"headerlink\" title=\"NSURLConnection机制\"></a>NSURLConnection机制</h2><p><code>NSURLConnection</code> 作为 Core Foundation / CFNetwork 框架的 API 之上的一个抽象，在 2003 年，随着第一版的 Safari 的发布就发布了。<code>NSURLConnection</code> 这个名字，实际上是指代的 Foundation 框架的 URL 加载系统中一系列有关联的组件：<code>NSURLRequest</code>、<code>NSURLResponse</code>、<code>NSURLProtocol</code>、 <code>NSURLCache</code>、 <code>NSHTTPCookieStorage</code>、<code>NSURLCredentialStorage</code> 以及同名类 <code>NSURLConnection</code>。</p>\n<p><code>NSURLRequest</code> 被传递给 <code>NSURLConnection</code>。被委托对象（遵守以前的非正式协议 <code>&lt;NSURLConnectionDelegate&gt;</code> 和 <code>&lt;NSURLConnectionDataDelegate&gt;</code>）异步地返回一个 <code>NSURLResponse</code> 以及包含服务器返回信息的 <code>NSData</code>。</p>\n<h3 id=\"缓存策略\"><a href=\"#缓存策略\" class=\"headerlink\" title=\"缓存策略\"></a>缓存策略</h3><p>在一个请求被发送到服务器之前，系统会先查询共享的缓存信息，然后根据<strong>策略（policy）</strong>以及<strong>可用性（availability）</strong>的不同，一个已经被缓存的响应可能会被立即返回。如果没有缓存的响应可用，则这个请求将根据我们指定的策略来缓存它的响应以便将来的请求可以使用。</p>\n<h3 id=\"鉴权查询\"><a href=\"#鉴权查询\" class=\"headerlink\" title=\"鉴权查询\"></a>鉴权查询</h3><p>在把请求发送给服务器的过程中，服务器可能会发出<strong>鉴权查询（authentication challenge）</strong>，这可以由共享的 cookie 或<strong>机密存储（credential storage）</strong>来自动响应，或者由被委托对象来响应。发送中的请求也可以被注册的 <code>NSURLProtocol</code> 对象所拦截，以便在必要的时候无缝地改变其加载行为。</p>\n<p>不管怎样，<code>NSURLConnection</code> 作为网络基础架构，已经服务了成千上万的 iOS 和 Mac OS 程序，并且做的还算相当不错。但是这些年，一些用例——尤其是在 iPhone 和 iPad 上面——已经对 <code>NSURLConnection</code> 的几个核心概念提出了挑战，让苹果有理由对它进行重构。</p>\n<p>在 2013 的 WWDC 上，苹果推出了 <code>NSURLConnection</code> 的继任者：<code>NSURLSession</code>。</p>\n<hr>\n<h2 id=\"NSURLSession成员\"><a href=\"#NSURLSession成员\" class=\"headerlink\" title=\"NSURLSession成员\"></a>NSURLSession成员</h2><p>和 <code>NSURLConnection</code> 一样，<code>NSURLSession</code> 指的也不仅是同名类 <code>NSURLSession</code>，还包括一系列相互关联的类。<code>NSURLSession</code> 包括了与之前相同的组件，<code>NSURLRequest</code> 与 <code>NSURLCache</code>，但是把 <code>NSURLConnection</code> 替换成了 <code>NSURLSession</code>、<code>NSURLSessionConfiguration</code> 以及 <code>NSURLSessionTask</code> 的 3 个子类：<code>NSURLSessionDataTask</code>，<code>NSURLSessionUploadTask</code>，<code>NSURLSessionDownloadTask</code>。</p>\n<ol>\n<li>NSURLSessionConfiguration可配置性初始化<br>与 <code>NSURLConnection</code> 相比，<code>NSURLsession</code> 最直接的改进就是可以配置每个 session 的缓存，协议，cookie，以及<strong>证书策略（credential policy）</strong>，甚至跨程序共享这些信息。这将允许程序和网络基础框架之间相互独立，不会发生干扰。每个 <code>NSURLSession</code> 对象都由一个 <code>NSURLSessionConfiguration</code> 对象来进行初始化，后者指定了刚才提到的那些策略以及一些用来增强移动设备上性能的新选项。</li>\n<li>抽象类NSURLSessionTask数据加载<br><code>NSURLSession</code> 中另一大块就是 session task。它负责处理数据的加载以及文件和数据在客户端与服务端之间的上传和下载。<code>NSURLSessionTask</code> 与 <code>NSURLConnection</code> 最大的相似之处在于它也负责数据的加载，最大的不同之处在于所有的 task 共享其创造者 <code>NSURLSession</code> 这一<strong>公共委托者（common delegate）</strong>。</li>\n</ol>\n<p>我们先来深入探讨 task，过后再来讨论 <code>NSURLSessionConfiguration</code>。</p>\n<h3 id=\"NSURLSessionTask\"><a href=\"#NSURLSessionTask\" class=\"headerlink\" title=\"NSURLSessionTask\"></a>NSURLSessionTask</h3><p><code>NSURLsessionTask</code> 是一个抽象类，其下有 3 个实体子类封装了现代程序三个最基本的网络任务：</p>\n<ol>\n<li><code>NSURLSessionDataTask</code>：加载数据，当加载任务完成时，它会返回相关联的数据，比如 JSON 或者 XML</li>\n<li><code>NSURLSessionUploadTask</code>：上传文件，当上传任务完成时，也会有上传相关数据返回，所以继承自 <code>NSURLSessionDataTask</code>。</li>\n<li><code>NSURLSessionDownloadTask</code>：下载文件，当下载任务结束时，它会返回已下载文件的一个临时的文件路径。</li>\n</ol>\n<p><img alt=\"NSURLSessionTask class diagram\" src=\"https://www.objccn.io/images/issues/issue-5/NSURLSession.png\" width=\"612\" height=\"294\"></p>\n<p>所有的 task 都是可以取消，暂停或者恢复的。当一个 download task 取消时，可以通过选项来创建一个<strong>恢复数据（resume data）</strong>，然后可以传递给下一次新创建的 download task，以便继续之前的下载。</p>\n<h4 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h4><p>不同于直接使用 <code>alloc-init</code> 初始化方法，task 是由一个 <code>NSURLSession</code> 创建的。每个 task 的构造方法都对应有或者没有 <code>completionHandler</code> 这个 block 的两个版本:</p>\n<ol>\n<li>block回调构造方式: <code>–dataTaskWithRequest:completionHandler:</code><br>通过指定 <code>completionHandler</code> 这个 block 将创建一个隐式的 delegate，来替代该 task 原来的 delegate——session。</li>\n<li>代理回调构造方式：<code>–dataTaskWithRequest:</code><br>对于需要 <code>override</code> 原有 session task 的 delegate 的默认行为的情况,使用代理回调</li>\n</ol>\n<p>这里不会立即运行 task，而是将该 task 对象先返回，允许我们进一步的配置，然后可以使用 <code>resume</code> 方法来让它开始运行。</p>\n<h5 id=\"数据加载工厂\"><a href=\"#数据加载工厂\" class=\"headerlink\" title=\"数据加载工厂\"></a>数据加载工厂</h5><p>Data task 可以通过 <code>NSURL</code> 或 <code>NSURLRequest</code> 创建（使用前者相当于是使用一个对于该 URL 进行标准 <code>GET</code> 请求的 <code>NSURLRequest</code>，这是一种快捷方法）：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURL</span> *URL = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://example.com\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSURLRequest</span> *request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:URL];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sharedSession];</span><br><span class=\"line\"><span class=\"built_in\">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request</span><br><span class=\"line\">completionHandler:</span><br><span class=\"line\">^(<span class=\"built_in\">NSData</span> *data, <span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSError</span> *error) &#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[task resume];</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"数据上传工厂\"><a href=\"#数据上传工厂\" class=\"headerlink\" title=\"数据上传工厂\"></a>数据上传工厂</h5><p>Upload task 的创建需要使用一个 request，另外加上一个要上传的 <code>NSData</code> 对象或者是一个本地文件的路径对应的 <code>NSURL</code>：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURL</span> *URL = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://example.com/upload\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSURLRequest</span> *request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:URL];</span><br><span class=\"line\"><span class=\"built_in\">NSData</span> *data = ...;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sharedSession];</span><br><span class=\"line\"><span class=\"built_in\">NSURLSessionUploadTask</span> *uploadTask = [session uploadTaskWithRequest:request</span><br><span class=\"line\">fromData:data</span><br><span class=\"line\">completionHandler:</span><br><span class=\"line\">^(<span class=\"built_in\">NSData</span> *data, <span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSError</span> *error) &#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[uploadTask resume];</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"数据下载工厂\"><a href=\"#数据下载工厂\" class=\"headerlink\" title=\"数据下载工厂\"></a>数据下载工厂</h5><p>Download task 也需要一个 request，不同之处在于 <code>completionHandler</code> 这个 block。Data task 和 upload task 会在任务完成时一次性返回，但是 Download task 是将数据一点点地写入本地的临时文件。所以在 <code>completionHandler</code> 这个 block 里，我们需要把文件从一个临时地址移动到一个永久的地址保存起来：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURL</span> *URL = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://example.com/file.zip\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSURLRequest</span> *request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:URL];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sharedSession];</span><br><span class=\"line\"><span class=\"built_in\">NSURLSessionDownloadTask</span> *downloadTask = [session downloadTaskWithRequest:request</span><br><span class=\"line\">completionHandler:</span><br><span class=\"line\">^(<span class=\"built_in\">NSURL</span> *location, <span class=\"built_in\">NSURLResponse</span> *response, <span class=\"built_in\">NSError</span> *error) &#123;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *documentsPath = [<span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>) firstObject];</span><br><span class=\"line\"><span class=\"built_in\">NSURL</span> *documentsDirectoryURL = [<span class=\"built_in\">NSURL</span> fileURLWithPath:documentsPath];</span><br><span class=\"line\"><span class=\"built_in\">NSURL</span> *newFileLocation = [documentsDirectoryURL URLByAppendingPathComponent:[[response URL] lastPathComponent]];</span><br><span class=\"line\">[[<span class=\"built_in\">NSFileManager</span> defaultManager] copyItemAtURL:location toURL:newFileLocation error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[downloadTask resume];</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p><span class=\"secondary radius label\">编者注</span> 原文中这块代码以及上文的表述中存有一些问题，详见这个 <a href=\"https://github.com/objcio/articles/issues/24\" target=\"_blank\" rel=\"noopener\">issue</a>，本文已进行更正，如果您有不同意见，欢迎在 <a href=\"https://github.com/objccn/articles\" target=\"_blank\" rel=\"noopener\">Github</a> 上给我们反馈。</p>\n</blockquote>\n<h4 id=\"NSURLSession-的-delegate-方法\"><a href=\"#NSURLSession-的-delegate-方法\" class=\"headerlink\" title=\"NSURLSession 的 delegate 方法\"></a>NSURLSession 的 delegate 方法</h4><p><code>NSURLSession</code> 的 delegate 方法是 <code>NSURLConnection</code> 的演化的十年中对于 ad-hoc 模式的一个显著改善。您可以查看这个<a href=\"https://gist.github.com/floriankugler/6870499\" target=\"_blank\" rel=\"noopener\">映射表</a>来进行一个完整的概览。</p>\n<h5 id=\"连接层-任务层代理\"><a href=\"#连接层-任务层代理\" class=\"headerlink\" title=\"连接层/任务层代理\"></a>连接层/任务层代理</h5><p><code>NSURLSession</code> 既拥有 seesion 的 delegate 方法，又拥有 task 的 delegate 方法用来处理鉴权查询。</p>\n<ol>\n<li>session 的 delegate 方法处理连接层的问题：诸如服务器信任，客户端证书的评估，<a href=\"http://en.wikipedia.org/wiki/NTLM\" target=\"_blank\" rel=\"noopener\">NTLM</a> 和 <a href=\"http://zh.wikipedia.org/wiki/Kerberos\" target=\"_blank\" rel=\"noopener\">Kerberos</a> 协议这类问题。</li>\n<li>task 的 delegate 处理网络请求为基础的问题：如 Basic，Digest，以及<strong>代理身份验证（Proxy authentication）</strong>等。</li>\n<li>网络请求结束代理<br>在 <code>NSURLConnection</code> 中两个delegate方法：<br>数据加载完成：<code>NSURLConnectionDataDelegate</code> 中的 <code>-connectionDidFinishLoading:</code><br>网络连接失败： <code>NSURLConnectionDelegate</code> 中的 <code>-connection:didFailWithError:</code>，<br>在 <code>NSURLSession</code> 中改为一个 delegate 方法：<ol>\n<li><code>NSURLSessionTaskDelegate</code> 的 <code>-URLSession:task:didCompleteWithError:</code></li>\n<li><code>NSURLSession</code> 中表示传输多少字节的参数类型现在改为 <code>int64_t</code>，以前在 <code>NSURLConnection</code> 中相应的参数的类型是 <code>long long</code>。</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"block参数回调代理模式\"><a href=\"#block参数回调代理模式\" class=\"headerlink\" title=\"block参数回调代理模式\"></a>block参数回调代理模式</h5><p><code>NSURLSession</code> 给 Foundation 框架引入了一种全新的模式：即 代理方法中以<code>completionHandler:</code>  这种block 作为参数的方式。</p>\n<ol>\n<li>这种模式允许 delegate 方法可以安全地在主线程与运行，而不会阻塞主线程；</li>\n<li>Delgate 只需要简单地调用 <code>dispatch_async</code> 就可以切换到后台进行相关的操作，然后在操作完成时调用 <code>completionHandler</code> 即可。</li>\n<li>它还可以有效地拥有多个返回值，而不需要我们使用笨拙的参数指针。</li>\n</ol>\n<p>以 <code>NSURLSessionTaskDelegate</code>代理中的方法为例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-URLSession:task:didReceiveChallenge:completionHandler:</span><br></pre></td></tr></table></figure></p>\n<p><code>completionHandler</code> 接受的两个参数：<br>参数一：<code>NSURLSessionAuthChallengeDisposition</code>:鉴权查询的策略<br>参数二：<code>NSURLCredential</code>:证书（仅当第一个参数——应对鉴权查询的策略为使用证书，即 <code>NSURLSessionAuthChallengeUseCredential</code> 时有效，否则该参数为 <code>NULL</code>）。</p>\n<blockquote>\n<p>想要查看更多关于 session task 的信息，可以查看 <a href=\"http://asciiwwdc.com/2013/sessions/705\" target=\"_blank\" rel=\"noopener\">WWDC Session 705: “What’s New in Foundation Networking”</a></p>\n</blockquote>\n<h3 id=\"NSURLSessionConfiguration\"><a href=\"#NSURLSessionConfiguration\" class=\"headerlink\" title=\"NSURLSessionConfiguration\"></a>NSURLSessionConfiguration</h3><p><code>NSURLSessionConfiguration</code> 对象用于对 <code>NSURLSession</code> 对象进行初始化。</p>\n<ol>\n<li>配置开发灵活性<br><code>NSURLSessionConfiguration</code> 扩充了 <code>NSMutableURLRequest</code> 所提供的<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSMutableURLRequest_Class/Reference/Reference.html\" target=\"_blank\" rel=\"noopener\">网络请求层的设置选项</a>，从指定可用网络，到 cookie，安全性，缓存策略，再到使用自定义协议，启动事件的设置，以及用于移动设备优化的几个新属性，你会发现使用 <code>NSURLSessionConfiguration</code> 可以找到几乎任何你想要进行配置的选项，提供给我们相当大的灵活性和控制权。</li>\n<li>配置加载机制<br><code>NSURLSession</code> 在初始化时会把配置它的 <code>NSURLSessionConfiguration</code> 对象进行一次 copy，并保存到自己的 <code>configuration</code> 属性中，而且这个属性是只读的。因此之后再修改最初配置 session 的那个 configuration 对象对于 session 是没有影响的。也就是说，configuration 只在初始化时被读取一次，之后都是不会变化的。</li>\n</ol>\n<h4 id=\"三个配置类工厂方法\"><a href=\"#三个配置类工厂方法\" class=\"headerlink\" title=\"三个配置类工厂方法\"></a>三个配置类工厂方法</h4><p>针对<code>NSURLSession</code> 不同的使用场景，如下三个配置类方法：</p>\n<ol>\n<li><code>+defaultSessionConfiguration</code>： 返回一个标准的 configuration，这个配置实际上与 <code>NSURLConnection</code> 的<strong>网络堆栈（networking stack）</strong>是一样的，具有相同的共享 <code>NSHTTPCookieStorage</code>，共享 <code>NSURLCache</code> 和共享 <code>NSURLCredentialStorage</code>。</li>\n<li><code>+ephemeralSessionConfiguration</code>： 返回一个预设配置，这个配置中不会对缓存，Cookie 和证书进行持久性的存储。这对于实现像秘密浏览这种功能来说是很理想的。</li>\n<li><code>+backgroundSessionConfiguration:(NSString *)identifier</code> 的独特之处在于，它会创建一个<em>后台 session</em>。后台 session 不同于常规的，普通的 session，它甚至可以在应用程序挂起，退出或者崩溃的情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外恢复后台传输的<strong>守护进程（daemon）</strong>提供上下文。</li>\n</ol>\n<p>想要查看更多关于后台 session 的信息，可以查看 <a href=\"http://asciiwwdc.com/2013/sessions/204\" target=\"_blank\" rel=\"noopener\">WWDC Session 204: “What’s New with Multitasking”</a></p>\n<h4 id=\"配置属性\"><a href=\"#配置属性\" class=\"headerlink\" title=\"配置属性\"></a>配置属性</h4><p><code>NSURLSessionConfiguration</code> 拥有 20 个配置属性。熟练掌握这些配置属性的用处，可以让应用程序充分地利用其网络环境。</p>\n<h5 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h5><ol>\n<li><p><code>HTTPAdditionalHeaders</code>: 指定了一组默认的可以设置<strong>出站请求（outbound request）</strong>的数据头。这对于跨 session 共享信息，如内容类型，语言，用户代理和身份认证，是很有用的。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *userPasswordString = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@:%@\"</span>, user, password];</span><br><span class=\"line\"><span class=\"built_in\">NSData</span> * userPasswordData = [userPasswordString dataUsingEncoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *base64EncodedCredential = [userPasswordData base64EncodedStringWithOptions:<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *authString = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"Basic %@\"</span>, base64EncodedCredential];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *userAgentString = <span class=\"string\">@\"AppName/com.example.app (iPhone 5s; iOS 7.0.2; Scale/2.0)\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">configuration.HTTPAdditionalHeaders = @&#123;<span class=\"string\">@\"Accept\"</span>: <span class=\"string\">@\"application/json\"</span>,</span><br><span class=\"line\"><span class=\"string\">@\"Accept-Language\"</span>: <span class=\"string\">@\"en\"</span>,</span><br><span class=\"line\"><span class=\"string\">@\"Authorization\"</span>: authString,</span><br><span class=\"line\"><span class=\"string\">@\"User-Agent\"</span>: userAgentString&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>networkServiceType</code>: 对标准的网络流量，网络电话，语音，视频，以及由一个后台进程使用的流量进行了区分。大多数应用程序都不需要设置这个。</p>\n</li>\n<li><code>allowsCellularAccess</code> 和 <code>discretionary</code> 被用于节省通过蜂窝网络连接的带宽。对于后台传输的情况，推荐大家使用 <code>discretionary</code> 这个属性，而不是 <code>allowsCellularAccess</code>，因为前者会把 WiFi 和电源的可用性考虑在内。</li>\n<li><code>timeoutIntervalForRequest</code> 和 <code>timeoutIntervalForResource</code> 分别指定了对于请求和资源的超时间隔。许多开发人员试图使用 <code>timeoutInterval</code> 去限制发送请求的总时间，但其实它真正的含义是：<strong>分组（packet）</strong>之间的时间。实际上我们应该使用 <code>timeoutIntervalForResource</code> 来规定整体超时的总时间，但应该只将其用于后台传输，而不是用户实际上可能想要去等待的任何东西。</li>\n<li><code>HTTPMaximumConnectionsPerHost</code>: 是 Foundation 框架中 URL 加载系统的一个新的配置选项。它曾经被 <code>NSURLConnection</code> 用于管理私有的连接池。现在有了 <code>NSURLSession</code>，开发者可以在需要时限制连接到特定主机的数量。</li>\n<li><code>HTTPShouldUsePipelining</code>: 这个属性在 <code>NSMutableURLRequest</code> 下也有，它可以被用于开启 <strong>HTTP 管线化（<a href=\"http://en.wikipedia.org/wiki/HTTP_pipelining\" target=\"_blank\" rel=\"noopener\">HTTP pipelining</a>）</strong>，这可以显着降低请求的加载时间，但是由于没有被服务器广泛支持，默认是禁用的。</li>\n<li><code>sessionSendsLaunchEvents</code>: 是另一个新的属性，该属性指定该 session 是否应该从后台启动。</li>\n<li><code>connectionProxyDictionary</code>: 指定了 session 连接中的代理服务器。同样地，大多数面向消费者的应用程序都不需要代理，所以基本上不需要配置这个属性。</li>\n</ol>\n<blockquote>\n<p>关于连接代理的更多信息可以在 <a href=\"https://developer.apple.com/library/mac/documentation/CoreFoundation/Reference/CFProxySupport/Reference/reference.html\" target=\"_blank\" rel=\"noopener\"><code>CFProxySupport</code> Reference</a> 找到。</p>\n</blockquote>\n<h5 id=\"Cookie-策略\"><a href=\"#Cookie-策略\" class=\"headerlink\" title=\"Cookie 策略\"></a>Cookie 策略</h5><ol>\n<li><code>HTTPCookieStorage</code>: 存储了 session 所使用的 cookie。默认情况下会使用 <code>NSHTTPCookieShorage</code> 的 <code>+sharedHTTPCookieStorage</code> 这个单例对象，这与 <code>NSURLConnection</code> 是相同的。</li>\n<li><code>HTTPCookieAcceptPolicy</code>: 决定了什么情况下 session 应该接受从服务器发出的 cookie。</li>\n<li><code>HTTPShouldSetCookies</code>: 指定了请求是否应该使用 session 存储的 cookie，即 <code>HTTPCookieSorage</code> 属性的值。</li>\n</ol>\n<h5 id=\"安全策略\"><a href=\"#安全策略\" class=\"headerlink\" title=\"安全策略\"></a>安全策略</h5><ol>\n<li><code>URLCredentialStorage</code>: 存储了 session 所使用的证书。默认情况下会使用 <code>NSURLCredentialStorage</code> 的 <code>+sharedCredentialStorage</code> 这个单例对象，这与 <code>NSURLConnection</code> 是相同的。</li>\n<li><code>TLSMaximumSupportedProtocol</code> 和 <code>TLSMinimumSupportedProtocol</code> 确定 session 是否支持 <a href=\"http://zh.wikipedia.org/wiki/安全套接层\" target=\"_blank\" rel=\"noopener\">SSL 协议</a>。</li>\n</ol>\n<h5 id=\"缓存策略-1\"><a href=\"#缓存策略-1\" class=\"headerlink\" title=\"缓存策略\"></a>缓存策略</h5><ol>\n<li><code>URLCache</code> : 是 session 使用的缓存。默认情况下会使用 <code>NSURLCache</code> 的 <code>+sharedURLCache</code> 这个单例对象，这与 <code>NSURLConnection</code> 是相同的。</li>\n<li><code>requestCachePolicy</code> : 指定了一个请求的缓存响应应该在什么时候返回。这相当于 <code>NSURLRequest</code> 的 <code>-cachePolicy</code> 方法。</li>\n</ol>\n<h5 id=\"自定义协议\"><a href=\"#自定义协议\" class=\"headerlink\" title=\"自定义协议\"></a>自定义协议</h5><ol>\n<li><code>protocolClasses</code>: 用来配置特定某个 session 所使用的自定义协议（该协议是 <code>NSURLProtocol</code> 的子类）的数组。</li>\n</ol>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>iOS 7 和 Mac OS X 10.9 Mavericks 中 URL 加载系统的变化，是对 <code>NSURLConnection</code> 进行深思熟虑后的一个自然而然的进化。总体而言，苹果的 Foundation 框架团队干了一件令人钦佩的的工作，他们研究并预测了移动开发者现有的和新兴的用例，创造了能够满足日常任务而且非常好用的 API 。</p>\n<p>尽管在这个体系结构中，某些决定对于可组合性和可扩展性而言是一种倒退，但是 <code>NSURLSession</code> 仍然是实现更高级别网络功能的一个强大的基础框架。</p>\n<hr>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"API","path":"api/categories/API.json"}],"tags":[]},{"title":"支持OSX浏览PDF简单视图","slug":"macOS/支持OSX浏览PDF简单视图","date":"2017-09-08T18:48:43.000Z","updated":"2017-10-02T22:02:12.000Z","comments":true,"path":"api/articles/macOS/支持OSX浏览PDF简单视图.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><div id=\"enc_content\">U2FsdGVkX19GgcRpSm8t97uBq7UrSwU/fw9AjFsi+inY/8Gf9ZGUyLsVDE0d5nMgglnitl3imeSfV0XodXiGJrbmWVrH+8t8l53pYSNsCF2C833ZBetFCp/2NRvx7251A0k399hAo57o47yxnMuxGgsydreFAvbSeifGLg5nbFl+O+VHNZegeoROcUwAYzKwUEWzCy7KgoQsKh8imSicYY3zQAF8KPCN2gK8GH0hog/yPlCuyxEz7PZ8f+Z5ZkcF5rKj2D/tMPzYU5O68g5pBRMZ5wKrCqArkMnu65cGccuDGUV0So1AaM82Lw9F+ni/4++y4KGLbHX8qK0pChFodHCZBOIGZdfR/cPdE4aSpcSx9HiO1f5wMX/AqTPt+gsTQGDLPoiHgmhi5xjO4asTJQwEdDvdTEyc3PZhk13lLemg1vvwdA3nXWzjH3X7gkxTSD4gSI1jhM6Imv6F3K5sgFhFGbM+flqPkioYTpFTdKqiJ3HiLOcACHpMtkHb2zM1+pokFJVjGx19MAhXaKGM85MUNXGeQArgcIa9c8rIYQEyUPUM89qbRAr03SPDTUv7gf4LL6NYHquASCrHsOcUlYxYb1S1Ew7sdoYB3OBZ1M7f/ay4fTrXMuUPokf+DjGeK3N9pTBFG14A8r80hwRFYk1OJ0Oj0YKA8mMBgCEkAlv3dBRmaCmekQFpdS3EJCY3AwJSJ0xU9minz0VSEzloT702/WRwNORyAEF7rGL+Sr5Be3sDsaHYdzHsVCsTVMr1GWVhzY0GYsNZNcm4SoIHjuPQzAKyU+C0AKL4v92C7uru79DTuqjtEo8R/V0NKvxCvXpAHgGZPgVG2J8jMU7dthtJ33TV4sICe7crWSwdHeSj+1TopekheJle48HYksZihqC7CeU7Aw2DlVSW9XqGWVFbALNUS+uxpUiXI30vnZbj1DFK4fBXzwPUodMHNrbYFb6uqSI9xlrovMmUl79OZF3Mu8Id21MrJlhlwVmCpI9j5z8NUJ0v9sVovx5KGA2QTK+g2lT5UWl+KhDnyizL0vwnB8Y6eAwG3PZEP/iwcAFBrdbKCaIHF2gkzlUE37YWyE7iMYEdyO6u12YIsqA4vHDykHvcoGONKXcqfjw2iCKlz9k0OcjoNnX+zBQwRhN+QMNT71WiLKE9Nf1W5RtGpmz6mfKgLjIF1GgGvzRzbgDTJIWRTF0FPU6ELzhjEHty</div><script src=\"/js/crypto-js.js\"></script><script>var pwd = window.prompt(\"please input password\",\"\");var txt = document.getElementById(\"enc_content\").innerHTML;var bytes  = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);document.getElementById(\"enc_content\").innerHTML = plaintext</script>","raw":null,"categories":[{"name":"分类","path":"api/categories/分类.json"}],"tags":[]},{"title":"ngrok使用","slug":"工具/ngrok使用","date":"2017-09-06T12:23:24.000Z","updated":"2017-10-02T22:00:43.000Z","comments":true,"path":"api/articles/工具/ngrok使用.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/tcp协议SSH端口22.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h3><p>1.注册<a href=\"https://ngrok.com/signup\" target=\"_blank\" rel=\"noopener\">https://ngrok.com/signup</a></p>\n<ol>\n<li>Start by <a href=\"https://ngrok.com/download\" target=\"_blank\" rel=\"noopener\">downloading ngrok</a>.</li>\n<li><p>Install your authtoken</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./ngrok authtoken 2tpoyojTzL5w55Y4na5DY_3shJgaMVzjJ*****</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Create your first secure tunnel</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./ngrok http 80</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Open the web interface at <a href=\"http://localhost:4040\" target=\"_blank\" rel=\"noopener\">http://localhost:4040</a> to inspect and replay requests</p>\n</li>\n<li>Read the documentation for instructions on advanced features like adding HTTP authentication, setting custom subdomains and more.<h3 id=\"开启TCP协议\"><a href=\"#开启TCP协议\" class=\"headerlink\" title=\"开启TCP协议\"></a>开启TCP协议</h3></li>\n<li>开启TCP实现SSH远程访问. <a href=\"https://ngrok.com/docs#tcp\" target=\"_blank\" rel=\"noopener\">详见</a><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./ngrok tcp 22</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如图：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/tcp协议SSH端口22.png?imageMogr2/2/w/800\"></p>\n<blockquote>\n<p>每当执行开启命令，端口就会随机生成最新的。</p>\n</blockquote>\n<ol>\n<li>配置SSH远程工具<br>自定义SSH名：ngrok<br>SSH域名地址：0.tcp.ngrok.io  (ngrok提供的免费域名，IP地址ping就变新)<br>SSH端口号：16335 （每次重新启动时需更新）<br>用户名称/密码: 电脑管理员账户/密码<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/ssh工具配置.jpg?imageMogr2/2/w/800\"></li>\n<li>手机热点访问远程内网电脑<br>连接前准备：<ol>\n<li>使用“网络实用工具”扫描<code>0.tcp.ngrok.io</code>域名，确保当前网络16335端口开启</li>\n<li>备选方案，使用手机热点分享，来访问内网电脑，进行连通测试。<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/网络实用工具.png?imageMogr2/2/w/800\"></li>\n</ol>\n</li>\n<li>连接成功。<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/SSH连接成功.jpg?imageMogr2/2/w/800\">\n总结：可以使用ngrok客户端，开启tcp协议端口，实现SSH远程控制，在不要求过高的网速和安全，可以不搭建ngrok服务器。</li>\n</ol>\n<h3 id=\"强大的tunnel-隧道-工具部署原理\"><a href=\"#强大的tunnel-隧道-工具部署原理\" class=\"headerlink\" title=\"强大的tunnel(隧道)工具部署原理\"></a>强大的tunnel(隧道)工具部署原理</h3><p><a href=\"http://tonybai.com/2015/05/14/ngrok-source-intro/\" target=\"_blank\" rel=\"noopener\">部署</a><br>ngrok在其github官方页面上的自我诠释是 “introspected tunnels to localhost”，这个诠释有两层含义：<br>1、可以用来建立public到localhost的tunnel，让居于内网主机上的服务可以暴露给public，俗称内网穿透。<br>2、支持对隧道中数据的introspection（内省），支持可视化的观察隧道内数据，并replay（重放）相关请求（诸如http请 求）。<br>因此ngrok可以很便捷的协助进行服务端程序调试，尤其在进行一些Web server开发中。ngrok更强大的一点是它支持tcp层之上的所有应用协议或者说与应用层协议无关。比如：你可以通过ngrok实现ssh登录到内 网主 机，也可以通过ngrok实现远程桌面(VNC)方式访问内网主机。</p>\n<p>一、ngrok tunnel与ngrok部署</p>\n<p>网络tunnel（隧道）对多数人都是很”神秘“的概念，tunnel种类很多，没有标准定义，我了解的也不多（日常工作较少涉及），这里也就不 深入了。在《HTTP权威指南》中有关于HTTP tunnel（http上承载非web流量）和SSL tunnel的说明，但ngrok中的tunnel又与这些有所不同。</p>\n<p>ngrok实现了一个tcp之上的端到端的tunnel，两端的程序在ngrok实现的Tunnel内透明的进行数据交互。<br><img src=\"http://tonybai.com/wp-content/uploads/ngrok-tunnel.png\" alt=\"\"><br>ngrok分为client端(ngrok)和服务端(ngrokd)，实际使用中的部署如下：<br><img src=\"http://tonybai.com/wp-content/uploads/ngrok-deployment.png\" alt=\"\"><br>内网服务程序可以与ngrok client部署在同一主机，也可以部署在内网可达的其他主机上。ngrok和ngrokd会为建立与public client间的专用通道（tunnel）。</p>\n","raw":null,"categories":[{"name":"工具","path":"api/categories/工具.json"},{"name":"网络","path":"api/categories/网络.json"}],"tags":[]},{"title":"搞定III目录笔记","slug":"阅读/搞定III目录笔记","date":"2017-08-17T15:41:11.000Z","updated":"2017-08-17T15:55:45.000Z","comments":true,"path":"api/articles/阅读/搞定III目录笔记.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>11个模型</p>\n<h2 id=\"《搞定III》\"><a href=\"#《搞定III》\" class=\"headerlink\" title=\"《搞定III》\"></a>《搞定III》</h2><p>第1章 GTD现象<br>几类读者：似懂非懂型，止步于列举清单等<br>第二类：很难坚持<br>第三类：学以致用型<br>如何阅读本书：<br>手头备小本子，“假设的肯定”<br>自我培训：可信赖，可操作，长期追踪的步骤找到最终答案<br>相信自己的决定的钥匙</p>\n<p>第2章 步骤<br>第3章 自我管理的基本内容</p>\n<h3 id=\"获得掌控\"><a href=\"#获得掌控\" class=\"headerlink\" title=\"获得掌控\"></a>获得掌控</h3><pre><code>第4章 捕捉 :梦想家，发散思维搜集所有信息\n第5章 明确意义:执行者，处理原材料，有的放矢\n     1. 结果导向型思维的战术价值\n     2.\n第6章 组织整理\n第7章 深思\n第8章 参与\n第9章 把GTD运用到工作和生活中\n</code></pre><h3 id=\"六个高度-六层次法\"><a href=\"#六个高度-六层次法\" class=\"headerlink\" title=\"六个高度:六层次法\"></a>六个高度:六层次法</h3><pre><code>第10章 摆正视角\n第11章 紧急问题：下一步行动\n第12章 1万英尺：项目\n第13章 2万英尺：关注和责任范围\n第14章 3万英尺：长短期目标\n第15章 4万英尺：愿景\n第16章 5万英尺：宗旨和原则\n第17章 摆正视角：重访“格雷西的花园”\n</code></pre><h3 id=\"实际运用\"><a href=\"#实际运用\" class=\"headerlink\" title=\"实际运用\"></a>实际运用</h3><p>第18章 实际运用<br>第19章 尾声</p>\n","raw":null,"categories":[{"name":"阅读","path":"api/categories/阅读.json"}],"tags":[]},{"title":"在space-vim平台安装若干插件","slug":"shell/在space-vim平台安装若干插件","date":"2017-08-17T14:26:46.000Z","updated":"2017-08-17T15:02:27.000Z","comments":true,"path":"api/articles/shell/在space-vim平台安装若干插件.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"space-vim\"><a href=\"#space-vim\" class=\"headerlink\" title=\"space-vim\"></a>space-vim</h2><p>首次启用一个 layer，需要执行 SPC f R, 或者 :so $MYVIMRC, 重新加载 .vimrc 并执行 :PlugInstall 安装所需的相关插件 。或者退出重新打开 vim, vim-plug 将会检测并自动安装缺失的插件。<br>基于vim-plug的插件管理平台<br><a href=\"https://github.com/junegunn/vim-plug#commands\" target=\"_blank\" rel=\"noopener\">vim-plug命令工具</a></p>\n<h3 id=\"Commands\"><a href=\"#Commands\" class=\"headerlink\" title=\"Commands\"></a>Commands</h3><table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>PlugInstall [name ...] [#threads]</code></td>\n<td>Install plugins</td>\n</tr>\n<tr>\n<td><code>PlugUpdate [name ...] [#threads]</code></td>\n<td>Install or update plugins</td>\n</tr>\n<tr>\n<td><code>PlugClean[!]</code></td>\n<td>Remove unused directories (bang version will clean without prompt)</td>\n</tr>\n<tr>\n<td><code>PlugUpgrade</code></td>\n<td>Upgrade vim-plug itself</td>\n</tr>\n<tr>\n<td><code>PlugStatus</code></td>\n<td>Check the status of plugins</td>\n</tr>\n<tr>\n<td><code>PlugDiff</code></td>\n<td>Examine changes from the previous update and the pending changes</td>\n</tr>\n<tr>\n<td><code>PlugSnapshot[!] [output path]</code></td>\n<td>Generate script for restoring the current snapshot of the plugins</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Plug-options\"><a href=\"#Plug-options\" class=\"headerlink\" title=\"Plug options\"></a><code>Plug</code> options</h3><table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>branch</code>/<code>tag</code>/<code>commit</code></td>\n<td>Branch/tag/commit of the repository to use</td>\n</tr>\n<tr>\n<td><code>rtp</code></td>\n<td>Subdirectory that contains Vim plugin</td>\n</tr>\n<tr>\n<td><code>dir</code></td>\n<td>Custom directory for the plugin</td>\n</tr>\n<tr>\n<td><code>as</code></td>\n<td>Use different name for the plugin</td>\n</tr>\n<tr>\n<td><code>do</code></td>\n<td>Post-update hook (string or funcref)</td>\n</tr>\n<tr>\n<td><code>on</code></td>\n<td>On-demand loading: Commands or <code>&lt;Plug&gt;</code>-mappings</td>\n</tr>\n<tr>\n<td><code>for</code></td>\n<td>On-demand loading: File types</td>\n</tr>\n<tr>\n<td><code>frozen</code></td>\n<td>Do not update unless explicitly specified</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"安装objc-自动提示插件YouCompleteMe\"><a href=\"#安装objc-自动提示插件YouCompleteMe\" class=\"headerlink\" title=\"安装objc 自动提示插件YouCompleteMe\"></a>安装objc 自动提示插件YouCompleteMe</h2><p><a href=\"https://github.com/Valloric/YouCompleteMe#commands\" target=\"_blank\" rel=\"noopener\">YouCompleteMe命令工具</a></p>\n<ol>\n<li><p>在spacevim添加<br>使用space-vim封装的layer</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Layer &apos;ycmd&apos;         &quot;语法自动补齐</span><br></pre></td></tr></table></figure>\n<p>YouCompleteMe 安装位置： <code>~/.vim/plugged/YouCompleteMe</code> 。</p>\n</li>\n<li><p>编译 YCM<br>在使用space-vim平台上，使用layer方式安装会执行如下编译操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">!./install.py --clang-completer</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>详见脚本：space-vim/layers/+tools/ycmd/packages.vim</p>\n<p>参考：<a href=\"http://www.cocoachina.com/ios/20170224/18751.html\" target=\"_blank\" rel=\"noopener\">征服恐惧！用 Vim 写 iOS App</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install cmake</span><br><span class=\"line\">./install.py --clang-completer --system-libclang</span><br></pre></td></tr></table></figure></p>\n<p><code>--clang-completer</code>: 告诉脚本需要 clang 的支持<br><code>--system-libclang</code>: 告诉编译脚本使用系统的 clang，因为之前 clang 升级 4.0 的时候，并没有已经编译好的包给我下载，所以这里不用系统 clang 的话，编译脚本会下载一个 clang 3.0，这样就无法支持 iOS 10.0 以后的 sdk 了，因为 iOS 10.0 以后的 sdk 为了支持 swift 引入了一些 clang 3.0 不支持的新语法，所以这里要加上 –system-libclang。</p>\n<ol>\n<li>FlagsForFile脚本获取编译参数<br>YCMD 是通过每个项目路径下的 <code>.ycm_extra_conf.py</code> 脚本文件，定义了<code>FlagsForFile</code> 的函数来获取某一个特定文件需要的编译参数，一般情况下大部分文件的编译参数是相同的。</li>\n</ol>\n<h3 id=\"配置swiftlint语法矫正工具\"><a href=\"#配置swiftlint语法矫正工具\" class=\"headerlink\" title=\"配置swiftlint语法矫正工具\"></a>配置swiftlint语法矫正工具</h3><p>安装<br>方式一：<code>brew install swiftlint</code><br>方式二：下载[swiftlint.pkg][<a href=\"https://github.com/realm/SwiftLint/releases/latest\" target=\"_blank\" rel=\"noopener\">https://github.com/realm/SwiftLint/releases/latest</a>]<br>方式三：<code>pod &#39;SwiftLint&#39;</code>，对单个项目集成swiftlint</p>\n<p>配置<br>在Xcode中<br>新增一个： “Run Script Phase”:<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">which</span> swiftlint &gt;/dev/null; <span class=\"keyword\">then</span></span><br><span class=\"line\">swiftlint</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure></p>\n<p>在终端预览：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ swiftlint <span class=\"built_in\">help</span></span><br><span class=\"line\">Available commands:</span><br><span class=\"line\"></span><br><span class=\"line\">autocorrect  Automatically correct warnings and errors</span><br><span class=\"line\"><span class=\"built_in\">help</span>         Display general or <span class=\"built_in\">command</span>-specific <span class=\"built_in\">help</span></span><br><span class=\"line\">lint         Print lint warnings and errors <span class=\"keyword\">for</span> the Swift files <span class=\"keyword\">in</span> the current directory (default <span class=\"built_in\">command</span>)</span><br><span class=\"line\">rules        Display the list of rules and their identifiers</span><br><span class=\"line\">version      Display the current version of SwiftLint</span><br></pre></td></tr></table></figure>\n<p>支持vim编辑器：<br><a href=\"https://github.com/keith/swift.vim\" target=\"_blank\" rel=\"noopener\">keith/swift.vim</a></p>\n<ol>\n<li>安装 <a href=\"https://github.com/scrooloose/syntastic/\" target=\"_blank\" rel=\"noopener\">syntastic</a></li>\n<li>当在存在<code>Package.swift</code>的swift目录中启动vim，swiftpm将自动可用。</li>\n<li>当在存在<code>.swiftlint.yml</code>的swift目录中启动vim，且SwiftLint已安装，自动启用swiftlint。</li>\n<li>在vimrc中添加配置，当启动vim即可使用：<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">let</span> g:syntastic_swift_checkers = [<span class=\"string\">'swiftpm'</span>, <span class=\"string\">'swiftlint'</span>]</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"支持swift自动补齐\"><a href=\"#支持swift自动补齐\" class=\"headerlink\" title=\"支持swift自动补齐\"></a>支持swift自动补齐</h3><p>keith/sourcekittendaemon.vim：这个插件提供了Vim集成SourceKittenDaemon。这意味着你可以在vim中开发swift项目<br>需要两步：<br>    方式一：<code>brew install sourcekitten</code><br>    方式二：clone源码 ,运行<code>swift build</code><br>    方式三： clone 源码，运行 <code>make install</code><br>    方式三： <a href=\"https://github.com/jpsim/SourceKitten/releases\" target=\"_blank\" rel=\"noopener\">pkg安装包</a><br>    执行<code>sourcekitten help</code>验证安装成功。</p>\n<ol>\n<li>安装SourceKittenDaemon环境<br> 安装并设置<a href=\"https://github.com/terhechte/SourceKittenDaemon\" target=\"_blank\" rel=\"noopener\">SourceKittenDaemon</a><br> 方式一：<a href=\"https://github.com/terhechte/SourceKittenDaemon/releases/\" target=\"_blank\" rel=\"noopener\">pkg安装包</a><br> 方式二：1. Clone the repository  2. 安装 <code>make install</code><br> 执行<code>SourceKittenDaemon help</code>验证安装成功。<br> 启动后台驻守服务HTTP：<a href=\"https://github.com/terhechte/SourceKittenDaemon/blob/master/Protocol.org\" target=\"_blank\" rel=\"noopener\">参考Protocol.org</a><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SourceKittenDaemon start --port 44876 --project /private/tmp/abcde/abcde.xcodeproj</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><code>--port</code>: 服务使用的端口号，默认为<code>8081</code>，vim目前不支持指定SourceKittenDaemon端口，使用默认的8081。<br><code>--project=</code>: 指定服务将要加载的<code>.xcodeproj</code>文件路径，不支持指定<code>.xcworkspaces</code>文件路径</p>\n<p>使用get方法请求后驻服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/complete  # X-Offset|X-Path|X-File</span><br><span class=\"line\">/stop     # 停止后驻服务. 一般用于为其他target提供服务时，重新启动服务。</span><br><span class=\"line\">/ping     # ping后驻服务，运行正常 return OK</span><br><span class=\"line\">/project  # 打印当前加载的project文件路径。</span><br><span class=\"line\">/files    # 打印一个当前加载的project中包含的所有swift文件列表</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>安装vim插件<br>使用vim-plug安装<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Plug &apos;keith/sourcekittendaemon.vim&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>NOTE: This plugin doesn’t provide Swift runtime files. If you’d like those checkout swift.vim</p>\n<h3 id=\"AsyncRun-shell-command\"><a href=\"#AsyncRun-shell-command\" class=\"headerlink\" title=\"AsyncRun shell command\"></a>AsyncRun shell command</h3><p>编辑器命令:AsyncRun + shell命令即可在后台执行shell命令，打开quickfix就可以实时查看执行结果了。也可以通过添加配置的方式来实现开始执行命令的时候自动打开quickfix窗口：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:copen //打开脚本运行日志窗口 </span><br><span class=\"line\">:AsyncRun git status  //异步执行shell脚本</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"vim","path":"api/categories/vim.json"},{"name":"工具","path":"api/categories/工具.json"}],"tags":[]},{"title":"PBBReader项目重构模型","slug":"个人项目/PBBReader项目重构模型","date":"2017-07-25T17:06:47.000Z","updated":"2017-08-17T14:54:01.000Z","comments":true,"path":"api/articles/个人项目/PBBReader项目重构模型.json","excerpt":null,"keywords":null,"cover":"http://www.plantuml.com/plantuml/svg/ZLPRJnj757xVNp5ofQpKS7cib0SaY8L2KneBK2lLvM5j3_OgQw_hNNfHX0G2WxaOJA10I75Y2iLDmQP1nc07_6TsnhjF-GkTdTcRRqddnPvpllFDDpDdpbbLL2K80YCZ4r28m9HHk6s-BXahMPnVmiK2ogzpOPXGOGh4g9_x518c8XQAuxza0w0_B_71PhE-fDMlJTZHFWZByQIS8Ao3GMP7kUmqq6ukyFevsghYtJBUMFWnWRF7Uc43M4GyuUmdmo949oluglY8nJTh3JP7MsMjVchC7-gD5VtL8R7x1WPyUYEFDqzHvXAbhxNw7YhVwlyM21MX9AHVc0C0Hc0frEwopRlInm-74fnH1rDYDAOEgd9oC2IhgXm7WCRGS8v_G0UmbDINK2vZiR2Di0cgRA3JVS303tYEH-cBvbdMmh-jeWzRZxwL8x1l0ePL8H6LOD-eB96Zx1jD2N7OzrYIPoDzVa4LGe82UOvQWG_bocYjE1m8-5vmW8mW-Uk74emAAfm6WWA-4MOJuHYnSdCS8mG-yw2MDvWkEmwV7-kDJQDGcGRaZ8EelDnyku1Nxz7hl6di3ceSwALB1dL1xQ4CMjh0cHnRs0Dj8-WEdNCsk_P6NxmZUMU9jlU3CjVQtHyj-s7q9uVetKljRiUONyNhVpihwALxL3h4Hul6gvmZXaQqUvYWapsqjOqoorhjdrPukuV1g--9qPXVG9bzlL1q8kPQD1i7QRrSxwAv-fxaAjwzTlbk6sXxhMrXnqOX-EK5thtNpvQDu-t_0JJUN7qMMDdIpp81_sWF-MI7pStBAI7KefqQNU6rVMEdffV_melf7ZJQpJkjLYCl7pKMsyYyBiR7BEIAoDEqoUOu-qa0d_AJ9AhGF-83BpZgvbEq6E7VBt6sX6exrEZYdKfc1jZhsieOcTT3LKK4URhD4cepnCahbbpRd6VRl9oGn0JyXA1d5E1TDeZkqoGdtGrpj1G0NqnLamyLEVmSgjQvMOuM6wKmwPdLS-DXejCpbTKOJ7dcoTcG98ObCUIzD-yoJwQc0Yr2XoV7dX1D7gLcGGE-vlcvThEAzsud_K-TSfDVGEbLl5aaxyGg1fCn8GK9n9h6PvEHcMcN1QNFcxj5L3r5wQhDydXM8ULuxDdaLyCIJAdVYV0NAreLup2bM9FXoC_4AofY8keXPFrBkp_IAtiM8H-S_65S3eaIrM4cdLi-AHEveN7XEJcdJX_VuXpgKMM2Ory_7OSHKGX8mcyzU3eXGrsUkBCFlRA4Qpbh1pDM-ewDjBwbkXWG8fxR3P3JaHE29q-34p0gAcfB3YX98UpDaU-XH7etTC_PanNEod4X2fM1NyE2ea1LwIA38Rg8wN3OaZeSL5Y7rIFFwwEfo0yvW_Jwz5NpoYg-0BWUddFkWbL1fzzn7Mt9QWqT7QONqblNEJVPGR_vYM7US4URQSbRq4-_GYZGRGXZ8xOTj9qxnzB2eNTwf-Em-RnV0_Qttemianyk99C4PDtL_BPZrly0","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><img src=\"http://www.plantuml.com/plantuml/svg/ZLPRJnj757xVNp5ofQpKS7cib0SaY8L2KneBK2lLvM5j3_OgQw_hNNfHX0G2WxaOJA10I75Y2iLDmQP1nc07_6TsnhjF-GkTdTcRRqddnPvpllFDDpDdpbbLL2K80YCZ4r28m9HHk6s-BXahMPnVmiK2ogzpOPXGOGh4g9_x518c8XQAuxza0w0_B_71PhE-fDMlJTZHFWZByQIS8Ao3GMP7kUmqq6ukyFevsghYtJBUMFWnWRF7Uc43M4GyuUmdmo949oluglY8nJTh3JP7MsMjVchC7-gD5VtL8R7x1WPyUYEFDqzHvXAbhxNw7YhVwlyM21MX9AHVc0C0Hc0frEwopRlInm-74fnH1rDYDAOEgd9oC2IhgXm7WCRGS8v_G0UmbDINK2vZiR2Di0cgRA3JVS303tYEH-cBvbdMmh-jeWzRZxwL8x1l0ePL8H6LOD-eB96Zx1jD2N7OzrYIPoDzVa4LGe82UOvQWG_bocYjE1m8-5vmW8mW-Uk74emAAfm6WWA-4MOJuHYnSdCS8mG-yw2MDvWkEmwV7-kDJQDGcGRaZ8EelDnyku1Nxz7hl6di3ceSwALB1dL1xQ4CMjh0cHnRs0Dj8-WEdNCsk_P6NxmZUMU9jlU3CjVQtHyj-s7q9uVetKljRiUONyNhVpihwALxL3h4Hul6gvmZXaQqUvYWapsqjOqoorhjdrPukuV1g--9qPXVG9bzlL1q8kPQD1i7QRrSxwAv-fxaAjwzTlbk6sXxhMrXnqOX-EK5thtNpvQDu-t_0JJUN7qMMDdIpp81_sWF-MI7pStBAI7KefqQNU6rVMEdffV_melf7ZJQpJkjLYCl7pKMsyYyBiR7BEIAoDEqoUOu-qa0d_AJ9AhGF-83BpZgvbEq6E7VBt6sX6exrEZYdKfc1jZhsieOcTT3LKK4URhD4cepnCahbbpRd6VRl9oGn0JyXA1d5E1TDeZkqoGdtGrpj1G0NqnLamyLEVmSgjQvMOuM6wKmwPdLS-DXejCpbTKOJ7dcoTcG98ObCUIzD-yoJwQc0Yr2XoV7dX1D7gLcGGE-vlcvThEAzsud_K-TSfDVGEbLl5aaxyGg1fCn8GK9n9h6PvEHcMcN1QNFcxj5L3r5wQhDydXM8ULuxDdaLyCIJAdVYV0NAreLup2bM9FXoC_4AofY8keXPFrBkp_IAtiM8H-S_65S3eaIrM4cdLi-AHEveN7XEJcdJX_VuXpgKMM2Ory_7OSHKGX8mcyzU3eXGrsUkBCFlRA4Qpbh1pDM-ewDjBwbkXWG8fxR3P3JaHE29q-34p0gAcfB3YX98UpDaU-XH7etTC_PanNEod4X2fM1NyE2ea1LwIA38Rg8wN3OaZeSL5Y7rIFFwwEfo0yvW_Jwz5NpoYg-0BWUddFkWbL1fzzn7Mt9QWqT7QONqblNEJVPGR_vYM7US4URQSbRq4-_GYZGRGXZ8xOTj9qxnzB2eNTwf-Em-RnV0_Qttemianyk99C4PDtL_BPZrly0\"></p>\n<h3 id=\"使用属性结构与法\"><a href=\"#使用属性结构与法\" class=\"headerlink\" title=\"使用属性结构与法\"></a>使用属性结构与法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\`\\`\\`puml</span><br><span class=\"line\">salt</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#123;T</span><br><span class=\"line\">    + world</span><br><span class=\"line\">    ++ America</span><br><span class=\"line\">    ++ sss</span><br><span class=\"line\">    +++ aaa</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\\`\\`\\`puml</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.plantuml.com/plantuml/svg/AqxCAU6gvgeEuLBGLYZFByf90JAq5HnpKuioanF1xEBYOX2jhP2OcCXLorKB0000\"></p>\n","raw":null,"categories":[{"name":"项目","path":"api/categories/项目.json"},{"name":"结构","path":"api/categories/结构.json"}],"tags":[]},{"title":"WKWebView控件和JS脚本传参及交互","slug":"iOS/WKWebView控件和JS脚本传参及交互","date":"2017-07-07T09:54:41.000Z","updated":"2017-09-09T08:07:47.000Z","comments":true,"path":"api/articles/iOS/WKWebView控件和JS脚本传参及交互.json","excerpt":null,"keywords":null,"cover":"http://www.plantuml.com/plantuml/svg/XLPjJzjM5FxkNt55f2O19rAtRnv2cfYg3THr6jloOR3AYI_1O6paE6HexKGfwLBUaa61bVSEA6YZZ0eDQ4B8d_6z3f_w5tQkhvqub6ht0_ZQvzpddESyvznOggLXbEXDuEGFAiwHnRcUllhq6jqu4b9Ojx29Xh2iO5Emoy_g1xlsvGufJf65RQVq36pjyfvTNgGRPL8u4x2kUBP2k9qlvBojaDqJ-iS2FNn5DbUHzpuiXDcNhLaffScPZ2WdCvOffonHPP23SWgBiguRbcofXYvYFJiA7lNZslNgCTdUbYAng7FmX6uy5oEXg5tRf3DxOkJNA9dB-wyxeYH_14zXYEMEkrWeJcMQb0fUAB3tdhZ17O0W-JVEmRndjdDEBelIruQ2nMznofBrj8R5UuO66OhtJ7aKYzsQaLN4BsHBJieP71R6vDI8dCQeJNtGnpXwiVtvDr-rTNPofwwkNmG4oqqPAEziiEvzOElXGqHNtj7JPGW2Dett7IYYAb5LLws4QWsvy5BAq0VLTDPqMPA2fkC66EDnMSlA5kwHn-M-bAcEMU0nEgPXPlwbh2iQDhdNOo4G63-r6Lnt42KGQIo6oDijEdd08et50l29tkyps0G_2nJ4_fc61bYeFNlRwq3gZSo3YVjvVnYfUrntvqVWMaYz_MIN9bbHE3ltSIO3rVEPqHd5jnWpC8zEBoJsDn2MWZMS1juXiDiEzkAAnUpABdGHZypZpqEvbIT9KHNG8LR7SSkn7uaYuzfuv7271ZBTchwUt24l3_sojQghpyYQAIof-Z387eh-dGfC31hcVLdLNUKzqBK9wJCF5qhYwzuV7QWfUHGoiHBK_N26smI5T9sVTwh7K9s0Z4PRICj8mncwi4-AkwGqtx0PCp8-2p2LwF99CwHmo5tk0DhxZPuUDhlU6qWRVvEJAxjQSruSIZ1gCBAhB0e9SVkGlyA2-zKonf0n2DeMwB_5-a41sBClAdPrYSqzn4oudQccXoncoVi8XTAcF240Y5rU81k7dFf4BrqzUtyvT_tdD9dPgLUhFYlmhdvynSXO_vsKZdhwUDBq8a_cbsyW9GtBCaOP56y4wMwS5alsrNhZLByUT6dUhcxqwv_48O87tVR56tfU0HCEugnD1r7UNwxvVeqlG7g__caSQ27vVQvR8BA563y32TLFdaAwVFxrwoYdwegHY-TmSaIruZVA6W-KDHuePuJNCmh-_Cc-AAiAlpE08r9Tegli9k9Od4nkoEa3SpshQJTAudUc56mzo9VElgQ5lrefPvLOE2V5bPu-kFIk9nU138v09Y_xTI2Ih6y1F939xUh_x3U-mvbUel6aeKo07BlSvSelV-gSLiZw5IdEr6jR32qeq2vlkRSHiwpFJ3bJxvoZrrBaKLVKgHpGvpKnqXvbLrIXXCI84Qq_MOETY4Z-pAwiXCIVnSTYX_WJWkETSirrZSMYv9Zj42GMYSUZzPThi0iBYTwsksseFVOZQzI1668xBbt96nDkKgYpXKiTQQe-WaAv8HNaU4FKRZVd-Eq1h84SeIXqyvLTEMjAMF3wWo6dJOnrmFPqJ7SkIEqfZ0Dm05o1Zp9an3GyQFbnDlJMQCSFP0--YTx_TUCI2lZmADp0abeM3pHbG_QccV9TdP322UGMSFEjKEUZE4TCQZ0N1-8mCoJKQ9ecW1yO6n0G6SzIuZtMEDN_5JPe06cca3GciCcKiZNBgEHl_mC0","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"WebKit简介\"><a href=\"#WebKit简介\" class=\"headerlink\" title=\"WebKit简介\"></a>WebKit简介</h3><div id=\"badge-container-huos3203-WKWebView-JS-d03bc0e\" class=\"hexo-github\" style=\"width: =\"></div>\n<script src=\"/hexo-github/badge.js\"></script>\n<script type=\"text/javascript\">\n  loadStyle(\"/hexo-github/style.css\");\n  loadStyle(\"/hexo-github/octicons/octicons.css\");\n  new Badge(\"#badge-container-huos3203-WKWebView-JS-d03bc0e\", \"huos3203\", \"WKWebView-JS\", \"d03bc0e\", false);\n</script>\n\n<p>自iOS8 以后，苹果推出了新框架 WebKit，提供了替换 UIWebView 的组件 WKWebView。各种 UIWebView 的性能问题没有了，速度更快了，占用内存少了，体验更好了，下面列举一些其它的优势:<br>1、在性能、稳定性、功能方面有很大提升（加载速度，内存的提升谁用谁知道）<br>2、更多的支持 HTML5 的特性<br>3、官方宣称的高达60fps的滚动刷新率以及内置手势<br>4、Safari 相同的 JavaScript 引擎<br>5、将 UIWebViewDelegate 与 UIWebView 拆分成了14类与3个协议，包含该更细节功能的实现。</p>\n<p><img src=\"http://www.plantuml.com/plantuml/svg/XLPjJzjM5FxkNt55f2O19rAtRnv2cfYg3THr6jloOR3AYI_1O6paE6HexKGfwLBUaa61bVSEA6YZZ0eDQ4B8d_6z3f_w5tQkhvqub6ht0_ZQvzpddESyvznOggLXbEXDuEGFAiwHnRcUllhq6jqu4b9Ojx29Xh2iO5Emoy_g1xlsvGufJf65RQVq36pjyfvTNgGRPL8u4x2kUBP2k9qlvBojaDqJ-iS2FNn5DbUHzpuiXDcNhLaffScPZ2WdCvOffonHPP23SWgBiguRbcofXYvYFJiA7lNZslNgCTdUbYAng7FmX6uy5oEXg5tRf3DxOkJNA9dB-wyxeYH_14zXYEMEkrWeJcMQb0fUAB3tdhZ17O0W-JVEmRndjdDEBelIruQ2nMznofBrj8R5UuO66OhtJ7aKYzsQaLN4BsHBJieP71R6vDI8dCQeJNtGnpXwiVtvDr-rTNPofwwkNmG4oqqPAEziiEvzOElXGqHNtj7JPGW2Dett7IYYAb5LLws4QWsvy5BAq0VLTDPqMPA2fkC66EDnMSlA5kwHn-M-bAcEMU0nEgPXPlwbh2iQDhdNOo4G63-r6Lnt42KGQIo6oDijEdd08et50l29tkyps0G_2nJ4_fc61bYeFNlRwq3gZSo3YVjvVnYfUrntvqVWMaYz_MIN9bbHE3ltSIO3rVEPqHd5jnWpC8zEBoJsDn2MWZMS1juXiDiEzkAAnUpABdGHZypZpqEvbIT9KHNG8LR7SSkn7uaYuzfuv7271ZBTchwUt24l3_sojQghpyYQAIof-Z387eh-dGfC31hcVLdLNUKzqBK9wJCF5qhYwzuV7QWfUHGoiHBK_N26smI5T9sVTwh7K9s0Z4PRICj8mncwi4-AkwGqtx0PCp8-2p2LwF99CwHmo5tk0DhxZPuUDhlU6qWRVvEJAxjQSruSIZ1gCBAhB0e9SVkGlyA2-zKonf0n2DeMwB_5-a41sBClAdPrYSqzn4oudQccXoncoVi8XTAcF240Y5rU81k7dFf4BrqzUtyvT_tdD9dPgLUhFYlmhdvynSXO_vsKZdhwUDBq8a_cbsyW9GtBCaOP56y4wMwS5alsrNhZLByUT6dUhcxqwv_48O87tVR56tfU0HCEugnD1r7UNwxvVeqlG7g__caSQ27vVQvR8BA563y32TLFdaAwVFxrwoYdwegHY-TmSaIruZVA6W-KDHuePuJNCmh-_Cc-AAiAlpE08r9Tegli9k9Od4nkoEa3SpshQJTAudUc56mzo9VElgQ5lrefPvLOE2V5bPu-kFIk9nU138v09Y_xTI2Ih6y1F939xUh_x3U-mvbUel6aeKo07BlSvSelV-gSLiZw5IdEr6jR32qeq2vlkRSHiwpFJ3bJxvoZrrBaKLVKgHpGvpKnqXvbLrIXXCI84Qq_MOETY4Z-pAwiXCIVnSTYX_WJWkETSirrZSMYv9Zj42GMYSUZzPThi0iBYTwsksseFVOZQzI1668xBbt96nDkKgYpXKiTQQe-WaAv8HNaU4FKRZVd-Eq1h84SeIXqyvLTEMjAMF3wWo6dJOnrmFPqJ7SkIEqfZ0Dm05o1Zp9an3GyQFbnDlJMQCSFP0--YTx_TUCI2lZmADp0abeM3pHbG_QccV9TdP322UGMSFEjKEUZE4TCQZ0N1-8mCoJKQ9ecW1yO6n0G6SzIuZtMEDN_5JPe06cca3GciCcKiZNBgEHl_mC0\"></p>\n<h4 id=\"添加监听代理和JS接口\"><a href=\"#添加监听代理和JS接口\" class=\"headerlink\" title=\"添加监听代理和JS接口\"></a>添加监听代理和JS接口</h4><p>在OC中添加监听的接口清单：以JS脚本的接口<code>showMobile</code>为例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">WKWebViewConfiguration</span> *config = [[<span class=\"built_in\">WKWebViewConfiguration</span> alloc] init];</span><br><span class=\"line\"><span class=\"built_in\">WKUserContentController</span> *userCC = config.userContentController;</span><br><span class=\"line\"><span class=\"comment\">//MARK:在OC中添加监听的接口清单：JS脚本的接口名</span></span><br><span class=\"line\">[userCC addScriptMessageHandler:<span class=\"keyword\">self</span> name:<span class=\"string\">@\"showMobile\"</span>];</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"设置WKUserContentController的代理\"><a href=\"#设置WKUserContentController的代理\" class=\"headerlink\" title=\"设置WKUserContentController的代理\"></a>设置WKUserContentController的代理</h4><ol>\n<li><p>设置代理类遵守<code>WKScriptMessageHandler</code>协议</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> () &lt;<span class=\"title\">WKScriptMessageHandler</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注册对JS接口监听，注入代理类</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[userCC addScriptMessageHandler:<span class=\"keyword\">self</span> name:<span class=\"string\">@\"showMobile\"</span>];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>实现<code>WKUserContentController</code>代理的回调方法,响应JS接口事件</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)userContentController:(<span class=\"built_in\">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class=\"built_in\">WKScriptMessage</span> *)message &#123;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,message.body);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"JS脚本接口\"><a href=\"#JS脚本接口\" class=\"headerlink\" title=\"JS脚本接口\"></a>JS脚本接口</h4><p>js接口声明格式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.webkit.messageHandlers.接口名.postMessage(<span class=\"string\">'参数'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>接口名: 在WKWebView中，当JS执行该接口时，OC会拦截预先监听的接口，并处理相关事件。</p>\n<p>参数：object类型，多个参数时需要封装为集合类型来实现多参传递。</p>\n<p>当OC拦截到该接口时，可以在<code>WKScriptMessageHandler</code>回调方法中的<code>WKScriptMessage</code>参数实例中获取该参数值: <code>message.body</code>。</p>\n<p>三个例子：</p>\n<ol>\n<li><p>JS无参调用OC<br><br>当无参调用OC时，参数必须为<code>null</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.webkit.messageHandlers.showMobile.postMessage(<span class=\"literal\">null</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>JS传参调用OC<br><br>传递单个参数时，直接写入即可，例如：<code>xiao黄</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.webkit.messageHandlers.showName.postMessage(<span class=\"string\">'xiao黄'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>传递多个参数时，需要封装为集合类型实现多参传递。<br><br>例如:当传递一个电话，一条信息，需要封装为<code>[&#39;13300001111&#39;,&#39;Go Climbing This Weekend !!!&#39;]</code><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.webkit.messageHandlers.showSendMsg.postMessage([<span class=\"string\">'13300001111'</span>, <span class=\"string\">'Go Climbing This Weekend !!!'</span>])</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"iOS原生API调用JS脚本\"><a href=\"#iOS原生API调用JS脚本\" class=\"headerlink\" title=\"iOS原生API调用JS脚本\"></a>iOS原生API调用JS脚本</h3><p>在网页加载完成之后调用JS代码才会执行，因为这个时候html页面已经注入到webView中并且可以响应到对应方法。<br><br>例如调用JS函数<code>alertMobile()</code>：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span>.wkWebView evaluateJavaScript:<span class=\"string\">@\"alertMobile()\"</span> completionHandler:^(<span class=\"keyword\">id</span> _Nullable response, <span class=\"built_in\">NSError</span> * _Nullable error) &#123;</span><br><span class=\"line\"><span class=\"comment\">//TODO</span></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ %@\"</span>,response,error);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"在OC中为JS定义属性-函数\"><a href=\"#在OC中为JS定义属性-函数\" class=\"headerlink\" title=\"在OC中为JS定义属性/函数\"></a>在OC中为JS定义属性/函数</h4><ul>\n<li>当注入的类型字符串类型时，必须用<code>&#39;&#39;</code>括起来。<br></li>\n<li>OC注入的参数为全局属性，在html中的JS脚本可以直接调用属性名来获取值。<br></li>\n</ul>\n<p>通过NSString形式，编写JS脚本，通过以下两种方式注入网页</p>\n<p>方式一：在初始化<code>WKWebView</code>时，通过配置<code>WKWebViewConfiguration&gt;userContentController</code>注入JS脚本  。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//MARK:向网页中注入JS脚本例如，参数/函数等</span></span><br><span class=\"line\"><span class=\"built_in\">WKUserScript</span> *script = [[<span class=\"built_in\">WKUserScript</span> alloc] initWithSource:<span class=\"string\">@\"var number=0;\"</span></span><br><span class=\"line\">injectionTime:<span class=\"built_in\">WKUserScriptInjectionTimeAtDocumentStart</span></span><br><span class=\"line\">forMainFrameOnly:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"><span class=\"built_in\">WKUserContentController</span> *userCC = config.userContentController;</span><br><span class=\"line\">[userCC addUserScript:script];</span><br></pre></td></tr></table></figure></p>\n<p>方式二：使用WKWebView实例方法<code>evaluateJavaScript</code>动态注入JS脚本</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span>.wkWebView evaluateJavaScript:<span class=\"string\">@\"var number=0;\"</span> completionHandler:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n<h4 id=\"iOS原生API调用JS函数\"><a href=\"#iOS原生API调用JS函数\" class=\"headerlink\" title=\"iOS原生API调用JS函数\"></a>iOS原生API调用JS函数</h4><p>使用WKWebView实例方法<code>evaluateJavaScript</code>动态调用JS函数<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span>.wkWebView evaluateJavaScript:<span class=\"string\">@\"alertSendMsg('18870707070','下午好！')\"</span> completionHandler:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"控件","path":"api/categories/控件.json"}],"tags":[]},{"title":"vim编辑器键盘映射命令map","slug":"shell/vim编辑器键盘映射命令map","date":"2017-07-04T15:06:52.000Z","updated":"2017-08-17T15:02:27.000Z","comments":true,"path":"api/articles/shell/vim编辑器键盘映射命令map.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>使用<code>:map</code>命令，可以将键盘上的某个按键与Vim的命令绑定起来。<br>例如使用以下命令，可以通过F5键将单词用花括号括起来：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:map &lt;F5&gt; i&#123;e&lt;Esc&gt;a&#125;&lt;Esc&gt;</span><br></pre></td></tr></table></figure></p>\n<p>执行过程：<code>i{</code>将插入字符<code>{</code>，然后使用<code>Esc</code>退回到命令状态；接着用<code>e</code>移到单词结尾，<code>a}</code>增加字符<code>}</code>，最后退至命令状态。<br>在执行以上命令之后，光标定位在一个单词上（例如amount），按下F5键，这时字符就会变成{amount}的形式。</p>\n<h2 id=\"不同模式下的键盘映射\"><a href=\"#不同模式下的键盘映射\" class=\"headerlink\" title=\"不同模式下的键盘映射\"></a>不同模式下的键盘映射</h2><p>使用下表中不同形式的map命令，可以针对特定的模式设置键盘映射：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Command 命令</th>\n<th style=\"text-align:center\">Normal 常规模式</th>\n<th style=\"text-align:center\">Visual可视化模式</th>\n<th style=\"text-align:center\">Operator Pending运算符模式</th>\n<th style=\"text-align:center\">Insert Only插入模式</th>\n<th style=\"text-align:center\">Command Line 命令行模式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">:map</td>\n<td style=\"text-align:center\">y</td>\n<td style=\"text-align:center\">y</td>\n<td style=\"text-align:center\">y</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">:nmap</td>\n<td style=\"text-align:center\">y</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">:vmap</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">y</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">:omap</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">y</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">:map!</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">y</td>\n<td style=\"text-align:center\">y</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">:imap</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">y</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">:cmap</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">y</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"查看键盘映射\"><a href=\"#查看键盘映射\" class=\"headerlink\" title=\"查看键盘映射\"></a>查看键盘映射</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:map</span><br></pre></td></tr></table></figure>\n<h3 id=\"取消键盘映射\"><a href=\"#取消键盘映射\" class=\"headerlink\" title=\"取消键盘映射\"></a>取消键盘映射</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:unmap &lt;F10&gt; #参数</span><br></pre></td></tr></table></figure>\n<p>注意：必须为:unmap命令指定一个参数。如果未指定任何参数，那么系统将会报错，而不会取消所有的键盘映射。<br>针对不同模式下的键盘映射，需要使用与其相对应的unmap命令。例如：使用:iunmap命令，取消插入模式下的键盘映射；而取消常规模式下的键盘映射，则需要使用:nunmap命令。<br>如果想要取消所有映射，可以使用:mapclear命令。请注意，这个命令将会移除所有用户定义和系统默认的键盘映射。</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"http://blog.csdn.net/daofengdeba/article/details/7605124\" target=\"_blank\" rel=\"noopener\">VIM键盘映射 (Map)</a><br><a href=\"http://www.pythonclub.org/vim/map-basic\" target=\"_blank\" rel=\"noopener\">Vim按键映射</a></p>\n","raw":null,"categories":[{"name":"vim","path":"api/categories/vim.json"},{"name":"工具","path":"api/categories/工具.json"}],"tags":[]}]}