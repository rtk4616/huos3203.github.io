{"title":"Swift包管理器SPM","slug":"swift/Swift包管理器SPM","date":"2017-08-17T14:52:23.000Z","updated":"2018-04-23T16:07:12.000Z","comments":true,"path":"api/articles/swift/Swift包管理器SPM.json","excerpt":null,"covers":null,"content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h2 id=\"概念概述\"><a href=\"#概念概述\" class=\"headerlink\" title=\"概念概述\"></a>概念概述</h2><p><a href=\"https://swift.org/getting-started\" target=\"_blank\" rel=\"noopener\">getting-started</a><br><a href=\"https://swift.org/package-manager/#conceptual-overview\" target=\"_blank\" rel=\"noopener\">Package Manager</a><br><div id=\"badge-container-huos3203-PerfectTemplate-20294e56\" class=\"hexo-github\" style=\"width: =\"></div>\n<script src=\"/hexo-github/badge.js\"></script>\n<script type=\"text/javascript\">\n  loadStyle(\"/hexo-github/style.css\");\n  loadStyle(\"/hexo-github/octicons/octicons.css\");\n  new Badge(\"#badge-container-huos3203-PerfectTemplate-20294e56\", \"huos3203\", \"PerfectTemplate\", \"20294e56\", false);\n</script>\n</p>\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><p>在 Swift 中我们使用模块来管理代码，每个模块指定一个命名空间并强制指定模块外哪些部分的代码是可以被访问控制的。</p>\n<p>一个程序可以将它所有代码聚合在一个模块中，也可以将它作为依赖关系导入到其他模块。除了少量系统提供的模块，像 OS X 中的 Darwin 或者 Linux 中的 Glibc 等的大多数依赖需要代码被下载或者内置才能被使用。</p>\n<p>当你将编写的解决特定问题的代码独立成一个模块时，这段代码可以在其他情况下被重新利用。例如，一个模块提供了发起网络请求的功能，在一个照片分享的 app 或者 一个天气的 app 里它都是可以使用的。使用模块可以让你的代码建立在其他开发者的代码之上，而不是你自己去重复实现相同的功能。</p>\n<h3 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h3><p>一个包由 Swift 源文件和一个清单文件组成。这个清单文件称为 Package.swift，定义包名或者它的内容使用PackageDescription 模块。</p>\n<p>一个包有一个或者多个目标，每个目标指定一个产品并且可能声明一个或者多个依赖。</p>\n<h3 id=\"产品\"><a href=\"#产品\" class=\"headerlink\" title=\"产品\"></a>产品</h3><p>一个目标可能构建一个库或者一个可执行文件作为其产品。库是包含可以被其他 Swift 代码导入的模块。可执行文件是一段可以被操作系统运行的程序。</p>\n<h3 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h3><p>目标依赖是指包中代码必须添加的模块。依赖由包资源的绝对或者相对 URL 和一些可以被使用的包的版本要求所组成。包管理器的作用是通过自动为工程下载和编译所有依赖的过程中，减少协调的成本。这是一个递归的过程：依赖能有自己的依赖，其中每一个也可以具有依赖，形成了一个依赖相关图。包管理器下载和编译所需要满足整个依赖相关图的一切。</p>\n<h2 id=\"使用Swift编译系统\"><a href=\"#使用Swift编译系统\" class=\"headerlink\" title=\"使用Swift编译系统\"></a>使用Swift编译系统</h2><p>Swift 编译系统为编译库、可执行文件和在不同工程之间共享代码提供了基本的约定。</p>\n<h3 id=\"创建包结构\"><a href=\"#创建包结构\" class=\"headerlink\" title=\"创建包结构\"></a>创建包结构</h3><p>root<br>  |–Package.swift       # 依赖清单文件<br>  |–Sources/               # 源码目录<br>      |–main.swift         # 资源文件<br>创建一个新的 Swift 包，首先创建并进入到一个新的目录命名为 Hello：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir Hello</span><br><span class=\"line\">$ cd Hello</span><br></pre></td></tr></table></figure></p>\n<p>每个包在其根目录下都必须拥有一个命名为<code>Package.swift</code>清单文件。如果清单文件为空，那包管理器将会使用常规默认的方式来编译包。创建一个空的清单文件使用命令：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swift package init</span><br><span class=\"line\">swift build  <span class=\"comment\">#编译可执行文件</span></span><br><span class=\"line\">swift <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"多个源文件协作\"><a href=\"#多个源文件协作\" class=\"headerlink\" title=\"多个源文件协作\"></a>多个源文件协作</h3><p>下一步，让我们在新的资源文件里定义一个新的方法 <code>sayHello(_:)</code> 然后直接用 <code>print(_:)</code> 替换执行调用的内容。<br>在 <code>Sources/</code> 目录下创建一个新文件命名为 <code>Greeter.swift</code> 然后输入如下代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sayHello</span><span class=\"params\">(name: String)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Hello, \\(name)!\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>sayHello(_:)</code> 方法带一个单一的字符串参数，然后在前面打印一个 “Hello”，后面跟着函数参数单词 “World”。</p>\n<p>现在打开 <code>main.swift</code>， 然后替换原来的内容为下面代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"type\">Process</span>.arguments.<span class=\"built_in\">count</span> != <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Usage: hello NAME\"</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name = <span class=\"type\">Process</span>.arguments[<span class=\"number\">1</span>]</span><br><span class=\"line\">    sayHello(name)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>跟之前的硬编码不同，<code>main.swift</code> 现在从命令行参数中读取。替代之前直接调用 <code>print(_:)</code>， <code>main.swift</code> 现在调用 <code>sayHello(_:)</code> 方法。因为这个方法是 <code>Hello 模块</code>的一部分，所以不需要使用到 <code>import</code> 语句。</p>\n<p>运行 swift build 并尝试 Hello 的新版本：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ swift build</span><br><span class=\"line\">$ .build/debug/<span class=\"type\">Hello</span> 'whoami'</span><br></pre></td></tr></table></figure></p>\n<p>目前为止，你已经能够运用开源 Swift 来运行一些你想要的程序了。接下来我们就可以进入正题开始入手 SPM 。</p>\n","categories":[{"name":"swift","path":"api/categories/swift.json"},{"name":"包管理","path":"api/categories/包管理.json"}],"tags":[]}