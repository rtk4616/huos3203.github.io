{"total":157,"pageSize":10,"pageCount":16,"data":[{"title":"CFBundleDisplayName更改APP启动图标的名称","slug":"iOS/更改设备屏幕上显示的应用程序图标下方的名称","date":"2017-02-24T14:23:59.000Z","updated":"2017-05-26T18:13:13.000Z","comments":true,"path":"api/articles/iOS/更改设备屏幕上显示的应用程序图标下方的名称.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/qa1823_ExpandAppInProjectNavigator.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>修改APP启动图标上的名称，需配置<code>Info.plist</code>文件，增加<code>CFBundleDisplayName</code>属性键值对。<br>进入到如下界面：<br><!--长宽设置百分比大小无效果--><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/qa1823_ExpandAppInProjectNavigator.png?imageMogr2/2/w/800\"></p>\n<p>在<code>Info.plist</code>文件属性列表中搜索”Bundle display name”，如果存在就修改为新APP名称。<br>如果不存在，在任何一个属性条目下，点击”+”按钮，弹出的下拉列表中选择”Bundle display name”，再双击”Bundle display name”属性值列，输入新APP名称。<br><!--长宽设置百分比大小无效果--><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/qa1823_WatchKitAppInfoPane.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"agvtool自动增加版本号命令行工具\"><a href=\"#agvtool自动增加版本号命令行工具\" class=\"headerlink\" title=\"agvtool自动增加版本号命令行工具\"></a>agvtool自动增加版本号命令行工具</h2><p>版本号和编译号分别是代表了正式发布版本和内部版本， agvtool 是一个自动增加版本号的命令行工具。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/QA1827_AppStoreBuildNumber.png?imageMogr2/2/w/800\"><br>注意：版本号是给用户看的，用于标明当前的发行版本，并且被存储在 App 的 Info.plist 文件的 CFBundleShortVersionString (Bundle versions string, short) 中。编译号是内部使用的，用于标明未发行或者已内部发行的应用程序，并且它被存储在 Info.plist 文件的 CFBundleVersion (Bundle version) 中。</p>\n<p>注意：如果应用程序包含了多个目标（target）， agvtool 工具将会把所有目标都设置为同一个版本号和编译号。</p>\n<h3 id=\"设置-Current-Project-Version-为选定的值\"><a href=\"#设置-Current-Project-Version-为选定的值\" class=\"headerlink\" title=\"设置 Current Project Version 为选定的值\"></a>设置 Current Project Version 为选定的值</h3><p>Xcode 工程文件 project.pbxproj 包含了 CURRENT_PROJECT_VERSION (Current Project Version) 编译设定，这个编译设定指定了当前工程的版本。<br>agvtool 会搜索此编译选项。如果这个值存在就运行，否则不运行，这个值用来更新编译号。</p>\n<h3 id=\"设置-Versioning-System-为-Apple-Generic\"><a href=\"#设置-Versioning-System-为-Apple-Generic\" class=\"headerlink\" title=\"设置 Versioning System 为 Apple Generic\"></a>设置 Versioning System 为 Apple Generic</h3><p>默认情况下苹果不使用任何版本系统，设置为 Apple Generic 确保 Xcode 包含全部的 agvtool 生成的版本信息。</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/QA1827_Versioning.png?imageMogr2/2/w/800\">\n<p>注意： Current Project Version 的值必须是整数或者浮点数，新工程最好设置为1。</p>\n<h3 id=\"设置版本和编译号\"><a href=\"#设置版本和编译号\" class=\"headerlink\" title=\"设置版本和编译号\"></a>设置版本和编译号</h3><p>agvtool 从 Info.plist 文件搜索版本和编译号。如果存在就更新，不存在就不执行。<br>确保 CFBundleVersion (Bundle version) 和 CFBundleShortVersionString (Bundle versions string, short) 存在。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/QA1827_InfoPaneInXcode.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"版本号命令\"><a href=\"#版本号命令\" class=\"headerlink\" title=\"版本号命令\"></a>版本号命令</h3><p>退出 Xcode，在终端下进入到包含 .xcodeproj 工程文件的目录， .xcodeproj 文件包含了 project.pbxproj 文件。</p>\n<ol>\n<li><p>查看版本号：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">agvtool what-marketing-version</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新版本号</p>\n</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">agvtool new-marketing-version &lt;指定的版本号&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"编译号命令\"><a href=\"#编译号命令\" class=\"headerlink\" title=\"编译号命令\"></a>编译号命令</h3><ol>\n<li><p>将编译号设置为指定版本</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">agvtool new-version -all &lt;指定的版本号&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新编译号</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">agvtool next-version -all</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看当前编译号</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">agvtool what-version</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"配置","path":"api/categories/配置.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"经历","path":"api/tags/经历.json"},{"name":"配置","path":"api/tags/配置.json"}]},{"title":"高期望实现异步单元测试","slug":"测试/高期望实现异步单元测试","date":"2017-02-20T23:09:30.000Z","updated":"2017-05-26T11:03:05.000Z","comments":true,"path":"api/articles/测试/高期望实现异步单元测试.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"异步单元测试\"><a href=\"#异步单元测试\" class=\"headerlink\" title=\"异步单元测试\"></a>异步单元测试</h2><p>在Xcode 6之前的版本里面并没有内置<code>XCTest</code>，只能是在主线程的<code>RunLoop</code>里面使用一个<code>while循环</code>,然后一直等待响应或者直到<code>timeout</code>.</p>\n<p>在Xcode 6里，苹果以<code>XCTestExpection类</code>的方式向<code>XCTest框架</code>里添加了<code>测试期望</code>(test expection)。<br>XCTest框架中相关的方法：设置期望，实现期望，通知期望，谓词计算期望等，以及期望的传递。</p>\n<h3 id=\"常规实现方式\"><a href=\"#常规实现方式\" class=\"headerlink\" title=\"常规实现方式\"></a>常规实现方式</h3><p>在主线程里，使用<code>while循环</code>每隔10毫秒会执行一次，直到有响应或者5秒之后超出响应时间限制才会跳出：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testAsyncTheOldWay</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timeoutDate = <span class=\"type\">Date</span>.<span class=\"keyword\">init</span>(timeIntervalSinceNow: <span class=\"number\">5.0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> responseHasArrived = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"type\">Alamofire</span>.request(<span class=\"string\">\"https://www.baidu.com\"</span>).responseData&#123;response <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"获取到的数据长度：\\(String(data: response.data!, </span></span><br><span class=\"line\"><span class=\"string\">                                   encoding:String.Encoding.utf8)!)\"</span>)</span><br><span class=\"line\">        responseHasArrived = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"type\">XCTAssert</span>((response.data?.<span class=\"built_in\">count</span>)! &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (responseHasArrived == <span class=\"literal\">false</span> </span><br><span class=\"line\">            &amp;&amp; (timeoutDate.timeIntervalSinceNow &gt; <span class=\"number\">0</span>)) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">CFRunLoopRunInMode</span>(<span class=\"type\">CFRunLoopMode</span>.defaultMode, <span class=\"number\">0.01</span>, <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (responseHasArrived == <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">XCTFail</span>(<span class=\"string\">\"Test timed out\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"XCTest相关API\"><a href=\"#XCTest相关API\" class=\"headerlink\" title=\"XCTest相关API\"></a>XCTest相关API</h2><p>在Xcode 6里，苹果以<code>XCTestExpection类</code>的方式向<code>XCTest框架</code>里添加了<code>测试期望</code>(test expection)。</p>\n<h3 id=\"XCTestExpection-高期望-High-Expectations-的实现和使用\"><a href=\"#XCTestExpection-高期望-High-Expectations-的实现和使用\" class=\"headerlink\" title=\"XCTestExpection:高期望(High Expectations)的实现和使用\"></a>XCTestExpection:高期望(High Expectations)的实现和使用</h3><p>设置期望，实现期望，通知期望，谓词计算期望等，以及期望的传递。</p>\n<h4 id=\"expectation-description-为XCTest测试单元设置期望\"><a href=\"#expectation-description-为XCTest测试单元设置期望\" class=\"headerlink\" title=\"expectation(description:):为XCTest测试单元设置期望\"></a><code>expectation(description:)</code>:为XCTest测试单元设置期望</h4><p>为XCTest单元测试，设置一个测试期望以及错误信息描述，并在某一时刻<code>fulfill</code>实现该期望对象<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//expectation(description: String) -&gt; XCTestExpectation</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> expection = expectation(description: <span class=\"string\">\"失败时显示原因\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"fulfill-调用它表示测试达到期望值\"><a href=\"#fulfill-调用它表示测试达到期望值\" class=\"headerlink\" title=\"fulfill():调用它表示测试达到期望值\"></a><code>fulfill()</code>:调用它表示测试达到期望值</h5><p>一般在单元测试通过时调用，告知测试已达期望，这一方法替代了<code>responseHasArrived</code>作为Flag的方式<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//- (void)fulfill;</span></span><br><span class=\"line\">expection.fulfill()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"waitForExpectations-timeout-handler-在方法底部设置测试期望的时效\"><a href=\"#waitForExpectations-timeout-handler-在方法底部设置测试期望的时效\" class=\"headerlink\" title=\"waitForExpectations(timeout:handler:):在方法底部设置测试期望的时效\"></a><code>waitForExpectations(timeout:handler:)</code>:在方法底部设置测试期望的时效</h4><p>在方法底部指定一个超时，如果测试条件不适合时间范围便会结束执行<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// open func waitForExpectations(timeout: TimeInterval, handler: XCTest.XCWaitCompletionHandler? = nil)</span></span><br><span class=\"line\">waitForExpectations(timeout: <span class=\"number\">5</span>) &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"错误信息:\\(error?.localizedDescription)\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如果完成处理的代码在指定时限里执行并调用了<code>fulfill()</code>方法，那么就说明所有的测试期望在此期间都已经被实现。否则就测试就被打断不再执行</p>\n<h4 id=\"expectation-forNotification-object-handler-通知期望\"><a href=\"#expectation-forNotification-object-handler-通知期望\" class=\"headerlink\" title=\"expectation(forNotification:object:handler:):通知期望\"></a>expectation(forNotification:object:handler:):通知期望</h4><p>该方法监听一个通知,如果在规定时间内正确收到通知则测试通过<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//expectation(forNotification notificationName: String, object objectToObserve: Any?, handler: XCTest.XCNotificationExpectationHandler? = nil) -&gt; XCTestExpectation</span></span><br><span class=\"line\"><span class=\"comment\">//设置一个测试通知期望</span></span><br><span class=\"line\">expectation(forNotification: <span class=\"string\">\"BLDownloadImageNotification\"</span>, </span><br><span class=\"line\">                     object: <span class=\"literal\">nil</span>) </span><br><span class=\"line\">&#123;(notification) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> userInfo = notification.userInfo <span class=\"keyword\">as</span>! [<span class=\"type\">String</span>:<span class=\"type\">String</span>]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name = userInfo[<span class=\"string\">\"name\"</span>]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"name:\\(name)\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">来定义一个通知并发送通知，来测试：</span><br><span class=\"line\"><span class=\"keyword\">let</span> notif =  <span class=\"type\">Notification</span>.<span class=\"type\">Name</span>(rawValue: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\"><span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.post(name: notif, object: <span class=\"keyword\">self</span>, userInfo: [<span class=\"string\">\"name\"</span>:<span class=\"string\">\"huosan\"</span>,<span class=\"string\">\"sex\"</span>:<span class=\"string\">\"man\"</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置延迟多少秒后，如果没有满足测试条件就报错</span></span><br><span class=\"line\">waitForExpectations(timeout: <span class=\"number\">3</span>, handler: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"使用expectation-description-实现\"><a href=\"#使用expectation-description-实现\" class=\"headerlink\" title=\"使用expectation(description:)实现\"></a>使用<code>expectation(description:)</code>实现</h5><p>帮助理解 <code>expectation(forNotification:object:handler:)</code> 方法和 <code>expectation(description:)</code> 的区别<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testAsynForNotificationWithExpectation</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> expectation = <span class=\"keyword\">self</span>.expectation(description: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> notif = <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>(rawValue: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sub = <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(forName: notif, object: <span class=\"literal\">nil</span>, queue: <span class=\"literal\">nil</span>) &#123; (notification) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        expectation.fulfill()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//发送一个通知</span></span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.post(name: notif, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//waitForExpectations</span></span><br><span class=\"line\">    waitForExpectations(timeout: <span class=\"number\">1</span>, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//移除通知</span></span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.removeObserver(sub)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"expectation-for-evaluatedWith-handler-谓词计算测试法\"><a href=\"#expectation-for-evaluatedWith-handler-谓词计算测试法\" class=\"headerlink\" title=\"expectation(for:evaluatedWith:handler:):谓词计算测试法\"></a>expectation(for:evaluatedWith:handler:):谓词计算测试法</h4><p>利用谓词计算，判断<code>button</code>的<code>backgroundImageForState</code>方法，是否正确的获得了<code>backgroundImage</code>，如果<code>20秒</code>内正确获得则通过测试，否则失败<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//open func expectation(for predicate: NSPredicate, evaluatedWith object: Any, handler: XCTest.XCPredicateExpectationHandler? = nil) -&gt; XCTestExpectation</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testThatBackgroundImageChanges</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> viewController = <span class=\"type\">OnclickLikeViewController</span>()</span><br><span class=\"line\">    <span class=\"comment\">//viewController.loadView()  //不执行viewDidload方法</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"number\">_</span> = viewController.view</span><br><span class=\"line\">    <span class=\"keyword\">let</span> button = viewController.button</span><br><span class=\"line\">    <span class=\"keyword\">let</span> img = button.backgroundImage(<span class=\"keyword\">for</span>: .normal)</span><br><span class=\"line\">    <span class=\"type\">XCTAssertNil</span>(img,<span class=\"string\">\"此时img不为nil,中止执行\"</span>)  <span class=\"comment\">//当img不是nil时，执行断言</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> predicate = <span class=\"type\">NSPredicate</span>.<span class=\"keyword\">init</span> &#123; (anyobject, bindings) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> button = anyobject <span class=\"keyword\">as</span>! <span class=\"type\">UIButton</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> button.backgroundImage(<span class=\"keyword\">for</span>: <span class=\"type\">UIControlState</span>()) != <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    expectation(<span class=\"keyword\">for</span>: predicate, evaluatedWith: button, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    waitForExpectations(timeout: <span class=\"number\">20</span>, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"使用expectation-description-实现-1\"><a href=\"#使用expectation-description-实现-1\" class=\"headerlink\" title=\"使用expectation(description:)实现\"></a>使用<code>expectation(description:)</code>实现</h5><p>帮助理解 <code>expectation(for:evaluatedWith:handler:)</code> 方法和 <code>expectation(description:)</code> 的区别<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testThatBackgroundImageChanges</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//设置期望</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> expectation = <span class=\"keyword\">self</span>.expectation(description: <span class=\"string\">\"backgroundImageForState\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> viewController = <span class=\"type\">OnclickLikeViewController</span>()</span><br><span class=\"line\">    <span class=\"comment\">//viewController.loadView()  //不执行viewDidload方法</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"number\">_</span> = viewController.view</span><br><span class=\"line\">    <span class=\"keyword\">let</span> button = viewController.button</span><br><span class=\"line\">    <span class=\"keyword\">let</span> img = button.backgroundImage(<span class=\"keyword\">for</span>: .normal)</span><br><span class=\"line\">    <span class=\"type\">XCTAssertNil</span>(img,<span class=\"string\">\"此时img不为nil,中止执行\"</span>)  <span class=\"comment\">//当img不是nil时，执行断言</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> predicate = <span class=\"type\">NSPredicate</span>.<span class=\"keyword\">init</span> &#123; (anyobject, bindings) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> button = anyobject <span class=\"keyword\">as</span>! <span class=\"type\">UIButton</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> button.backgroundImage(<span class=\"keyword\">for</span>: <span class=\"type\">UIControlState</span>()) != <span class=\"literal\">nil</span></span><br><span class=\"line\">        <span class=\"comment\">//实现测试期望</span></span><br><span class=\"line\">        expectation.fulfill()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//等待期望实现</span></span><br><span class=\"line\">    waitForExpectations(timeout: <span class=\"number\">20</span>, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传递expectation在目的方法中再fulfill-实现期望\"><a href=\"#传递expectation在目的方法中再fulfill-实现期望\" class=\"headerlink\" title=\"传递expectation在目的方法中再fulfill()实现期望\"></a>传递expectation在目的方法中再fulfill()实现期望</h3><p>例如将期望封装在字典中，通过通知来传递给异步下载的方法中调用该期望的<code>fulfill()</code>方法，实现单元测试的期望<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*/</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testAsynForNotificationWithExpectation2</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> expectation = <span class=\"keyword\">self</span>.expectation(description: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> notif = <span class=\"type\">Notification</span>.<span class=\"type\">Name</span>(rawValue: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(<span class=\"keyword\">self</span>, selector: #selector(<span class=\"type\">AsyncTheOldWayTest</span>.downLoadImage(<span class=\"number\">_</span>:)), name: notif, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//将期望封装在字典中传递</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> userInf = [<span class=\"string\">\"name\"</span>:<span class=\"string\">\"huosan\"</span>,<span class=\"string\">\"sex\"</span>:<span class=\"string\">\"man\"</span>,<span class=\"string\">\"expectation\"</span>:expectation]</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.post(name: notif, object: <span class=\"keyword\">self</span>, userInfo: userInf)</span><br><span class=\"line\">        <span class=\"comment\">//等待期望实现</span></span><br><span class=\"line\">        waitForExpectations(timeout: <span class=\"number\">1</span>, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.removeObserver(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">downLoadImage</span><span class=\"params\">(<span class=\"number\">_</span> notification:Notification)</span></span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> userInfo = notification.userInfo <span class=\"keyword\">as</span>! [<span class=\"type\">String</span>:<span class=\"type\">AnyObject</span>]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> name = userInfo[<span class=\"string\">\"name\"</span>]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> sex = userInfo[<span class=\"string\">\"sex\"</span>]</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"name:\\(name), sex = \\(sex)\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> expectation = userInfo[<span class=\"string\">\"expectation\"</span>] <span class=\"keyword\">as</span>! <span class=\"type\">XCTestExpectation</span></span><br><span class=\"line\">        expectation.fulfill()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"测试","path":"api/categories/测试.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"单元测试","path":"api/tags/单元测试.json"}]},{"title":"UI自动测试开发相关API","slug":"测试/UI自动测试学习","date":"2017-02-20T17:16:49.000Z","updated":"2017-05-26T11:03:05.000Z","comments":true,"path":"api/articles/测试/UI自动测试学习.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/XCUIElementAttributes.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"UI-Testing-和-Accessibility\"><a href=\"#UI-Testing-和-Accessibility\" class=\"headerlink\" title=\"UI Testing 和 Accessibility\"></a>UI Testing 和 Accessibility</h2><p>UI Accessibility 早在 iOS 3.0 就被引入了，用来辅助身体不便的人士使用 app。VoiceOver 是 Apple 的屏幕阅读技术，而 UI Accessibility 的基本原则就是对屏幕上的 UI 元素进行分类和标记。两者配合，通过阅读或者聆听这些元素，用户就可以在不接触屏幕的情况下通过声音来使用 app。</p>\n<p>Accessibility 的核心思想是对 UI 元素进行分类和标记 – 将屏幕上的 UI 分类为像是按钮，文本框，cell 或者是静态文本 (也就是 label) 这样的类型，然后使用 identifier 来区分不同的 UI 元素。用户可以通过语音控制 app 的按钮点击，或是询问某个 label 的内容等等，十分方便。iOS SDK 中的控件都实现了默认的 Accessibility 支持，而我们如果使用自定义的控件的话，则需要自行使用 Accessibility 的 API 来进行添加。</p>\n<h2 id=\"UI-Testing-API\"><a href=\"#UI-Testing-API\" class=\"headerlink\" title=\"UI Testing API\"></a>UI Testing API</h2><h3 id=\"XCUIApplication-获取APP实例\"><a href=\"#XCUIApplication-获取APP实例\" class=\"headerlink\" title=\"XCUIApplication()获取APP实例\"></a>XCUIApplication()获取APP实例</h3><p><code>XCUIApplication()</code>继承<code>XCUIElement</code>，这个类掌管应用程序的生命周期，里面包含两个主要方法<br><code>launch():</code>启动程序<br><code>terminate():</code>终止程序</p>\n<h3 id=\"获取XCUIElementQuery对象的四种方式\"><a href=\"#获取XCUIElementQuery对象的四种方式\" class=\"headerlink\" title=\"获取XCUIElementQuery对象的四种方式\"></a>获取<code>XCUIElementQuery</code>对象的四种方式</h3><h4 id=\"第一种简写形式：buttons-gt-XCUIElementQuery\"><a href=\"#第一种简写形式：buttons-gt-XCUIElementQuery\" class=\"headerlink\" title=\"第一种简写形式：buttons-&gt;XCUIElementQuery\"></a>第一种简写形式：<code>buttons-&gt;XCUIElementQuery</code></h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttons:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().buttons</span><br><span class=\"line\"><span class=\"keyword\">let</span> textFields:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().textFields</span><br></pre></td></tr></table></figure>\n<h4 id=\"三种通过XCUIElementType的枚举值\"><a href=\"#三种通过XCUIElementType的枚举值\" class=\"headerlink\" title=\"三种通过XCUIElementType的枚举值\"></a>三种通过<code>XCUIElementType</code>的枚举值</h4><p>通过<code>XCUIElementType</code>的枚举值来获取<code>XCUIElementQuery</code>对象，其中第二种是简写方式。<br><code>XCUIElementType</code>枚举声明如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">XCUIElementType</span> : <span class=\"title\">UInt</span> </span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">case</span> button</span><br><span class=\"line\">    <span class=\"keyword\">case</span> radioButton</span><br><span class=\"line\">    <span class=\"keyword\">case</span> textField</span><br><span class=\"line\">    <span class=\"keyword\">case</span> comboBox</span><br><span class=\"line\">    <span class=\"keyword\">case</span> menuButton</span><br><span class=\"line\">    <span class=\"keyword\">case</span> toolbarButton</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"第一种获取所有的元素：descendantsMatchingType-gt-XCUIElementQuery\"><a href=\"#第一种获取所有的元素：descendantsMatchingType-gt-XCUIElementQuery\" class=\"headerlink\" title=\"第一种获取所有的元素：descendantsMatchingType-&gt;XCUIElementQuery\"></a>第一种获取所有的元素：<code>descendantsMatchingType-&gt;XCUIElementQuery</code></h5><p>取某种类型的元素以及它的子类集合，能获取到系统级控件如<code>UIButton</code>，和用户自定义的UI控件<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttons:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().descendantsMatchingType(.<span class=\"type\">Button</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> textFields:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().descendantsMatchingType(.textField)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"第三种仅获取当前层级子元素：childrenMatchingType\"><a href=\"#第三种仅获取当前层级子元素：childrenMatchingType\" class=\"headerlink\" title=\"第三种仅获取当前层级子元素：childrenMatchingType\"></a>第三种仅获取当前层级子元素：<code>childrenMatchingType</code></h5><p>取某种类型的元素集合，不包含它的子类，即仅获取系统级控件如<code>UIButton</code>，不获取用户自定义的UI控件<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttons:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().childrenMatchingType(.<span class=\"type\">Button</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> textFields:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().childrenMatchingType(.textField)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"第四种所有包含的元素：containingType\"><a href=\"#第四种所有包含的元素：containingType\" class=\"headerlink\" title=\"第四种所有包含的元素：containingType\"></a>第四种所有包含的元素：<code>containingType</code></h5><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttons:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().containingType(.<span class=\"type\">Button</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> textFields:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().containingType(.textField)</span><br></pre></td></tr></table></figure>\n<h3 id=\"XCUIElement表示系统的各种UI控件\"><a href=\"#XCUIElement表示系统的各种UI控件\" class=\"headerlink\" title=\"XCUIElement表示系统的各种UI控件\"></a>XCUIElement表示系统的各种UI控件</h3><p><code>XCUIElement</code>UI控件在测试框架中的代理，继承<code>NSObject</code>，实现<code>XCUIElementAttributes</code>协议, <code>XCUIElementTypeQueryProvider</code>协议，可以表示系统的各种UI控件。</p>\n<ol>\n<li>XCUIElementAttributes协议：里面包含了UIAccessibility中的部分属性<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/XCUIElementAttributes.png?imageMogr2/2/w/800\">\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/UIAccessibility.jpg?imageMogr2/2/w/800\"></li>\n<li>XCUIElementTypeQueryProvider协议：包含了系统中大部分UI控件的类型，可通过读属性的方式取得某种类型的UI集合<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/XCUIElementTypeQueryProvider.png?imageMogr2/2/w/800\">\n</li>\n</ol>\n<h4 id=\"访问UI控件\"><a href=\"#访问UI控件\" class=\"headerlink\" title=\"访问UI控件\"></a>访问UI控件</h4><ol>\n<li><code>exist:</code>判断当前的UI元素是否存在，如果对一个不存在的元素进行操作，会导致测试组件抛出异常并中断测试.</li>\n<li><code>element()</code>／<code>下标方法</code>：<code>XCUIElementQuery</code>实例的方法获取UI控件，不能直接通过<code>XCUIElement</code> 来访问 app 中的元素，只能通过 <code>Accessibility</code> 中的像是 <code>identifier</code> 或者 <code>frame</code> 这样的属性来获取 UI 的信息。<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> userNameTextField:<span class=\"type\">XCUIElement</span> = app.textFields.element(boundBy: <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> userNameTextField:<span class=\"type\">XCUIElement</span> = app.textFields[<span class=\"string\">\"username\"</span>]</span><br></pre></td></tr></table></figure>\n对于 <code>XCUIElementQuery</code>，<code>Query</code>的执行是有延迟的，它和最后我们得到的 <code>XCUIElement</code> 并不是一一对应的。和 <code>NSURL</code> 与请求到的内容的关系类似，随着时间的变化，同一个 <code>URL</code> 有可能请求到不同的内容。<br>在拿到<code>Query</code>实例后，只有在通过<code>下标</code>或<code>访问方法</code>访问时，才会真正寻找对应的 <code>UI 控件</code>。这就是说，随着我们的 UI 的变化，同样的 <code>query</code> 也可能获取到不用的<code>UI控件</code>。为了获取UI元素准确：我们可以通过在 <code>Interface Builder</code> 或者<code>代码</code>中，对UI控件的 <code>identifier</code>属性进行设置，这样就可以使用下标的方式进行访问了。</li>\n</ol>\n<h4 id=\"设置UI控件触发事件和属性值\"><a href=\"#设置UI控件触发事件和属性值\" class=\"headerlink\" title=\"设置UI控件触发事件和属性值\"></a>设置UI控件<code>触发事件</code>和<code>属性值</code></h4><p>使用<code>typeText(text:String)</code>,<code>tap()</code>,<code>doubleTap()</code>等方法。<br>以获取userNameTextField控件为例：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> userNameTextField:<span class=\"type\">XCUIElement</span> = app.textFields.element(boundBy: <span class=\"number\">0</span>)</span><br><span class=\"line\">userNameTextField.tap()</span><br><span class=\"line\">userNameTextField.typeText(<span class=\"string\">\"文本内容\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"XCUIElementAttributes协议\"><a href=\"#XCUIElementAttributes协议\" class=\"headerlink\" title=\"XCUIElementAttributes协议\"></a>XCUIElementAttributes协议</h4><p>UI元素中包含的各个属性，<code>identifier</code>，<code>frame</code>,<code>title</code>,<code>label</code>等…</p>\n<ol>\n<li>使用: 可使用这些属性来获取UI元素对象。<figure class=\"highlight swift\"><figcaption><span>title获取</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> username = <span class=\"string\">\"hsg\"</span></span><br><span class=\"line\">userNameTextField.typeText(username)</span><br><span class=\"line\">app.textFields[username].tap()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><figcaption><span>identifier获取</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> identifier = <span class=\"string\">\"hsg\"</span></span><br><span class=\"line\">userNameTextField.typeText(username)</span><br><span class=\"line\">app.textFields[username].tap()</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"测试","path":"api/categories/测试.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"单元测试","path":"api/tags/单元测试.json"}]},{"title":"自定义展示型控制器","slug":"自定义展示型控制器","date":"2017-02-17T12:26:11.000Z","updated":"2018-04-24T11:49:45.000Z","comments":true,"path":"api/articles/自定义展示型控制器.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/semi-transparent.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><div id=\"badge-container-huos3203-PresentationsDemo-2cce4c908\" class=\"hexo-github\" style=\"width: =\"></div>\n<script src=\"/hexo-github/badge.js\"></script>\n<script type=\"text/javascript\">\n  loadStyle(\"/hexo-github/style.css\");\n  loadStyle(\"/hexo-github/octicons/octicons.css\");\n  new Badge(\"#badge-container-huos3203-PresentationsDemo-2cce4c908\", \"huos3203\", \"PresentationsDemo\", \"2cce4c908\", false);\n</script>\n\n<h2 id=\"触发转场的方式\"><a href=\"#触发转场的方式\" class=\"headerlink\" title=\"触发转场的方式\"></a>触发转场的方式</h2><h3 id=\"官方支持的自定义转场\"><a href=\"#官方支持的自定义转场\" class=\"headerlink\" title=\"官方支持的自定义转场\"></a>官方支持的自定义转场</h3><ul>\n<li>在 <code>UINavigationController</code> 中 <code>push</code> 和 <code>pop</code>;</li>\n<li>在 <code>UITabBarController</code> 中切换 <code>Tab</code>;</li>\n<li>Modal 转场：<code>presentation</code> 和 <code>dismissal</code>，俗称视图控制器的模态显示和消失，仅限于<code>modalPresentationStyle</code>属性为 <code>UIModalPresentationFullScreen</code> 或 <code>UIModalPresentationCustom</code> 这两种模式;<br><code>UICollectionViewController</code> 的布局转场：仅限于 <code>UICollectionViewController</code> 与 <code>UINavigationController</code> 结合的转场方式，与上面三种都有点不同，不过实现很简单，可跳转至该链接查看。<br>官方的支持包含了 iOS 中的大部分转场方式，还有一种自定义容器中的转场并没有得到系统的直接支持，不过借助协议这种灵活的方式，我们依然能够实现对自定义容器控制器转场的定制，在压轴环节我们将实现这一点。<h3 id=\"相关触发转场的动作\"><a href=\"#相关触发转场的动作\" class=\"headerlink\" title=\"相关触发转场的动作\"></a>相关触发转场的动作</h3><h4 id=\"UINavigationController\"><a href=\"#UINavigationController\" class=\"headerlink\" title=\"UINavigationController\"></a>UINavigationController</h4><code>UINavigationController</code> 中所有修改其<code>viewControllers</code>栈中 <code>VC</code> 的方法都可以自定义转场动画：<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//我们使用的最广泛的 push 和 pop 方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pushViewController</span><span class=\"params\">(<span class=\"number\">_</span> viewController: UIViewController, animated animated: Bool)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">popViewControllerAnimated</span><span class=\"params\">(<span class=\"number\">_</span> animated: Bool)</span></span> -&gt; <span class=\"type\">UIViewController</span>?</span><br><span class=\"line\"><span class=\"comment\">//不怎么常用的 pop 方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">popToRootViewControllerAnimated</span><span class=\"params\">(<span class=\"number\">_</span> animated: Bool)</span></span> -&gt; [<span class=\"type\">UIViewController</span>]?</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">popToRootViewControllerAnimated</span><span class=\"params\">(<span class=\"number\">_</span> animated: Bool)</span></span> -&gt; [<span class=\"type\">UIViewController</span>]?</span><br><span class=\"line\"><span class=\"comment\">//这个方法有有点特别，是对 VC 栈的整体更新，开启动画后的执行比较复杂，具体参考文档说明。不建议在这种情况下开启转场动画。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setViewControllers</span><span class=\"params\">(<span class=\"number\">_</span> viewControllers: [UIViewController], animated animated: Bool)</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"UITabBarController\"><a href=\"#UITabBarController\" class=\"headerlink\" title=\"UITabBarController\"></a>UITabBarController</h4><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注意传递的参数必须是其下的子 VC</span></span><br><span class=\"line\"><span class=\"keyword\">unowned</span>(unsafe) <span class=\"keyword\">var</span> selectedViewController: <span class=\"type\">UIViewController</span>?</span><br><span class=\"line\"><span class=\"keyword\">var</span> selectedIndex: <span class=\"type\">Int</span></span><br><span class=\"line\"><span class=\"comment\">//和上面类似的整体更新</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setViewControllers</span><span class=\"params\">(<span class=\"number\">_</span> viewControllers: [UIViewController]?, animated animated: Bool)</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Modal-转场：\"><a href=\"#Modal-转场：\" class=\"headerlink\" title=\"Modal 转场：\"></a>Modal 转场：</h4><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Presentation 转场</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentViewController</span><span class=\"params\">(<span class=\"number\">_</span> viewControllerToPresent: UIViewController, animated flag: Bool, completion completion: <span class=\"params\">(<span class=\"params\">()</span></span></span></span> -&gt; <span class=\"type\">Void</span>)?)</span><br><span class=\"line\"><span class=\"comment\">// Dismissal 转场</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dismissViewControllerAnimated</span><span class=\"params\">(<span class=\"number\">_</span> flag: Bool, completion completion: <span class=\"params\">(<span class=\"params\">()</span></span></span></span> -&gt; <span class=\"type\">Void</span>)?)</span><br></pre></td></tr></table></figure>\n<h4 id=\"Segue\"><a href=\"#Segue\" class=\"headerlink\" title=\"Segue\"></a>Segue</h4>在 <code>storyboard</code> 里设置 <code>segue</code>有两种方式：<code>Button to VC</code>，这种在点击 <code>Button</code> 的时候触发转场；<code>VC to VC</code>，这种需要在代码中调用<code>performSegueWithIdentifier:sender:</code>。<code>prepareForSegue:sender:</code>方法是在转场发生前修改转场参数的最后机会。这点对于 <code>Modal</code> 转场比较重要，因为在 <code>storyboard</code>里 <code>Modal</code> 转场的 <code>Segue</code> 类型不支持选择 <code>Custom</code> 模式，使用 <code>segue</code> 方式触发时必须在<code>prepareForSegue:sender:</code>里修改模式。</li>\n</ul>\n<h4 id=\"iOS-8-的变化\"><a href=\"#iOS-8-的变化\" class=\"headerlink\" title=\"iOS 8 的变化\"></a>iOS 8 的变化</h4><p>iOS 8 引入了适应性布局，由此添加了两种新的方式来显示一个视图控制器：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">showViewController</span><span class=\"params\">(<span class=\"number\">_</span> vc: UIViewController, sender sender: AnyObject?)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">showDetailViewController</span><span class=\"params\">(<span class=\"number\">_</span> vc: UIViewController, sender sender: AnyObject?)</span></span></span><br></pre></td></tr></table></figure><br>这两个方法咋看上去是给 <code>UISplitViewController</code> 用的，在 <code>storyboard</code> 里 <code>segue</code> 的候选模式里，直接给出了<code>Show(e.g. Push)</code>和<code>Show Detail(e.g. Replace)</code>这样的提示，以至于我之前一直对这两个 segue 有误解。实际上这两个方法智能判断当前的显示环境来决定如何显示，iOS 8 想统一显示视图控制器的方式，不过引入这两个方法增加了使用的复杂性，来看看这两个方法的使用规则。<br>这两个方法在 <code>UISplitViewController</code> 上的确是按名字显示的那样去工作的，而在本文关注的控制器上是这样工作的：<br>|  |ViewController|NavigationController|TabBarController|<br>|:——-|:——-|:——–|:——–|<br>|showViewController:sender: |Presentation| Push | Presentation(by self) |<br>|showDetailViewController:sender: |Presentation| Presentation(by self) | Presentation(by self)|<br><code>UINavigationController</code> 重写了<code>showViewController:sender:</code>而执行 <code>push</code> 操作，上面的<code>by self</code>意思是用容器 <code>VC</code> 本身而非其下子 <code>VC</code> 去执行 <code>presentation</code>。这两个方法的行为可以通过重写来改变。<br>当非容器类 VC 内嵌在这两种容器 VC 里时，会通过最近的容器 VC 来执行：<br>||VC in NavigationController|VC in TabBarController|<br>|:——-|:——-|:——–|<br>|showViewController:sender: |Push(by NavigationController)| Presentation(by TabBarController) |<br>|showDetailViewController:sender: |Presentation(by NavigationController)| Presentation(by TabBarController) |</p>\n<h3 id=\"转场五大工具\"><a href=\"#转场五大工具\" class=\"headerlink\" title=\"转场五大工具\"></a>转场五大工具</h3><p>iOS 7 以协议的方式开放了自定义转场的 API，协议的好处是不再拘泥于具体的某个类，只要是遵守该协议的对象都能参与转场，非常灵活。转场协议由5种协议组成，在实际中只需要我们提供其中的两个或三个便能实现绝大部分的转场动画：</p>\n<h4 id=\"转场代理-Transition-Delegate-：\"><a href=\"#转场代理-Transition-Delegate-：\" class=\"headerlink\" title=\"转场代理(Transition Delegate)：\"></a>转场代理(Transition Delegate)：</h4><p>有如下三种容器转场代理，对应上面三种类型的转场：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"type\">UINavigationControllerDelegate</span>&gt; <span class=\"comment\">//UINavigationController 的 delegate 属性遵守该协议。</span></span><br><span class=\"line\">&lt;<span class=\"type\">UITabBarControllerDelegate</span>&gt; <span class=\"comment\">//UITabBarController 的 delegate 属性遵守该协议。</span></span><br><span class=\"line\">&lt;<span class=\"type\">UIViewControllerTransitioningDelegate</span>&gt; <span class=\"comment\">//UIViewController 的 transitioningDelegate 属性遵守该协议。</span></span><br></pre></td></tr></table></figure><br>这里除了<uiviewcontrollertransitioningdelegate>是 iOS 7 新增的协议，其他两种在 iOS 2 里就存在了，在 iOS 7 时扩充了这两种协议来支持自定义转场。</uiviewcontrollertransitioningdelegate></p>\n<h4 id=\"动画控制器-Animation-Controller-：\"><a href=\"#动画控制器-Animation-Controller-：\" class=\"headerlink\" title=\"动画控制器(Animation Controller)：\"></a>动画控制器(Animation Controller)：</h4><p>最重要的部分，负责添加视图以及执行动画；遵守<uiviewcontrolleranimatedtransitioning>协议；由我们实现。</uiviewcontrolleranimatedtransitioning></p>\n<h4 id=\"交互控制器-Interaction-Controller-：\"><a href=\"#交互控制器-Interaction-Controller-：\" class=\"headerlink\" title=\"交互控制器(Interaction Controller)：\"></a>交互控制器(Interaction Controller)：</h4><p>通过交互手段，通常是手势来驱动动画控制器实现的动画，使得用户能够控制整个过程；遵守<uiviewcontrollerinteractivetransitioning>协议；系统已经打包好现成的类供我们使用。</uiviewcontrollerinteractivetransitioning></p>\n<h4 id=\"转场环境-Transition-Context\"><a href=\"#转场环境-Transition-Context\" class=\"headerlink\" title=\"转场环境(Transition Context):\"></a>转场环境(Transition Context):</h4><p>提供转场中需要的数据；遵守<uiviewcontrollercontexttransitioning>协议；由 UIKit 在转场开始前生成并提供给我们提交的动画控制器和交互控制器使用。</uiviewcontrollercontexttransitioning></p>\n<h4 id=\"转场协调器-Transition-Coordinator-：\"><a href=\"#转场协调器-Transition-Coordinator-：\" class=\"headerlink\" title=\"转场协调器(Transition Coordinator)：\"></a>转场协调器(Transition Coordinator)：</h4><p>可在转场动画发生的同时并行执行其他的动画，其作用与其说协调不如说辅助，主要在 Modal 转场和交互转场取消时使用，其他时候很少用到；遵守<uiviewcontrollertransitioncoordinator>协议；由 UIKit 在转场时生成，UIViewController 在 iOS 7 中新增了方法transitionCoordinator()返回一个遵守该协议的对象，且该方法只在该控制器处于转场过程中才返回一个此类对象，不参与转场时返回 nil。</uiviewcontrollertransitioncoordinator></p>\n<p>总结下，5个协议只需要我们操心3个；实现一个最低限度可用的转场动画，我们只需要提供上面五个组件里的两个：转场代理和动画控制器即可，还有一个转场环境是必需的，不过这由系统提供；当进一步实现交互转场时，还需要我们提供交互控制器，也有现成的类供我们使用。</p>\n<h2 id=\"特殊的-Modal-转场\"><a href=\"#特殊的-Modal-转场\" class=\"headerlink\" title=\"特殊的 Modal 转场\"></a>特殊的 Modal 转场</h2><p>容器类 VC 的转场里 <code>fromView</code> 和 <code>toView</code> 是 <code>containerView</code> 的子层次的视图，而 Modal 转场里 <code>presentingView</code> 与 <code>containerView</code> 是同层次的视图，只有 <code>presentedView</code> 是 <code>containerView</code> 的子层次视图。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/semi-transparent.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"iOS-8引入的UIPresentationController\"><a href=\"#iOS-8引入的UIPresentationController\" class=\"headerlink\" title=\"iOS 8引入的UIPresentationController\"></a>iOS 8引入的UIPresentationController</h3><p><code>UIPresentationController</code>类，该类接管了 <code>UIViewController</code> 的显示过程，为其提供转场和视图管理支持。在 iOS 8.0 以上的系统里，你可以在 <code>presentation</code> 转场结束后打印视图控制器的结构，会发现 <code>presentedVC</code> 是由一个<code>UIPresentationController</code>对象来显示的，查看视图结构也能看到 <code>presentedView</code> 是 <code>UIView</code> 私有子类的<code>UITtansitionView</code>的子视图，这就是前面 <code>containerView</code> 的真面目.<br>当<code>UIViewController</code>的<code>modalPresentationStyle</code>属性为<code>.Custom</code>时(不支持.FullScreen)，我们有机会通过控制器的转场代理提供<code>UIPresentationController</code>的子类对 <code>Modal 转场</code>进行进一步的定制。实际上该类也可以在<code>.FullScreen</code>模式下使用，但是会丢失由该类负责的动画，保险起见还是遵循官方的建议，只在<code>.Custom</code>模式下使用该类。<br><code>UIPresentationController</code>类赋予 Modal 转场以下特性：</p>\n<ol>\n<li>定制 <code>presentedView</code> 的外观，尺寸以及在 <code>containerView</code> 中添加自定义视图并为这些视图添加动画；</li>\n<li>可以选择是否移除 <code>presentingView</code></li>\n<li>可以在不需要动画控制器的情况下单独工作</li>\n<li>iOS 8 中的自适应适应性布局<br><code>UIPresentationController</code>类提供了如下的方法参与转场，对转场过程实现了更加细致的控制，从命名便可以看出与动画控制器里的<code>animateTransition:</code>的关系：<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationTransitionWillBegin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationTransitionDidEnd</span><span class=\"params\">(<span class=\"number\">_</span> completed: Bool)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dismissalTransitionWillBegin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dismissalTransitionDidEnd</span><span class=\"params\">(<span class=\"number\">_</span> completed: Bool)</span></span></span><br></pre></td></tr></table></figure>\n除了 presentingView，UIPresentationController类拥有转场过程中剩下的角色：<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//指定初始化方法。</span></span><br><span class=\"line\"><span class=\"keyword\">init</span>(presentedViewController presentedViewController: <span class=\"type\">UIViewController</span>, presentingViewController presentingViewController: <span class=\"type\">UIViewController</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> presentingViewController: <span class=\"type\">UIViewController</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> presentedViewController: <span class=\"type\">UIViewController</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> containerView: <span class=\"type\">UIView</span>? &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"><span class=\"comment\">//提供给动画控制器使用的视图，默认返回 presentedVC.view，通过重写该方法返回其他视图，但一定要是 presentedVC.view 的上层视图。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentedView</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">UIView</span>?    </span><br></pre></td></tr></table></figure>\n没有 <code>presentingView</code> 是因为 <code>Custom</code> 模式下 <code>presentingView</code> 不受 <code>containerView</code> 管理，<code>UIPresentationController</code>类并没有改变这一点。iOS 8 扩充了转场环境协议，可以通过<code>viewForKey:</code>方便获取转场的视图，而该方法在 <code>Modal</code> 转场中获取的是<code>presentedView()</code>返回的视图。因此我们可以在子类中将 <code>presentedView</code> 包装在其他视图后重写该方法返回包装后的视图当做 <code>presentedView</code> 在动画控制器中使用。</li>\n</ol>\n<h3 id=\"定制presentedView\"><a href=\"#定制presentedView\" class=\"headerlink\" title=\"定制presentedView\"></a>定制presentedView</h3><h4 id=\"外观：重载size方法和frameOfPresentedViewInContainerView属性\"><a href=\"#外观：重载size方法和frameOfPresentedViewInContainerView属性\" class=\"headerlink\" title=\"外观：重载size方法和frameOfPresentedViewInContainerView属性\"></a>外观：重载size方法和frameOfPresentedViewInContainerView属性</h4><p>重载存储属性：get方法返回登场页面的位置和大小<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">var</span> frameOfPresentedViewInContainerView: <span class=\"type\">CGRect</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> presentViewFrame = <span class=\"type\">CGRect</span>.zero</span><br><span class=\"line\">    <span class=\"keyword\">let</span> containerBounds = containerView?.bounds</span><br><span class=\"line\">    <span class=\"comment\">//登场控制器内容页面的大小</span></span><br><span class=\"line\">    presentViewFrame.size = size(forChildContentContainer: presentedViewController, </span><br><span class=\"line\">                                  withParentContainerSize: (containerBounds?.size)!)</span><br><span class=\"line\">    presentViewFrame.origin.x = (containerBounds?.size.width)! - presentViewFrame.size.width</span><br><span class=\"line\">    <span class=\"keyword\">return</span> presentViewFrame</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回登场控制器内容页面的大小，在这里设置为屏幕宽度的三分之一款</span></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">size</span><span class=\"params\">(forChildContentContainer container: UIContentContainer, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   withParentContainerSize parentSize: CGSize)</span></span> -&gt; <span class=\"type\">CGSize</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">CGSize</span>.<span class=\"keyword\">init</span>(width:<span class=\"type\">CGFloat</span>(floorf(<span class=\"type\">Float</span>(parentSize.width/<span class=\"number\">3.0</span>))), height: parentSize.height)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"过渡动画，转场协调器-Transition-Coordinator\"><a href=\"#过渡动画，转场协调器-Transition-Coordinator\" class=\"headerlink\" title=\"过渡动画，转场协调器(Transition Coordinator)\"></a>过渡动画，转场协调器(Transition Coordinator)</h4><p>参与角色都准备好了，但有个问题，无法直接访问动画控制器，不知道转场的持续时间，怎么与转场过程同步？这时候前面提到的用处甚少的转场协调器(Transition Coordinator)将在这里派上用场。该对象可通过 <code>UIViewController</code> 的<code>transitionCoordinator()</code>方法获取，这是 iOS 7 为自定义转场新增的 API，该方法只在控制器处于转场过程中才返回一个与当前转场有关的有效对象，其他时候返回 <code>nil</code>。</p>\n<h5 id=\"转场开始\"><a href=\"#转场开始\" class=\"headerlink\" title=\"转场开始\"></a>转场开始</h5><ol>\n<li>在<code>containerView</code>中插入过渡视图<code>chromeView</code></li>\n<li>为转场中<code>chromeView</code>过渡视图添加转场动画</li>\n<li><code>presentedViewController.transitionCoordinator</code>转场协调器，添加转场的登场和退场动画<figure class=\"highlight swift\"><figcaption><span>presentationTransitionWillBegin</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationTransitionWillBegin</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    chromeView.frame = (<span class=\"keyword\">self</span>.containerView?.bounds)!</span><br><span class=\"line\">    chromeView.alpha = <span class=\"number\">0.0</span></span><br><span class=\"line\">    <span class=\"comment\">//在`containerView`中插入视图`chromeView`    </span></span><br><span class=\"line\">    containerView?.insertSubview(chromeView, at:<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//coordinator转场协调器负责转场动画的呈现和dismissal</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> coordinator = presentedViewController.transitionCoordinator</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (coordinator != <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//添加登场动画</span></span><br><span class=\"line\">        coordinator!.animate(alongsideTransition: &#123;</span><br><span class=\"line\">        (context:<span class=\"type\">UIViewControllerTransitionCoordinatorContext</span>!) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"comment\">//animate the alpha to 1.0.</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.chromeView.alpha = <span class=\"number\">1.0</span></span><br><span class=\"line\">        &#125;, completion:<span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        chromeView.alpha = <span class=\"number\">1.0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"转场结束\"><a href=\"#转场结束\" class=\"headerlink\" title=\"转场结束\"></a>转场结束</h5><p>在<code>presentedViewController.transitionCoordinator</code>转场协调器中添加转场的退场动画<br><figure class=\"highlight swift\"><figcaption><span>dismissalTransitionWillBegin</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dismissalTransitionWillBegin</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> coordinator = presentedViewController.transitionCoordinator</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (coordinator != <span class=\"literal\">nil</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//添加退场动画</span></span><br><span class=\"line\">        coordinator!.animate(alongsideTransition: &#123;</span><br><span class=\"line\">        (context:<span class=\"type\">UIViewControllerTransitionCoordinatorContext</span>!) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.chromeView.alpha = <span class=\"number\">0.0</span></span><br><span class=\"line\">        &#125;, completion:<span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        chromeView.alpha = <span class=\"number\">0.0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"适配屏幕旋转\"><a href=\"#适配屏幕旋转\" class=\"headerlink\" title=\"适配屏幕旋转\"></a>适配屏幕旋转</h4><p>在设备旋转的情况下，重置背景视图的外观和登场控制器内容的外观<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">containerViewWillLayoutSubviews</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    chromeView.frame = (containerView?.bounds)!</span><br><span class=\"line\">    presentedView?.frame = frameOfPresentedViewInContainerView</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Modal的两种PresentationStyle\"><a href=\"#Modal的两种PresentationStyle\" class=\"headerlink\" title=\"Modal的两种PresentationStyle\"></a>Modal的两种PresentationStyle</h4><ol>\n<li>设置整个转场动画是否将覆盖全屏幕<br> <code>.OverFullScreen</code>: 浮动式全屏，即：登场视图下方的视图不会完全被遮挡<br> <code>.FullScreen</code>  : 全覆盖全屏 即：占据全屏来显示登场视图<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设置整个转场动画是否将覆盖全屏幕</span></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">var</span> shouldPresentInFullscreen: <span class=\"type\">Bool</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">var</span> adaptivePresentationStyle: <span class=\"type\">UIModalPresentationStyle</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">UIModalPresentationStyle</span>.fullScreen</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"交互式转场\"><a href=\"#交互式转场\" class=\"headerlink\" title=\"交互式转场\"></a>交互式转场</h2><h3 id=\"实现交互化\"><a href=\"#实现交互化\" class=\"headerlink\" title=\"实现交互化\"></a>实现交互化</h3><p>在非交互转场的基础上将之交互化需要两个条件：<br>由转场代理提供交互控制器，这是一个遵守<uiviewcontrollerinteractivetransitioning>协议的对象，不过系统已经打包好了现成的类<code>UIPercentDrivenInteractiveTransition</code>供我们使用。我们不需要做任何配置，仅仅在转场代理的相应方法中提供一个该类实例便能工作。另外交互控制器必须有动画控制器才能工作。<br>交互控制器还需要交互手段的配合，最常见的是使用手势，或是其他事件，来驱动整个转场进程。</uiviewcontrollerinteractivetransitioning></p>\n<h3 id=\"使用一个变量来标记交互状态配合转场交互\"><a href=\"#使用一个变量来标记交互状态配合转场交互\" class=\"headerlink\" title=\"使用一个变量来标记交互状态配合转场交互\"></a>使用一个变量来标记交互状态配合转场交互</h3><p>如果在转场代理中提供了交互控制器，而转场发生时并没有方法来驱动转场进程(比如手势)，转场过程将一直处于开始阶段无法结束。<br>在两个容器控制器<code>NavigationController</code>和<code>TabBarController</code>转场为例：</p>\n<ol>\n<li>在 <code>NavigationController</code> 中点击 <code>NavigationBar</code> 也能实现 <code>pop</code> 返回操作，但此时没有了交互手段的支持，转场过程卡壳；</li>\n<li>在 <code>TabBarController</code> 的代理里提供交互控制器存在同样的问题，点击 <code>TabBar</code> 切换页面时也没有实现交互控制。因此仅在确实处于交互状态时才提供交互控制器，可以使用一个变量来标记交互状态，该变量由交互手势来更新状态。</li>\n</ol>\n<h3 id=\"转场动画控制器：向转场中添加视图，执行转场动画\"><a href=\"#转场动画控制器：向转场中添加视图，执行转场动画\" class=\"headerlink\" title=\"转场动画控制器：向转场中添加视图，执行转场动画\"></a>转场动画控制器：向转场中添加视图，执行转场动画</h3><p>转场 API 是协议的好处是不受限于具体的类，只要对象实现该协议便能参与转场过程，这也带来另外一个好处：封装便于复用，尽管三大转场代理协议的方法不尽相同。<br>但它们返回的动画控制器遵守的是同一个协议，因此可以将动画控制器封装作为第三方动画控制器在其他控制器的转场过程中使用。<br><code>UIViewControllerAnimatedTransitioning</code>代理协议方法，提供了转场所需要的重要数据：</p>\n<ol>\n<li><code>containerView()</code>：运行转场动画的容器视图</li>\n<li>转场视图控制器<ul>\n<li>方法一：<code>viewController(forKey:)</code>：<code>UITransitionContextViewControllerKey</code>枚举值：<code>from</code>，<code>to</code></li>\n<li>方法二：<code>viewForKey(_ key: String) -&gt; UIView? AVAILABLE_IOS(8_0)</code>:iOS 8新增 API 用于方便获取参与转场的视图.两个键值：<code>UITransitionContextFromViewKey</code>,<code>UITransitionContextToViewKey</code>.</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleAnimatedTransitioning</span>: <span class=\"title\">NSObject</span>,<span class=\"title\">UIViewControllerAnimatedTransitioning</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//used to determine if the presentation animation is presenting (as opposed to dismissing).</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> isPresentation : <span class=\"type\">Bool</span> = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//returns the duration in seconds of the transition animation.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">transitionDuration</span><span class=\"params\">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class=\"type\">TimeInterval</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//返回动画时间</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0.5</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//get the respective views of these view controllers. </span></span><br><span class=\"line\">    <span class=\"comment\">//Next we get the container view and if the presentation animation is presenting, we add the to view to the container view.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animateTransition</span><span class=\"params\">(using transitionContext: UIViewControllerContextTransitioning)</span></span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//get the from and to view controllers from the UIViewControllerContextTransitioning object.</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> fromVC = transitionContext.viewController(forKey: <span class=\"type\">UITransitionContextViewControllerKey</span>.from)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> toVC = transitionContext.viewController(forKey: <span class=\"type\">UITransitionContextViewControllerKey</span>.to)</span><br><span class=\"line\">        <span class=\"comment\">//determine the start and end positions of the view.</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> fromView = fromVC?.view</span><br><span class=\"line\">        <span class=\"keyword\">let</span> toView = toVC?.view</span><br><span class=\"line\">        <span class=\"keyword\">let</span> containerView = transitionContext.containerView</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> isPresentation </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            containerView.addSubview(toView!)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//decide on which view controller to animate based on whether the transition is a presentation or dismissal</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> animatingVC = isPresentation ? toVC : fromVC</span><br><span class=\"line\">        <span class=\"keyword\">let</span> animatingView = animatingVC?.view</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> finalFrameForVC = transitionContext.finalFrame(<span class=\"keyword\">for</span>: animatingVC!)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> initialFrameForVC = finalFrameForVC</span><br><span class=\"line\">        <span class=\"comment\">//This will animate the view from right to left during a presentation and vice versa during dismissal.</span></span><br><span class=\"line\">        initialFrameForVC.origin.x += initialFrameForVC.size.width</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> initialFrame = isPresentation ? initialFrameForVC : finalFrameForVC</span><br><span class=\"line\">        <span class=\"keyword\">let</span> finalFrame = isPresentation ? finalFrameForVC : initialFrameForVC</span><br><span class=\"line\"></span><br><span class=\"line\">        animatingView?.frame = initialFrame</span><br><span class=\"line\">        <span class=\"comment\">//根据协议中的方法获取动画的时间。</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> duration = transitionDuration(using: transitionContext)</span><br><span class=\"line\">        <span class=\"type\">UIView</span>.animate(withDuration: duration, delay:<span class=\"number\">0</span>, usingSpringWithDamping:<span class=\"number\">300.0</span>, initialSpringVelocity:<span class=\"number\">5.0</span>, options:<span class=\"type\">UIViewAnimationOptions</span>.allowUserInteraction, animations:&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//we move the view to the final position.</span></span><br><span class=\"line\">            animatingView?.frame = finalFrame</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;, completion:&#123; (value: <span class=\"type\">Bool</span>) <span class=\"keyword\">in</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> !<span class=\"keyword\">self</span>.isPresentation &#123;</span><br><span class=\"line\">                <span class=\"comment\">//If the transition is a dismissal, we remove the view.</span></span><br><span class=\"line\">                fromView?.removeFromSuperview()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//we complete the transition by calling transitionContext.completeTransition()</span></span><br><span class=\"line\">            transitionContext.completeTransition(<span class=\"literal\">true</span>)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//    UIView.transitionFromView(fromView, toView: toView, duration: durantion, options: .TransitionCurlDown, completion: &#123; _ in</span></span><br><span class=\"line\">    <span class=\"comment\">//    let isCancelled = transitionContext.transitionWasCancelled()</span></span><br><span class=\"line\">    <span class=\"comment\">//    transitionContext.completeTransition(!isCancelled)</span></span><br><span class=\"line\">    <span class=\"comment\">//    &#125;)</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//如果实现了，会在转场动画结束后调用，可以执行一些收尾工作。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationEnded</span><span class=\"params\">(<span class=\"number\">_</span> transitionCompleted: Bool)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"转场代理协议-Transition-Delegate\"><a href=\"#转场代理协议-Transition-Delegate\" class=\"headerlink\" title=\"转场代理协议(Transition Delegate)\"></a>转场代理协议(Transition Delegate)</h2><p>自定义转场的第一步便是提供转场代理，告诉系统使用我们提供的代理而不是系统的默认代理来执行转场。</p>\n<h3 id=\"实现转场代理协议方法，整合动画控制器和自定义展示控制器\"><a href=\"#实现转场代理协议方法，整合动画控制器和自定义展示控制器\" class=\"headerlink\" title=\"实现转场代理协议方法，整合动画控制器和自定义展示控制器\"></a>实现转场代理协议方法，整合动画控制器和自定义展示控制器</h3><ol>\n<li>返回管理用户信息视图控制器如何展示的控制器。前面实现的<code>ExamplePresentationViewController</code>类可同时处理 <code>presentation</code>转场 和 <code>dismissal</code> 转场。</li>\n<li>动画控制器为 <code>presentation</code> 和 <code>dismissal</code> 转场分别提供了动画控制器。<blockquote>\n<p><code>UIPresentationController</code>只在 iOS 8中可用，通过available关键字可以解决 API 的版本差异。</p>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleTransitioningDelegate</span>: <span class=\"title\">NSObject</span>,<span class=\"title\">UIViewControllerTransitioningDelegate</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//returns a presentation controller that manages the presentation of a view controller.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationController</span><span class=\"params\">(forPresented presented: UIViewController, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                            presenting: UIViewController?, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                source: UIViewController)</span></span> -&gt; <span class=\"type\">UIPresentationController</span>? </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//presentation动画控制器</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> presentationController = <span class=\"type\">ExamplePresentationViewController</span>(presentedViewController:presented, </span><br><span class=\"line\">                                                                                    presenting:presenting)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> presentationController</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//为presentation转场提供登场转场动画控制器</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationController</span><span class=\"params\">(forPresented presented: UIViewController, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                         presenting: UIViewController, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                             source: UIViewController)</span></span> -&gt; <span class=\"type\">UIViewControllerAnimatedTransitioning</span>? </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//登场转场动画控制器</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> animator = <span class=\"type\">ExampleAnimatedTransitioning</span>()</span><br><span class=\"line\">        animator.isPresentation = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> animator</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//为dismissal 转场提供退场转场动画控制器</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationController</span><span class=\"params\">(forDismissed dismissed: UIViewController)</span></span> -&gt; <span class=\"type\">UIViewControllerAnimatedTransitioning</span>? </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//退场转场动画控制器</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> animator = <span class=\"type\">ExampleAnimatedTransitioning</span>()</span><br><span class=\"line\">        animator.isPresentation = <span class=\"literal\">false</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> animator</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用自定义的转场的代理\"><a href=\"#使用自定义的转场的代理\" class=\"headerlink\" title=\"使用自定义的转场的代理\"></a>使用自定义的转场的代理</h3><p>自定义转场的第一步便是提供转场代理，告诉系统使用我们提供的代理而不是系统的默认代理来执行转场。<br>UIViewControllerTransitioningDelegate转场代理：</p>\n<ol>\n<li>强引用代理变量:强引用的变量来维护该代理</li>\n<li>Modal转场代理的特性：由presentedVC自身来遵循转场代理<code>presentedVC.modalPresentationStyle</code>，和前两个容器控制器转场代理不同。</li>\n<li>两种支持自定义转场模式：<code>.Custom</code>或<code>.FullScreen</code>,默认值为<code>.FullScreen</code><figure class=\"highlight swift\"><figcaption><span>fromVC.class</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//强引用的变量来维护该代理</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> exampleTransitionDelegate = <span class=\"type\">ExampleTransitioningDelegate</span>()</span><br><span class=\"line\"><span class=\"comment\">//create an instance of ExampleViewController which will provide the content to display.</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> presentedVC = <span class=\"type\">ExampleViewController</span>()</span><br><span class=\"line\">presentedVC.modalPresentationStyle = .custom</span><br><span class=\"line\">presentedVC.transitioningDelegate = exampleTransitionDelegate</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//present this view controller.</span></span><br><span class=\"line\">present(toVC, animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"两种常规的转场方式\"><a href=\"#两种常规的转场方式\" class=\"headerlink\" title=\"两种常规的转场方式\"></a>两种常规的转场方式</h2><h3 id=\"UIView方式-transitionFromView\"><a href=\"#UIView方式-transitionFromView\" class=\"headerlink\" title=\"UIView方式:transitionFromView\"></a>UIView方式:transitionFromView</h3><p>不需要获取 <code>containerView</code> 以及手动添加 <code>toView</code> 就能实现一个指定类型的转场动画，而缺点则是只能使用指定类型的动画。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UIView</span>.transitionFromView(fromView, toView: toView, duration: durantion, options: .<span class=\"type\">TransitionCurlDown</span>, completion: &#123; <span class=\"number\">_</span> <span class=\"keyword\">in</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isCancelled = transitionContext.transitionWasCancelled()</span><br><span class=\"line\">transitionContext.completeTransition(!isCancelled)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"UIViewController方式：在子-VC-间转换的方法\"><a href=\"#UIViewController方式：在子-VC-间转换的方法\" class=\"headerlink\" title=\"UIViewController方式：在子 VC 间转换的方法\"></a>UIViewController方式：在子 VC 间转换的方法</h3><p>该方法用 toVC 的视图转换 fromVC 的视图在父视图中的位置，并且执行<code>animations闭包</code>里的动画。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transitionFromViewController:toViewController:duration:options:animations:completion:</span><br></pre></td></tr></table></figure><br>该方法仅限于在自定义容器控制器里使用，如果直接使用 <code>UINavigationController</code> 和 <code>UITabBarController</code> 调用该方法执行子VC间转换会抛出异常。</p>\n<blockquote>\n<p>不过 iOS 7 中这两个容器控制器开放的自定义转场做的是同样的事情，回头再看第一章 Transition 解释，转场协议 API 将这个方法拆分成了上面的几个组件，并且加入了激动人心的交互控制，以便我们能够方便定制转场动画。</p>\n</blockquote>\n<p><a href=\"http://www.appcoda.com/presentation-controllers-tutorial/\" target=\"_blank\" rel=\"noopener\">原文</a></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"转场","path":"api/categories/转场.json"}],"tags":[{"name":"动画","path":"api/tags/动画.json"},{"name":"转场","path":"api/tags/转场.json"}]},{"title":"整理iOS中几种常用的展示型视图控制器","slug":"iOS中几种常用的展示控制器使用","date":"2017-02-16T17:53:18.000Z","updated":"2017-02-16T21:56:31.000Z","comments":true,"path":"api/articles/iOS中几种常用的展示控制器使用.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/iPhoneipadalert.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><a href=\"https://www.dropbox.com/s/4gj6levvlav2xzc/PresentationsDemoStart.zip?dl=0\" target=\"_blank\" rel=\"noopener\">开始项目</a><br><a href=\"https://github.com/appcoda/Presentation-Controllers-Demo\" target=\"_blank\" rel=\"noopener\">完整项目</a></p>\n<h2 id=\"UIAlertController\"><a href=\"#UIAlertController\" class=\"headerlink\" title=\"UIAlertController\"></a>UIAlertController</h2><p>在iOS8中，提供<code>UIAlertController</code>控制器代替<code>UIAlertView</code>和<code>UIActionSheet</code>两个控件。给用户展示提示信息的新的一种方式。</p>\n<h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><ol>\n<li>能够自适应的（在iPad上，an <code>action sheet</code> style alert will present itself in a popover），</li>\n<li>显示方式：可以轻松切换<code>Action sheets</code>和<code>alert view</code>两种显示样式<code>alert view</code>被以modal态显示presenting视图控制器上，<code>Action sheets</code>被固定在以屏幕底部。 </li>\n<li>按钮事件实现：使用闭包的方式来处理，相较之前通过实现代理的方式要简单很多。</li>\n<li>子控件支持：<code>Alert view</code>支持按钮和输入框两种，Action sheets仅支持按钮一种控件。</li>\n<li>不同于以往的两类<code>UIAlertController</code>继承自<code>UIViewController</code>。这意味着可以使用视图控制器提供展示信息的功能。</li>\n</ol>\n<h3 id=\"创建使用UIAlertController\"><a href=\"#创建使用UIAlertController\" class=\"headerlink\" title=\"创建使用UIAlertController\"></a>创建使用UIAlertController</h3><p>用<code>title</code>，<code>message</code>参数来实例化<code>alertController</code>实例，然后在实例中添加两个闭包的按钮<br><figure class=\"highlight swift\"><figcaption><span>showAlertWasTapped</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@IBAction</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">showAlertWasTapped</span><span class=\"params\">(sender: UIButton)</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> alertController = <span class=\"type\">UIAlertController</span>(title: <span class=\"string\">\"Appcoda\"</span>, message: <span class=\"string\">\"Message in alert dialog\"</span>, preferredStyle: <span class=\"type\">UIAlertControllerStyle</span>.<span class=\"type\">Alert</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> deleteAction = <span class=\"type\">UIAlertAction</span>(title: <span class=\"string\">\"Delete\"</span>, style: <span class=\"type\">UIAlertActionStyle</span>.<span class=\"type\">Destructive</span>, handler: &#123;(alert :<span class=\"type\">UIAlertAction</span>!) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"built_in\">println</span>(<span class=\"string\">\"Delete button tapped\"</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    alertController.addAction(deleteAction)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> okAction = <span class=\"type\">UIAlertAction</span>(title: <span class=\"string\">\"OK\"</span>, style: <span class=\"type\">UIAlertActionStyle</span>.<span class=\"type\">Default</span>, handler: &#123;(alert :<span class=\"type\">UIAlertAction</span>!) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"built_in\">println</span>(<span class=\"string\">\"OK button tapped\"</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    alertController.addAction(okAction)</span><br><span class=\"line\"></span><br><span class=\"line\">    presentViewController(alertController, animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>运行效果：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/iPhoneipadalert.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"UIAlertControllerStyle枚举：Alert切换ActionSheet\"><a href=\"#UIAlertControllerStyle枚举：Alert切换ActionSheet\" class=\"headerlink\" title=\"UIAlertControllerStyle枚举：Alert切换ActionSheet\"></a>UIAlertControllerStyle枚举：<code>Alert</code>切换<code>ActionSheet</code></h3><p>在<code>UIAlertController</code>之前，切换<code>alert</code>和<code>action sheet</code>需要重写大量的代码，但现在只需要改变一个枚举值<code>UIAlertControllerStyle.Alert</code>为<code>UIAlertControllerStyle.ActionSheet</code>.<br><figure class=\"highlight swift\"><figcaption><span>UIAlertControllerStyle.ActionSheet</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> alertController = <span class=\"type\">UIAlertController</span>(title: <span class=\"string\">\"Appcoda\"</span>, message: <span class=\"string\">\"Message in alert dialog\"</span>, preferredStyle: <span class=\"type\">UIAlertControllerStyle</span>.<span class=\"type\">ActionSheet</span>)</span><br></pre></td></tr></table></figure><br>在iPhone上，屏幕底部显示一个<code>action sheet</code>。<br>问题：在iPad上，点击上面的按钮崩溃，需要定义锚点位置。</p>\n<h3 id=\"popoverPresentationController锚点：sourceView-sourceRect\"><a href=\"#popoverPresentationController锚点：sourceView-sourceRect\" class=\"headerlink\" title=\"popoverPresentationController锚点：sourceView/sourceRect\"></a>popoverPresentationController锚点：sourceView/sourceRect</h3><p><code>popover controller</code>在<code>alertController</code>视图内展示，需要一个<code>popover箭头</code>指向<code>alertController</code>视图的某一位置。<br>通过设置<code>sourceView</code>来确定<code>popover箭头</code>位置，这个<code>popover</code>以及<code>popover箭头</code>指向的矩形区域都在这个<code>sourceView</code>上。<br>在调用<code>presentViewController()</code>之前添加代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alertController.popoverPresentationController?.sourceView = view</span><br><span class=\"line\">alertController.popoverPresentationController?.sourceRect = sender.frame</span><br></pre></td></tr></table></figure><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/popover箭头.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"UIPopoverPresentationController\"><a href=\"#UIPopoverPresentationController\" class=\"headerlink\" title=\"UIPopoverPresentationController\"></a>UIPopoverPresentationController</h2><p><code>Alert</code>主要用于显示用户的提示信息，当展示的信息很多时，就需要借助<code>popover presentation controller</code>。</p>\n<h3 id=\"在compact和regular两种屏幕中显示模态视图\"><a href=\"#在compact和regular两种屏幕中显示模态视图\" class=\"headerlink\" title=\"在compact和regular两种屏幕中显示模态视图\"></a>在compact和regular两种屏幕中显示模态视图</h3><p>在<code>storyboard</code>文件，设置视图的<code>storyboard ID</code>:<code>PopoverViewController</code>，设置模态视图展示样式，展示在<code>compact-width</code>和<code>regular-width</code>的两种设备屏幕上。<br>实现如下：<br><figure class=\"highlight swift\"><figcaption><span>actionWasTapped</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@IBAction</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">actionWasTapped</span><span class=\"params\">(sender: UIBarButtonItem)</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> storyboard : <span class=\"type\">UIStoryboard</span> = <span class=\"type\">UIStoryboard</span>(name: <span class=\"string\">\"Main\"</span>, bundle: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> vc = storyboard.instantiateViewControllerWithIdentifier(<span class=\"string\">\"PopoverViewController\"</span>) <span class=\"keyword\">as</span>! <span class=\"type\">UIViewController</span></span><br><span class=\"line\">    vc.modalPresentationStyle = <span class=\"type\">UIModalPresentationStyle</span>.<span class=\"type\">Popover</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> popover: <span class=\"type\">UIPopoverPresentationController</span> = vc.popoverPresentationController!</span><br><span class=\"line\">    popover.barButtonItem = sender  <span class=\"comment\">//`popover箭头`锚的位置</span></span><br><span class=\"line\">    presentViewController(vc, animated: <span class=\"literal\">true</span>, completion:<span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"设置锚点四种方式\"><a href=\"#设置锚点四种方式\" class=\"headerlink\" title=\"设置锚点四种方式\"></a>设置锚点四种方式</h4><ol>\n<li>barButtonItem<br>先获取该视图控制器的<code>popoverPresentationController</code>控制器，通过<code>popover</code>控制器的<code>barButtonItem</code>属性来设置锚点控件。当弹出时<code>popover箭头</code>就指向这个barButtonItem控件。</li>\n<li>通过指定<code>sourceView</code>和<code>sourceRect</code>两个属性，就像前面例子中一样来指定锚点位置。</li>\n<li>通过其他属性来实现，例如：<code>permittedArrowDirections</code>，也能够指定锚点。</li>\n<li>如果在在展示过程中，无法确定箭头的方向时，就是用默认值：<code>UIPopoverArrowDirection.Any</code>.<br>在iPad显示：</li>\n</ol>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/UIPopoverArrowDirection.png?imageMogr2/2/w/800\">\n<p>在iPhone上以模态显示：</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/iPhonemodally.png?imageMogr2/2/w/800\">\n<h3 id=\"在iPhone设备上dissmiss模态视图\"><a href=\"#在iPhone设备上dissmiss模态视图\" class=\"headerlink\" title=\"在iPhone设备上dissmiss模态视图\"></a>在iPhone设备上dissmiss模态视图</h3><p>要在iPhone设备上，实现模态视图dissmiss功能，需要借助导航控制器，同时这个模态视图需要遵循<code>UIPopoverPresentationController</code>协议，实现两个代理方法</p>\n<h4 id=\"实现UIPopoverPresentationController协议\"><a href=\"#实现UIPopoverPresentationController协议\" class=\"headerlink\" title=\"实现UIPopoverPresentationController协议\"></a>实现<code>UIPopoverPresentationController</code>协议</h4><ol>\n<li><code>PopoverViewController</code>类定义修改如下:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PopoverViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">UIPopoverPresentationControllerDelegate</span> </span>&#123;</span><br></pre></td></tr></table></figure></li>\n<li>在actionWasTapped()函数中调用<code>presentViewController()</code>之前添加：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">popover.delegate = <span class=\"keyword\">self</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法一：返回自适应设备的视图展示样式\"><a href=\"#方法一：返回自适应设备的视图展示样式\" class=\"headerlink\" title=\"方法一：返回自适应设备的视图展示样式\"></a>方法一：返回自适应设备的视图展示样式</h4>当APP在<code>compact-width</code>设备上弹出一个视图时调用.这个方法告诉OS系统使用的视图展示样式。<br>这里OS系统被告知在<code>compact-width</code>设备上，使用全屏的样式展示视图。<figure class=\"highlight swift\"><figcaption><span>adaptivePresentationStyleForPresentationController()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">adaptivePresentationStyleForPresentationController</span><span class=\"params\">(controller: UIPresentationController)</span></span> -&gt; <span class=\"type\">UIModalPresentationStyle</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">UIModalPresentationStyle</span>.<span class=\"type\">FullScreen</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二：返回自定义的视图控制器\"><a href=\"#方法二：返回自定义的视图控制器\" class=\"headerlink\" title=\"方法二：返回自定义的视图控制器\"></a>方法二：返回自定义的视图控制器</h4>当前展现的视图和原来的展示方式不同时调用.我们设置这个视图的<code>Popover presentation</code>展示方式，但是我们指定在<code>compact-width</code>设备上，这样它会以full screen样式展示。在这个函数中，样式切换发生时，会return自定义的视图控制器。<figure class=\"highlight swift\"><figcaption><span>presentationController(_:viewControllerForAdaptivePresentationStyle)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationController</span><span class=\"params\">(controller: UIPresentationController, viewControllerForAdaptivePresentationStyle style: UIModalPresentationStyle)</span></span> -&gt; <span class=\"type\">UIViewController</span>? </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> navigationController = <span class=\"type\">UINavigationController</span>(rootViewController: controller.presentedViewController)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> btnDone = <span class=\"type\">UIBarButtonItem</span>(title: <span class=\"string\">\"Done\"</span>, style: .<span class=\"type\">Done</span>, target: <span class=\"keyword\">self</span>, action: <span class=\"string\">\"dismiss\"</span>)</span><br><span class=\"line\">    navigationController.topViewController.navigationItem.rightBarButtonItem = btnDone</span><br><span class=\"line\">    <span class=\"keyword\">return</span> navigationController</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"Done按钮的dismiss事件\"><a href=\"#Done按钮的dismiss事件\" class=\"headerlink\" title=\"Done按钮的dismiss事件\"></a><code>Done</code>按钮的dismiss事件</h4><p>在导航控制器中国封装这个视图，在导航条上添加一个<code>Done</code>按钮，点击<code>Done</code>dismiss这个视图<br><figure class=\"highlight swift\"><figcaption><span>dismiss</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dismiss</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.dismissViewControllerAnimated(<span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在iPhone上，显示修改后的视图控制器，多出带按钮的导航栏。<br>在iPad上，视图控制器显示没有导航控制器，因为它不使用全屏幕显示。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/adaptivePresentationStyleForPresentationController.png?imageMogr2/2/w/800\"><br>如果想让iPhone像iPad一样显示一个Popover，只<code>adaptivePresentationStyleForPresentationController</code>返回：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"type\">UIModalPresentationStyle</span>.<span class=\"type\">None</span></span><br></pre></td></tr></table></figure><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/UIModalPresentationStyle.None.png?imageMogr2/2/w/800\"></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"转场","path":"api/categories/转场.json"}],"tags":[{"name":"动画","path":"api/tags/动画.json"},{"name":"转场","path":"api/tags/转场.json"},{"name":"UI","path":"api/tags/UI.json"}]},{"title":"JavaScript自动化组件OC桥接","slug":"macOS/JavaScript自动化组件OC桥接","date":"2017-02-15T17:19:30.000Z","updated":"2017-02-16T13:43:01.000Z","comments":true,"path":"api/articles/macOS/JavaScript自动化组件OC桥接.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><a href=\"https://developer.apple.com/library/content/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/OSX10-10.html#//apple_ref/doc/uid/TP40014508-CH109-SW8\" target=\"_blank\" rel=\"noopener\">文档</a><br><code>JavaScript自动化</code>有一个内置的<code>Objective-C Bridge</code>，使您能够访问文件系统，创建Cocoa应用程序。<br><code>Objective-C Bridge</code>的主要接入点是全局属性<code>objc</code>和<code>$</code>。</p>\n<h2 id=\"Frameworks\"><a href=\"#Frameworks\" class=\"headerlink\" title=\"Frameworks\"></a>Frameworks</h2><p><code>Foundation framework</code>中的语法默认支持<code>JavaScript自动化</code>。也可以通过使用<code>ObjC.import()</code>方法导入其他Frameworks 和 libraries。<br>例如，使用<code>Cocoa框架</code>中的<code>NSBeep()</code>函数，需要导入<code>Cocoa框架</code><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjC.import(<span class=\"string\">'Cocoa'</span>)</span><br><span class=\"line\">$.NSBeep()</span><br></pre></td></tr></table></figure><br>除了系统框架之外，一些系统库的功能也被暴露出来。这个功能可以通过<code>头文件</code>的名称来暴漏出来（不带.h）<br>例如：<br>arpa/inet, asl, copyfile, dispatch, dyld, errno, getopt, glob, grp, ifaddrs, launch, membership, netdb, netinet/in, notify, objc, paths, pwd, readline, removefile, signal, spawn, sqlite3, stdio, stdlib, string, sys/fcntl, sys/file, sys/ioctl, sys/mount, sys/param, sys/resource, sys/socket, sys/stat, sys/sysctl, sys/time, sys/times, sys/types, sys/wait, sys/xattr, syslog, time, unistd, uuid/uuid, vImage, vecLib, vmnet, xpc, 和 zlib.<br>导入框架时，系统将参考桥接支持文件。除了内置的框架和库，您可以导入任何具有桥接支持的框架，只需要将完整路径传递给框架，如下示例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjC.import(<span class=\"string\">'/Library/Frameworks/Awesome.framework'</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>原始的<code>JavaScript数据类型</code>映射到<code>C数据类型</code>。例如，一个<code>JavaScript字符串</code>映射为<code>char *</code>，而<code>JavaScript整数</code>映射到<code>int</code>。使用<code>objc API</code>返回一个<code>char *</code>时，会得到一个<code>JS 字符串</code></p>\n<p>原始的<code>JavaScript数据类型</code>将被自动转换为<code>ObjC对象类型</code>，并能作为一个预期的对象类型的参数传递给ObjC方法。<br>例如，一个<code>JS字符串</code>将被转换为一个<code>NSString对象</code>如果是什么方法签名说应该是输入。</p>\n<blockquote>\n<p>注意，然而，ObjC方法返回的ObjC对象类型是不会自动转换为原始的JavaScript的数据类型。</p>\n</blockquote>\n<h2 id=\"实例化的类和调用方法\"><a href=\"#实例化的类和调用方法\" class=\"headerlink\" title=\"实例化的类和调用方法\"></a>实例化的类和调用方法</h2><p>所有类都定义为<code>$对象</code>的属性。ObjC对象的方法有两种方式调用，根据是否需要参数的方法。<br>如果ObjC方法不带参数，然后调用<code>JavaScript属性名</code>访问<code>属性值</code>。这个例子中实例化一个空的字符串。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = $.NSMutableString.alloc.init</span><br></pre></td></tr></table></figure><br>如果ObjC方法不带参数，根据<code>JSExport</code>规范来命名，通过JavaScript的方法调用（function-typed property）；<br>对于多参数的方法，Objective-C的方法每个部分都合并在一起，冒号后的字母变为大写并移除冒号。比如下边协议中的方法，在JavaScript调用就是：doFooWithBar(foo, bar);<br>这个例子说明<code>JavaScript字符串</code>转为<code>NSString</code>然后写入到一个文件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = $.NSString.alloc.initWithUTF8String(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\">str.writeToFileAtomically(<span class=\"string\">'/tmp/foo'</span>, <span class=\"literal\">true</span>)</span><br></pre></td></tr></table></figure></p>\n<p>如果你调用一个方法，如<code>-intValue</code>，返回<code>C数据类型</code>而不是一个对象，然后你会回到原始的<code>JavaScript数据类型</code>。<br>此示例返回原始的JavaScript的整数，99。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.NSNumber.numberWithInt(<span class=\"number\">99</span>).intValue</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"访问-ObjC-Properties\"><a href=\"#访问-ObjC-Properties\" class=\"headerlink\" title=\"访问 ObjC Properties\"></a>访问 ObjC Properties</h3><p><code>ObjC属性</code>也可以通过<code>JavaScript属性</code>来访问，很像调用无参数方法。<br>当一个<code>桥接对象属性</code>的被访问时，ObjC属性列表是第一参考，如果列表中存在该名称对应的属性，那么就调用相应属性的<code>getter</code>或<code>setter</code>选择器。如果该名称的ObjC属性不在类中属性的列表中，那么该属性名称就作为<code>方法选择器</code>来调用。<br>使用自定义<code>getter</code>名定义一个属性，你可以使用<code>属性</code>名 或 <code>getter</code>名，并得到相同的结果。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task = $.NSTask.alloc.init</span><br><span class=\"line\">task.running == task.isRunning</span><br></pre></td></tr></table></figure><br>另外，不同的参数方法，<code>桥接对象属性</code>映射到<code>ObjC属性</code>也可以设置为（read/write属性）。下面的两行定义了一个ObjC属性：<code>launchPath</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task.launchPath = <span class=\"string\">'/bin/sleep'</span></span><br><span class=\"line\">task.setLaunchPath(<span class=\"string\">'/bin/sleep'</span>)</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"JS","path":"api/categories/JS.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"混编","path":"api/tags/混编.json"}]},{"title":"shell命令+AppleScript脚本+Swift代码相互调用","slug":"macOS/shell命令+AppleScript脚本+Swift代码相互调用","date":"2017-02-15T17:19:30.000Z","updated":"2017-02-15T17:19:30.000Z","comments":true,"path":"api/articles/macOS/shell命令+AppleScript脚本+Swift代码相互调用.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>当想让自己的app支持播放，但有没有足够的时间来开发自己的播放器，可以先考虑用mpv播放器来实现相关功能，这是<code>AppleScript</code>作为互通的桥梁。</p>\n<h2 id=\"NSTask调用AppleScript\"><a href=\"#NSTask调用AppleScript\" class=\"headerlink\" title=\"NSTask调用AppleScript\"></a><code>NSTask</code>调用<code>AppleScript</code></h2><h3 id=\"调用脚本文件main-scpt\"><a href=\"#调用脚本文件main-scpt\" class=\"headerlink\" title=\"调用脚本文件main.scpt\"></a>调用脚本文件<code>main.scpt</code></h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//let bundle = NSBundle.init(forClass: self.dynamicType)</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bundle = <span class=\"type\">NSBundle</span>.mainBundle()</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> scriptPath = bundle.pathForResource(<span class=\"string\">\"main\"</span>, ofType: <span class=\"string\">\"scpt\"</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> paths = [scriptPath]</span><br><span class=\"line\">    <span class=\"type\">NSTask</span>.launchedTaskWithLaunchPath(<span class=\"string\">\"/usr/bin/osascript\"</span>, arguments: paths)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"调用APPleScript脚本片段\"><a href=\"#调用APPleScript脚本片段\" class=\"headerlink\" title=\"调用APPleScript脚本片段\"></a>调用<code>APPleScript脚本片段</code></h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bundle = <span class=\"type\">NSBundle</span>.mainBundle()</span><br><span class=\"line\"><span class=\"keyword\">let</span> videoPath = bundle.pathForResource(<span class=\"string\">\"BigBuck\"</span>, ofType: <span class=\"string\">\"m4v\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//https://developer.apple.com/library/mac/technotes/tn2084/_index.html</span></span><br><span class=\"line\"><span class=\"comment\">//open -na /Applications/mpv.app命令行必须是 -na 才能调用当前指定的播放器，否则会调用系统默认播发器</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAppleScript = <span class=\"string\">\"on run\\ndo shell script \\\"open -na /Applications/mpv.app \\(videoPath!)\\\"\\ntell application \\\"mpv\\\" to activate\\n end run\"</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(myAppleScript)</span><br><span class=\"line\"><span class=\"keyword\">var</span> error: <span class=\"type\">NSDictionary</span>?</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> scriptObject = <span class=\"type\">NSAppleScript</span>(source: myAppleScript) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> output: <span class=\"type\">NSAppleEventDescriptor</span> = scriptObject.executeAndReturnError(</span><br><span class=\"line\">    &amp;error) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(output.stringValue)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (error != <span class=\"literal\">nil</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"error: \\(error)\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"AppleScript调用shell\"><a href=\"#AppleScript调用shell\" class=\"headerlink\" title=\"AppleScript调用shell\"></a><code>AppleScript</code>调用<code>shell</code></h2><p>AppleScript语句中为on run {变量名称，逗号隔开} 以endrun结束。中间为AppleScript语句。</p>\n<h3 id=\"do-shell-script\"><a href=\"#do-shell-script\" class=\"headerlink\" title=\"do shell script\"></a>do shell script</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on run [变量1,变量2...]  #开始 多个变量名称，用逗号隔开</span><br><span class=\"line\">    do shell script \"open -n /Applications/mpv.app\" #AppleScript语句  </span><br><span class=\"line\">end run #结束</span><br></pre></td></tr></table></figure>\n<h2 id=\"终端osascript调用AppleScript\"><a href=\"#终端osascript调用AppleScript\" class=\"headerlink\" title=\"终端osascript调用AppleScript\"></a>终端<code>osascript</code>调用<code>AppleScript</code></h2><p><a href=\"http://www.hackmac.org/tutorials/run-applescript-from-the-command-line/\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">osascript -e 'applescript command' #单引号</span><br></pre></td></tr></table></figure>\n<h3 id=\"打开Finder窗口\"><a href=\"#打开Finder窗口\" class=\"headerlink\" title=\"打开Finder窗口\"></a>打开Finder窗口</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">osascript -e 'tell app \"Finder\" to make new Finder window'</span><br></pre></td></tr></table></figure>\n<h3 id=\"打开某个程序同时弹出”Hello-World”提示框\"><a href=\"#打开某个程序同时弹出”Hello-World”提示框\" class=\"headerlink\" title=\"打开某个程序同时弹出”Hello World”提示框\"></a>打开某个程序同时弹出”Hello World”提示框</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">osascript -e <span class=\"string\">'tell app \"applicationname\" to display dialog \"Hello World\"'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"设置音量，音量大小范围（0-7）\"><a href=\"#设置音量，音量大小范围（0-7）\" class=\"headerlink\" title=\"设置音量，音量大小范围（0-7）\"></a>设置音量，音量大小范围（0-7）</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">osascript -e <span class=\"string\">\"set volume number\"</span></span><br></pre></td></tr></table></figure>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"JS","path":"api/categories/JS.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"混编","path":"api/tags/混编.json"},{"name":"脚本","path":"api/tags/脚本.json"},{"name":"AppleScript","path":"api/tags/AppleScript.json"},{"name":"shell","path":"api/tags/shell.json"}]},{"title":"macOS支持JavaScript自动化组件基础","slug":"macOS/macOS支持JavaScript自动化组件基础","date":"2017-02-15T17:19:30.000Z","updated":"2017-02-16T13:43:01.000Z","comments":true,"path":"api/articles/macOS/macOS支持JavaScript自动化组件基础.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>苹果 <code>OS X Yosemite系统</code>把 <code>JavaScript</code>作为<code>AppleScript</code>的另一选择。<code>Automation</code> 是 <code>OS X 10.10版本</code>中的新特性，苹果在官网发布<a href=\"https://developer.apple.com/library/prerelease/mac/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/index.html#//apple_ref/doc/uid/TP40014508\" target=\"_blank\" rel=\"noopener\">JavaScript for Automation Release Notes</a>有篇文章介绍了用<code>JavaScript</code>写自动化<code>Automation</code>脚本。<br><code>JavaScript</code>凭借其简单的语法，良好的性能，超轻量的框架，极小耦合的模块系统等等优势已经吸引了很多大厂的关注。<br>再加上<code>JavaScript</code>先天开放且无版权专利纠纷的问题，拥有非常广泛的开发者（开源）群体，苹果将其引入<code>OS X平台</code>代替私有的<code>AppleScript</code>，可能也有着一部分开放性平台的考虑，从而吸引广泛的第三方开发者。<br>资源<br><a href=\"https://github.com/tylergaw/js-osx-app-examples\" target=\"_blank\" rel=\"noopener\">JavaScript OS X App Examples</a><br><a href=\"https://github.com/dtinth/JXA-Cookbook\" target=\"_blank\" rel=\"noopener\">JavaScript for Automation Cookbook</a></p>\n<h2 id=\"OSA框架-Open-Scripting-Architecture\"><a href=\"#OSA框架-Open-Scripting-Architecture\" class=\"headerlink\" title=\"OSA框架:Open Scripting Architecture\"></a>OSA框架:<code>Open Scripting Architecture</code></h2><p><code>OSA</code>组件用于实现MacAPP自动化操作。这些框架组件使用场景包括：<code>Script Editor</code>编辑器，全系统的<code>Script菜单</code>，<code>Run JavaScript Automator</code>命令的操作，<code>applets</code>小程序，命令行<code>osascript</code>工具，<code>NSUserScriptTask API</code>中，还可以运用在其他的<code>OSA</code>组件中例如：<code>AppleScript</code>。这也就包括了<code>Mail</code>规则、<code>Folder</code>操作、<code>Address Book</code>插件、日历闹钟和消息触发器。</p>\n<h2 id=\"脚本字典\"><a href=\"#脚本字典\" class=\"headerlink\" title=\"脚本字典\"></a>脚本字典</h2><p>脚本字典详细介绍APP的对象模型。在脚本字典映射到有效的JavaScript标识符遵循一套规范的术语。在<code>Script Editor</code>脚本字典浏览器已经更新到显示术语<code>AppleScript</code>，<code>JavaScript</code>和O<code>bjective-C</code>（Scripting Bridge framework）格式。</p>\n<h3 id=\"打开脚本字典\"><a href=\"#打开脚本字典\" class=\"headerlink\" title=\"打开脚本字典\"></a>打开脚本字典</h3><p>启动<code>Script Editor</code> (/Applications/Utilities/) –&gt;<code>File &gt; Open Dictionary or Window &gt; Library</code>。</p>\n<h2 id=\"object-specifier\"><a href=\"#object-specifier\" class=\"headerlink\" title=\"object specifier\"></a>object specifier</h2><p>在<code>JavaScript自动化主机</code>环境中的大部分对象指的是外部实例，如：其他APP，window或在这些APP的相关数据。当访问一个APP对象或APP中的某个元素的<code>JavaScript属性</code>时，会返回一个新的<code>object specifier</code>，也就是这个对象的<code>specifier 属性</code>。</p>\n<blockquote>\n<p>object specifier不是外部实例属性的实际值，是这个对象的引用指针。如果要获取这个属性的实际值，使用get／set方法。</p>\n</blockquote>\n<h2 id=\"访问APP\"><a href=\"#访问APP\" class=\"headerlink\" title=\"访问APP\"></a>访问APP</h2><p>六种方式:<br><figure class=\"highlight js\"><figcaption><span>By name</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application(<span class=\"string\">'Mail'</span>)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><figcaption><span>By bundle ID</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application(<span class=\"string\">'com.apple.mail'</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>By path</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application(<span class=\"string\">'/Applications/Mail.app'</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>By process ID</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application(<span class=\"number\">763</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>On a remote machine</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application(<span class=\"string\">'eppc://127.0.0.1/Mail'</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>currentApplication</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application.currentApplication()</span><br></pre></td></tr></table></figure>\n<h2 id=\"语法示例\"><a href=\"#语法示例\" class=\"headerlink\" title=\"语法示例\"></a>语法示例</h2><figure class=\"highlight js\"><figcaption><span>Access properties</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.name</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>Access elements</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.outgoingMessages[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>Call commands</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.open(...)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>Create new objects</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.OutgoingMessage(...)</span><br></pre></td></tr></table></figure>\n<h3 id=\"属性的get-set方法\"><a href=\"#属性的get-set方法\" class=\"headerlink\" title=\"属性的get/set方法\"></a>属性的get/set方法</h3><p>点运算符访问脚本对象，是JavaScript语法特性之一。<br>如上所述，返回的对象是一个<code>object specifier</code>是一个对象的引用，而不是属性实际值。<br>当访问属性时，会作为一个get函数，返回实际值：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subject = Mail.inbox.messages[<span class=\"number\">0</span>].subject()</span><br></pre></td></tr></table></figure><br>当赋值属性时，会作为一个set函数，把参数赋值该属性：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.outgoingMessages[<span class=\"number\">0</span>].subject = <span class=\"string\">'Hello world'</span></span><br></pre></td></tr></table></figure><br>获取数组中的每个元素属性（在这种情况下，得到邮件收件箱中的每份邮件的标题）<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subjects = Mail.inbox.messages.subject()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"元素数组\"><a href=\"#元素数组\" class=\"headerlink\" title=\"元素数组\"></a>元素数组</h3><p>通过在数组中调用特定元素检索方法，或使用方括号并指定要检索的元素的名称或索引来访问数组中的元素。返回值是对象相关，与自己的属性和元素，引用数组元素。他们可以访问<br><figure class=\"highlight js\"><figcaption><span>索引</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span> = Mail.windows.at(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">window</span> = Mail.windows[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure><br><figure class=\"highlight js\"><figcaption><span>name</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span> = Mail.windows.byName(<span class=\"string\">'New Message'</span>)</span><br><span class=\"line\"><span class=\"built_in\">window</span> = Mail.windows[<span class=\"string\">'New Message'</span>]</span><br></pre></td></tr></table></figure><br><figure class=\"highlight js\"><figcaption><span>ID</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span> = Mail.windows.byId(<span class=\"number\">412</span>)</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Note: 使用ID来访问不是方括号[]而是().</p>\n</blockquote>\n<h3 id=\"调用命令\"><a href=\"#调用命令\" class=\"headerlink\" title=\"调用命令\"></a>调用命令</h3><p>命令被称为函数。</p>\n<ol>\n<li>直接参数的函数，该参数作为命令的第一个参数传递。</li>\n<li>如果函数需要带参数名的参数，那么这个参数可以接受一个键值对对象。</li>\n<li>如果函数需要一个直接参数，就需要传递一个带参数名的参数作为第二个参数。</li>\n<li>如果函数不存在直接参数，那么带参数名的参数作为第一个参数传递，并且唯一参数。</li>\n<li>直接参数是可选的，可以不用传递任何值，当第一个参数存在参数名时，则传递NULL作为第一个参数。<figure class=\"highlight js\"><figcaption><span>无参数命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message.open()</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>无参数名的命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.open(message)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>带参数名的命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response = message.reply(&#123;</span><br><span class=\"line\">replayAll: <span class=\"literal\">true</span>,</span><br><span class=\"line\">openingWindow: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>Command with direct parameter and named parameters</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Safari.doJavaScript(<span class=\"string\">'alert(\"Hello world\")'</span>, &#123;</span><br><span class=\"line\"><span class=\"keyword\">in</span>: Safari.windows[<span class=\"number\">0</span>].tabs[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Creating-Objects\"><a href=\"#Creating-Objects\" class=\"headerlink\" title=\"Creating Objects\"></a>Creating Objects</h2><p>通过调用<code>类构造函数</code>初始化<code>属性</code>和<code>数据</code>来创建新对象。<br>在创建对象时,需要执行的其中步骤：</p>\n<ol>\n<li><code>make()</code>方法：调用对象上的<code>make()</code>方法来实例化对象。</li>\n<li><code>push()</code>方法：调用对象数组上的<code>push</code>方法来实例化对象。<br>在调用这些方法中的一个之前，对象实际上并不存在于应用程序中。</li>\n</ol>\n<h3 id=\"Create-a-new-object\"><a href=\"#Create-a-new-object\" class=\"headerlink\" title=\"Create a new object.\"></a>Create a new object.</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message = Mail.OutgoingMessage().make()</span><br></pre></td></tr></table></figure>\n<h3 id=\"Create-a-new-object-with-properties\"><a href=\"#Create-a-new-object-with-properties\" class=\"headerlink\" title=\"Create a new object with properties.\"></a>Create a new object with properties.</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message = Mail.OutgoingMessage(&#123;</span><br><span class=\"line\">subject: <span class=\"string\">'Hello world'</span>,</span><br><span class=\"line\">visible: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Mail.outgoingMessages.push(message)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Create-a-new-object-with-data\"><a href=\"#Create-a-new-object-with-data\" class=\"headerlink\" title=\"Create a new object with data.\"></a>Create a new object with data.</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">para = TextEdit.Paragraph(&#123;&#125;, <span class=\"string\">'Some text'</span>)</span><br><span class=\"line\">TextEdit.documents[<span class=\"number\">0</span>].paragraphs.push(para)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用对象\"><a href=\"#使用对象\" class=\"headerlink\" title=\"使用对象\"></a>使用对象</h3><p>一旦你在应用程序中创建一个新的对象（通过调用<code>make</code>或<code>push</code>），可以像任何现有的应用程序对象一样进行交互。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message = Mail.OutgoingMessage().make()</span><br><span class=\"line\">message.subject = <span class=\"string\">'Hello world'</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Scripting-Additions\"><a href=\"#Scripting-Additions\" class=\"headerlink\" title=\"Scripting Additions\"></a>Scripting Additions</h3><p>使用脚本添加（脚本插件）来增强应用程序的功能。操作系统有一套标准的脚本添加提供speak text,展示用户交互对话，等。<br>使用这些，必须明确设置<code>includeStandardAdditions</code>的<code>flag</code>为 <code>true</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app = Application.currentApplication()</span><br><span class=\"line\">app.includeStandardAdditions = <span class=\"literal\">true</span></span><br><span class=\"line\">app.say(<span class=\"string\">'Hello world'</span>)</span><br><span class=\"line\">app.displayDialog(<span class=\"string\">'Please enter your email address'</span>, &#123;</span><br><span class=\"line\">withTitle: <span class=\"string\">'Email'</span>,</span><br><span class=\"line\">defaultAnswer: <span class=\"string\">'your_email@site.com'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Applets\"><a href=\"#Applets\" class=\"headerlink\" title=\"Applets\"></a>Applets</h2><p>在<code>Script Editor</code>编写脚本并保存为一个应用程序，且可以被双击独立运行的程序称为<code>Applet</code>。<br>程序支持以下事件处理：<br>当Applet运行时，<code>run</code>处理事件被调用：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<p>用于拖放操作的<code>openDocuments</code>处理事件程序包配置小程序，当文档被拖放到该小程序上时，这个处理操作将被执行：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">openDocuments</span>(<span class=\"params\">docs</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><br>传递的参数是一个文件路径字符串数组。<br><a href=\"https://developer.apple.com/library/content/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/OSX10-10.html#//apple_ref/doc/uid/TP40014508-CH109-SW8\" target=\"_blank\" rel=\"noopener\">更多样例</a></p>\n<h2 id=\"UI-Automation\"><a href=\"#UI-Automation\" class=\"headerlink\" title=\"UI Automation\"></a>UI Automation</h2><p>通过编写系统事件应用程序，可以自动化应用程序的用户界面。在脚本编辑器<code>Script Editor</code>中浏览<code>System Events</code>的脚本字典，特别是进程套件<code>Processes Suite</code>，以查看支持此类型自动化的应用程序接口元素的列表。<br>下面的示例使用UI脚本创建Notes中的新注释。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Notes = Application(<span class=\"string\">'Notes'</span>)</span><br><span class=\"line\">Notes.activate()</span><br><span class=\"line\"></span><br><span class=\"line\">delay(<span class=\"number\">1</span>)</span><br><span class=\"line\">SystemEvents = Application(<span class=\"string\">'System Events'</span>)</span><br><span class=\"line\">Notes = SystemEvents.processes[<span class=\"string\">'Notes'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">Notes.windows[<span class=\"number\">0</span>].splitterGroups[<span class=\"number\">0</span>].groups[<span class=\"number\">1</span>].groups[<span class=\"number\">0</span>].buttons[<span class=\"number\">0</span>].click()</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"JS","path":"api/categories/JS.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"混编","path":"api/tags/混编.json"},{"name":"JavaScript","path":"api/tags/JavaScript.json"}]},{"title":"通过沙盒中JS脚本访问其他APP","slug":"macOS/通过沙盒中JS脚本访问其他APP","date":"2017-02-14T18:25:29.000Z","updated":"2017-02-16T13:43:01.000Z","comments":true,"path":"api/articles/macOS/通过沙盒中JS脚本访问其他APP.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>如何使用脚本字典里的命令和对象来与其他的应用进行通讯?<br>这个教程将向您展示现在使用 <code>AppleScript</code> 来控制别的应用的最佳方式。我也会告诉您一些小技巧以帮助您和您的用户用最小的努力就架设起 <code>AppleScript</code>。</p>\n<h2 id=\"在自己的APP中编写\"><a href=\"#在自己的APP中编写\" class=\"headerlink\" title=\"在自己的APP中编写\"></a>在自己的APP中编写</h2><h3 id=\"编写AppleScript代码\"><a href=\"#编写AppleScript代码\" class=\"headerlink\" title=\"编写AppleScript代码\"></a>编写AppleScript代码</h3><p><a href=\"https://developer.apple.com/library/mac/documentation/applescript/conceptual/applescriptlangguide/introduction/ASLR_intro.html#//apple_ref/doc/uid/TP40000983-CH208-SW1\" target=\"_blank\" rel=\"noopener\">AppleScript 脚本指南</a><br>与其他应用进行通讯的脚本一般来说都很短，也容易理解。<code>AppleScript</code> 可以被想做一种传送的机制，而不是一种处理环境。<br>典型脚本:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on chockify(inputString)</span><br><span class=\"line\">    set resultString to <span class=\"string\">\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        repeat <span class=\"keyword\">with</span> inputStringCharacter <span class=\"keyword\">in</span> inputString</span><br><span class=\"line\">            set asciiValue to (ASCII number inputStringCharacter)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (asciiValue &gt; <span class=\"number\">96</span> and asciiValue &lt; <span class=\"number\">123</span>) then</span><br><span class=\"line\">                set resultString to resultString &amp; (ASCII character (asciiValue - <span class=\"number\">32</span>))</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((asciiValue &gt; <span class=\"number\">64</span> and asciiValue &lt; <span class=\"number\">91</span>) or (asciiValue = <span class=\"number\">32</span>)) then</span><br><span class=\"line\">                    set resultString to resultString &amp; inputStringCharacter</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (asciiValue &gt; <span class=\"number\">47</span> and asciiValue &lt; <span class=\"number\">58</span>) then</span><br><span class=\"line\">                        set numberStrings to &#123;<span class=\"string\">\"ZERO\"</span>, <span class=\"string\">\"ONE\"</span>, <span class=\"string\">\"TWO\"</span>, <span class=\"string\">\"THREE\"</span>, <span class=\"string\">\"FOR\"</span>, <span class=\"string\">\"FIVE\"</span>, <span class=\"string\">\"SIX\"</span>, <span class=\"string\">\"SEVEN\"</span>, <span class=\"string\">\"EIGHT\"</span>, <span class=\"string\">\"NINE\"</span>&#125;</span><br><span class=\"line\">                        set itemIndex to asciiValue - <span class=\"number\">47</span></span><br><span class=\"line\">                        set numberString to item itemIndex <span class=\"keyword\">of</span> numberStrings</span><br><span class=\"line\">                        set resultString to resultString &amp; numberString &amp; <span class=\"string\">\" \"</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (asciiValue = <span class=\"number\">33</span>) then</span><br><span class=\"line\">                            set resultString to resultString &amp; <span class=\"string\">\" DUH\"</span></span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (asciiValue = <span class=\"number\">63</span>) then</span><br><span class=\"line\">                                set resultString to resultString &amp; <span class=\"string\">\" IF YOU KNOW WHAT I MEAN\"</span></span><br><span class=\"line\">                            end <span class=\"keyword\">if</span></span><br><span class=\"line\">                        end <span class=\"keyword\">if</span></span><br><span class=\"line\">                    end <span class=\"keyword\">if</span></span><br><span class=\"line\">                end <span class=\"keyword\">if</span></span><br><span class=\"line\">            end <span class=\"keyword\">if</span></span><br><span class=\"line\">        end repeat</span><br><span class=\"line\">        resultString</span><br><span class=\"line\">end chockify</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"创建事件描述符-event-descriptor\"><a href=\"#创建事件描述符-event-descriptor\" class=\"headerlink\" title=\"创建事件描述符 (event descriptor)\"></a>创建事件描述符 (event descriptor)</h3><ol>\n<li>导入Carbon.h<br>它有关于所有的 AppleEvent 的定义。<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Carbon/Carbon.h&gt;</span> // for AppleScript definitions</span></span><br></pre></td></tr></table></figure></li>\n<li>OC中创建<code>chockify</code>事件描述符<br>这是可以在你的脚本和应用之间互相传递的一个数据块。可以把它理解成一个封装好的会去执行某个事件的目标，一个将被调用的函数，以及这个函数的参数。使用一个 <code>NSString</code> 作为参数，创建<code>chockify</code>事件描述符：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSAppleEventDescriptor</span> *)chockifyEventDescriptorWithString:(<span class=\"built_in\">NSString</span> *)inputString</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// parameter</span></span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *parameter = [<span class=\"built_in\">NSAppleEventDescriptor</span> descriptorWithString:inputString];</span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *parameters = [<span class=\"built_in\">NSAppleEventDescriptor</span> listDescriptor];</span><br><span class=\"line\">    [parameters insertDescriptor:parameter atIndex:<span class=\"number\">1</span>]; <span class=\"comment\">// you have to love a language with indices that start at 1 instead of 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// target</span></span><br><span class=\"line\">    ProcessSerialNumber psn = &#123;<span class=\"number\">0</span>, kCurrentProcess&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *target = [<span class=\"built_in\">NSAppleEventDescriptor</span> descriptorWithDescriptorType:typeProcessSerialNumber bytes:&amp;psn length:<span class=\"keyword\">sizeof</span>(ProcessSerialNumber)];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// function</span></span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *function = [<span class=\"built_in\">NSAppleEventDescriptor</span> descriptorWithString:<span class=\"string\">@\"chockify\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// event</span></span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *event = [<span class=\"built_in\">NSAppleEventDescriptor</span> appleEventWithEventClass:kASAppleScriptSuite eventID:kASSubroutineEvent targetDescriptor:target returnID:kAutoGenerateReturnID transactionID:kAnyTransactionID];</span><br><span class=\"line\">    [event setParamDescriptor:function forKeyword:keyASSubroutineName];</span><br><span class=\"line\">    [event setParamDescriptor:parameters forKeyword:keyDirectObject];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> event;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"OC中加载-AppleScript\"><a href=\"#OC中加载-AppleScript\" class=\"headerlink\" title=\"OC中加载 AppleScript\"></a>OC中加载 AppleScript</h3><p>通过应用包(Application bundle)的一个 <code>URL</code> 可以创建 <code>NSAppleScript</code>的实例。而反过来，脚本也要和上面创建的 <code>chockify 事件描述符</code>一起使用。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURL</span> *URL = [[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"Automation\"</span> withExtension:<span class=\"string\">@\"scpt\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (URL) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAppleScript</span> *appleScript = [[<span class=\"built_in\">NSAppleScript</span> alloc] initWithContentsOfURL:URL error:<span class=\"literal\">NULL</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *event = [<span class=\"keyword\">self</span> chockifyEventDescriptorWithString:[<span class=\"keyword\">self</span>.chockifyInputTextField stringValue]];</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *error = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *resultEventDescriptor = [appleScript executeAppleEvent:event error:&amp;error];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! resultEventDescriptor) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s AppleScript run error = %@\"</span>, __PRETTY_FUNCTION__, error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> *string = [<span class=\"keyword\">self</span> stringForResultEventDescriptor:resultEventDescriptor];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> updateChockifyTextFieldWithString:string];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如果一切正常的话，你会得到另一个事件描述符。如果出错了，你会得到一个包含了描述错误信息的字典。虽说这个模式和很多其他 <code>Foundation 类</code>很相似，但是返回的错误并不是一个 <code>NSError</code> 的实例。</p>\n<h3 id=\"调用事件描述符\"><a href=\"#调用事件描述符\" class=\"headerlink\" title=\"调用事件描述符\"></a>调用事件描述符</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)stringForResultEventDescriptor:(<span class=\"built_in\">NSAppleEventDescriptor</span> *)resultEventDescriptor</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *result = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resultEventDescriptor)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([resultEventDescriptor descriptorType] != kAENullEvent)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ([resultEventDescriptor descriptorType] == kTXNUnicodeTextData) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result = [resultEventDescriptor stringValue];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>InputString 输入可以被正确整形输出，并且你现在也看到想在你的应用里运行 AppleScripts 的方法</p>\n<h2 id=\"调用沙盒中脚本代码与访问其他应用\"><a href=\"#调用沙盒中脚本代码与访问其他应用\" class=\"headerlink\" title=\"调用沙盒中脚本代码与访问其他应用\"></a>调用沙盒中脚本代码与访问其他应用</h2><h3 id=\"了解APP沙盒限制\"><a href=\"#了解APP沙盒限制\" class=\"headerlink\" title=\"了解APP沙盒限制\"></a>了解APP沙盒限制</h3><p>如果一段脚本可以轻易地拿到浏览器当前页面上的内容，甚至是在任意标签和窗口运行<code>JavaScript</code>。想象一下如果这些页面里有你的银行账号，或者包含你的信用卡信息什么的。</p>\n<p>对于沙盒应用，Apple 所提倡的是通过用户的需要来驱动安全策略。这意味着是否运行你的脚本完全取决于用户。这些脚本可能是来自互联网，也可能是你应用的一部分。一旦得到了权限，脚本就可以以一种受限的方式与系统其他部分进行交互了。<code>NSUserScriptTask</code>使这一切变得可能。<br>由此：Apple 引入了一个新的抽象类 <code>NSUserScriptTask</code>,有三个具体的子类实现:</p>\n<ol>\n<li><code>NSUserUnixTask</code>: 执行 Unix shell 命令</li>\n<li><code>NSUserAutomatorTask</code>: Automator 工作流</li>\n<li><code>NSUserAppleScriptTask</code>:执行<code>AppleScript脚本</code>,脚本是异步执行的,所以脚本不能对用户界面做更新操作。</li>\n</ol>\n<h3 id=\"开始安装运行脚本\"><a href=\"#开始安装运行脚本\" class=\"headerlink\" title=\"开始安装运行脚本\"></a>开始安装运行脚本</h3><p>怎么向用户请求运行脚本的许可，让你的应用与用户的其他应用更好地工作在一起？<br>两种策略:</p>\n<ol>\n<li>帮助用户来存放运行脚本的位置</li>\n<li>获取行脚本目录可读写</li>\n</ol>\n<h4 id=\"帮用户存放运行脚本的位置\"><a href=\"#帮用户存放运行脚本的位置\" class=\"headerlink\" title=\"帮用户存放运行脚本的位置\"></a>帮用户存放运行脚本的位置</h4><p>只能把把这些脚本放到用户的脚本文件夹(<code>User &gt; Library &gt; Application Scripts/bundle identifier/</code>)中，以只读的方式来运行你的脚本。<br>脚本想要进入这个特定的文件夹的唯一方式就是用用户把它们复制到那里。再者<code>Library 文件夹</code>在 OS X 里默认还是隐藏的。这样对用户都很不友好。<br>让代码来帮助用户打开这个隐藏文件夹：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\"><span class=\"built_in\">NSURL</span> *directoryURL = [[<span class=\"built_in\">NSFileManager</span> defaultManager] URLForDirectory:<span class=\"built_in\">NSApplicationScriptsDirectory</span> inDomain:<span class=\"built_in\">NSUserDomainMask</span> appropriateForURL:<span class=\"literal\">nil</span> create:<span class=\"literal\">YES</span> error:&amp;error];</span><br><span class=\"line\">[[<span class=\"built_in\">NSWorkspace</span> sharedWorkspace] openURL:directoryURL];</span><br></pre></td></tr></table></figure><br>通过你的应用的某个控件打开这个文件夹，然后进行编辑。这对于用户自己写的脚本来说是个很好的解决方案。</p>\n<h4 id=\"设置运行脚本目录的读写权限\"><a href=\"#设置运行脚本目录的读写权限\" class=\"headerlink\" title=\"设置运行脚本目录的读写权限\"></a>设置运行脚本目录的读写权限</h4><ol>\n<li>在 Xcode 里，你需要更新 <code>Capabilities</code>，让其包括 <code>User Selected File to Read/Write</code>。在 <code>App Sandbox &gt; File Access</code>里找到相关选项。</li>\n<li>用户的意愿是关键，因为你需要获取权限以将脚本添加到文件夹：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\"><span class=\"built_in\">NSURL</span> *directoryURL = [[<span class=\"built_in\">NSFileManager</span> defaultManager] URLForDirectory:<span class=\"built_in\">NSApplicationScriptsDirectory</span> inDomain:<span class=\"built_in\">NSUserDomainMask</span> appropriateForURL:<span class=\"literal\">nil</span> create:<span class=\"literal\">YES</span> error:&amp;error];</span><br><span class=\"line\"><span class=\"built_in\">NSOpenPanel</span> *openPanel = [<span class=\"built_in\">NSOpenPanel</span> openPanel];</span><br><span class=\"line\">[openPanel setDirectoryURL:directoryURL];</span><br><span class=\"line\">[openPanel setCanChooseDirectories:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">[openPanel setCanChooseFiles:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">[openPanel setPrompt:<span class=\"string\">@\"Select Script Folder\"</span>];</span><br><span class=\"line\">[openPanel setMessage:<span class=\"string\">@\"Please select the User &gt; Library &gt; Application Scripts &gt; com.iconfactory.Scriptinator folder\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">[openPanel beginWithCompletionHandler:^(<span class=\"built_in\">NSInteger</span> result) &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (result == <span class=\"built_in\">NSFileHandlingPanelOKButton</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *selectedURL = [openPanel URL];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([selectedURL isEqual:directoryURL])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSURL</span> *destinationURL = [selectedURL URLByAppendingPathComponent:<span class=\"string\">@\"Automation.scpt\"</span>];</span><br><span class=\"line\">        <span class=\"built_in\">NSFileManager</span> *fileManager = [<span class=\"built_in\">NSFileManager</span> defaultManager];</span><br><span class=\"line\">        <span class=\"built_in\">NSURL</span> *sourceURL = [[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"Automation\"</span> withExtension:<span class=\"string\">@\"scpt\"</span>];</span><br><span class=\"line\">        <span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\">        <span class=\"built_in\">BOOL</span> success = [fileManager copyItemAtURL:sourceURL toURL:destinationURL error:&amp;error];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (success)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSAlert</span> *alert = [<span class=\"built_in\">NSAlert</span> alertWithMessageText:<span class=\"string\">@\"Script Installed\"</span> defaultButton:<span class=\"string\">@\"OK\"</span> alternateButton:<span class=\"literal\">nil</span> otherButton:<span class=\"literal\">nil</span> informativeTextWithFormat:<span class=\"string\">@\"The Automation script was installed succcessfully.\"</span>];</span><br><span class=\"line\">            [alert runModal];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s error = %@\"</span>, __PRETTY_FUNCTION__, error);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ([error code] == <span class=\"built_in\">NSFileWriteFileExistsError</span>) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// this is where you could update the script, by removing the old one and copying in a new one</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// the item couldn't be copied, try again</span></span><br><span class=\"line\">                [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(installAutomationScript:) withObject:<span class=\"keyword\">self</span> afterDelay:<span class=\"number\">0.0</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// try again because the user changed the folder path</span></span><br><span class=\"line\">        [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(installAutomationScript:) withObject:<span class=\"keyword\">self</span> afterDelay:<span class=\"number\">0.0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n这么一来，应用包中的 <code>Automation.scpt</code> 文件现在暴露在常规的文件系统中了。</li>\n</ol>\n<h3 id=\"执行脚本任务\"><a href=\"#执行脚本任务\" class=\"headerlink\" title=\"执行脚本任务\"></a>执行脚本任务</h3><p>使用 <code>NSUserAppleScriptTask</code> 来替代 <code>NSAppleScript</code>，来运行上面创建的<code>事件描述符</code>。<br>你大概会经常用到这些脚本任务。文档警告说对于给定的类的某个实例， <code>NSUserAppleScriptTask</code> 不应该被执行多次。所以写一个<code>工厂函数</code>来在需要的时候创建任务：<br><figure class=\"highlight objc\"><figcaption><span>工厂函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSUserAppleScriptTask</span> *)automationScriptTask</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSUserAppleScriptTask</span> *result = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *directoryURL = [[<span class=\"built_in\">NSFileManager</span> defaultManager] URLForDirectory:<span class=\"built_in\">NSApplicationScriptsDirectory</span> inDomain:<span class=\"built_in\">NSUserDomainMask</span> appropriateForURL:<span class=\"literal\">nil</span> create:<span class=\"literal\">YES</span> error:&amp;error];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (directoryURL) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSURL</span> *scriptURL = [directoryURL URLByAppendingPathComponent:<span class=\"string\">@\"Automation.scpt\"</span>];</span><br><span class=\"line\">        result = [[<span class=\"built_in\">NSUserAppleScriptTask</span> alloc] initWithURL:scriptURL error:&amp;error];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! result) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s no AppleScript task error = %@\"</span>, __PRETTY_FUNCTION__, error);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> if you're not running in a sandbox, the directory URL will always be nil</span></span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s no Application Scripts folder error = %@\"</span>, __PRETTY_FUNCTION__, error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>如果你正在写一个同时适用于沙盒和非沙盒的 Mac 应用的话，在获取 <code>directoryURL</code> 时你需要特别小心。<code>NSApplicationScriptsDirectory</code>只在沙盒中有效。</p>\n</blockquote>\n<p>在创建脚本任务后，你需要使用 <code>AppleEvent</code> 并提供一个结束处理来执行它：<br><figure class=\"highlight objc\"><figcaption><span>AppleEvent</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSUserAppleScriptTask</span> *automationScriptTask = [<span class=\"keyword\">self</span> automationScriptTask];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (automationScriptTask) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *event = [<span class=\"keyword\">self</span> safariURLEventDescriptor];</span><br><span class=\"line\">    [automationScriptTask executeWithAppleEvent:event completionHandler:^(<span class=\"built_in\">NSAppleEventDescriptor</span> *resultEventDescriptor, <span class=\"built_in\">NSError</span> *error) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! resultEventDescriptor) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s AppleScript task error = %@\"</span>, __PRETTY_FUNCTION__, error);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSURL</span> *URL = [<span class=\"keyword\">self</span> URLForResultEventDescriptor:resultEventDescriptor];</span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> The completion handler for the script is not run on the main thread. Before you update any UI, you'll need to get</span></span><br><span class=\"line\">            <span class=\"comment\">// on that thread by using libdispatch or performing a selector.</span></span><br><span class=\"line\">            [<span class=\"keyword\">self</span> performSelectorOnMainThread:<span class=\"keyword\">@selector</span>(updateURLTextFieldWithURL:) withObject:URL waitUntilDone:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>对于用户写的脚本，用户可能期望你的应用只是简单地’运行’脚本 (而不去调用事件描述符中指定的函数)。在这种情况下，你可以为 <code>event</code> 传递一个 <code>nil</code>，脚本就会像用户在 <code>Finder</code> 中双击那样的行为进行执行。<br><code>NSUserAppleScriptTask</code>脚本是异步执行的，所以你的用户界面并不会被一个 (比较长) 的脚本锁住，在结束后会执行回调处理。</p>\n<h2 id=\"同步操作\"><a href=\"#同步操作\" class=\"headerlink\" title=\"同步操作\"></a>同步操作</h2><p><code>NSAppleScript</code> 和 <code>NSUserAppleScriptTask</code> 有一个微妙的区别：新的机制是异步执行的。对于大部分情况，使用一个结束回调来处理会是一个好得多的方式，因为这样就不会因为执行脚本而阻碍你的应用。<br>然而有时候如果你想带有依赖地来执行任务的时候，事情就变得有些取巧了。比方说一个任务需要在另一个任务开始之前必须完成。这种情况下你就会想念 <code>NSAppleScript</code> 的同步特性了。<br>要获得传统方式的行为，一种简单的方法是使用一个<code>信号量(semaphore)</code> 来确保同时只有一个任务运行、在你的类或者应用的初始化方法中，使用 <code>libdispatch</code> 创建一个信号量：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.appleScriptTaskSemaphore = dispatch_semaphore_create(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure><br>接下来在初始化脚本任务之前，简单地等待信号量。当任务完成时，标记相同的这个信号量：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// wait for any previous tasks to complete before starting a new one — remember that you're blocking the main thread here!</span></span><br><span class=\"line\">dispatch_semaphore_wait(<span class=\"keyword\">self</span>.appleScriptTaskSemaphore, DISPATCH_TIME_FOREVER);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// run the script task</span></span><br><span class=\"line\"><span class=\"built_in\">NSAppleEventDescriptor</span> *event = [<span class=\"keyword\">self</span> openNetworkPreferencesEventDescriptor];</span><br><span class=\"line\">[automationScriptTask executeWithAppleEvent:event completionHandler:^(<span class=\"built_in\">NSAppleEventDescriptor</span> *resultEventDescriptor, <span class=\"built_in\">NSError</span> *error) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! resultEventDescriptor)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s AppleScript task error = %@\"</span>, __PRETTY_FUNCTION__, error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> performSelectorOnMainThread:<span class=\"keyword\">@selector</span>(showNetworkAlert) withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// the task has completed, so let any pending tasks proceed</span></span><br><span class=\"line\">    dispatch_semaphore_signal(<span class=\"keyword\">self</span>.appleScriptTaskSemaphore);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure><br>再强调一下，除非确实有所需要，否则最好别这么做。</p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"JS","path":"api/categories/JS.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"沙盒","path":"api/tags/沙盒.json"},{"name":"脚本","path":"api/tags/脚本.json"},{"name":"AppleScript","path":"api/tags/AppleScript.json"}]},{"title":"macOS之PDFKit基础","slug":"macOS/macOS之PDFKit基础","date":"2017-02-14T14:29:18.000Z","updated":"2018-01-08T14:10:41.000Z","comments":true,"path":"api/articles/macOS/macOS之PDFKit基础.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/view_vspage_space.gif?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>一个PDF的基本构建块是Documents本身。Documents通常作为文件存储在磁盘上。<br>作为文件版本，可以支持元数据标记如作者，创建日期，等等。<br>一个文件可以加密，需要密码才能查看它。两级加密存在：</p>\n<ul>\n<li>用户级加密：如果用户成功地获得用户级权限，他或她可以查看文档，但可以限制打印或复制文档。</li>\n<li>所有者级别加密：获得所有者级别权限的用户可以查看文档并具有完全使用权限。<br>许多加密的PDF文件有一个“dummy”的用户密码为<code>空字符串</code>。大多数PDF文档解析器（包括PDF套件）自动尝试空字符串密码加密后的文件，如果成功，只显示文档。因此，在技术上加密的文档不一定提示用户口令。</li>\n</ul>\n<h2 id=\"PDF页面\"><a href=\"#PDF页面\" class=\"headerlink\" title=\"PDF页面\"></a>PDF页面</h2><p>一个PDF文档由若干页面组成。这个页面看起来就像一本物理书页面显示在屏幕上。同时PDF页面可以包含<code>超链接</code>和<code>注释</code>。页面可以支持<code>裁剪</code>，还有其他使用功能：例如隐藏多余的部分（如注册标记）。</p>\n<h3 id=\"view-VS-page空间坐标\"><a href=\"#view-VS-page空间坐标\" class=\"headerlink\" title=\"view VS page空间坐标\"></a>view VS page空间坐标</h3><p>页面上的大多数对象都是在<code>page</code>空间中指定的，而不是在<code>view</code>空间中。<br>也就是说，坐标系统是在点（每英寸72点），<code>坐标原点</code>在page左侧底部，而不是<code>view</code>。<code>page</code>空间不关心缩放，显示模式等等。一个有<code>bounds</code>的item，比如说32points，保留这些界限，无论显示大小。<br>图view和page坐标系比较<br><img title=\"view和page坐标系比较\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/view_vspage_space.gif?imageMogr2/2/w/800\"><br><code>PDFView class</code>包含几个转换方法，将坐标系统从<code>view space</code>的<code>page space</code>，反之亦然。</p>\n<h2 id=\"PDF-Kit-Classes\"><a href=\"#PDF-Kit-Classes\" class=\"headerlink\" title=\"PDF Kit Classes\"></a>PDF Kit Classes</h2><p><code>PDF Kit</code>套件提供了几个不同功能的<code>类</code>。<br><code>PDFView</code>和<code>PDFSelection</code>除外，这些<code>类</code>大致对应着各个<code>对象</code>在PDF格式的规范需求。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/pdfkit_inheritancehierarchy.gif?imageMogr2/2/w/800\"></p>\n<h3 id=\"PDFView-Class\"><a href=\"#PDFView-Class\" class=\"headerlink\" title=\"PDFView Class\"></a>PDFView Class</h3><p><code>PDFView类</code>，就好比Web工具包的<code>WebView类</code>，源于<code>Application Kit</code>中的<code>NSView类</code>。在项目开发中，你可以使用<code>Interface Builder</code>轻松拖动一个<code>PDFView对象</code>放在一个window中。<del>从/Developer/Extras/Palettes/PDFKit.palette得到调色板。</del><br><code>PDFView</code>可能是<code>PDF Kit</code>中唯一个需要你自定义的的类。在APP中显示PDF数据，允许用户选择文档内容和导航浏览PDF文档，设置缩放级别，复制文本内容到剪贴板。用户可以拖放PDF文档到<code>PDFView</code>。<br><code>PDFView</code>能通过调用其他<code>PDF实用类</code>来实现其大部分功能。如果要添加特殊功能，则需要用户自定义<code>实用类</code>的子类来扩展其特殊功能。<br>Utility classes as used by PDFView<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/pdfkit_uses_hierarchy.gif?imageMogr2/2/w/800\"></p>\n<h3 id=\"PDF-Kit-Utility-Classes\"><a href=\"#PDF-Kit-Utility-Classes\" class=\"headerlink\" title=\"PDF Kit Utility Classes\"></a>PDF Kit Utility Classes</h3><p>PDF套件工具类提供一种混合的<code>Foundation-like</code>和<code>Application Kit-like</code>的行为。他们有类似的<code>NSString类</code>和<code>NSString Additions</code>方法。这些类都系橙自<code>NSObject</code><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/pdfkit_inheritancehierarchy.gif?imageMogr2/2/w/800\"></p>\n<h4 id=\"PDF-Document\"><a href=\"#PDF-Document\" class=\"headerlink\" title=\"PDF Document\"></a>PDF Document</h4><p><code>PDFDocument</code>是<code>PDF kit工具类</code>中重要类，代表着PDF data或PDF文件。其他实用工具类一般都在<code>PDFDocument</code>方法中的实例化。是<code>PDFPage</code>和<code>PDFOutline</code>；或相关支持操作：<code>PDFSelection</code>和<code>PDFDestination</code>。<br>你<code>PDFDocument对象</code>初始化，需要一个<code>PDF数据</code>或一个指向PDF文件的<code>URL</code>。实例化之后就可以访问<code>页数</code>，<code>添加</code>或<code>删除</code>页面，对所选内容为<code>NSString对象</code>进行<code>查找</code>或<code>分析</code>。</p>\n<h4 id=\"PDFPage\"><a href=\"#PDFPage\" class=\"headerlink\" title=\"PDFPage\"></a>PDFPage</h4><p><code>PDFPage</code>代表一个PDF文档的页面。你的应用程序获取一个<code>PDFPage</code>对象必须通过从<code>PDFDocument</code>对象来实例化。<code>PDFPage</code>对象是用户所看到的屏幕，和一个<code>view</code>可以同时显示多个<code>page</code>。你可以使用<code>PDFPage</code>把PDF文档内容渲染到屏幕上，添加<code>注释</code>，<code>计数字符串</code>，定义<code>选择</code>，获取一个<code>page</code>中的文本内容作为<code>NSString对象</code>或<code>NSAttributedString对象</code>。</p>\n<h4 id=\"PDFOutline\"><a href=\"#PDFOutline\" class=\"headerlink\" title=\"PDFOutline\"></a>PDFOutline</h4><p>除了显示实际的文件内容，<code>PDF Kit</code>也能呈现<code>PDFOutline</code>信息，前提是PDF文档中存在目录结构。在目录结构中，一个<code>PDFOutline对象</code>代表一个<code>父目录</code>或<code>子目录</code>。<br>目录是由一个层次的<code>PDFOutline对象</code>组层。顶层是<code>根目录对象</code>，它仅作为其他目录对象的容器。用户的<code>根目录</code>是不可见的。</p>\n<h4 id=\"PDFSelection\"><a href=\"#PDFSelection\" class=\"headerlink\" title=\"PDFSelection\"></a>PDFSelection</h4><p>一个<code>PDFSelection</code>对象包含一个跨PDF文档中文本。你不要直接创建<code>PDFSelection</code>。<code>PDFSelection</code>对象是作为返回值来实例化的。例如：通过调用<code>PDFPage</code>或<code>PDFDocument</code>对象中的selection方法，并从成功搜索的返回值来实例化<code>PDFSelection</code>对象。<br>在同时显示多个<code>PDFPage</code>的<code>PDFView</code>中，<code>PDFSelection</code>可以是不连续的，或两者兼具的。例如，可以选择在一个单柱连续两列页面的文本。可以在任何方向从一个选择区, 合并选择区, 或扩展选择区中得到文本和网页覆盖。</p>\n<h4 id=\"PDFAnnotation\"><a href=\"#PDFAnnotation\" class=\"headerlink\" title=\"PDFAnnotation\"></a>PDFAnnotation</h4><p>一个<code>PDFAnnotation</code>对象可以表示多种内容以外，在一个PDF文件的主要文本内容：链接、表单元素，突出圈子，等等。每个注释与页面上的特定位置相关，并且可以与用户提供交互性。<br><code>PDFAnnotation</code>是如图所示的具体类的抽象类。各种具体类代表<code>PDF Kit</code>支持的注释类型。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/annotations.gif?imageMogr2/2/w/800\"></p>\n<h4 id=\"PDFBorder\"><a href=\"#PDFBorder\" class=\"headerlink\" title=\"PDFBorder\"></a>PDFBorder</h4><p><code>PDFBorder</code>对象封装的拉伸<code>PDFAnnotation</code>对象边框的行为。可以定义一个PDF的bord线的风格属性（例如，固体，破灭，或斜面），bord线的宽度，和圆角半径。</p>\n<p>过期:<del>从/Developer/Extras/Palettes/PDFKit.palette得到调色板。</del><br>Here’s what Apple says about it:<br><blockquote><p>“To add the PDFKit palette in Interface Builder, select the Palettes tab in the Preferences panel. Click the Add<br>button, navigate to the /Developer/Extras/Palettes folder, and select the PDFKit palette. Next, select the Customize Toolbar menu item in the Tools/Palettes menu and drag the PDFKit palette to the toolbar to make it visible.”</p>\n<footer><strong>老文档</strong><cite><a href=\"http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Conceptual/PDFKitGuide/PDFKit_Prog_Tasks/PDFKit_Prog_Tasks.html\" target=\"_blank\" rel=\"noopener\">PDFKit_Prog_Tasks</a></cite></footer></blockquote><br>So:<br>there’s no Palettes tab anywhere in the Preferences panel and the Xcode Help return a blank when searching for it.<br>There’s no PDFKit.palette file anywhere on my HD (says Spotlight).<br>I guess these instructions are for an older version of XCode but it’s all Apple seemed to have on it…</p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"PDF","path":"api/categories/PDF.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"PDF","path":"api/tags/PDF.json"},{"name":"阅读器","path":"api/tags/阅读器.json"}]}]}