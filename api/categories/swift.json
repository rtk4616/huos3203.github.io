{"name":"swift","postlist":[{"title":"Framework:实现使用swift开发","slug":"swift/Framework:实现使用swift开发","date":"2018-06-23T16:41:58.000Z","updated":"2018-06-23T16:41:58.000Z","comments":true,"path":"api/articles/swift/Framework:实现使用swift开发.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/IMG_3714.JPG?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><!--github库卡片-->\n<div id=\"badge-container-huos3203-JHHomeAPP-813e4b\" class=\"hexo-github\" style=\"width: =\"></div>\n<script src=\"/hexo-github/badge.js\"></script>\n<script type=\"text/javascript\">\n  loadStyle(\"/hexo-github/style.css\");\n  loadStyle(\"/hexo-github/octicons/octicons.css\");\n  new Badge(\"#badge-container-huos3203-JHHomeAPP-813e4b\", \"huos3203\", \"JHHomeAPP\", \"813e4b\", false);\n</script>\n\n<p>设想：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/IMG_3714.JPG?imageMogr2/2/w/800\"></p>\n<h3 id=\"创建三个角色\"><a href=\"#创建三个角色\" class=\"headerlink\" title=\"创建三个角色\"></a>创建三个角色</h3><ol>\n<li>主项目：<code>JHHomeAPP</code></li>\n<li>静态库组件：<code>FirstPlug</code> <ul>\n<li><code>SwiftInStaticLib</code>(包含Swift源码实现的静态库)</li>\n</ul>\n</li>\n<li>动态库<code>secondFramework</code></li>\n</ol>\n<h3 id=\"静态库：问题1\"><a href=\"#静态库：问题1\" class=\"headerlink\" title=\"静态库：问题1\"></a>静态库：问题1</h3><p>当静态库组件中存在swift源码时，依赖该组件的主工程会报错：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ld: warning: Auto-Linking library not found for -lswiftDispatch</span><br><span class=\"line\">ld: warning: Auto-Linking library not found for -lswiftCoreFoundation</span><br><span class=\"line\">ld: warning: Auto-Linking library not found for -lswiftObjectiveC</span><br><span class=\"line\">ld: warning: Auto-Linking library not found for -lswiftDarwin</span><br><span class=\"line\">ld: warning: Auto-Linking library not found for -lswiftFoundation</span><br><span class=\"line\">ld: warning: Auto-Linking library not found for -lswiftCoreGraphics</span><br><span class=\"line\">ld: warning: Auto-Linking library not found for -lswiftCore</span><br><span class=\"line\">ld: warning: Auto-Linking library not found for -lswiftSwiftOnoneSupport</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>联想方法：<br>设置 <code>Always Embed Swift Standard Libraries</code>: <code>YES</code><br>结果无效。</li>\n<li>适用的解决方法<br>在主工程中新建一个空的swift源文件，不需要自动新建<code>$(SWIFT_MODULE_NAME)-Swift.h</code>映射文件和<code>JHHomeAPP/JHHomeAPP-Bridging-Header.h</code>头文件。<br><strong>使用方法2，问题1就不存在了，证明了在静态库中可以使用swift源码文件进行开发,同样证明了静态库可以封装包含swift源码的静态库。</strong></li>\n</ol>\n<h3 id=\"Framework：问题2\"><a href=\"#Framework：问题2\" class=\"headerlink\" title=\"Framework：问题2\"></a>Framework：问题2</h3><ol>\n<li>在动态库中objc源码方法可以封装到静态库，并在可执行文件中调用。</li>\n<li>当在Framework中新建swift源文件时，第一次编译运行出现崩溃问题：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dyld: Library not loaded: @rpath/libswiftCoreImage.dylib</span><br><span class=\"line\">Referenced from: .../../Debug-iphonesimulator/SecondFramework.framework/SecondFramework</span><br><span class=\"line\">Reason: image not found</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>解决办法：需要在<code>ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES</code>设置为<code>YES</code>.再次编译出现问题3。</p>\n<h3 id=\"Framework-问题3\"><a href=\"#Framework-问题3\" class=\"headerlink\" title=\"Framework: 问题3\"></a>Framework: 问题3</h3><p>当在oc源码文件中用引用<code>-Swift.h</code>头文件时，出现一下问题:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;SecondFramework-Swift.h&apos; file not found</span><br><span class=\"line\">#import &quot;SecondFramework-Swift.h&quot;</span><br><span class=\"line\">^~~~~~~~~~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure></p>\n<p>结果将：<code>Install Objective-C Compatibility Header</code> : <code>NO</code>可以正常调用swift方法了。</p>\n<blockquote>\n<p>验证：framework可以封装到静态库中，当有swift源码实现时需要设置ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES=YES</p>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>Product Module Name: 该项默认为项目名或自定义的名称</li>\n<li>Defines Module: 设置为YES （framework默认为YES，静态库默认为NO）</li>\n<li>Embedded Content Contains Swift: 设置为YES</li>\n<li>Install Objective-C Compatibility Header：设置为YES （如上题说：在framework中设置为NO，才能正常运行，在静态库中似乎不影响）</li>\n<li>Objective-C Bridging Header: 自定义需要桥接到Swift中的OC头文件（EX：$(SRCROOT)/Swift-Bridging-Header.h）</li>\n</ol>\n","raw":null,"categories":[{"name":"swift","path":"api/categories/swift.json"}],"tags":[]},{"title":"Objective-C的运行时以及swift的动态性","slug":"swift/Objective-C的运行时以及swift的动态性","date":"2017-09-25T20:01:36.000Z","updated":"2017-10-02T22:00:42.000Z","comments":true,"path":"api/articles/swift/Objective-C的运行时以及swift的动态性.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"Objective-C-运行时\"><a href=\"#Objective-C-运行时\" class=\"headerlink\" title=\"Objective-C 运行时\"></a>Objective-C 运行时</h2><p>Objective-C 是一门基于运行时的编程语言，这意味着所有方法、变量、类之间的链接，都会推迟到应用实际运行的最后一刻才会建立。这将给开发人员极高的灵活性，因为我们可以修改这些链接。而不同的是，Swift 绝大多数时候是一门面向编译时的语言。因此在 Swift 当中，灵活性受到了限制，不过您会因此得到更多的安全性。</p>\n<h3 id=\"runtime-h开源库\"><a href=\"#runtime-h开源库\" class=\"headerlink\" title=\"runtime.h开源库\"></a>runtime.h开源库</h3><p>Objective-C 的运行时本质上是一个库。它负责了 “Objective” 这个部分，因此您所知、所爱的面向对象编程，都是在这里实现的。如果您想要访问里面的函数的话，只需要导入这个库即可：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>runtime.h</code>开源库主要由 C 和汇编编写而成，其实现了诸如类、对象、方法调度、协议等面向对象编程这个部分。</p>\n<h4 id=\"构建模块\"><a href=\"#构建模块\" class=\"headerlink\" title=\"构建模块\"></a>构建模块</h4><h5 id=\"对象结构体\"><a href=\"#对象结构体\" class=\"headerlink\" title=\"对象结构体\"></a>对象结构体</h5><p>那么什么是对象呢？对象在 runtime.h 当中是这样定义的：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_class *Class;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> objc_object &#123;</span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>isa</strong>:建立<code>对象</code>只与一个类引用关联，也就是这个 isa 的意思所在。这也就是 Objective-C 当中的所有对象都需要实现的。</p>\n<h5 id=\"类结构体\"><a href=\"#类结构体\" class=\"headerlink\" title=\"类结构体\"></a>类结构体</h5><p>那么类又是什么呢？类的定义要稍微复杂一些。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_class &#123;</span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">    Class super_class;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> version;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> info;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> instance_size;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_ivar_list *ivars;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list **methodLists;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_cache *cache;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *protocols;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>属性说明：<br><strong>isa</strong>属性：建立自身与 <code>super_class</code> 这个值进行关联。<br><strong>super_class</strong>:除了 NSObject 这个类之外，super_class 的值永远不会为 nil，因为 Objective-C 当中的其余类都是以某种方式继承自 NSObject 的。<br><strong>ivars</strong>：变量列表<br><strong>methodLists</strong>：方法列表<br><strong>protocols</strong>：协议列表<br>其他属性：<code>name</code>、<code>version</code>、<code>info</code> 之类的值，不过这些并不是我们感兴趣的内容。<br>这些就是我们能在运行时修改和读取的。可以看到，对象其实本质上是一个非常简单的结构体，类同样也是。</p>\n<h3 id=\"allocateClassPair函数创建类\"><a href=\"#allocateClassPair函数创建类\" class=\"headerlink\" title=\"allocateClassPair函数创建类\"></a>allocateClassPair函数创建类</h3><p>我们可以借助运行时函数，从而在运行时动态创建类。</p>\n<ol>\n<li>要用的 Objective-C 运行时函数：<code>allocateClassPair</code>。提供三个参数即可：<br><strong>isa</strong>：关联引用，这里提供了NSObject<br>类名：<br>额外字节的定义：通常我们都直接赋值 0 即可</li>\n<li>添加变量、方法以及协议</li>\n<li><code>registerClassPair</code>注册这个 ClassPair,注册之后，我们就无法修改变量列表了，不过其余的内容仍然可以修改。</li>\n<li>初始化类结束~我们所创建的这个类和其余的 Objective-C 类毫无区别。<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类函数的构造器</span></span><br><span class=\"line\">Class myClass = objc_allocateClassPair([<span class=\"built_in\">NSObject</span> <span class=\"keyword\">class</span>], <span class=\"string\">\"MyClass\"</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在这里添加变量、方法和协议</span></span><br><span class=\"line\"></span><br><span class=\"line\">objc_registerClassPair(myClass);</span><br><span class=\"line\"><span class=\"comment\">// 当类注册之后，变量列表将会被锁定</span></span><br><span class=\"line\"></span><br><span class=\"line\">[[myClass alloc] init];</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>我们为什么要这么做呢？因为这个函数被大量运用在库提供者制作的框架当中。如果您无法知道用户将会创建什么样的数据，那么您就需要在运行时进行类的创建了。Core Data 就使用了这个功能。此外，如果您愿意的话，它还可以用在 JSON 解析当中。</p>\n<h3 id=\"在类别中添加存储属性\"><a href=\"#在类别中添加存储属性\" class=\"headerlink\" title=\"在类别中添加存储属性\"></a>在类别中添加存储属性</h3><p>如果您想要扩展一个不是自己创建的类，想要向其中添加函数，有一个便捷的方法便是使用 Objective-C 的类别 (Category) 特性。Swift 的扩展与之非常相似。类别的一个问题便在于，它无法添加存储属性。您可以添加一个计算属性，但是存储属性是无法添加的。</p>\n<p>运行时的另一个特性便是：我们可以借助 <code>setAssociatedObject</code> 和 <code>getAssociatedObject</code> 这两个函数，向既有的类当中添加存储属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation NSObject (AssociatedObject)</span><br><span class=\"line\">@dynamic associatedObject;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setAssociatedObject:(id)object &#123;</span><br><span class=\"line\">    objc_setAssociatedObject(self, @selector(associatedObject), object,</span><br><span class=\"line\">    OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (id)associatedObject &#123;</span><br><span class=\"line\">    return objc_getAssociatedObject(self, @selector(associatedObject));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对于不是自己创建的类而言，使用这个方法进行扩展无疑是非常好用的。</p>\n<h3 id=\"内省机制\"><a href=\"#内省机制\" class=\"headerlink\" title=\"内省机制\"></a>内省机制</h3><p>「内省 (introspection)」机制是用来判别这个类能执行何种操作。通常，我们所使用的往往是最基础的内省功能。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类成员判断</span></span><br><span class=\"line\">[myObject isMemberOfClass:<span class=\"built_in\">NSObject</span>.class];</span><br><span class=\"line\"><span class=\"comment\">//类方法判断</span></span><br><span class=\"line\">[myObject respondsToSelector:<span class=\"keyword\">@selector</span>(doStuff:)];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// isa == class</span></span><br><span class=\"line\">class_respondsToSelector(myObject.class, <span class=\"keyword\">@selector</span>(doStuff:));</span><br></pre></td></tr></table></figure></p>\n<p><code>isMemberOfClass</code>:是 Foundation 当中的一部分，这里我们查看 myObject 是否是 NSObject 的子类。<br><code>respondsToSelector:</code>:当我们使用了一个带有可选方法的协议时，为了避免崩溃发生，可以借助这个函数来判断这个对象是否可以调用此可选方法。<br><strong>在运行时层面</strong><br><code>isMemberOfClass</code>: 对比两者的 <strong>isa</strong> 是否相同。<br><code>respondsToSelector</code>:则封装了一个 Objective-C 运行时函数：<code>respondsToSelector</code>，其接受 <code>Selector</code> 和<code>类</code>为参数。</p>\n<h3 id=\"单元测试：方法列表\"><a href=\"#单元测试：方法列表\" class=\"headerlink\" title=\"单元测试：方法列表\"></a>单元测试：方法列表</h3><p>如果您写过单元测试的话，您就会知道当我们在编写 XCTestCase 的时候，需要完成 setUp 和 tearDown 的设定，随后才能编写相关的 test 函数。当测试运行的时候，系统会自行遍历所有的测试函数，并自动运行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unsigned int count;</span><br><span class=\"line\">Method *methods = class_copyMethodList(myObject.class,&amp;count);</span><br><span class=\"line\">//Ivar *list = class_copyIvarList(myObject.class,&amp;count);</span><br><span class=\"line\"></span><br><span class=\"line\">for(unsigned i = 0; i &lt; count; i++) &#123;</span><br><span class=\"line\">    SEL selector = method_getName(methods[i]);</span><br><span class=\"line\">    NSString *selectorString = NSStringFromSelector(selector);</span><br><span class=\"line\">    if ([selectorString containsString:@&quot;test&quot;]) &#123;</span><br><span class=\"line\">        [myObject performSelector:selector];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">free(methods);</span><br></pre></td></tr></table></figure></p>\n<p>这个功能是借助 Objective-C 的运行时机制实现的,即：借助运行时函数获取可以复制方法列表，还可以复制变量列表。可以获取方法名，然后将其转换为字符串，检查其是否包含有 “test”，如果有便可以运行。现在我们便搭建好了 XCTest 的最简单版本！</p>\n<h3 id=\"方法-变量的结构体成员\"><a href=\"#方法-变量的结构体成员\" class=\"headerlink\" title=\"方法/变量的结构体成员\"></a>方法/变量的结构体成员</h3><ol>\n<li><p>变量结构体：包含了变量类型和变量名称。偏移量 (offset) 则是内存管理方面的内容。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_ivar &#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *ivar_name;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *ivar_type;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ivar_offset;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法结构体：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_method &#123;</span><br><span class=\"line\">    SEL method_name;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *method_types;</span><br><span class=\"line\">    IMP method_imp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>SEL</strong>： 使用Selector 来表示的Objective-C方法的名称，对应在 performSelector 当中所匹配的内容。<br><strong>方法类型</strong>：使用编码字符串来表示其类型。<br><strong>IMP</strong>：是方法实现的一种特定的表示方式。</p>\n<h4 id=\"给对象添加方法\"><a href=\"#给对象添加方法\" class=\"headerlink\" title=\"给对象添加方法\"></a>给对象添加方法</h4><p>了解方法结构体后，可知我们同样可以在运行时向对象当中添加方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">Method doStuff = class_getInstanceMethod(<span class=\"keyword\">self</span>.class, <span class=\"keyword\">@selector</span>(doStuff));</span><br><span class=\"line\"><span class=\"comment\">//获取方法的实现</span></span><br><span class=\"line\">IMP doStuffImplementation = method_getImplementation(doStuff);</span><br><span class=\"line\"><span class=\"comment\">//获取方法的类型</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types = method_getTypeEncoding(doStuff); <span class=\"comment\">//“v@:@\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">class_addMethod(myClass.class, <span class=\"keyword\">@selector</span>(doStuff:), doStuffImplementation, types);</span><br></pre></td></tr></table></figure></p>\n<p><code>class_addMethod</code>: 向对象当中添加方法的运行时函数。它所需的参数，即上述方法结构体当中的那三个值：Selector、方法实现和方法类型。</p>\n<h4 id=\"调用新加的方法\"><a href=\"#调用新加的方法\" class=\"headerlink\" title=\"调用新加的方法\"></a>调用新加的方法</h4><p>当然，我们添加了方法目的就是要使用它们。我们可以使用 <code>[self doStuff]</code> 或者<code>[self performSelector:@selector(doStuff)]</code>来进行调用，实际上在运行时级别，它们都是借助 <code>objc_msgSend</code> 向对象发送了一个消息。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方式一</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> doStuff];</span><br><span class=\"line\"><span class=\"comment\">//方式二</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(doStuff)];</span><br><span class=\"line\"><span class=\"comment\">//方式三</span></span><br><span class=\"line\">objc_msgSend(<span class=\"keyword\">self</span>, <span class=\"keyword\">@selector</span>(message));</span><br></pre></td></tr></table></figure></p>\n<p>但是如果调用方法所在的对象为 nil 的时候，我们就会得到一个异常，应用便会崩溃。但事实证明，在崩溃之前会预留几个步骤，从而允许我们对某个不存在的函数进行一些操作。</p>\n<h3 id=\"方法转发\"><a href=\"#方法转发\" class=\"headerlink\" title=\"方法转发\"></a>方法转发</h3><p>当我们试图桥接两个不同的框架的时候，可以将方法转发 (forward) 给其余目标。这个功能便非常有用。当我们调用某个未实现的方法时，这便是会发生的操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1</span><br><span class=\"line\">+(BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class=\"line\">    // 添加实例方法并返回 YES 的一次机会，它随后会再次尝试发送消息</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">+(BOOL)resolveClassMethod:(SEL)sel&#123;</span><br><span class=\"line\">    // 添加类方法并返回 YES 的一次机会，它随后会再次尝试发送消息</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 2</span><br><span class=\"line\">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class=\"line\">    // 返回可以处理 Selector 的对象</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 3</span><br><span class=\"line\">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class=\"line\">    // 您需要实现它来创建 NSInvocation</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)forwardInvocation:(NSInvocation *)invocation &#123;</span><br><span class=\"line\">    // 在您所选择的目标上调用 Selector</span><br><span class=\"line\">    [invocation invokeWithTarget:target];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当您调用了某个不存在的方法时，运行时有如下处理步骤：</p>\n<ol>\n<li>首先调用两个类方法：一个名为 <code>resolveInstanceMethod</code>类方法，如果所调用的方法是类方法，则调用为调用 <code>resolveClassMethod</code>类方法。这时候我们便有机会来添加方法了，步骤的话我们之前就已经展示过了。如果我们返回了 YES，就意味着原始方法将会再次被调用。</li>\n<li><code>forwardingTargetForSelector</code>：当不要添加新方法时，可以直接返回需要调用方法的目标对象即可，之后这个对象就会调用 Selector。</li>\n<li><code>forwardInvocation</code>方法：实现在您所选择的目标对象上调用 Selector，所有的调用过程都被封装到 <code>NSInvocation</code> 对象当中。如果您需要这么做，那么还需要实现 <code>methodSignatureForSelector</code>。<br>完成以上步骤，便可以可以将方法转发给其他对象。<h3 id=\"方法混淆：替换或交换\"><a href=\"#方法混淆：替换或交换\" class=\"headerlink\" title=\"方法混淆：替换或交换\"></a>方法混淆：替换或交换</h3>您可以使用运行时当中最著名的动态特性：方法混淆 (swizzling),即使用 <code>class_replaceMethod</code> 或者 <code>method_exchangeImplementations</code> 来替换方法。之所以想要混淆，是因为它可以用于日志记录和 Mock 测试。<br>混淆的基本方法如下所示：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">void</span>)load &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        Class <span class=\"keyword\">class</span> = [<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        SEL originalSelector = <span class=\"keyword\">@selector</span>(doSomething);</span><br><span class=\"line\">        SEL swizzledSelector = <span class=\"keyword\">@selector</span>(mo_doSomething);</span><br><span class=\"line\"></span><br><span class=\"line\">        Method originalMethod = class_getInstanceMethod(<span class=\"keyword\">class</span>,</span><br><span class=\"line\">        originalSelector);</span><br><span class=\"line\">        Method swizzledMethod = class_getInstanceMethod(<span class=\"keyword\">class</span>,</span><br><span class=\"line\">        swizzledSelector);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">BOOL</span> didAddMethod = class_addMethod(<span class=\"keyword\">class</span>, originalSelector,</span><br><span class=\"line\">                                method_getImplementation(swizzledMethod),</span><br><span class=\"line\">                                method_getTypeEncoding(swizzledMethod));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (didAddMethod) &#123;</span><br><span class=\"line\">            class_replaceMethod(<span class=\"keyword\">class</span>,swizzledSelector,</span><br><span class=\"line\">                                method_getImplementation(originalMethod),</span><br><span class=\"line\">                                method_getTypeEncoding(originalMethod));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>当类加载之后，会调用一个名为 <code>load</code> 的类函数。由于我们只打算混淆一次，因此我们需要使用 <code>dispatch_once</code>。接着我们便可以得到该方法，然后使用 <code>class_replaceMethod</code> 或者 <code>method_exchangeImplementations</code> 来替换方法。</p>\n<h2 id=\"Foundation\"><a href=\"#Foundation\" class=\"headerlink\" title=\"Foundation\"></a>Foundation</h2><p>Foundation 框架实现了基于运行时一个特性的两个API：</p>\n<ol>\n<li><code>键值编码 (key-value-coding, KVC)</code></li>\n<li><code>键值观察 (key-value observing, KVO)</code><br>KVC 和 KVO 允许我们将 UI 和数据进行绑定，这也是 Rx 以及其他响应式框架实现的基础。<h3 id=\"KVC\"><a href=\"#KVC\" class=\"headerlink\" title=\"KVC\"></a>KVC</h3>KVC 的工作方式如下所示：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSNumber</span> *number;</span><br><span class=\"line\"></span><br><span class=\"line\">[myClass valueForKey:<span class=\"string\">@\"number\"</span>];</span><br><span class=\"line\">[myClass setValue:@(<span class=\"number\">4</span>) forKey:<span class=\"string\">@\"number\"</span>];</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>例如，假设我们有这个 number 属性，您可以将属性名称作为键，来获取属性值或者设置属性值。这个功能可以用在此前我们所看到的获取变量列表、协议列表，以及危险的混淆功能当中。</p>\n<h3 id=\"KVO\"><a href=\"#KVO\" class=\"headerlink\" title=\"KVO\"></a>KVO</h3><p>通常所说的 Objective-C 「动态性」，往往都是指 KVO。虽然还有其余的函数，但是这些是最常见、最常用的。这也就是人们所说的，Swift 缺失的部分。</p>\n<ol>\n<li>使用KVO对状态的变化进行注册<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[myClass addObserver:<span class=\"keyword\">self</span></span><br><span class=\"line\">forKeyPath:<span class=\"string\">@\"number\"</span></span><br><span class=\"line\">options:<span class=\"built_in\">NSKeyValueObservingOptionInitial</span> | <span class=\"built_in\">NSKeyValueObservingOptionNew</span></span><br><span class=\"line\">context:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath</span><br><span class=\"line\">ofObject:(<span class=\"keyword\">id</span>)object</span><br><span class=\"line\">change:(<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSKeyValueChangeKey</span>,<span class=\"keyword\">id</span>&gt; *)change</span><br><span class=\"line\">context:(<span class=\"keyword\">void</span> *)context&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Respond to observation.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>在观察的值发生变更之后，KVO 会调用此方法立即通知观察者。通过这个方法，我们便可以按需更新 UI。</p>\n<ol>\n<li>弊端：难以调试<br>KVO这些操作都存有隐患。比方说 KVO，特别是当我们对某个不是自己所创建的类进行观察时，往往会发现有出乎意料的变化发生。通常而言，这些问题是非常难以调试的，也很难去理解为什么出错。在实际产品当中，我并不建议使用它们，尽管它们非常好用。但是在实际产品当中，我会很谨慎地去使用这些功能。</li>\n</ol>\n<p>Apple 也是如此认为的，因此它们在视图控制器当中添加了这个私有方法，可以使用 class-dump 来查看。</p>\n<ul>\n<li>(void)                   attentionClassDumpUser:<br>yesItsUsAgain:<br>althoughSwizzlingAndOverridingPrivateMethodsIsFun:<br>itWasntMuchFunWhenYourAppStoppedWorking:<br>pleaseRefrainFromDoingSoInTheFutureOkayThanksBye:</li>\n</ul>\n<p>的确，很让人抓狂。</p>\n<h2 id=\"Swift\"><a href=\"#Swift\" class=\"headerlink\" title=\"Swift\"></a>Swift</h2><p>Swift 是一种强类型语言。即默认类型是安全的静态类型。如果需要的话，不安全类型也是存在的，但是 Swift 仍然是尽力推动我们使用安全的静态类型。Swift 中的动态性可以通过 Objective-C 运行时来获得。</p>\n<p>本来这是很好的，但是 Swift 开源并迁移到 Linux 之后，由于 Linux 上的 Swift 并不提供 Objective-C 运行时，事情就大条了。社区的关键点在于，让 Swift 未来能够自己配备动态性，而不是依赖于 Apple。</p>\n<h3 id=\"Swift中的两个动态修饰符\"><a href=\"#Swift中的两个动态修饰符\" class=\"headerlink\" title=\"Swift中的两个动态修饰符\"></a>Swift中的两个动态修饰符</h3><ol>\n<li><code>@objc</code>: 将Swift API 暴露给 Objective-C 运行时，但是它仍然不能保证编译器会尝试对其进行优化。</li>\n<li><code>@dynamic</code>:动态功能修饰符，它隐含添加了 <code>@objc</code>功能。</li>\n</ol>\n<h3 id=\"Swift中运行时方法\"><a href=\"#Swift中运行时方法\" class=\"headerlink\" title=\"Swift中运行时方法\"></a>Swift中运行时方法</h3><p>回到我们的动态特性当中，让我们来看一看 Swift 当中这些动态特性是什么样的。假设我们需要使用内省机制、转发方法、替换和绑定方法。</p>\n<h4 id=\"方法转发-1\"><a href=\"#方法转发-1\" class=\"headerlink\" title=\"方法转发\"></a>方法转发</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\">override <span class=\"keyword\">class</span> func resolveInstanceMethod(_ sel: Selector!)</span><br><span class=\"line\">-&gt; Bool &#123;</span><br><span class=\"line\"><span class=\"comment\">// 添加实例方法并返回 true 的一次机会，它随后会再次尝试发送消息</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\">override func forwardingTarget(<span class=\"keyword\">for</span> aSelector: Selector!) -&gt;</span><br><span class=\"line\">Any? &#123;</span><br><span class=\"line\"><span class=\"comment\">// 返回可以处理 Selector 的对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3 - Swift 不支持 NSInvocation</span></span><br></pre></td></tr></table></figure>\n<p>resolveInstanceMethod 同样会被调用，forwardingTarget 看起来似乎更贴近于 Swift 3 风格的 API。但是 NSInvocation 并不能在 Swift 当中使用。我们同样可以实现方法转发，因此看起来也不算太坏。</p>\n<h4 id=\"方法混淆\"><a href=\"#方法混淆\" class=\"headerlink\" title=\"方法混淆\"></a>方法混淆</h4><p><code>load</code> 在 Swift 不再会被调用，因此我们需要在 <code>initialize</code> 中进行混淆。在 Objective-C 当中使用的 <code>dispatch_once</code>，但是在 Swift 3 中被废弃。事情变得略为复杂。虽然对于特定类型的函数而言，我们仍然可以将其定义为动态函数，但是它会消除大部分混淆的功能。</p>\n<h4 id=\"内省机制-1\"><a href=\"#内省机制-1\" class=\"headerlink\" title=\"内省机制\"></a>内省机制</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if self is MyClass &#123;</span><br><span class=\"line\">    // YAY</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let myString = &quot;myString&quot;;</span><br><span class=\"line\">let mirror = Mirror(reflecting: myString)</span><br><span class=\"line\">print(mirror.subjectType) // “String&quot;</span><br><span class=\"line\">let string = String(reflecting: type(of:</span><br><span class=\"line\">myString)) // Swift.String</span><br><span class=\"line\"></span><br><span class=\"line\">// No native method introspection</span><br></pre></td></tr></table></figure>\n<p><code>is</code> 替代了 <code>isMemberOfClass</code>，它同样也可以对 Swift 值类型:结构体、枚举以及其他 Swift 当中的新类型使用。此外还有一个新的映射 API，它主要针对于管道 (pipe) 和数据。</p>\n<h4 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h4><p>目前，我们没有原生的办法来实现内省。这也预示着这个功能未来可能会出现，但是目前我们还无法实现。这很令人沮丧，特别是当您想到我们此前所实现的 XCTestCase。如果您打算为 Linux 编写单元测试的时候，就无法自动遍历所有的函数。您必须实现 static var allTests，然后手动列出所有的测试函数。这很糟糕。</p>\n<h4 id=\"KVC-KVO功能的削弱\"><a href=\"#KVC-KVO功能的削弱\" class=\"headerlink\" title=\"KVC/KVO功能的削弱\"></a>KVC/KVO功能的削弱</h4><p>KVO 的魅力在于，您可以在不是自己所创建的类当中使用它，也可以只对您想要监听变化的类使用。KVO 和 KVC 在 Swift 被极大地削弱了。<br>两点要求：</p>\n<ol>\n<li>被观察的对象必须要继承自 NSObject，并且使用一个 Objective-C 类型。</li>\n<li>被观察的变量必须要声明为 @dynamic。您必须要对想要观察的事务了如指掌。<br>问题是 Swift 并没有很好的替代方案。您可以使用 Rx 或者基于协议来观察对象。但是语言自身是没有原生的解决方案的。</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总而言之，Objective-C 的动态性无疑是非常强大的、极其有用，虽然也存在危险性。Swift 目前没有足够的替代方案来解决这些问题，但是可以预见在不久的将来 Swift 的动态性将会出现，这是值得我们期待的。</p>\n","raw":null,"categories":[{"name":"swift","path":"api/categories/swift.json"},{"name":"语法","path":"api/categories/语法.json"}],"tags":[]},{"title":"互动性的教学工具XCPlayground","slug":"swift/互动性的教学工具XCPlayground","date":"2017-03-01T17:27:16.000Z","updated":"2017-03-01T17:27:16.000Z","comments":true,"path":"api/articles/swift/互动性的教学工具XCPlayground.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/xcplayground-sources.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>Playground 展示语法和实时执行真实数据的特性，为编写方法和库接口提供了很好的机会，通过实时编译我们能了解语法、写出例子以及获得方法如何使用的说明，所有这些就如一个活的文档展示在眼前。</p>\n<ol>\n<li>演习框架API，了解框架结构<br><a href=\"https://github.com/objcio/PersonalSwiftPlaygrounds\" target=\"_blank\" rel=\"noopener\">SceneKitMac.playground</a><br>是一个功能完备带动画的 3D 场景。你需要打开 Assistant Editor (在菜单上依次点击 View | Assistant Editor | Show Assistant Editor)，3D 效果和动画将会被自动渲染。这不需要编译循环，而且任何的改动，比如改变颜色、几何形状、亮度等，都能实时反映出来。使用它能在一个交互例子中很好的记录和介绍如何使用SceneKit框架。</li>\n<li>测试驱动开发<br>我们可以验证一个方法的执行是否正确，甚至在加载到 playground 的时候就能判断方法是否被正确解析。不难想象我们也可以在 playground 里添加断言，以及创建真正的单元测试。或者更进一步，创建出符合条件的测试，从而在你打字时就实现测试驱动开发。</li>\n</ol>\n<h2 id=\"Sources\"><a href=\"#Sources\" class=\"headerlink\" title=\"Sources\"></a>Sources</h2><p>打开 Project Navigator (⌘1) 并展开 Playground 文件，你就能看到”Sources”路径。<br>放到此目录下的源文件会被编译成模块(module)并自动导入到 Playground 中，并且这个编译只会进行一次(或者我们对该目录下的文件进行修改的时候)，而非每次你敲入一个字母的时候就编译一次。 这将会大大提高代码执行的效率。</p>\n<blockquote>\n<p>注意：由于此目录下的文件都是被编译成模块导入的，只有被设置成 public 的类型，属性或方法才能在 Playground 中使用。</p>\n</blockquote>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcplayground-sources.png?imageMogr2/2/w/800\">\n<h2 id=\"导入Frameworks\"><a href=\"#导入Frameworks\" class=\"headerlink\" title=\"导入Frameworks\"></a>导入Frameworks</h2><p>如果想要导入外部 framework，创建一个 Xcode Workspace 包含了 framework 项目和你的 Playground。在 Build 之后，就可以通过常规的import命令导入对应的包。</p>\n<h3 id=\"手动配置cocoa-touch-Framework来桥接playground\"><a href=\"#手动配置cocoa-touch-Framework来桥接playground\" class=\"headerlink\" title=\"手动配置cocoa touch Framework来桥接playground\"></a>手动配置cocoa touch Framework来桥接playground</h3><p>在Playgroud中使用个人项目中的类相关方法，需要借助于Custom Frameworks桥接<br>注：.swift的文件中的方法必须是public修饰。<br>参考文档：<code>Playground help -&gt; Importing Custom Frameworks into a Playground</code></p>\n<ol>\n<li>导入个人项目文件，需要借助<code>cocoa touch Framework</code>桥接<code>playground</code></li>\n<li>需要<code>workspace</code>来管理<code>Framework</code>项目和<code>playground</code>文件，典型例子：pod项目都是用workspace来管理多个项目。</li>\n<li>把个人项目的<code>swift文件</code>关联到<code>Cocoa touch Framework</code>项目的<code>target</code>中：<br> 详细设置：选中target -&gt; build phases -&gt; compiles sources -&gt;点击 + 加号，选中原项目中的swift</li>\n<li>在<code>build</code>选项中选中Framework的scheme进行编译 ,要保证framework的target配置：<code>build setting -&gt; build active architecture Only -&gt;debug</code>选项设置为<code>YES</code></li>\n<li>打开playground文件 import Framework名称，此时即可使用Framework中的提供的public API方法了。<br>Workspace相关设置，build生成的目录：xcode偏好设置要和项目中的workspace中设置要保持一致.</li>\n<li>xcode的偏好设置中 -&gt;Locations -&gt; Locations -&gt;点击打开 Advanced…在弹出框中设置Unique选项.</li>\n<li>在workspace中选中菜单 File -&gt; workspace settings… -&gt; 在弹出框中设置为Unique选项.</li>\n</ol>\n<h3 id=\"导入cocopads管理的依赖库\"><a href=\"#导入cocopads管理的依赖库\" class=\"headerlink\" title=\"导入cocopads管理的依赖库\"></a>导入cocopads管理的依赖库</h3><p>xcode7.3.1和cocoapods1.0版本导致playground无法import相关动态库<br>解决办法：<a href=\"http://stackoverflow.com/questions/38216238/xcode-playground-with-cocoapods#\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/38216238/xcode-playground-with-cocoapods#</a><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#在写入磁盘之前，修改一些工程的配置:</span></span><br><span class=\"line\">post_install <span class=\"keyword\">do</span> |installer|</span><br><span class=\"line\">    installer.pods_project.targets.each <span class=\"keyword\">do</span> |target|</span><br><span class=\"line\">        <span class=\"keyword\">if</span> target.name != <span class=\"string\">'CocoaAsyncSocket'</span></span><br><span class=\"line\">            <span class=\"comment\">#playground相关配置，会导致'GCDAsyncSocket.h' file not found</span></span><br><span class=\"line\">            target.build_configurations.each <span class=\"keyword\">do</span> |config|</span><br><span class=\"line\">                config.build_settings[<span class=\"string\">'CONFIGURATION_BUILD_DIR'</span>] = <span class=\"string\">'$PODS_CONFIGURATION_BUILD_DIR'</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">#Use Legacy Swift Language Version” (SWIFT_VERSION):</span></span><br><span class=\"line\">                <span class=\"comment\">#   https://github.com/CocoaPods/CocoaPods/issues/5864#issuecomment-247109685</span></span><br><span class=\"line\">                puts <span class=\"string\">\"SWIFT_VERSIION:\"</span></span><br><span class=\"line\">                config.build_settings[<span class=\"string\">'SWIFT_VERSION'</span>] = <span class=\"string\">\"3.0.1\"</span></span><br><span class=\"line\">                puts config.build_settings[<span class=\"string\">'SWIFT_VERSION'</span>]</span><br><span class=\"line\">            end</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"comment\">#输出操作</span></span><br><span class=\"line\">            puts <span class=\"string\">\"以下不能在playground中使用的库名：\"</span></span><br><span class=\"line\">            puts target.name</span><br><span class=\"line\">        end</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Playground沙盒Resources\"><a href=\"#Playground沙盒Resources\" class=\"headerlink\" title=\"Playground沙盒Resources\"></a>Playground沙盒Resources</h2><p>Playgrounds 有两个与相关的Resources关联起来：一个是每一个独立的 playground 本地的，另一个则是 playground 之间共享的。在你的实验过程中，Playgrounds 能够支持 XML，JSON 数据，XIB，和图像文件。这也增加了其使用可用性。</p>\n<h2 id=\"本地-bundle访问本地资源\"><a href=\"#本地-bundle访问本地资源\" class=\"headerlink\" title=\"本地 bundle访问本地资源\"></a>本地 bundle访问本地资源</h2><p>Resources 文件夹, 与 Sources 文件夹一样在 Playground 的包路径中, 通过 Project Navigator 就可见了——只需要简单的拖拽图像和数据文件，就可以在 Playground 中使用了。对应的内容在 main bundle 中也是可见的。比如，我们可以像这样非常快捷的加载一个包含天气数据的 JSON 文件：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> jsonPath = <span class=\"type\">NSBundle</span>.mainBundle().bundlePath.stringByAppendingPathComponent(<span class=\"string\">\"weather.json\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span></span><br><span class=\"line\">jsonData = <span class=\"type\">NSData</span>(contentsOfFile: jsonPath),</span><br><span class=\"line\">json = <span class=\"type\">NSJSONSerialization</span>.<span class=\"type\">JSONObjectWithData</span>(jsonData, options: <span class=\"literal\">nil</span>, error: <span class=\"literal\">nil</span>) <span class=\"keyword\">as</span>? [<span class=\"type\">String</span>: <span class=\"type\">AnyObject</span>] </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"共享-访问Documents共享目录\"><a href=\"#共享-访问Documents共享目录\" class=\"headerlink\" title=\"共享 访问Documents共享目录\"></a>共享 访问Documents共享目录</h2><p>“共享 Playground 数据”的内容在你的”Documents”文件夹路径下，也同样对于你创建的任何 Playground 都可见。我们通过XCPSharedDataDirectoryPath常量来访问该共享文件夹。</p>\n<p>如果你自习想尝试，需要在 “~/Documents/Shared Playground Data” 下简历一个文件夹。 这里我们尝试载入一个名字叫做 “image.png” 的图片文件:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sharedImagePath = <span class=\"type\">XCPSharedDataDirectoryPath</span>.stringByAppendingPathComponent(<span class=\"string\">\"image.png\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> image = <span class=\"type\">UIImage</span>(contentsOfFile: sharedImagePath) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"PlaygroundSupport\"><a href=\"#PlaygroundSupport\" class=\"headerlink\" title=\"PlaygroundSupport\"></a>PlaygroundSupport</h2><h3 id=\"liveView视图代理\"><a href=\"#liveView视图代理\" class=\"headerlink\" title=\"liveView视图代理\"></a>liveView视图代理</h3><p>实现在playground中实现UI显示及交互操作<br>liveView定义：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> liveView: <span class=\"type\">XCPlaygroundLiveViewable</span>?</span><br></pre></td></tr></table></figure><br>遵循了<code>XCPlaygroundLiveViewable</code>协议即可在playground中可视化显示：</p>\n<ol>\n<li>在iOS 和 tvOS中<code>UIView</code> and <code>UIViewController</code>遵循该协议</li>\n<li>在OS X中<code>NSView</code> and <code>NSViewController</code>遵循该协议</li>\n<li>用户自定类型，须遵守XCPlaygroundLiveViewable协议<br>总之，只要遵守改协议并实现代理方法，都可以在playground中可视化显示。<br>用法：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.liveView = <span class=\"type\">UIView</span>()／<span class=\"type\">NSViewController</span>()</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"捕获值（XCPCaptureValue在XCPlayground中过时）\"><a href=\"#捕获值（XCPCaptureValue在XCPlayground中过时）\" class=\"headerlink\" title=\"捕获值（XCPCaptureValue在XCPlayground中过时）\"></a>捕获值（XCPCaptureValue在XCPlayground中过时）</h3><p><a href=\"http://swifter.tips/playground-capture/\" target=\"_blank\" rel=\"noopener\">冒泡排序可视化预览</a><br><figure class=\"highlight swift\"><figcaption><span>XCPlayground Module</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// This function has been deprecated.</span></span><br><span class=\"line\"><span class=\"meta\">@available</span>(*, deprecated)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">XCPCaptureValue</span>&lt;T&gt;<span class=\"params\">(identifier: String, value: T)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>简介：可以多次调用该方法来做图，相同的 identifier 的数据将会出现在同一张图上，而 value 将根据输入的次序进行排列,将一组数据轻而易举地绘制到时间轴上，从而让我们能看到每一步的结果。这不仅对我们直观且及时地了解算法内部的变化很有帮助，也会是教学或者演示时候的神兵利器。</p>\n<ol>\n<li>使用：导入框架<code>import XCPlayground</code></li>\n<li>扩展：XCPCaptureValue 的数据输入是任意类型的，所以不论是传什么进去都是可以表示的。它们将以 QuickLook 预览的方式被表现出来，一些像 UIImage，UIColor 或者 UIBezierPath 这样的类型已经实现了 QuickLook。当然对于那些没有实现快速预览的 NSObject 子类，也可以通过重写</li>\n</ol>\n<p>一个 Playground 通常立即显示简单表达式的结果。数组，字符串，数字等等，会在结果面板把计算后的结果显示出来。那么，随着时间改变的值是如何处理的呢？</p>\n<p>通过使用 XCPCaptureValue() 函数，我们可以随着一系列的迭代建立一个变动值的图。回到我们上面提到的天气例子，让我们来看看按小时计的温度数据，使用 XCPCaptureValue 来在辅助编辑界面以时间线的方式显示 温度的值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> XCPlayground</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> forecast <span class=\"keyword\">in</span> forecasts </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> tempString = forecast[<span class=\"string\">\"temp\"</span>]?[<span class=\"string\">\"english\"</span>] <span class=\"keyword\">as</span>? <span class=\"type\">String</span>, temperature = tempString.toInt()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">XCPCaptureValue</span>(<span class=\"string\">\"Temperature\"</span>, temperature)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另一种可选的方式是, 选择 Editor → Show Result For Current Line 就会捕获当前线的数值并且直接以图表的形势显示在 Playground 流中：</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcplayground-capture.png?imageMogr2/2/w/800\">\n<h3 id=\"异步执行（Asynchronous-Execution）\"><a href=\"#异步执行（Asynchronous-Execution）\" class=\"headerlink\" title=\"异步执行（Asynchronous Execution）\"></a>异步执行（Asynchronous Execution）</h3><p>不同于大部分 Swift 代码，是作为框架或者应用的一部分，Playgrounds 被当做是 高级代码。Playground 中的高级代码是按照指令接着指令的顺序从上到下执行的。<br>这种无容器风格的代码执行提供了立即反馈，但是存在着一个问题：在执行到了 Playground 底部后，会立即停止。网络请求，计时器，以及长时间运行的后台队列都会在提供反馈成功或者失败之前被立即终止。<br><code>PlaygroundSupport</code> 模块包含一个能够延长该过程的函数：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> needsIndefiniteExecution: <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>开启异步：默认值为<code>false</code>,当使用liveView代理时，会自动设置为<code>true</code>。当为<code>true</code>时，在高级代码执行完成后，会告诉Xcode继续运行Playground页面。为<code>false</code>时，当代码执行完直接终止。</li>\n<li>手动终止：还可以使用<code>PlaygroundPage.finishExecution()</code>手动终止正在运行的Playground。</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> PlaygroundSupport</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.needsIndefiniteExecution = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> url = <span class=\"type\">NSURL</span>(string: <span class=\"string\">\"http://httpbin.org/image/png\"</span>)!</span><br><span class=\"line\"><span class=\"keyword\">let</span> task = <span class=\"type\">NSURLSession</span>.sharedSession().dataTaskWithURL(url) &#123;</span><br><span class=\"line\">    data, <span class=\"number\">_</span>, <span class=\"number\">_</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> image = <span class=\"type\">UIImage</span>(data: data)</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//手动终止</span></span><br><span class=\"line\">        <span class=\"type\">PlaygroundPage</span>.current.currentPage.finishExecution()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">task.resume()</span><br></pre></td></tr></table></figure>\n<h2 id=\"支持Markdown格式的文档\"><a href=\"#支持Markdown格式的文档\" class=\"headerlink\" title=\"支持Markdown格式的文档\"></a>支持Markdown格式的文档</h2><p><a href=\"https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>除了实验用途，Playgrounds 在展示 Swift 语言的工具和框架中也一样强大。特别文档部分可以作为丰富格式的方式展示出来，以提供对于代码的清晰解释从而展示某个技术或者正确使用某个 Library 的方式。</p>\n<p>不同于<a href=\"http://nshipster.cn/swift-documentation/\" target=\"_blank\" rel=\"noopener\">Swift代码中的注释文档语法</a>, <code>Swift Playgrounds</code> 使用 <code>Markdown</code> 来显示多格式的文档。<br>例如：<br><code>//:</code>：可以指定单行文本说明<br><code>/*: Markdown格式内容... */</code>：可以用<code>Markdown</code>格式来显示丰富的文档内容</p>\n<p><code>xcode</code>切换备注以<code>Markdown</code>格式显示：</p>\n<ol>\n<li>选择<code>Editor → Show Rendered Markup</code> 菜单</li>\n<li>在 <code>File Inspector (⌘⌥1)</code> 选中 <code>Render Documentation</code> 复选框。<blockquote>\n<p>在xcode8中打开之前版本时，菜单上的<code>Show Rendered Markup</code>会显示为<code>Upgrade playgound...</code>升级菜单项，这样就需要先点击升级菜单项之后，才能激活上述（1）（2）设置项。</p>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//: This line will have **bold** and *italic* text.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*:</span></span><br><span class=\"line\"><span class=\"comment\">## Headers of All Sizes</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">### Lists of Links</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">- [NSHipster](http://nshipster.com)</span></span><br><span class=\"line\"><span class=\"comment\">- [ASCIIwwdc](http://asciiwwdc.com)</span></span><br><span class=\"line\"><span class=\"comment\">- [SwiftDoc](http://swiftdoc.org)</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">### Images, Too</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">![Remote Image](http://nshipster.s3.amazonaws.com/alert.gif)</span></span><br><span class=\"line\"><span class=\"comment\">![Local Image](bomb.gif) </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*Images in the Resources directory can be referenced locally*</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcplayground-documentation.png?imageMogr2/2/w/800\">\n<p>Playgrounds 提供了一个我们关于分享和学习 OS X 和 iOS 相关工具的方式的重大改变。Playground 可以展示每一个特性，并且为将来的用户探索和发现你创建的库提供了空间。丢掉你的静态README.md， 换成可互动的README.playground吧，再玩起来！</p>\n","raw":null,"categories":[{"name":"swift","path":"api/categories/swift.json"},{"name":"playground","path":"api/categories/playground.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"测试","path":"api/tags/测试.json"}]},{"title":"使用JavaScript把JSON数据转为对象","slug":"swift/使用JavaScript把JSON数据定义对象","date":"2017-02-12T14:41:35.000Z","updated":"2017-02-16T13:43:01.000Z","comments":true,"path":"api/articles/swift/使用JavaScript把JSON数据定义对象.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"将JSON数据序列化为代码实例\"><a href=\"#将JSON数据序列化为代码实例\" class=\"headerlink\" title=\"将JSON数据序列化为代码实例\"></a>将JSON数据序列化为代码实例</h2><ol>\n<li>定义一个继承自 <code>JSExport</code> 子协议 <code>PersonJSExports</code></li>\n<li>定义一个遵守<code>PersonJSExports</code>协议的<code>Person</code>数据模</li>\n<li>使用 <code>JavaScript</code> 把<code>JSON</code>转为<code>类</code>并实例化<code>对象</code><br>都有一个完整的 <code>JVM</code> 在那儿了，谁还需要 <code>NSJSONSerialization</code>？</li>\n</ol>\n<h2 id=\"JSExport语言互通协议\"><a href=\"#JSExport语言互通协议\" class=\"headerlink\" title=\"JSExport语言互通协议\"></a>JSExport语言互通协议</h2><p><code>JavaScript</code>可以脱离<code>prototype继承</code>完全用<code>JSON</code>来定义对象，但是<code>Objective-C</code>编程不能脱离<code>类</code>和<code>继承</code>。所以<code>JavaScriptCore</code>就提供了<code>JSExport</code>作为两种语言的互通协议。<br><code>JSExport</code>中没有预定义任何方法，但是所有继承<code>JSExport</code>的协议中定义的方法即协议方法，都可以在<code>JSContext</code>中被调用。</p>\n<h2 id=\"JSExportAs-宏-指定方法在JS中调用的名称\"><a href=\"#JSExportAs-宏-指定方法在JS中调用的名称\" class=\"headerlink\" title=\"JSExportAs 宏: 指定方法在JS中调用的名称\"></a>JSExportAs 宏: 指定方法在JS中调用的名称</h2><p>对于多参数的方法，<code>JavaScriptCore</code>的转换方式将<code>Objective-C</code>的方法每个部分都合并在一起，冒号后的字母变为大写并移除冒号。比如下边协议中的方法，在JavaScript调用就是：doFooWithBar(foo, bar);<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">MultiArgs</span> &lt;<span class=\"title\">JSExport</span>&gt;</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)doFoo:(<span class=\"keyword\">id</span>)foo withBar:(<span class=\"keyword\">id</span>)bar;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure><br>如果希望方法在JavaScript中有一个比较短的名字，就需要用的JSExport.h中提供的宏：<br><figure class=\"highlight objc\"><figcaption><span>JSExport.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSExportAs(PropertyName, Selector)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight objc\"><figcaption><span>JSExportAs的官方宏定义 xcdoc://?url=developer.apple.com/library/etc/redirect/xcode/ios/1151/documentation/JavaScriptCore/Reference/JSExport_Ref/index.html</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define JSExportAs(PropertyName, Selector) \\</span></span><br><span class=\"line\"><span class=\"keyword\">@optional</span> Selector __JS_EXPORT_AS__<span class=\"meta\">##PropertyName:(id)argument; @required Selector</span></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>如 <code>setX:Y:Z</code>方法，我们可以给他重命名，让 JS 中通过 <code>set3D(x,y,z)</code> 来调用<br><figure class=\"highlight objc\"><figcaption><span>使用方法</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSExportAs(set3D,</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setX:(<span class=\"keyword\">id</span>)x Y:(<span class=\"keyword\">id</span>)y Z:(<span class=\"keyword\">id</span>)z</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">//调用</span></span><br><span class=\"line\">set3D(x,y,z)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"定义PersonJSExports协议和create协议方法（类方法）\"><a href=\"#定义PersonJSExports协议和create协议方法（类方法）\" class=\"headerlink\" title=\"定义PersonJSExports协议和create协议方法（类方法）\"></a>定义PersonJSExports协议和create协议方法（类方法）</h3><p><code>Person 类</code>实现了<code>PersonJSExports 协议</code>，该协议规定哪些属性可以在 <code>JavaScript</code>中可用。<br>在<code>JavaScript</code>语境中，不能像：<code>var person = new Person()</code>来初始化实例，可以在定义<code>PersonJSExports</code>协议方法时，添加一个协议方法来弥补这一点。见下例<code>create...</code>类方法：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Custom protocol must be declared with `@objc`</span></span><br><span class=\"line\"><span class=\"meta\">@objc</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">PersonJSExports</span> : <span class=\"title\">JSExport</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> firstName: <span class=\"type\">String</span> &#123; <span class=\"keyword\">get</span> <span class=\"keyword\">set</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> lastName: <span class=\"type\">String</span> &#123; <span class=\"keyword\">get</span> <span class=\"keyword\">set</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> birthYear: <span class=\"type\">NSNumber</span>? &#123; <span class=\"keyword\">get</span> <span class=\"keyword\">set</span> &#125;</span><br><span class=\"line\">    <span class=\"comment\">//方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getFullName</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 在JavaScript中调用这个类方法</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">func</span> <span class=\"title\">createWithFirstName</span>(<span class=\"title\">firstName</span>: <span class=\"title\">String</span>, <span class=\"title\">lastName</span>: <span class=\"title\">String</span>) -&gt; <span class=\"title\">Person</span></span></span><br><span class=\"line\"><span class=\"class\">&#125;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">### 定义<span class=\"title\">Person</span>模型</span></span><br><span class=\"line\"><span class=\"class\">定义一个遵守`<span class=\"title\">PersonJSExports</span>`协议的`<span class=\"title\">Person</span>`数据模</span></span><br><span class=\"line\"><span class=\"class\">// <span class=\"title\">Custom</span> <span class=\"title\">class</span> <span class=\"title\">must</span> <span class=\"title\">inherit</span> <span class=\"title\">from</span> `<span class=\"title\">NSObject</span>`</span></span><br><span class=\"line\"><span class=\"class\">@<span class=\"title\">objc</span> <span class=\"title\">class</span> <span class=\"title\">Person</span> : <span class=\"title\">NSObject</span>, <span class=\"title\">PersonJSExports</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// JS协议属性必须声明为`dynamic`</span></span><br><span class=\"line\">    <span class=\"keyword\">dynamic</span> <span class=\"keyword\">var</span> firstName: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">dynamic</span> <span class=\"keyword\">var</span> lastName: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">dynamic</span> <span class=\"keyword\">var</span> birthYear: <span class=\"type\">NSNumber</span>?</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(firstName: <span class=\"type\">String</span>, lastName: <span class=\"type\">String</span>)   </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.firstName = firstName</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.lastName = lastName</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//JS协议类方法</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">func</span> <span class=\"title\">createWithFirstName</span>(<span class=\"title\">firstName</span>: <span class=\"title\">String</span>, <span class=\"title\">lastName</span>: <span class=\"title\">String</span>) -&gt; <span class=\"title\">Person</span> </span></span><br><span class=\"line\"><span class=\"class\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Person</span>(firstName: firstName, lastName: lastName)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//JS协议方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getFullName</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\\(firstName) \\(lastName)\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"JSContext-配置\"><a href=\"#JSContext-配置\" class=\"headerlink\" title=\"JSContext 配置\"></a>JSContext 配置</h3><p>之前，我们可以用我们已经创建的 Person 类，我们需要将其导出到 <code>JavaScript</code> 环境。我们也将借此导入<a href=\"http://mustache.github.io\" target=\"_blank\" rel=\"noopener\">Mustache JS library</a>，我们将应用模板到我们的 Person 对象。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// export Person class，JS中以该`Person标示符`作为类名使用</span></span><br><span class=\"line\">context.setObject(<span class=\"type\">Person</span>.<span class=\"keyword\">self</span>, forKeyedSubscript: <span class=\"string\">\"Person\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// load Mustache.js</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> mustacheJSString = <span class=\"type\">String</span>(contentsOfFile:..., encoding:<span class=\"type\">NSUTF8StringEncoding</span>, error:<span class=\"literal\">nil</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    context.evaluateScript(mustacheJSString)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"JavaScript-数据和进程\"><a href=\"#JavaScript-数据和进程\" class=\"headerlink\" title=\"JavaScript 数据和进程\"></a>JavaScript 数据和进程</h3><p>下面就来看看我们简单的 JSON 例子，这段代码将创建新的 Person 实例。<br>数据：<br><figure class=\"highlight json\"><figcaption><span>Persons.json</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    &#123; <span class=\"attr\">\"first\"</span>: <span class=\"string\">\"Grace\"</span>,     <span class=\"attr\">\"last\"</span>: <span class=\"string\">\"Hopper\"</span>,   <span class=\"attr\">\"year\"</span>: <span class=\"number\">1906</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">\"first\"</span>: <span class=\"string\">\"Ada\"</span>,       <span class=\"attr\">\"last\"</span>: <span class=\"string\">\"Lovelace\"</span>, <span class=\"attr\">\"year\"</span>: <span class=\"number\">1815</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">\"first\"</span>: <span class=\"string\">\"Margaret\"</span>,  <span class=\"attr\">\"last\"</span>: <span class=\"string\">\"Hamilton\"</span>, <span class=\"attr\">\"year\"</span>: <span class=\"number\">1936</span> &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure><br>创建新的 Person 实例：<br><figure class=\"highlight js\"><figcaption><span>loadPeople.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> loadPeopleFromJSON = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jsonString</span>) </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(jsonString);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> people = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; data.length; i++) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//在swift中的js协议方法：`createWithFirstName:lastName:`</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> person = Person.createWithFirstNameLastName(data[i].first, data[i].last);</span><br><span class=\"line\">        person.birthYear = data[i].year;</span><br><span class=\"line\">        <span class=\"comment\">//`push:`添加到数组中</span></span><br><span class=\"line\">        people.push(person);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//返回该对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> people;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><code>JSContext</code>加载装换<code>loadPeople.js</code>脚本<br>加载js脚本之后，<code>loadPeopleFromJSON</code>即可作为下标被<code>context</code>调用该方法:<br><figure class=\"highlight swift\"><figcaption><span>加载loadPeople.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// load loadPeople.js</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> loadPeople = <span class=\"type\">String</span>(contentsOfFile:..., encoding:<span class=\"type\">NSUTF8StringEncoding</span>, error:<span class=\"literal\">nil</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//加载js脚本之后，`loadPeopleFromJSON`即可作为下标被context调用该方法</span></span><br><span class=\"line\">    context.evaluateScript(loadPeople)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意：JavaScriptCore 转换的 Objective-C / Swift 方法名是 JavaScript 兼容的。由于 JavaScript 没有参数 名称，任何外部参数名称都会被转换为驼峰形式并且附加到函数名后。在这个例子中，Objective-C 的方法 createWithFirstName:lastName: 变成了在JavaScript中的 createWithFirstNameLastName()。</p>\n</blockquote>\n<h3 id=\"使用Mustache-模板-渲染\"><a href=\"#使用Mustache-模板-渲染\" class=\"headerlink\" title=\"使用Mustache 模板 渲染\"></a>使用Mustache 模板 渲染</h3><p>Mustache 是一个很强大的 template 引擎，可以通过解析 json 来绑定并渲染占位符。如果你做过一些前端开发的话，会知道这是一种很常用的 HTML 绑定 Model 的做法，GRMustache.swift 是这个框架的 Swift 实现。<br><a href=\"http://blog.csdn.net/kevin_luan/article/details/46485561\" target=\"_blank\" rel=\"noopener\">mustache模板引擎</a><br><a href=\"https://github.com/BjornRuud/Swiftache\" target=\"_blank\" rel=\"noopener\">Mustache 的 Swift 语言实现版本</a><br>mustache的特点就是很语法很简单，主要语法如下:</p>\n<pre><code>1. {{ name }} 打印变量，默认是escape过的，如果不要escape,用3个分隔符 {{{ name }}}，或者用 {{ &name }}，这个和分隔符无关\n2. {{#person}}…{{/person}} 区块，4种方式\n    person 是真假值，决定是否输出\n    person 是list of array，会循环展开 for x in person:section.render(&apos;xxx)\n    person 是匿名函数/object, 区块包裹的html 会作为参数传递进去\n    person 是dict，直接打印 dict[key]\n3. {{^person}}…{{/person}，反向区块\n    4. {{！name }} 注释\n5. {{> box }} 载入子模块\n</code></pre><p>加载 <code>JSON 数据</code>，调用 <code>JSContext</code> 将数据解析成 <code>Person 对象</code>的数组，并用 <code>Mustache 模板</code>呈现每个<code>Person</code>：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从文件`Persons.json`中加载json数据</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> peopleJSON = <span class=\"type\">NSString</span>(contentsOfFile:..., encoding: <span class=\"type\">NSUTF8StringEncoding</span>, error: <span class=\"literal\">nil</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取js中定义的`loadPeopleFromJSON`的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> load = context.objectForKeyedSubscript(<span class=\"string\">\"loadPeopleFromJSON\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 通过调用load方法将`JSON 数据`解析成`Person 对象`的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> people = load.callWithArguments([peopleJSON]).toArray() <span class=\"keyword\">as</span>? [<span class=\"type\">Person</span>] </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// get rendering function and create template</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> mustacheRender = context.objectForKeyedSubscript(<span class=\"string\">\"Mustache\"</span>).objectForKeyedSubscript(<span class=\"string\">\"render\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> template = <span class=\"string\">\", born \"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// loop through people and render Person object as string</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> person <span class=\"keyword\">in</span> people </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">println</span>(mustacheRender.callWithArguments([template, person]))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// Grace Hopper, born 1906</span></span><br><span class=\"line\"><span class=\"comment\">// Ada Lovelace, born 1815</span></span><br><span class=\"line\"><span class=\"comment\">// Margaret Hamilton, born 1936</span></span><br></pre></td></tr></table></figure><br>JavaScript 代码段可能是附带应用一起发布的基本的用户定义的插件。</p>\n","raw":null,"categories":[{"name":"swift","path":"api/categories/swift.json"},{"name":"JS混编","path":"api/categories/JS混编.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"iOS","path":"api/tags/iOS.json"},{"name":"swift","path":"api/tags/swift.json"},{"name":"macOS","path":"api/tags/macOS.json"},{"name":"混编","path":"api/tags/混编.json"},{"name":"Java​Script​Core","path":"api/tags/Java​Script​Core.json"},{"name":"json","path":"api/tags/json.json"}]},{"title":"Java​Script​Core实现swift混编","slug":"swift/Java​Script​Core实现swift混编","date":"2017-02-12T13:34:06.000Z","updated":"2017-02-16T13:43:01.000Z","comments":true,"path":"api/articles/swift/Java​Script​Core实现swift混编.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/JSValueType.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>OS X Mavericks 和 iOS 7 引入了 <code>JavaScriptCore</code> 库，它把 <code>WebKit 的 JavaScript</code> 引擎用 <code>Objective-C</code> 封装，提供了简单，快速以及安全的方式接入世界上最流行的语言。不管你爱它还是恨它，<code>JavaScript</code> 的普遍存在使得程序员、工具以及融合到 OS X 和 iOS 里这样超快的虚拟机中资源的使用都大幅增长。</p>\n<ol>\n<li>如何从 <code>JavaScript 环境</code>中提取值以及如何调用其中定义的函数?</li>\n<li>那么反向呢？怎样从 <code>JavaScript</code> 访问我们在 <code>Objective-C</code>或 <code>Swift</code> 定义的对象和方法？</li>\n</ol>\n<h2 id=\"swift通过JSContext调用JavaScript\"><a href=\"#swift通过JSContext调用JavaScript\" class=\"headerlink\" title=\"swift通过JSContext调用JavaScript\"></a>swift通过JSContext调用JavaScript</h2><p>如何从<code>JavaScript 环境</code>中提取值以及如何调用其中定义的函数?</p>\n<h3 id=\"全局实例JSContext：运行JavaScript代码的环境\"><a href=\"#全局实例JSContext：运行JavaScript代码的环境\" class=\"headerlink\" title=\"全局实例JSContext：运行JavaScript代码的环境\"></a>全局实例JSContext：运行JavaScript代码的环境</h3><p>全局实例<code>JSContext</code>作用就像在浏览器内运行的一个<code>JavaScript</code>脚本，<code>JSContext</code> 类似于 <code>window</code>。<br>通过<code>JSContext</code>实例运行<code>JavaScript</code>代码<code>创建变量</code>，<code>做计算</code>，<code>定义方法</code>：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> context = <span class=\"type\">JSContext</span>()    <span class=\"comment\">//创建全局环境</span></span><br><span class=\"line\">context.evaluateScript(<span class=\"string\">\"var num = 5 + 5\"</span>) <span class=\"comment\">//计算</span></span><br><span class=\"line\">context.evaluateScript(<span class=\"string\">\"var names = ['Grace', 'Ada', 'Margaret']\"</span>) <span class=\"comment\">//定义变量</span></span><br><span class=\"line\">context.evaluateScript(<span class=\"string\">\"var triple = function(value) &#123; return value * 3 &#125;\"</span>) <span class=\"comment\">//定义方法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> tripleNum: <span class=\"type\">JSValue</span> = context.evaluateScript(<span class=\"string\">\"triple(num)\"</span>)  </span><br></pre></td></tr></table></figure></p>\n<h3 id=\"动态类型JSValue-包裹JSContext环境下每一个可能的JS值\"><a href=\"#动态类型JSValue-包裹JSContext环境下每一个可能的JS值\" class=\"headerlink\" title=\"动态类型JSValue:包裹JSContext环境下每一个可能的JS值\"></a>动态类型JSValue:包裹JSContext环境下每一个可能的JS值</h3><p><code>JavaScript</code> 是动态语言，所以动态类型<code>JSValue</code>包裹JSContext环境中任何可能的JS值，字符串和数字；数组、对象和方法；甚至错误和特殊的 JavaScript 值诸如 <code>null</code> 和 <code>undefined</code>。<br>获取<code>tripleNum</code>值：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">println</span>(<span class=\"string\">\"Tripled: \\(tripleNum.toInt32())\"</span>)</span><br></pre></td></tr></table></figure><br><code>JSValue</code> 包括一系列方法用于访问其可能的值以保证有正确的 <code>Foundation 基本类型</code><br>包括：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/JSValueType.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"下标取值：访问JSContext环境下的任何值\"><a href=\"#下标取值：访问JSContext环境下的任何值\" class=\"headerlink\" title=\"下标取值：访问JSContext环境下的任何值\"></a>下标取值：访问JSContext环境下的任何值</h3><p><code>JSContext</code> 和 <code>JSValue</code> 实例可以使用下标的方式访问之前创建的 <code>context</code> 的任何值。</p>\n<ul>\n<li><code>JSContext</code>：需要一个字符串下标</li>\n<li><code>JSValue</code>：允许使用<code>字符串</code>或<code>整数</code>标来得到里面的对象和数组</li>\n</ul>\n<h4 id=\"JSContext下标取值\"><a href=\"#JSContext下标取值\" class=\"headerlink\" title=\"JSContext下标取值\"></a>JSContext下标取值</h4><ol>\n<li><code>swift</code>语法<figure class=\"highlight swift\"><figcaption><span>未映射成[]的原始方法</span><a href=\"http://nshipster.cn/object-subscripting/\" target=\"_blank\" rel=\"noopener\">objectAtKeyedSubscript()和objectAtIndexedSubscript()</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> names = context.objectForKeyedSubscript(<span class=\"string\">\"names\"</span>)  <span class=\"comment\">//JSContext字符串下标原始方法</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"JSValue整数下标原始方法\"><a href=\"#JSValue整数下标原始方法\" class=\"headerlink\" title=\"JSValue整数下标原始方法\"></a>JSValue整数下标原始方法</h4><figure class=\"highlight swift\"><figcaption><span>未映射成[]的原始方法</span><a href=\"http://nshipster.cn/object-subscripting/\" target=\"_blank\" rel=\"noopener\">objectAtKeyedSubscript()和objectAtIndexedSubscript()</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> initialName = names.objectAtIndexedSubscript(<span class=\"number\">0</span>)   <span class=\"comment\">//JSValue整数下标原始方法</span></span><br><span class=\"line\"><span class=\"built_in\">println</span>(<span class=\"string\">\"The first name: \\(initialName.toString())\"</span>)  <span class=\"comment\">//JSValue method</span></span><br><span class=\"line\"><span class=\"comment\">// The first name: Grace</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在这里，Objective-C 代码可以利用下标表示法，如下例：context[@”names”]，names[0]，[initialName toString]，Swift 目前只公开<a href=\"http://nshipster.cn/object-subscripting/\" target=\"_blank\" rel=\"noopener\">原始方法</a>:<code>objectAtKeyedSubscript()</code> 和 <code>objectAtIndexedSubscript()</code>来让下标成为可能。</p>\n</blockquote>\n<h3 id=\"callWithArguments调用JS方法：只需传入Foundation基本类型参数\"><a href=\"#callWithArguments调用JS方法：只需传入Foundation基本类型参数\" class=\"headerlink\" title=\"callWithArguments调用JS方法：只需传入Foundation基本类型参数\"></a>callWithArguments调用JS方法：只需传入Foundation基本类型参数</h3><p>上述<code>JavaScript</code>代码中，<code>JSValue</code>包装了一个<code>triple函数</code>，在<code>Objective-C / Swift</code> 代码中可以使用 <code>Foundation基本类型</code>作为参数来直接调用该函数。再次，<code>JavaScriptCore</code> 很轻松的处理了这个桥接：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> tripleFunction = context.objectForKeyedSubscript(<span class=\"string\">\"triple\"</span>) <span class=\"comment\">//下标取值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = tripleFunction.callWithArguments([<span class=\"number\">5</span>]) <span class=\"comment\">//传入基本类型参数直接调用</span></span><br><span class=\"line\"><span class=\"built_in\">println</span>(<span class=\"string\">\"Five tripled: \\(result.toInt32())\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"exceptionHandler错误处理\"><a href=\"#exceptionHandler错误处理\" class=\"headerlink\" title=\"exceptionHandler错误处理\"></a><code>exceptionHandler</code>错误处理</h3><p><code>exceptionHandler</code> 是一个接收<code>JSContext 引用</code>和<code>异常本身</code>的回调处理的闭包。<br>通过设置上下文的 <code>exceptionHandler</code> 属性，可以观察和记录<code>语法</code>，<code>类型</code>以及<code>运行时错误</code>:<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.exceptionHandler = &#123; context, exception <span class=\"keyword\">in</span></span><br><span class=\"line\"><span class=\"built_in\">println</span>(<span class=\"string\">\"JS Error: \\(exception)\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">context.evaluateScript(<span class=\"string\">\"function multiply(value1, value2) &#123; return value1 * value2 \"</span>)</span><br><span class=\"line\"><span class=\"comment\">// JS Error: SyntaxError: Unexpected end of script</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"JS Error: %@\"</span>, exception);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">[context evaluateScript:<span class=\"string\">@\"function multiply(value1, value2) &#123; return value1 * value2 \"</span>];</span><br><span class=\"line\"><span class=\"comment\">// JS Error: SyntaxError: Unexpected end of script</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"JavaScript-通过JSContext调用-swift／OC\"><a href=\"#JavaScript-通过JSContext调用-swift／OC\" class=\"headerlink\" title=\"JavaScript 通过JSContext调用 swift／OC\"></a>JavaScript 通过JSContext调用 swift／OC</h2><p>怎样从 <code>JavaScript</code> 访问我们在 <code>Objective-C</code>或 <code>Swift</code> 定义的对象和方法？<br>让 <code>JSContext</code> 访问我们的本地客户端代码的方式主要有两种：</p>\n<ol>\n<li><code>block块</code>键值对：把OC中的<code>block块</code>赋值给<code>JSContext</code>的一个标示键，该标识键的<code>JSValue</code>可以通过<code>callWithArguments</code>调用.</li>\n<li><code>JSExport 协议</code>。</li>\n</ol>\n<h3 id=\"block块-键值对-该block键的JSValue通过callWithArguments调用\"><a href=\"#block块-键值对-该block键的JSValue通过callWithArguments调用\" class=\"headerlink\" title=\"block块 键值对:该block键的JSValue通过callWithArguments调用\"></a>block块 键值对:该block键的<code>JSValue</code>通过<code>callWithArguments</code>调用</h3><p>当一个 <code>Objective-C block</code> 被赋给 <code>JSContext</code> 里的一个标识符，<code>JavaScriptCore</code> 会自动的把 <code>block</code> 封装在 <code>JavaScript 函数</code>里，并以该标示符作为函数名来调用该block的实现。这使得在 <code>JavaScript</code> 中可以简单的使用 <code>Foundation</code> 和 <code>Cocoa</code>类，所有的桥接都为你做好了。<br><a href=\"http://nshipster.cn/cfstringtransform/\" target=\"_blank\" rel=\"noopener\">CFStringTransform</a>处理语言的强大威力</p>\n<p>在 <code>JSContext</code> 中使用 <code>Swift 闭包</code>需要注意两点:</p>\n<ol>\n<li>与 <code>@objc_block</code> 属性一起声明</li>\n<li>使用Swift中的<code>unsafeBitCast()</code>函数，把对象转换为<code>AnyObject</code></li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> simplifyString: <span class=\"meta\">@objc</span>_block <span class=\"type\">String</span> -&gt; <span class=\"type\">String</span> = &#123; input <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> mutableString = <span class=\"type\">NSMutableString</span>(string: input) <span class=\"keyword\">as</span> <span class=\"type\">CFMutableStringRef</span></span><br><span class=\"line\">    <span class=\"type\">CFStringTransform</span>(mutableString, <span class=\"literal\">nil</span>, kCFStringTransformToLatin, <span class=\"type\">Boolean</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">    <span class=\"type\">CFStringTransform</span>(mutableString, <span class=\"literal\">nil</span>, kCFStringTransformStripCombiningMarks, <span class=\"type\">Boolean</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mutableString</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">context.setObject(<span class=\"built_in\">unsafeBitCast</span>(simplifyString, <span class=\"type\">AnyObject</span>.<span class=\"keyword\">self</span>), forKeyedSubscript: <span class=\"string\">\"simplifyString\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//通过simplifyString标示符来调用block的实现</span></span><br><span class=\"line\"><span class=\"built_in\">println</span>(context.evaluateScript(<span class=\"string\">\"simplifyString('안녕하새요!')\"</span>))</span><br><span class=\"line\"><span class=\"comment\">// annyeonghasaeyo!</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//给标示符赋值一个oc-block，该标示符会被自动装换为JavaScript函数</span></span><br><span class=\"line\">context[<span class=\"string\">@\"simplifyString\"</span>] = ^(<span class=\"built_in\">NSString</span> *input) &#123;</span><br><span class=\"line\"><span class=\"built_in\">NSMutableString</span> *mutableString = [input mutableCopy];</span><br><span class=\"line\"><span class=\"built_in\">CFStringTransform</span>((__bridge <span class=\"built_in\">CFMutableStringRef</span>)mutableString, <span class=\"literal\">NULL</span>, kCFStringTransformToLatin, <span class=\"literal\">NO</span>);</span><br><span class=\"line\"><span class=\"built_in\">CFStringTransform</span>((__bridge <span class=\"built_in\">CFMutableStringRef</span>)mutableString, <span class=\"literal\">NULL</span>, kCFStringTransformStripCombiningMarks, <span class=\"literal\">NO</span>);</span><br><span class=\"line\"><span class=\"keyword\">return</span> mutableString;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过simplifyString标示符来调用block的实现</span></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [context evaluateScript:<span class=\"string\">@\"simplifyString('안녕하새요!')\"</span>]);</span><br></pre></td></tr></table></figure>\n<h4 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h4><p>由于 <code>block</code> 可以保有变量引用，而且 <code>JSContext</code> 也强引用它所有的变量，为了避免强引用循环需要特别小心。<br>避免保有<code>JSContext</code> 或<code>一个 block</code> 里的任何 <code>JSValue</code>。相反，使用 <code>[JSContext currentContext]</code> 得到当前上下文，并把你需要的任何值用参数传递。</p>\n<h3 id=\"JSExport-协议\"><a href=\"#JSExport-协议\" class=\"headerlink\" title=\"JSExport 协议\"></a>JSExport 协议</h3><p>在继承<code>JSExport 协议</code>的子协议里声明的属性，实例方法还是类方法，都会自动暴漏给<code>JavaScript</code>代码来调用。</p>\n","raw":null,"categories":[{"name":"swift","path":"api/categories/swift.json"},{"name":"JS混编","path":"api/categories/JS混编.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"iOS","path":"api/tags/iOS.json"},{"name":"swift","path":"api/tags/swift.json"},{"name":"macOS","path":"api/tags/macOS.json"},{"name":"混编","path":"api/tags/混编.json"},{"name":"Java​Script​Core","path":"api/tags/Java​Script​Core.json"}]},{"title":"swift错误处理","slug":"swift/错误处理","date":"2017-01-11T17:04:21.000Z","updated":"2017-01-12T11:57:41.000Z","comments":true,"path":"api/articles/swift/错误处理.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>Error handling is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime.<br>Some operations aren’t guaranteed to always complete execution or produce a useful output. Optionals are used to represent the absence of a value, but when an operation fails, it’s often useful to understand what caused the failure, so that your code can respond accordingly.<br>As an example, consider the task of reading and processing data from a file on disk. There are a number of ways this task can fail, including the file not existing at the specified path, the file not having read permissions, or the file not being encoded in a compatible format. Distinguishing among these different situations allows a program to resolve some errors and to communicate to the user any errors it can’t resolve.<br>举例，在读取和处理磁盘上的一个文件的数据时，会有有许多方法失败，包括指定的文件路径找不到，没有文件的读取权限，或文件编码格式不兼容。在这些不同情况下，就可以让程序提示用户导致程序无法执行的具体原因。</p>\n<h1 id=\"Representing-and-Throwing-Errors\"><a href=\"#Representing-and-Throwing-Errors\" class=\"headerlink\" title=\"Representing and Throwing Errors\"></a>Representing and Throwing Errors</h1><p>In Swift, errors are represented by values of types that conform to the Error protocol. This empty protocol indicates that a type can be used for error handling.<br>在swift中，错误类型是遵循Error 协议。</p>\n<p>Swift enumerations are particularly well suited to modeling a group of related error conditions, with associated values allowing for additional information about the nature of an error to be communicated. For example, here’s how you might represent the error conditions of operating a vending machine inside a game:<br>swift枚举类型特别适合为一组错误条件建模，用来关联导致错误的真正原因的相关信息。例如：<br>一个在操作一台游戏机时的会出现的错误枚举类：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">VendingMachineError</span>: <span class=\"title\">Error</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> invalidSelection</span><br><span class=\"line\"><span class=\"keyword\">case</span> insufficientFunds(coinsNeeded: <span class=\"type\">Int</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> outOfStock</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Throwing an error lets you indicate that something unexpected happened and the normal flow of execution can’t continue. You use a throw statement to throw an error. For example, the following code throws an error to indicate that five additional coins are needed by the vending machine:<br>抛出错误说明游戏出现异常，导致其他操作无法进行。这是需要通过Throw语句来抛出这个错误。例如，以下代码抛出了一个错误表明需要five：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"type\">VendingMachineError</span>.insufficientFunds(coinsNeeded: <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Handling-Errors\"><a href=\"#Handling-Errors\" class=\"headerlink\" title=\"Handling Errors\"></a>Handling Errors</h1><p>When an error is thrown, some surrounding piece of code must be responsible for handling the error—for example, by correcting the problem, trying an alternative approach, or informing the user of the failure.<br>当错误抛出后，这段代码必须来处理这个错误。例如：通过纠正问题，尝试其他方式实现，或通知用户的失败。</p>\n<p>There are four ways to handle errors in Swift. You can propagate the error from a function to the code that calls that function, handle the error using a do-catch statement, handle the error as an optional value, or assert that the error will not occur. Each approach is described in a section below.<br>在swift中有四种处理错误机制:</p>\n<pre><code>1. 向调用方法中传递这个错误\n2. 使用do-catch语句处理\n3. 把错误设置为可选型\n4.断言不会出现异常的情况下，使用try!禁止异常抛出\n</code></pre><p>When a function throws an error, it changes the flow of your program, so it’s important that you can quickly identify places in your code that can throw errors. To identify these places in your code, write the try keyword—or the try? or try! variation—before a piece of code that calls a function, method, or initializer that can throw an error. These keywords are described in the sections below.<br>当一个方法抛出错误时，会打断程序正常的工作流，必须快速定位到可能抛出错误的代码。可以使用关键字<code>try</code> 要注意 <code>try?</code>或<code>try!</code>之间的差异。在调用一个函数，方法或者构造器之前，来抛出异常。</p>\n<h2 id=\"Propagating-Errors-Using-Throwing-Functions\"><a href=\"#Propagating-Errors-Using-Throwing-Functions\" class=\"headerlink\" title=\"Propagating Errors Using Throwing Functions\"></a>Propagating Errors Using Throwing Functions</h2><p>To indicate that a function, method, or initializer can throw an error, you write the throws keyword in the function’s declaration after its parameters. A function marked with throws is called a throwing function. If the function specifies a return type, you write the throwskeyword before the return arrow (-&gt;).<br>函数，方法或构造器都可以抛出异常，只需要在声明它们时添加关键字：<code>throws</code>即可，这种方法被称为<code>throws</code>函数，<code>throws</code>关键字位置在参数之后，返回值(-&gt;)之前</p>\n<p>A throwing function propagates errors that are thrown inside of it to the scope from which it’s called.<br>抛出函数会把错误抛给调用它的函数周期中去。</p>\n<a id=\"more\"></a>\n<p>Only throwing functions can propagate errors. Any errors thrown inside a nonthrowing function must be handled inside the function.<br>只有抛出函数能传递错误，如果不是抛出函数，它自己必须处理掉任何抛进来的错误。</p>\n<p>In the example below, the VendingMachine class has a <code>vend(itemNamed:)</code> method that throws an appropriate VendingMachineError if the requested item is not available, is out of stock, or has a cost that exceeds the current deposited amount:<br>在下面的例子中，对某个请求内容不可用时，自动售货机会通过<code>vend(itemNamed:)</code>方法抛出一个对应的<code>VendingMachineError</code>错误，缺货或超过目前的存款金额成本：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Item</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> price: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">count</span>: <span class=\"type\">Int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VendingMachine</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> inventory = [</span><br><span class=\"line\">        <span class=\"string\">\"Candy Bar\"</span>: <span class=\"type\">Item</span>(price: <span class=\"number\">12</span>, <span class=\"built_in\">count</span>: <span class=\"number\">7</span>),</span><br><span class=\"line\">        <span class=\"string\">\"Chips\"</span>: <span class=\"type\">Item</span>(price: <span class=\"number\">10</span>, <span class=\"built_in\">count</span>: <span class=\"number\">4</span>),</span><br><span class=\"line\">        <span class=\"string\">\"Pretzels\"</span>: <span class=\"type\">Item</span>(price: <span class=\"number\">7</span>, <span class=\"built_in\">count</span>: <span class=\"number\">11</span>)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    <span class=\"keyword\">var</span> coinsDeposited = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">vend</span><span class=\"params\">(itemNamed name: String)</span></span> <span class=\"keyword\">throws</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> item = inventory[name] <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"type\">VendingMachineError</span>.invalidSelection</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> item.<span class=\"built_in\">count</span> &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"type\">VendingMachineError</span>.outOfStock</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> item.price &lt;= coinsDeposited <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"type\">VendingMachineError</span>.insufficientFunds(coinsNeeded: item.price - coinsDeposited)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        coinsDeposited -= item.price</span><br><span class=\"line\">        <span class=\"keyword\">var</span> newItem = item</span><br><span class=\"line\">        newItem.<span class=\"built_in\">count</span> -= <span class=\"number\">1</span></span><br><span class=\"line\">        inventory[name] = newItem</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Dispensing \\(name)\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>The implementation of the <code>vend(itemNamed:)</code> method uses guard statements to exit the method early and throw appropriate errors if any of the requirements for purchasing a snack aren’t met. Because a throw statement immediately transfers program control, an item will be vended only if all of these requirements are met.<br><code>vend(itemNamed:)</code>方法的实现中使用 <code>guard语句</code>来判断，当在购买操作不符合相应条件会直接抛出相应的错误，来打断该方法的其他操作。因为<code>throw语句</code>会立即转移程序控制权，保证了机器仅出售满足所有条件的物品。</p>\n<p>Because the <code>vend(itemNamed:)</code> method propagates any errors it throws, any code that calls this method must either handle the errors—using a <code>do-catch</code> statement, <code>try?</code>, or <code>try!</code>—or continue to propagate them. For example, the <code>buyFavoriteSnack(person:vendingMachine:)</code> in the example below is also a throwing function, and any errors that the <code>vend(itemNamed:)</code> method throws will propagate up to the point where the <code>buyFavoriteSnack(person:vendingMachine:)</code>function is called.<br>因为vend(itemNamed:)的方法抛出所有错误，所以调用该方法的函数必须处理错误（ <code>do-catch, try?, or try!</code>处理，或使用<code>try</code>向上抛出）。</p>\n<p>例如，<code>buyFavoriteSnack(person:vendingMachine:)</code>也是一个抛出函数，从<code>vend(itemNamed:)</code>方法接受到的所有错误，都会被会<code>buyFavoriteSnack(person:vendingMachine:)</code>继续抛给调用它的函数中。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> favoriteSnacks = [</span><br><span class=\"line\">    <span class=\"string\">\"Alice\"</span>: <span class=\"string\">\"Chips\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"Bob\"</span>: <span class=\"string\">\"Licorice\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"Eve\"</span>: <span class=\"string\">\"Pretzels\"</span>,</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buyFavoriteSnack</span><span class=\"params\">(person: String, vendingMachine: VendingMachine)</span></span> <span class=\"keyword\">throws</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> snackName = favoriteSnacks[person] ?? <span class=\"string\">\"Candy Bar\"</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> vendingMachine.vend(itemNamed: snackName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>In this example, the <code>buyFavoriteSnack(person: vendingMachine:)</code> function looks up a given person’s favorite snack and tries to buy it for them by calling the <code>vend(itemNamed:)</code> method. Because the <code>vend(itemNamed:)</code> method can throw an error, it’s called with the trykeyword in front of it.<br><code>buyFavoriteSnack(person: vendingMachine:)</code> 函数查找买家中意的snake，并<code>vend(itemNamed:)</code>调用尝试购买。使用在方法前使用<code>try</code>关键字来抛出异常，并向上传递。</p>\n<p>Throwing initializers can propagate errors in the same way as throwing functions. For example, the initializer for the <code>PurchasedSnackstructure</code> in the listing below calls a throwing function as part of the initialization process, and it handles any errors that it encounters by propagating them to its caller.<br>抛出构造器也能向抛出函数一样传递错误，例如：<code>PurchasedSnackstructure</code>的构造器中调用了抛出函数：<code>vend(itemNamed:)</code>，抛出构造器可以通过向上传递来处理这些错误。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PurchasedSnack</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, vendingMachine: <span class=\"type\">VendingMachine</span>) <span class=\"keyword\">throws</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> vendingMachine.vend(itemNamed: name)</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Handling-Errors-Using-Do-Catch\"><a href=\"#Handling-Errors-Using-Do-Catch\" class=\"headerlink\" title=\"Handling Errors Using Do-Catch\"></a>Handling Errors Using Do-Catch</h2><p>You use a do-catch statement to handle errors by running a block of code. If an error is thrown by the code in the <code>do</code> clause, it is matched against the <code>catch</code>clauses to determine which one of them can handle the error.<br>使用<code>do-catch</code>语句通过运行代码块来处理错误。在<code>do</code>分句中如果抛出了一个错误，那么就可以在<code>catch</code>分句中进行处理的匹配到错误<br>Here is the general form of a <code>do-catch</code>statement:<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> expression</span><br><span class=\"line\">    statements</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> pattern <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">    statements</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> pattern <span class=\"number\">2</span> <span class=\"keyword\">where</span> condition &#123;</span><br><span class=\"line\">    statements</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>You write a pattern after catch to indicate what errors that clause can handle. If a <code>catch</code> clause doesn’t have a pattern, the clause matches any <code>error</code> and binds the <code>error</code> to a local constant named error. For more information about pattern matching, see Patterns.<br>在关键字catch后边跟随匹配模式，这个<code>catch分句</code>就会处理匹配到的错误，如果关键字<code>catch分句</code>没有任何匹配模式，那么这个分句将会匹配到所有错误，并把这些错误信息赋值给系统常量<code>error</code>。</p>\n<p>The <code>catch</code>clauses don’t have to handle every possible error that the code in its <code>do</code> clause can throw. If none of the catch clauses handle the error, the error propagates to the surrounding scope. However, the error must be handled by some surrounding scope—either by an enclosing <code>do-catch</code> clause that handles the error or by being inside a throwing function. For example, the following code handles all three cases of the <code>VendingMachineError</code>enumeration, but all other errors have to be handled by its surrounding scope:<br><code>catch分句</code>不必对<code>do分句</code>中的代码可能抛出每一个的错误，如果某个错误没有被<code>catch分句</code>匹配到处理，这个错误将会传递到调用它的函数周期中，这个错误必须在这个函数周期中处理，或通过<code>do-catch语句</code>来处理，或通过内部的抛出函数处理。</p>\n<p>例如，下面的代码处理<code>VendingMachineError</code>枚举类中的三个错误<code>cases</code>，但其他的错误都是由其周边范围处理：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vendingMachine = <span class=\"type\">VendingMachine</span>()</span><br><span class=\"line\">vendingMachine.coinsDeposited = <span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> buyFavoriteSnack(person: <span class=\"string\">\"Alice\"</span>, vendingMachine: vendingMachine)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"type\">VendingMachineError</span>.invalidSelection &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Invalid Selection.\"</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"type\">VendingMachineError</span>.outOfStock &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Out of Stock.\"</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"type\">VendingMachineError</span>.insufficientFunds(<span class=\"keyword\">let</span> coinsNeeded) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Insufficient funds. Please insert an additional \\(coinsNeeded) coins.\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Prints \"Insufficient funds. Please insert an additional 2 coins.\"</span></span><br></pre></td></tr></table></figure></p>\n<p>In the above example, the <code>buyFavoriteSnack(person:vendingMachine:)</code> function is called in a try expression, because it can throw an error. If an error is thrown, execution immediately transfers to the <code>catch</code> clauses, which decide whether to allow propagation to continue. If no error is thrown, the remaining statements in the do statement are executed.<br>在上述代码中因为<code>buyFavoriteSnack(person:vendingMachine:)</code>函数会抛出错误异常，所以要在try表达式中调用。如果抛出异常就会立马执行是否继续传递的catch分句，如果没有抛出异常，会保持do分句中的代码正常进行。</p>\n<h2 id=\"Converting-Errors-to-Optional-Values\"><a href=\"#Converting-Errors-to-Optional-Values\" class=\"headerlink\" title=\"Converting Errors to Optional Values\"></a>Converting Errors to Optional Values</h2><p>You use try? to handle an error by converting it to an optional value. If an error is thrown while evaluating the <code>try?</code> expression, the value of the expression is nil. For example, in the following code x and y have the same value and behavior:<br>使用<code>try?表达式</code>处理错误，是通过把错误转换为<code>可选值(?)类型</code>处理。在<code>try?</code>表达式中出现抛出错误时，这个表达式的值<code>=nil</code>。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someThrowingFunction</span><span class=\"params\">()</span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"keyword\">try</span>? someThrowingFunction()</span><br><span class=\"line\"><span class=\"keyword\">let</span> y: <span class=\"type\">Int</span>?</span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    y = <span class=\"keyword\">try</span> someThrowingFunction()</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">    y = <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>If someThrowingFunction() throws an error, the value of x and y is nil. Otherwise, the value of x and y is the value that the function returned. Note that x and y are an optional of whatever type someThrowingFunction() returns. Here the function returns an integer, so xand y are optional integers.<br>如果函数<code>someThrowingFunction()</code>抛出异常，<code>x,y = nil</code>，否则:<code>x,y</code>就时函数<code>return</code>的值。</p>\n<blockquote>\n<p>注意：<code>x,y</code>是一个可选的someThrowingFunction()返回类型。在这里函数返回integer，那么x,y是可选的integer类型。</p>\n</blockquote>\n<p>Using <code>try?</code> lets you write concise error handling code when you want to handle all errors in the same way. For example, the following code uses several approaches to fetch data, or returns nil if all of the approaches fail.<br>当用这种方式来处理所有错误时，使用<code>try?</code>表达式能写更简洁的错误处理代码，例如：下面的代码使用几种方法来获取数据，如果这些方法失败就会返回nil。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fetchData</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Data</span>? &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> data = <span class=\"keyword\">try</span>? fetchDataFromDisk() &#123; <span class=\"keyword\">return</span> data &#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> data = <span class=\"keyword\">try</span>? fetchDataFromServer() &#123; <span class=\"keyword\">return</span> data &#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Disabling-Error-Propagation\"><a href=\"#Disabling-Error-Propagation\" class=\"headerlink\" title=\"Disabling Error Propagation\"></a>Disabling Error Propagation</h2><p>Sometimes you know a throwing function or method won’t, in fact, throw an error at runtime. On those occasions, you can write <code>try!</code> before the expression to disable error propagation and wrap the call in a runtime assertion that no error will be thrown. If an error actually is thrown, you’ll get a runtime error.<br>有时你认为不会出现异常的抛出函数或方法，但事实上，却在运行时抛出异常了。在其他情况下，可以使用<code>try!</code>表达式来禁止错误传递，并且十分肯定断言在运行时不会有异常抛出。如果有异常抛出，就会得到一个运行时错误。</p>\n<p>For example, the following code uses a <code>loadImage(atPath:)</code> function, which loads the image resource at a given path or throws an error if the image can’t be loaded. In this case, because the image is shipped with the application, no error will be thrown at runtime, so it is appropriate to disable error propagation.<br>例如：使用<code>loadImage(atPath:)</code>函数要么通过这个路径加载image，要么image加载失败抛出一个错误。在这种情况下，因为<code>image</code>在app资源目录<code>resources</code>中，所以在运行时肯定不会有异常抛出。因此可以使用<code>try!</code>禁止错误传递。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> photo = <span class=\"keyword\">try</span>! loadImage(atPath: <span class=\"string\">\"./Resources/John Appleseed.jpg\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Specifying-Cleanup-Actions\"><a href=\"#Specifying-Cleanup-Actions\" class=\"headerlink\" title=\"Specifying Cleanup Actions\"></a>Specifying Cleanup Actions</h2><p>You use a defer statement to execute a set of statements just before code execution leaves the current block of code. This statement lets you do any necessary cleanup that should be performed regardless of how execution leaves the current block of code—whether it leaves because an error was thrown or because of a statement such as return or break. For example, you can use a defer statement to ensure that file descriptors are closed and manually allocated memory is freed.<br>在代码执行离开当前代码块之前，使用一个“defer语句”来执行一组语句。defer语句让做一些必要的清理操作，在执行如何离开当前代码块：因为抛出异常或者因为<code>return，break语句</code>导致。例如：使用<code>defer语句</code>执行关闭文件和内存的释放操作，来确保清理操作完成。</p>\n<p>A defer statement defers execution until the current scope is exited. This statement consists of the defer keyword and the statements to be executed later. The deferred statements may not contain any code that would transfer control out of the statements, such as a break or a return statement, or by throwing an error. Deferred actions are executed in reverse order of how they are specified—that is, the code in the first defer statement executes after code in the second, and so on.<br><code>defer语句</code>推迟在直到当前作用域推出时，再执行。<code>defer语句</code>由<code>defer</code>关键字和一些清理操作语句组成。<code>defer语句</code>不包含transfer control out of the statements例如<code>（return，break，throw）</code>等。</p>\n<p><code>defer</code>延迟操作是按照指定的顺序执行的，就是先执行最后一个<code>defer语句</code>中的代码之后，再执行第倒数第二个<code>defer语句</code>的代码，以此类推，倒叙清理退场。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">processFile</span><span class=\"params\">(filename: String)</span></span> <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> exists(filename) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> file = <span class=\"keyword\">open</span>(filename)</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> &#123;</span><br><span class=\"line\">            close(file)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">let</span> line = <span class=\"keyword\">try</span> file.readline() </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Work with the file.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">            <span class=\"comment\">// close(file) is called here, at the end of the scope.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>The above example uses a defer statement to ensure that the <code>open(_:)</code> function has a corresponding call to <code>close(_:)</code>.<br>使用defer语句，确保了在open的同时与之相关的还有close。</p>\n<p>You can use a defer statement even when no error handling code is involved.<br>即使在没有涉及错误处理代码的时候，也可以使用“延迟”语句。</p>\n","raw":null,"categories":[{"name":"swift","path":"api/categories/swift.json"},{"name":"语法","path":"api/categories/语法.json"}],"tags":[{"name":"安全","path":"api/tags/安全.json"}]},{"title":"Realm数据库引擎-swift","slug":"swift/Realm数据库引擎-swift","date":"2015-12-16T05:56:15.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/swift/Realm数据库引擎-swift.json","excerpt":null,"keywords":null,"cover":"http://cc.cocimg.com/api/uploads/20150505/1430807925718367.jpg","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>中心思想：<br>继承RLMObject新建数据模型，添加相应属性，即可使用realm数据库引擎，对用户数据创建持久化，更新，删除等操作。</p>\n<h4 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h4><p><a href=\"http://realm.io/\" target=\"_blank\" rel=\"noopener\">Realm</a> 是一个跨平台的移动数据库引擎，于 2014 年 7 月发布，准确来说，它是专门为移动应用所设计的数据持久化解决方案之一。</p>\n<ul>\n<li>特点：它拥有自己的数据库存储引擎<br>  Realm 并不是对 Core Data 的简单封装，相反地， Realm 并不是基于 Core Data ，也不是基于 SQLite 所构建的。它拥有自己的数据库存储引擎，可以高效且快速地完成数据库的构建操作。</li>\n<li>Realm 支持 Swift 、 Objective-C 以及 Java 语言来编写（ Android 平台和 iOS 平台使用不同的 SDK ）。</li>\n<li>Realm 比使用 SQLite 以及 Core Data 要快很多。</li>\n<li>可视化工具<a href=\"https://itunes.apple.com/cn/app/realm-browser/id1007457278?mt=12\" target=\"_blank\" rel=\"noopener\">Realm Browser</a> ：可以让您轻松地读写 Realm 数据库的逻辑结构以及其中的数据（以 .realm 结尾），虽然 Realm Browser 的功能还十分简陋，真的只能读写而已。</li>\n<li>RealmPlugin：是 Xcode 建模插件，通过 <a href=\"http://alcatraz.io/\" target=\"_blank\" rel=\"noopener\">Alcatraz</a>安装“RealmPlugin”<h4 id=\"目的：\"><a href=\"#目的：\" class=\"headerlink\" title=\"目的：\"></a>目的：</h4>学习如何导入 Realm 框架、创建数据模型，实现 Swift 执行查询以及插入、更新和删除记录，以及使用既有的数据库。<h4 id=\"实例学习：\"><a href=\"#实例学习：\" class=\"headerlink\" title=\"实例学习：\"></a>实例学习：</h4>测试APP<a href=\"https://github.com/SemperIdem/SISpeciesNotes/tree/master\" target=\"_blank\" rel=\"noopener\">物种监测</a><br>用于记录这个 “ 动植物王国 ” 当中所发现物种的相关信息，包括种群数量、发现区域、年龄结构等等。</li>\n</ul>\n<p>在 Xcode 当中打开我们的起始项目。此时， <a href=\"http://www.raywenderlich.com/81615/www.raywenderlich.com/21365/introduction-to-mapkit-in-ios-6-tutorial\" target=\"_blank\" rel=\"noopener\">MapKit</a><br>已经在项目当中建立好了，而且项目已经拥有了一些简单的创建、更新和删除物种信息的功能.</p>\n<h4 id=\"cocoapods安装（Swift-2-1）：\"><a href=\"#cocoapods安装（Swift-2-1）：\" class=\"headerlink\" title=\"cocoapods安装（Swift 2.1）：\"></a>cocoapods安装（Swift 2.1）：</h4><p>在项目中创建Podfile配置文件，添加RealmSwift支持<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use_frameworks!   //</span><br><span class=\"line\">pod &apos;RealmSwift&apos;</span><br></pre></td></tr></table></figure></p>\n<p>执行 <code>pod install</code>下载realmSwift框架，生成<strong>.xcworkspace</strong>文件，自动重启原始项目。<br>设置Xcode项目在git版本控制中的忽略配置：详见<a href=\"http://stackoverflow.com/questions/49478/git-ignore-file-for-xcode-projects\" target=\"_blank\" rel=\"noopener\">.gitignore</a></p>\n<p><a href=\"http://blog.csdn.net/remote_roamer/article/details/47835347\" target=\"_blank\" rel=\"noopener\">use_frameworks!</a>   </p>\n<pre><code>如果在cocoapods 里面不使用 use_frameworks!,则是通过static libraries 这个方式来管理pod的代码。这样就需要在app-Bridging-Header.h 文件里面去import相应的.h 文件。而如果使用了use_frameworks!,则cocoapods 使用了frameworks 来取代static libraries 方式。 \n</code></pre><h4 id=\"开始使用：\"><a href=\"#开始使用：\" class=\"headerlink\" title=\"开始使用：\"></a>开始使用：</h4><p>编译并运行这个应用，然后尝试定位到某个您感兴趣的位置（使用模拟器的位置模拟），然后点击右上角的 “+” 按钮创建一个新的标记点。点选地图上的这个标记点，然后点击其弹出来的气泡，接下来会弹出这个标记点的详细信息。随后，点击类别文本框，就可以看到如下图所示的类别列表了:<br><img src=\"http://cc.cocimg.com/api/uploads/20150505/1430807925718367.jpg\" alt=\"\"></p>\n<ol>\n<li><p>使用Realm数据库将类别列表持久化</p>\n<ul>\n<li><p>打开<strong>CategoriesTableViewController.swift </strong>文件添加方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">populateDefaultCategories</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.results = <span class=\"type\">CategoryModel</span>.allObjects() <span class=\"comment\">// 1 查询数据返回包含类别对象的RLMResults数组</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> results.<span class=\"built_in\">count</span> == <span class=\"number\">0</span> &#123; <span class=\"comment\">// 2   通过返回结果的个数，初始化本地realm数据库</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> realm = <span class=\"type\">RLMRealm</span>.defaultRealm() <span class=\"comment\">// 3 访问默认的 realm 单例对象</span></span><br><span class=\"line\">realm.beginWriteTransaction() <span class=\"comment\">// 4   在默认 realm 数据库中启动一个事务</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> defaultCategories = <span class=\"type\">Categories</span>.allValues <span class=\"comment\">// 5 使用Categories 枚举来创建一个含有全部默认类别的数组</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> category <span class=\"keyword\">in</span> defaultCategories &#123;</span><br><span class=\"line\"><span class=\"comment\">// 6 初始化类别实例对象，设置其 name 属性，加入realm中</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> newCategory = <span class=\"type\">CategoryModel</span>()</span><br><span class=\"line\">newCategory.name = category</span><br><span class=\"line\">realm.addObject(newCategory)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">realm.commitWriteTransaction() <span class=\"comment\">// 7    调用 commitWriteTransaction() 方法来关闭事务，并且向数据库提交数据</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.results = <span class=\"type\">CategoryModel</span>.allObjects()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 viewDidLoad() 方法的底部加入以下代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">populateDefaultCategories()</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"swift","path":"api/categories/swift.json"},{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[{"name":"数据库","path":"api/tags/数据库.json"},{"name":"realm","path":"api/tags/realm.json"}]},{"title":"OC与swift相互调用","slug":"swift/OC与swift相互调用","date":"2015-12-01T11:42:18.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/swift/OC与swift相互调用.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"Swift中使用OC的类声明-–-实现配置-桥接的头文件\"><a href=\"#Swift中使用OC的类声明-–-实现配置-桥接的头文件\" class=\"headerlink\" title=\"Swift中使用OC的类声明  – 实现配置 桥接的头文件\"></a>Swift中使用OC的类声明  – 实现配置 桥接的头文件</h4><h6 id=\"方式一：自动添加桥接头文件\"><a href=\"#方式一：自动添加桥接头文件\" class=\"headerlink\" title=\"方式一：自动添加桥接头文件\"></a>方式一：自动添加桥接头文件</h6><ol>\n<li>在一个全新的Swift，利用第一次新建提示的方式自动添加桥接头文件。</li>\n<li>点确定这后就会生成一个以<producename-bridging-header.h>的头文件。</producename-bridging-header.h></li>\n<li>在targets-&gt;build settings -&gt;Object-C Bridging Header 设为生成的个桥接的头文件即可。</li>\n<li>把想要在swift类中调用的OC头文件放使用import “” 写到这个桥接文件中：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  Use this file to import your target's public headers that you would like to expose to Swift.  </span></span><br><span class=\"line\"><span class=\"comment\">//MixDemo/MixDemo-Bridging-Header.h    </span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"OCChannel.h\"</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h6 id=\"方式二：手动添加桥接头文件\"><a href=\"#方式二：手动添加桥接头文件\" class=\"headerlink\" title=\"方式二：手动添加桥接头文件\"></a>方式二：手动添加桥接头文件</h6><p>同样的，当你知道这个swift搜索头文件的关系后，就不需要再理会这个-Bridging-Header.h的文件了。<br>完全可以手工建一个并取自己喜欢的名字：</p>\n<ol>\n<li>新建一个头文件，名为:OCContainerHeader.h</li>\n<li>在targets-&gt;build settings -&gt;Object-C Bridging Header 设为生成的个桥接的头文件即可。</li>\n<li>把想要在swift类中调用的OC头文件放使用import “” 写到这个桥接文件中：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  Use this file to import your target's public headers that you would like to expose to Swift.  \t</span></span><br><span class=\"line\"><span class=\"comment\">//MixDemo/MixDemo-Bridging-Header.h    </span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"OCChannel.h\"</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"OC如何调用Swift写的类-–-为了在-Objective-C-中可用，-Swift-类必须是-Objective-C-类的子类，或者用-Objective-C-标记；\"><a href=\"#OC如何调用Swift写的类-–-为了在-Objective-C-中可用，-Swift-类必须是-Objective-C-类的子类，或者用-Objective-C-标记；\" class=\"headerlink\" title=\"OC如何调用Swift写的类  –     为了在 Objective-C 中可用， Swift 类必须是 Objective-C 类的子类，或者用 @Objective-C 标记；\"></a>OC如何调用Swift写的类  –     为了在 Objective-C 中可用， Swift 类必须是 Objective-C 类的子类，或者用 @Objective-C 标记；</h4><ol>\n<li>选中targets-&gt;build settings -&gt;packing-&gt;Product Module Name 中设置模块名（可以自定义），这个名称很重要 swift 的头文件就是根据这个来命名的，例如：SwiftModule。</li>\n<li>在OC头文件类中，添加import “SwiftModule-swift.h”但你在整个工程中是找不到这个文件的，但可以使用CMD+ 鼠标点击可看这个头文件中的内容。  </li>\n</ol>\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p>这样，工程中如查Swift要使用OC,则把需要使用的OC类的头文件，全写在MixDemo-Bridging-Header.h里。同样如果OC中所使用的swift类，只需要Clean一把，再编就可以了，但不要忘了导入SwiftModule-swift.h哦（名称自取，但-swift.h是固定的），另外还有一个需要读者注意的。</p>\n<p>注：<br>    凡是用Swift写的类，如果不继成自NSObject或NSObject 的派生类，哪么编译后将不会生成对应的转换类。从而使得OC 中找不到相应的声明。<br>如我的例子中 class Act 这样不会被编译到SwiftModule-swift.h中，但写为 class Act : NSObject，就可以编译出相应的声明。另外可以使用@objc加以声明，但这个还是一样，类最好继承NSObject下来。</p>\n","raw":null,"categories":[{"name":"swift","path":"api/categories/swift.json"},{"name":"OC混编","path":"api/categories/OC混编.json"}],"tags":[{"name":"混编","path":"api/tags/混编.json"}]},{"title":"Swift入门","slug":"swift/Swift入门","date":"2015-11-27T17:18:21.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/swift/Swift入门.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><ul>\n<li><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.html#//apple_ref/doc/uid/TP40014097-CH2-XID_1\" target=\"_blank\" rel=\"noopener\">苹果官方</a>  </li>\n<li><a href=\"http://wiki.jikexueyuan.com/project/swift/\" target=\"_blank\" rel=\"noopener\">中文版</a><h4 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h4>Apple基于已有的编译器、调试器、框架作为其基础架构。通过ARC(Automatic Reference Counting，自动引用计数)来简化内存管理。我们的框架栈则一直基于Cocoa，且Objective-C进化支持了块、collection literal和模块，允许现代语言的框架无需深入即可使用。<br>(by gashero)感谢这些基础工作，才使得可以在Apple软件开发中引入新的编程语言Swift。</li>\n</ul>\n<h4 id=\"swift有点\"><a href=\"#swift有点\" class=\"headerlink\" title=\"swift有点\"></a>swift有点</h4><p>编译器是按照性能优化的，而语言是为开发优化的</p>\n<p>Swift采用了Objective-C的命名参数和动态对象模型。提供了对Cocoa框架和mix-and-match的互操作性。基于这些基础，Swift引入了很多新功能和结合面向过程和面向对象的功能。<br>Swift对新的程序员也是友好的：</p>\n<ol>\n<li>它是工业级品质的系统编程语言，却又像脚本语言一样的友好。</li>\n<li>它支持playground，允许程序员实验一段Swift代码功能并立即看到结果，而无需麻烦的构建和运行一个应用。<br>Swift集成了现代编程语言思想，以及Apple工程文化的智慧，编译器是按照性能优化的，而语言是为开发优化的，无需互相折中。</li>\n</ol>\n<h4 id=\"swift语法\"><a href=\"#swift语法\" class=\"headerlink\" title=\"swift语法\"></a>swift语法</h4><p>Playground允许你编辑代码并立即看到结果,可以从”Hello, world”开始学起并过渡到整个系统。<br>在Xcode的playground中打开:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println(<span class=\"string\">\"Hello, world\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>在Swift，这就是完整的程序:</p>\n<ol>\n<li>无需导入(import)输入输出和字符串处理的系统库。</li>\n<li>全局范围的代码就是用于程序的入口，所以你无需编写一个 main() 函数。也无需在每个语句后写分号。</li>\n</ol>\n<p>所有这些使得Swift成为Apple软件开发者创新的源泉。</p>\n<h4 id=\"简单值-–-使用-let-来定义常量，-var-定义变量\"><a href=\"#简单值-–-使用-let-来定义常量，-var-定义变量\" class=\"headerlink\" title=\"简单值  – 使用 let 来定义常量， var 定义变量\"></a>简单值  – 使用 let 来定义常量， var 定义变量</h4><p>提供一个值就可以创建常量或变量，并让编译器推断其类型,一个常量或变量必须与赋值时拥有相同的类型。因此你不用严格定义类型。<br>常量定义类似于函数式编程语言中的变量,常量的值无需在编译时指定，但是至少要赋值一次,赋值后就无法修改。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myVariable = <span class=\"number\">42</span></span><br><span class=\"line\">myVariable = <span class=\"number\">50</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myConstant = <span class=\"number\">42</span></span><br></pre></td></tr></table></figure></p>\n<p>在上面例子中，编译其会推断myVariable是一个整数类型，因为其初始化值就是个整数。</p>\n<h6 id=\"1-显示-隐式-初始化数据类型-—-类型与变量名绑定，属于静态类型语言\"><a href=\"#1-显示-隐式-初始化数据类型-—-类型与变量名绑定，属于静态类型语言\" class=\"headerlink\" title=\"1. 显示/隐式 初始化数据类型 —   类型与变量名绑定，属于静态类型语言\"></a>1. 显示/隐式 初始化数据类型 —   类型与变量名绑定，属于静态类型语言</h6><p>类型与变量名绑定，属于静态类型语言。有助于静态优化。与Python、JavaScript等有所区别。<br>例如：初始化值没有提供足够的信息(或没有初始化值)，可以在变量名后写类型，以冒号分隔。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> imlicitInteger = <span class=\"number\">70</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> imlicitDouble = <span class=\"number\">70.0</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> explicitDouble: <span class=\"type\">Double</span> = <span class=\"number\">70</span></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"2-变量-拼接到字符串-–-变量值永远不会隐含转换到其他类型\"><a href=\"#2-变量-拼接到字符串-–-变量值永远不会隐含转换到其他类型\" class=\"headerlink\" title=\"2. 变量  拼接到字符串  – 变量值永远不会隐含转换到其他类型\"></a>2. 变量  拼接到字符串  – 变量值永远不会隐含转换到其他类型</h6><ul>\n<li><p>String(变量名)</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> label = <span class=\"string\">\"The width is \"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> width = <span class=\"number\">94</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> widthLabel = label + <span class=\"type\">String</span>(width)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>以小括号来写值，并用反斜线(“”)放在小括号之前</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> apples = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> oranges = <span class=\"number\">5</span>     <span class=\"comment\">//by gashero</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> appleSummary = <span class=\"string\">\"I have \\(apples) apples.\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fruitSummary = <span class=\"string\">\"I have \\(apples + oranges) pieces of fruit.\"</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"数组和字典的用法\"><a href=\"#数组和字典的用法\" class=\"headerlink\" title=\"数组和字典的用法\"></a>数组和字典的用法</h4><ol>\n<li>声明并初始化<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> emptyArray = <span class=\"type\">String</span>[]()</span><br><span class=\"line\"><span class=\"keyword\">let</span> emptyDictionary = <span class=\"type\">Dictionary</span>&lt;<span class=\"type\">String</span>, <span class=\"type\">Float</span>&gt;()</span><br><span class=\"line\">shoppingList = [] <span class=\"comment\">//去购物并买些东西</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如果数组类型无法推断，你可以写空的数组为 “[]” 和空的字典为 “[:]“。</p>\n<ol>\n<li>访问<br>创建一个数组和字典使用方括号 “[]”，访问其元素则是通过方括号中的索引或键。                      <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> shoppingList = [<span class=\"string\">\"catfish\"</span>, <span class=\"string\">\"water\"</span>, <span class=\"string\">\"tulips\"</span>, <span class=\"string\">\"blue paint\"</span>]</span><br><span class=\"line\">shoppingList[<span class=\"number\">1</span>] = <span class=\"string\">\"bottle of water\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> occupations = [</span><br><span class=\"line\">   <span class=\"string\">\"Malcolm\"</span>: <span class=\"string\">\"Captain\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"Kaylee\"</span>: <span class=\"string\">\"Mechanic\"</span>,</span><br><span class=\"line\">]</span><br><span class=\"line\">occupations[<span class=\"string\">\"Jayne\"</span>] = <span class=\"string\">\"Public Relations\"</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"控制流-–-条件控制，循环控制\"><a href=\"#控制流-–-条件控制，循环控制\" class=\"headerlink\" title=\"控制流  –  条件控制，循环控制\"></a>控制流  –  条件控制，循环控制</h4><h6 id=\"1-条件控制\"><a href=\"#1-条件控制\" class=\"headerlink\" title=\"1. 条件控制\"></a>1. 条件控制</h6><ul>\n<li><p>if  条件必须是布尔表达式<br>在 if 语句中，条件必须是布尔表达式，这意味着 if score { … } 是错误的，不能隐含的与0比较。<br>你可以一起使用 if 和 let 来防止值的丢失。这些值是可选的。<br>可选值可以包含一个值或包含一个 nil 来指定值还不存在。写一个问号 “?” 在类型后表示值是可选的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> optionalString: <span class=\"type\">String</span>? = <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">optionalString == <span class=\"literal\">nil</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> optionalName: <span class=\"type\">String</span>? = <span class=\"string\">\"John Appleseed\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> greeting = <span class=\"string\">\"Hello!\"</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> name = optionalName &#123;</span><br><span class=\"line\">    greeting = <span class=\"string\">\"Hello, \\(name)\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>switch 支持多种数据以及多种比较，不限制必须是整数和测试相等  </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> vegetable = <span class=\"string\">\"red pepper\"</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> vegetable &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">\"celery\"</span>:</span><br><span class=\"line\">    <span class=\"keyword\">let</span> vegetableComment = <span class=\"string\">\"Add some raisins and make ants on a log.\"</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">\"cucumber\"</span>, <span class=\"string\">\"watercress\"</span>:</span><br><span class=\"line\">    <span class=\"keyword\">let</span> vegetableComment = <span class=\"string\">\"That would make a good tea sandwich.\"</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">let</span> x <span class=\"keyword\">where</span> x.hasSuffix(<span class=\"string\">\"pepper\"</span>):</span><br><span class=\"line\">    <span class=\"keyword\">let</span> vegetableComment = <span class=\"string\">\"Is it a spicy \\(x)?\"</span></span><br><span class=\"line\"><span class=\"keyword\">default</span>:    <span class=\"comment\">//by gashero</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> vegetableComment = <span class=\"string\">\"Everything tastes good in soup.\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在执行匹配的情况后，程序会从 switch 跳出，而不是继续执行下一个情况。所以不再需要 break 跳出 switch 。</p>\n<h6 id=\"2-循环控制\"><a href=\"#2-循环控制\" class=\"headerlink\" title=\"2. 循环控制\"></a>2. 循环控制</h6><ul>\n<li>for-in 来迭代字典中的每个元素<br>可使用 for-in 来迭代字典中的每个元素，提供一对名字来使用每个键值对。<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> interestingNumbers = [</span><br><span class=\"line\">    <span class=\"string\">\"Prime\"</span>: [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>],</span><br><span class=\"line\">    <span class=\"string\">\"Fibonacci\"</span>: [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>],</span><br><span class=\"line\">    <span class=\"string\">\"Square\"</span>: [<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span>],</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"keyword\">var</span> largest = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (kind, numbers) <span class=\"keyword\">in</span> interestingNumbers &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> number <span class=\"keyword\">in</span> numbers &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> number &gt; largest &#123;</span><br><span class=\"line\">            largest = number</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```  </span><br><span class=\"line\">你可以在循环中保持一个索引，通过“..”来表示索引范围或明确声明一个初始值、条件、增量。   </span><br><span class=\"line\">这两个循环做相同的事情:  </span><br><span class=\"line\">```swift</span><br><span class=\"line\"><span class=\"keyword\">var</span> firstForLoop = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">3</span> &#123;</span><br><span class=\"line\">    firstForLoop += i</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">firstForLoop</span><br><span class=\"line\"><span class=\"keyword\">var</span> secondForLoop = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; ++i &#123;</span><br><span class=\"line\">    secondForLoop += <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>使用 .. 构造范围忽略最高值，而用 … 构造的范围则包含两个值。</p>\n<ul>\n<li>while 来重复执行代码块直到条件改变<br>使用 while 来重复执行代码块直到条件改变。循环的条件可以放在末尾来确保循环至少执行一次。<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> n &lt; <span class=\"number\">100</span> &#123;</span><br><span class=\"line\">    n = n * <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">n</span><br><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    m = m * <span class=\"number\">2</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> m &lt; <span class=\"number\">100</span></span><br><span class=\"line\">m</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"函数与闭包-–-函数是闭包的特殊情况\"><a href=\"#函数与闭包-–-函数是闭包的特殊情况\" class=\"headerlink\" title=\"函数与闭包  – 函数是闭包的特殊情况\"></a>函数与闭包  – 函数是闭包的特殊情况</h4><h6 id=\"1-闭包-无需名字，只需要放在大括号中即可\"><a href=\"#1-闭包-无需名字，只需要放在大括号中即可\" class=\"headerlink\" title=\"1. 闭包 无需名字，只需要放在大括号中即可\"></a>1. 闭包 无需名字，只需要放在大括号中即可</h6><p>编写闭包时有多种选项:</p>\n<ol>\n<li><p>使用 in 到特定参数和主体的返回值。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numbers.<span class=\"built_in\">map</span>(&#123;</span><br><span class=\"line\">    (number: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"number\">3</span> * number</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>单一语句的闭包可以直接返回值<br>例如：当一个闭包的类型是已知时，例如代表回调，你可以忽略其参数和返回值，或两者</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numbers.<span class=\"built_in\">map</span>(&#123;number <span class=\"keyword\">in</span> <span class=\"number\">3</span> * number&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过数字而不是名字来引用一个参数，这对于很短的闭包很有用。<br>例如：一个闭包传递其最后一个参数到函数作为返回值。  </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sort</span>([<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">12</span>, <span class=\"number\">2</span>]) &#123; $<span class=\"number\">0</span> &gt; $<span class=\"number\">1</span> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h6 id=\"2-函数\"><a href=\"#2-函数\" class=\"headerlink\" title=\"2. 函数\"></a>2. 函数</h6><ul>\n<li><p>函数的声明   –  使用func 声明一个函数  使用 -&gt;分隔参数的名字和返回值类型,<br>调用函数使用他的名字加上小括号中的参数列表</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">greet</span><span class=\"params\">(name: String, day: String)</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello \\(name), today is \\(day).\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">greet(<span class=\"string\">\"Bob\"</span>, <span class=\"string\">\"Tuesday\"</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数的嵌套<br>内嵌函数可以访问其定义所在函数的变量。<br>你可以使用内嵌函数来组织代码，避免过长和过于复杂：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">returnFifteen</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> y = <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        y += <span class=\"number\">5</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    add()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数接收的参数</p>\n<ol>\n<li><p>可变参数的个数  sumOf(numbers: Int…) -&gt; Int{}<br>函数可以接受可变参数个数，收集到一个数组中</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sumOf</span><span class=\"params\">(numbers: Int...)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> number <span class=\"keyword\">in</span> numbers &#123;</span><br><span class=\"line\">        sum += number</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//例子</span></span><br><span class=\"line\">sumOf(<span class=\"number\">42</span>, <span class=\"number\">597</span>, <span class=\"number\">12</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>其他函数作为参数  func hasAnyMatches(list: Int[], condition: Int -&gt; Bool) -&gt; Bool{}</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hasAnyMatches</span><span class=\"params\">(list: Int[], condition: Int -&gt; Bool)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> list &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> condition(item) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lessThanTen</span><span class=\"params\">(number: Int)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> number &lt; <span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">20</span>, <span class=\"number\">19</span>, <span class=\"number\">7</span>, <span class=\"number\">12</span>]</span><br><span class=\"line\">hasAnyMatches(numbers, lessThanTen)</span><br></pre></td></tr></table></figure>\n<p>函数实际是闭包的特殊情况。你可以写一个闭包而无需名字，只需要放在大括号中即可。使用 in 到特定参数和主体的返回值。</p>\n</li>\n</ol>\n</li>\n<li><p>函数的返回值</p>\n<ol>\n<li><p>返回多个值 ： getGasPrices() -&gt; (Double, Double, Double)<br>使用元组(tuple)来返回多个值                           </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getGasPrices</span><span class=\"params\">()</span></span> -&gt; (<span class=\"type\">Double</span>, <span class=\"type\">Double</span>, <span class=\"type\">Double</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"number\">3.59</span>, <span class=\"number\">3.69</span>, <span class=\"number\">3.79</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>返回另一个函数  ： makeIncrementer() -&gt; (Int -&gt; Int)<br>函数是第一类型的</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeIncrementer</span><span class=\"params\">()</span></span> -&gt; (<span class=\"type\">Int</span> -&gt; <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addOne</span><span class=\"params\">(number: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> + number</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> addOne</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> increment = makeIncrementer()</span><br><span class=\"line\">increment(<span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"对象与类\"><a href=\"#对象与类\" class=\"headerlink\" title=\"对象与类\"></a>对象与类</h4><h6 id=\"1-类的创建-：class-类名\"><a href=\"#1-类的创建-：class-类名\" class=\"headerlink\" title=\"1. 类的创建  ：class 类名 {}\"></a>1. 类的创建  ：class 类名 {}</h6><ol>\n<li><p>使用 class 可以创建一个类。<br>一个属性的声明则是在类里作为常量或变量声明的，除了是在类的上下文中。方法和函数也是这么写的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> numberOfSides = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">simpleDescription</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"A shape with \\(numberOfSides) sides.\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>类的构造器  ： 构造器来在创建实例时设置类，使用 init 来创建</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NamedShape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> numberOfSides: <span class=\"type\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\">    &#125;   <span class=\"comment\">//by gashero</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">simpleDescription</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"A Shape with \\(numberOfSides) sides.\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>self 用来区分 name 属性和 name 参数。<br>构造器的声明跟函数一样，除了会创建类的实例。每个属性都需要赋值，无论在声明里还是在构造器里。</p>\n<ol>\n<li>类的析构器，来执行对象销毁时的清理工作，使用 deinit 来创建<br>使用 deinit 来创建一个析构器，来执行对象销毁时的清理工作。</li>\n<li>超类的继承    <ul>\n<li>子类包括其超类的名字，以冒号分隔。在继承标准根类时无需声明，所以你可以忽略超类。  </li>\n<li>子类的方法可以通过标记 override 重载超类中的实现，而没有 override 的会被编译器看作是错误,编译器也会检查那些没有被重载的方法。<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span>: <span class=\"title\">NamedShape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sideLength: <span class=\"type\">Double</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(sideLength: <span class=\"type\">Double</span>, name: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.sideLength = sideLength</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(name: name)</span><br><span class=\"line\">        numberOfSides = <span class=\"number\">4</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">area</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Double</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sideLength * sideLength</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">simpleDescription</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"A square with sides of length \\(sideLength).\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> test = <span class=\"type\">Square</span>(sideLength: <span class=\"number\">5.2</span>, name: <span class=\"string\">\"my test square\"</span>)</span><br><span class=\"line\">test.area()</span><br><span class=\"line\">test.simpleDescription()</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h6 id=\"2-类的实例创建-类名-点语法来访问实例的属性和方法\"><a href=\"#2-类的实例创建-类名-点语法来访问实例的属性和方法\" class=\"headerlink\" title=\"2. 类的实例创建   :  类名()  ,点语法来访问实例的属性和方法\"></a>2. 类的实例创建   :  类名()  ,点语法来访问实例的属性和方法</h6><p>通过在类名后加小括号来创建类的实例。使用点语法来访问实例的属性和方法。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> shape = <span class=\"type\">Shape</span>()</span><br><span class=\"line\">shape.numberOfSides = <span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> shapeDescription = shape.simpleDescription()</span><br></pre></td></tr></table></figure></p>\n<p>可选类型 Int?<br>可选绑定 if while</p>\n<p>强制取值表达式 expression!<br>可选链表达式   expression?</p>\n<p>类型转换运算符 is , as, is?, as!</p>\n<p>标示符模式<br>值绑定模式<br>可选模式<br>类型转换模式</p>\n<p>实例方法  func<br>类型方法 class func</p>\n","raw":null,"categories":[{"name":"swift","path":"api/categories/swift.json"},{"name":"语法","path":"api/categories/语法.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"}]},{"title":"[转]Swift最佳实践","slug":"swift/[转]Swift最佳实践","date":"2015-09-29T17:05:21.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/swift/[转]Swift最佳实践.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>[英文][SwiftCommunityBestPractices]<br>[SwiftCommunityBestPractices]: <a href=\"https://github.com/schwa/Swift-Community-Best-Practices\" target=\"_blank\" rel=\"noopener\">https://github.com/schwa/Swift-Community-Best-Practices</a><br>[SwiftCommunity]: <a href=\"http://swift-lang.schwa.io/\" target=\"_blank\" rel=\"noopener\">http://swift-lang.schwa.io/</a><br>[swiftCaptureLists]: <a href=\"http://www.russbishop.net/swift-capture-lists\" target=\"_blank\" rel=\"noopener\">http://www.russbishop.net/swift-capture-lists</a><br>[SwiftURL]: <a href=\"https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html</a><br>[驼峰命名法URL]: <a href=\"http://www.wikiwand.com/en/Studly_caps\" target=\"_blank\" rel=\"noopener\">http://www.wikiwand.com/en/Studly_caps</a><br>[匈牙利命名法URL]: <a href=\"http://www.wikiwand.com/en/Hungarian_notation\" target=\"_blank\" rel=\"noopener\">http://www.wikiwand.com/en/Hungarian_notation</a></p>\n<h2 id=\"黄金法则\"><a href=\"#黄金法则\" class=\"headerlink\" title=\"黄金法则\"></a>黄金法则</h2><ul>\n<li>Apple 通常是对的。应紧随苹果所推荐的或他的 Demo 中所展示的方式。您应该尽可能地遵守 Apple 在 [The Swift Programming Language][SwiftURL] 一书中所定义的代码风格。但我们还是可以看到他们的示例代码中有不符合这些规则的地方，毕竟 Apple 是一家大公司嘛。</li>\n<li>不要仅仅为了减少字符的键入数量而使用模棱两可的简短命名，较长的命名都可以依赖自动完成、自我暗示、复制粘贴来减低键入的难度。命名的详细程度往往对代码维护者很有帮助。但过于冗长的命名却会绕过Swift的主要特性之一: 类型推导,所以命名的原则应该是简洁明了。</li>\n</ul>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><h3 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a>命名</h3><p>按照 [The Swift Programming Language][SwiftURL] 所推荐的命名法则，类型名称应该使用[首字母大写的驼峰命名法][uppercamelcaseURL] (例如: “VehicleController”)。</p>\n<p>变量与常量应该使用首字母小写的驼峰命名法(例如: “ vehicleName “ )。</p>\n<p>推荐使用 Swift 模块来定义代码的命名空间，而非在 Swift 代码上使用 Objective-C 样式的类前缀(除非接口要与 Objective-C 交互)。</p>\n<p>不推荐使用任何形式的[匈牙利命名法][匈牙利命名法URL]（比如：k 代表常量，m 代表方法）,取代代之我们应该使用短而简洁的名字并使用 Xcode 的类型快速帮助 (⌥ + 左击)。同样我们也不要使用类似 <code>SNAKE_CASE</code> 这样的名字。</p>\n<p>这些法则之上，唯一例外的情况就是枚举值了，枚举值在这里应该首字母大写(这是 Apple 的 [The Swift Programming Language][SwiftURL] 中的规范)：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Planet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"type\">Mercury</span>, <span class=\"type\">Venus</span>, <span class=\"type\">Earth</span>, <span class=\"type\">Mars</span>, <span class=\"type\">Jupiter</span>, <span class=\"type\">Saturn</span>, <span class=\"type\">Uranus</span>, <span class=\"type\">Nepture</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>有必要的话命名不要缩写<br>实际上在 Xcode 的”文本自动补全”功能下你可以轻而易举地键入 类似 <code>ViewController</code> 的长命名。</li>\n<li>极为常见的缩写<br>例如: <code>URL</code> 缩写应该是全部大写 ( “URL” )或者酌情全部小写( “url” )。<blockquote>\n<p>URL 的类型和变量命名推荐的规则： 如果 url 是一个类型，它应该被大写，如果是一个变量，那么应该小写。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>不应该使用注释来禁用代码,被注释掉的代码会污染你的源代码。<br>如果你当前想要删除一段代码，但将来又可能会用到，推荐你依赖 git 或你的 bug 追踪系统来管理。</p>\n<p>(TODO: 追加一个关于文档注释的小节，使用 nshipster 的链接)</p>\n<h3 id=\"类型推导\"><a href=\"#类型推导\" class=\"headerlink\" title=\"类型推导\"></a>类型推导</h3><p>如果可能的话，使用 Swift 的类型推导，以避免冗余的类型信息。例如：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> currentLocation = <span class=\"type\">Location</span>()</span><br></pre></td></tr></table></figure></p>\n<p>而非：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> currentLocation: <span class=\"type\">Location</span> = <span class=\"type\">Location</span>()</span><br></pre></td></tr></table></figure>\n<h3 id=\"内省\"><a href=\"#内省\" class=\"headerlink\" title=\"内省\"></a>内省</h3><p>让编译器自动推断所有的情况，这是可以做到的。在一些领域 <code>self</code> 应该被显式地使用，包括在 init 中设置参数，或者 <code>non-escaping</code>闭包。<br>例如：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Example</span></span>&#123;</span><br><span class=\"line\"> \t  <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">\t   <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\"> \t      <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\"> \t  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"捕获列表的类型推导\"><a href=\"#捕获列表的类型推导\" class=\"headerlink\" title=\"捕获列表的类型推导\"></a>捕获列表的类型推导</h3><p>在一个捕获列表( capture list )中指定参数类型会导致代码冗余。如果需要的话，仅指定类型即可。  </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> people = [</span><br><span class=\"line\">    (<span class=\"string\">\"Mary\"</span>, <span class=\"number\">42</span>),</span><br><span class=\"line\">    (<span class=\"string\">\"Susan\"</span>, <span class=\"number\">27</span>),</span><br><span class=\"line\">    (<span class=\"string\">\"Charlie\"</span>, <span class=\"number\">18</span>),</span><br><span class=\"line\">]\t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = people.<span class=\"built_in\">map</span>() &#123;</span><br><span class=\"line\">    (name: <span class=\"type\">String</span>, age: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">String</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"\\(name) is \\(age) years old\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果编译器可以推导出来的话，完全可以把类型删掉：<br><code>(name: String, age: Int) -&gt; String</code><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> strings = people.<span class=\"built_in\">map</span>() &#123;</span><br><span class=\"line\">    (name, age) <span class=\"keyword\">in</span> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"\\(name) is \\(age) years old\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用编号的参数名 (“$0”) 进一步降低冗长，往往能彻底消除捕获列表的代码冗余。在闭包中当参数名没有附带任何更多信息时仅使用编号形式即可( 如非常简单的映射和过滤器 )。</p>\n<p>Apple 能够并且将会改变闭包的参数类型，通过他们的 Objective-C 框架的 Swift 变种提供出来。<br>例如，<code>optionals</code> 被删除或更改为 <code>auto-unwrapping</code> 等。故意 under-specifying 可选并依赖 Swift 来推导类型，可以减少在这些情况下代码被破译的风险。</p>\n<p>你应该避免指定返回类型，例如这个捕获列表( capture list )就是完全多余的:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    ()-&gt;<span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Fired.\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>(以上内容也可以参考:[这里][swiftCaptureLists])</p>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>类型定义中使用的常量应当被申明成静态类型。例如:<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PhysicsModel</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> speedOfLightInAVacuum = <span class=\"number\">299_792_458</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Spaceship</span> </span>&#123;</span><br><span class=\"line\">  \t\t <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> topSpeed = <span class=\"type\">PhysicsModel</span>.speedOfLightInAVacuum</span><br><span class=\"line\"> \t     <span class=\"keyword\">var</span> speed: <span class=\"type\">Double</span></span><br><span class=\"line\">  \t\t <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fullSpeedAhead</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      \t\t speed = <span class=\"type\">Spaceship</span>.topSpeed</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>将常量标示为 <code>static</code> ，允许它们可以被无类型的实例引用。</p>\n<p>一般应该避免生成全局范围的常量，单例除外。</p>\n","raw":null,"categories":[{"name":"swift","path":"api/categories/swift.json"},{"name":"语法","path":"api/categories/语法.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"}]}]}