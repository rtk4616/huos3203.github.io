{"name":"UI","postlist":[{"title":"从UIKit到AppKit","slug":"macOS/从UIKit到AppKit","date":"2017-03-03T17:55:16.000Z","updated":"2017-03-03T17:55:16.000Z","comments":true,"path":"api/articles/macOS/从UIKit到AppKit.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/ViewEffectsInspector.jpg?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h2><h3 id=\"NSWindowController\"><a href=\"#NSWindowController\" class=\"headerlink\" title=\"NSWindowController\"></a>NSWindowController</h3><p>在<code>Mac</code>上应用都支持多窗口（<code>NSWindowController</code>），<code>AppKit</code> 中都有 <code>NSWindowController</code>担当着类似在<code>iOS</code>中的<code>view controller</code>处理的任务。</p>\n<blockquote>\n<p><code>window</code>在<code>iOS</code>占据整个屏幕，几乎不怎么不用。</p>\n<h3 id=\"NSViewController\"><a href=\"#NSViewController\" class=\"headerlink\" title=\"NSViewController\"></a>NSViewController</h3><p><code>AppKit</code> 中的 <code>NSViewController</code>默认不支持交互，缺少生命周期相关方法和<code>UIKit</code>中熟悉的特性。<br>但在OS X 10.10 Yosemite之后，<code>NSViewController</code>改进很多，默认支持交互中的响应链。</p>\n</blockquote>\n<h3 id=\"NSWindow-和-UIWindow\"><a href=\"#NSWindow-和-UIWindow\" class=\"headerlink\" title=\"NSWindow 和 UIWindow\"></a>NSWindow 和 UIWindow</h3><p>在<code>UIKit</code>中<code>UIWindow</code>是一个 <code>view</code> 的子类.<br>在<code>AppKit</code>中<code>NSWindow</code>用 <code>contentView</code> 属性持有一个指向其顶层 <code>view</code> 的引用。</p>\n<h2 id=\"响应者链（responder-chain）\"><a href=\"#响应者链（responder-chain）\" class=\"headerlink\" title=\"响应者链（responder chain）\"></a>响应者链（responder chain）</h2><p>如果你在为 OS X 10.9 或者更低版本的系统开发，请注意在默认情况下<code>view controller</code> 并不是响应者链的一环。相反，事件会沿着视图树向上传递然后直接到达 <code>window</code> 和 <code>window</code> <code>controller</code>。在这种情况下，如果你想在 <code>view controller</code> 处理事件，你需要手动把它添加到响应者链中。</p>\n<h3 id=\"Target-Action消息传递方式\"><a href=\"#Target-Action消息传递方式\" class=\"headerlink\" title=\"Target-Action消息传递方式\"></a>Target-Action消息传递方式</h3><p><code>Target-Action</code> 是回应 <code>UI 事件</code>时典型的消息传递方式。<code>iOS</code> 上的 <code>UIControl</code> 和 <code>Mac</code> 上的 <code>NSControl/NSCell</code> 都支持这个机制。<br><code>Target-Action</code> 在消息的发送者和接收者之间建立了一个松散的关系。消息的接收者不知道发送者，甚至消息的发送者也不知道消息的接收者会是什么。如果 <code>target</code> 是 <code>nil</code>，<code>action</code> 会在响应链 (responder chain) 中被传递下去，直到找到一个响应它的对象。</p>\n<h4 id=\"传递机制的局限\"><a href=\"#传递机制的局限\" class=\"headerlink\" title=\"传递机制的局限\"></a>传递机制的局限</h4><p>基于 <code>target-action</code> 传递机制的一个局限是，发送的消息不能携带自定义的信息：</p>\n<ol>\n<li>在<code>iOS</code> 中，可以选择性的把发送者和触发 <code>action</code> 的事件作为参数。</li>\n<li>在 <code>Mac</code> 平台上 <code>action</code> 方法的第一个参数永远是发送者，否则将不视为无效方法。<br>在<code>AppKit</code>唯一有效的<code>action</code> 方法声明方式：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)performAction:(<span class=\"keyword\">id</span>)sender;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"控件关联Action事件的区别\"><a href=\"#控件关联Action事件的区别\" class=\"headerlink\" title=\"控件关联Action事件的区别\"></a>控件关联Action事件的区别</h4><p><code>iOS</code> 上的 <code>UIControl</code> 和 <code>Mac</code> 上的 <code>NSControl/NSCell</code> 都支持这个机制。</p>\n<ol>\n<li>在 <code>iOS</code> 中，每个控件可以通过<code>addTarget:action:forControlEvents:</code>和多个 <code>target-action</code> 关联。</li>\n<li>在<code>AppKit</code>中通常一个<code>控件</code>仅对应一个 <code>target-action</code>对。</li>\n</ol>\n<h2 id=\"View视图系统\"><a href=\"#View视图系统\" class=\"headerlink\" title=\"View视图系统\"></a>View视图系统</h2><p>因为历史遗留问题，<code>Mac</code> 的视图系统和 <code>iOS</code>的视图系统有很大区别。</p>\n<ol>\n<li>绘图处理器差异<br><code>iOS</code>由 <code>Core Animation layer</code> 驱动，使用<code>GPU</code>处理。<br><code>AppKit</code>视图系统相关的任务主要靠 <code>CPU</code> 处理，因为在<code>AppKit</code>设计之初，<code>GPU</code>还没有诞生。<br>Mac开发参考资料：<br><a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CocoaViewsGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40002978\" target=\"_blank\" rel=\"noopener\">Introduction to View Programming Guide for Cocoa</a><br><a href=\"https://developer.apple.com/videos/wwdc/2012/#217\" target=\"_blank\" rel=\"noopener\">WWDC session：Layer-Backed Views: AppKit + Core Animation</a><br><a href=\"https://developer.apple.com/videos/wwdc/2013/#215\" target=\"_blank\" rel=\"noopener\">Optimizing Drawing and Scrolling</a></li>\n</ol>\n<h3 id=\"Layer-Backed-View-iOS反哺AppKit层支持视图\"><a href=\"#Layer-Backed-View-iOS反哺AppKit层支持视图\" class=\"headerlink\" title=\"Layer-Backed View: iOS反哺AppKit层支持视图\"></a>Layer-Backed View: iOS反哺AppKit层支持视图</h3><ol>\n<li><code>iOS</code>反哺<code>AppKit</code><br>默认情况下，<code>AppKit</code> 的 <code>view</code> 不是由 <code>Core Animation layer</code> 驱动的；<code>AppKit</code> 整合 <code>layer-backing</code> 是 <code>iOS</code> 反哺的结果。</li>\n</ol>\n<h4 id=\"layer-backing启用／禁用-wantsLayer\"><a href=\"#layer-backing启用／禁用-wantsLayer\" class=\"headerlink\" title=\"layer backing启用／禁用:wantsLayer\"></a>layer backing启用／禁用:wantsLayer</h4><p><code>AppKit</code> 区分 <code>layer-backed view</code> 和 <code>layer-hosting view</code>，可以在每个视图树的根节点启用或者禁用 <code>layer backing</code>。<br>启用 <code>layer backing</code></p>\n<ol>\n<li>方法一：把窗口的 <code>contentView</code> 的 <code>wantsLayer</code> 属性设置为 <code>YES</code></li>\n<li>方法二：在 <code>Interface Builder</code> 的 <code>View Effects Inspector</code> 面板完成<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/ViewEffectsInspector.jpg?imageMogr2/2/w/800\">\n这会导致 <code>window</code> 的视图树中所有的 <code>view</code> 都启用 <code>layer backing</code>，这样就没必要反复设置每个 <code>view</code> 的 <code>wantsLayer</code> 属性了。</li>\n</ol>\n<h4 id=\"修改layer属性\"><a href=\"#修改layer属性\" class=\"headerlink\" title=\"修改layer属性\"></a>修改layer属性</h4><p>在<code>AppKit</code>上开启<code>layer backing</code>之后，<code>layer</code>的拥有者是<code>AppKit</code>，这就意味着不能直接编辑 <code>layer</code>的属性。<br>在 <code>iOS</code> 上可以直接编辑：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.layer.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor].CGColor;</span><br></pre></td></tr></table></figure><br>在 <code>AppKit</code>编辑<code>layer</code>属性需要以下步骤：</p>\n<ol>\n<li>重写 <code>NSView</code> 的 <code>wantsUpdateLayer</code> 方法并返回 <code>YES</code>,这能让你可以改变 <code>layer</code> 的属性。<br>这样以来，在<code>view</code> 更新周期中，将不会再调用 <code>view</code> 的 <code>drawRect:</code> 方法。取而代之，调用<code>updateLayer</code>方法来更新<code>Layer</code>。<br>举个例子，用这方法去实现一个非常简单的有纯色背景的 <code>view</code>（没错，<code>NSView</code> 没有<code>backgroundColor</code> 属性）：<br>这个例子的前提是这个 <code>view</code> 的<code>父 view</code> 已经为其视图树启用了 <code>layer backing</code>。<br>另一种可行的实现则只需要重写 <code>drawRect:</code> 方法并在其中绘制背景颜色。<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ColoredView</span>: <span class=\"title\">NSView</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSColor</span> *backgroundColor;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ColoredView</span></span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)wantsUpdateLayer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)updateLayer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.layer.backgroundColor = <span class=\"keyword\">self</span>.backgroundColor.CGColor;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setBackgroundColor:(<span class=\"built_in\">NSColor</span> *)backgroundColor</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _backgroundColor = backgroundColor;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setNeedsDisplay:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"合并-Layer\"><a href=\"#合并-Layer\" class=\"headerlink\" title=\"合并 Layer\"></a>合并 Layer</h4><p>当APP启动过多的<code>layer-backed view</code> 会带来巨大的内存消耗（每一个 <code>layer</code> 有其自己的 <code>backing store</code>，还有可能和其他 <code>view</code>的 <code>backing store</code> 重叠）而且会带来潜在的合成这些 <code>layer</code> 的消耗。</p>\n<h5 id=\"canDrawSubviewsIntoLayer合并Layer\"><a href=\"#canDrawSubviewsIntoLayer合并Layer\" class=\"headerlink\" title=\"canDrawSubviewsIntoLayer合并Layer\"></a>canDrawSubviewsIntoLayer合并Layer</h5><p>从 OS X 10.9 开始，如果不单独对一个 <code>view</code> 中的子 <code>view</code> 做动画，可以通过设置 <code>canDrawSubviewsIntoLayer</code> 属性来让 <code>AppKit</code> 合并一个<code>视图树</code>中所有 <code>layer</code> 的内容到一个共有的 <code>layer</code>。</p>\n<h5 id=\"隐式layer-backed合并Layer\"><a href=\"#隐式layer-backed合并Layer\" class=\"headerlink\" title=\"隐式layer-backed合并Layer\"></a>隐式layer-backed合并Layer</h5><p>所有隐式 <code>layer-backed</code> 的<code>子 view</code>（比如，没有显式地对这些<code>子 view</code> 设置 <code>wantsLayer = YES</code>）现在将会被绘制到同一个 <code>layer</code> 中。不过<code>wantsLayer</code> 设置为 <code>YES</code> 的<code>子 view</code> 仍然持有它们自己的 <code>backing layer</code>， 而且不管 <code>wantsUpdateLayer</code> 返回什么，它们的 <code>drawRect:</code> 方法仍然会被调用。</p>\n<h4 id=\"Layer-重绘策略\"><a href=\"#Layer-重绘策略\" class=\"headerlink\" title=\"Layer 重绘策略\"></a>Layer 重绘策略</h4><h5 id=\"layer-backed-view-默认的自动重绘策略\"><a href=\"#layer-backed-view-默认的自动重绘策略\" class=\"headerlink\" title=\"layer-backed view 默认的自动重绘策略\"></a>layer-backed view 默认的自动重绘策略</h5><p><code>layer-backed view</code> 会默认设置重绘策略为 <code>NSViewLayerContentsRedrawDuringViewResize</code>。在行为上，这个非 <code>layer-backed view</code> 是类似的，不过如果动画的每一帧都引入一个绘制步骤的话可能会对动画的性能造成不利影响。</p>\n<h5 id=\"设置layer-backed-view手动重绘策略\"><a href=\"#设置layer-backed-view手动重绘策略\" class=\"headerlink\" title=\"设置layer-backed view手动重绘策略\"></a>设置layer-backed view手动重绘策略</h5><ol>\n<li>设置手动重绘策略：把 <code>layerContentsRedrawPolicy</code> 属性设置为 <code>NSViewLayerContentsRedrawOnSetNeedsDisplay</code> </li>\n<li>实现手动重绘操作：调用 <code>-setNeedsDisplay:</code>方法来触发重绘操作<br>这样便由你来决定 <code>layer</code> 的内容何时需要重绘。帧的改变将不再自动触发重绘。</li>\n</ol>\n<h5 id=\"设置view的属性来重绘Layer\"><a href=\"#设置view的属性来重绘Layer\" class=\"headerlink\" title=\"设置view的属性来重绘Layer\"></a>设置view的属性来重绘Layer</h5><ol>\n<li>view中<code>layerContentsPlacement</code>属性：等价<code>layer</code>中的 <code>contentGravity</code> 属性。<br>这个属性允许你指定在调整大小的时候当前的 <code>layer</code> 内容该怎么映射到 <code>layer</code> 上。</li>\n</ol>\n<h3 id=\"Layer-Hosting-View-使用-Core-Animation-layer\"><a href=\"#Layer-Hosting-View-使用-Core-Animation-layer\" class=\"headerlink\" title=\"Layer-Hosting View:使用 Core Animation layer\"></a>Layer-Hosting View:使用 Core Animation layer</h3><p><code>layer-hosting view</code> 是视图树中的叶子节点，使用这种模式可以对<code>layer</code> 及其<code>子 layer</code> 做任何操作，代价是你再也不能给该 <code>view</code> 添加任何<code>子 view</code>。</p>\n<h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><ol>\n<li>为 <code>view</code> 的 <code>layer</code> 属性分配一个 <code>layer 对象</code>，</li>\n<li>设置<code>wantsLayer</code> 为 <code>YES</code><br>这些步骤的顺序是非常关键：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithFrame:(<span class=\"type\">NSRect</span>)frame</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> initWithFrame:frame];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.layer = [[<span class=\"type\">CALayer</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.wantsLayer = <span class=\"type\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n在你设置了自定义的 <code>layer</code> 之后，再设置 <code>wantsLayer</code> 是非常重要的。</li>\n</ol>\n<h3 id=\"其他与-View-相关的陷阱\"><a href=\"#其他与-View-相关的陷阱\" class=\"headerlink\" title=\"其他与 View 相关的陷阱\"></a>其他与 View 相关的陷阱</h3><h4 id=\"坐标系统原点设置左下／左上角\"><a href=\"#坐标系统原点设置左下／左上角\" class=\"headerlink\" title=\"坐标系统原点设置左下／左上角\"></a>坐标系统原点设置左下／左上角</h4><p>通过重写<code>isFlipped</code> 并返回 <code>YES</code> 来恢复到你熟悉的左上角。</p>\n<h4 id=\"View背景颜色属性drawsBackground\"><a href=\"#View背景颜色属性drawsBackground\" class=\"headerlink\" title=\"View背景颜色属性drawsBackground\"></a>View背景颜色属性drawsBackground</h4><p>由于 <code>AppKit</code> 中的 <code>view</code> 没有背景颜色属性可以让你直接设置为 <code>[NSColor clearColor]</code> 来让其变得透明，许多 <code>NSView</code> 的子类比如 <code>NSTextView</code> 和 <code>NSScrollView</code> 开放了一个 <code>drawsBackground</code> 属性，如果你想让这一类 <code>view</code> 透明，你必须设置该属性为 <code>NO</code>。</p>\n<h4 id=\"设置光标追踪区域\"><a href=\"#设置光标追踪区域\" class=\"headerlink\" title=\"设置光标追踪区域\"></a>设置光标追踪区域</h4><p>为了能接收光标进出一个 view 或者在 view 里面移动的事件，你需要创建一个追踪区域。你可以在 <code>NSView</code> 中指定的 <code>updateTrackingAreas</code> 方法中来做这件事情。一个通用的写法看起来是这样子的：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)updateTrackingAreas</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> removeTrackingArea:<span class=\"keyword\">self</span>.trackingArea];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.trackingArea = [[<span class=\"type\">NSTrackingArea</span> alloc] initWithRect:<span class=\"type\">CGRectZero</span> </span><br><span class=\"line\">                                                     options:<span class=\"type\">NSTrackingMouseEnteredAndExited</span>|<span class=\"type\">NSTrackingInVisibleRect</span>|<span class=\"type\">NSTrackingActiveInActiveApp</span></span><br><span class=\"line\">                                                       owner:<span class=\"keyword\">self</span> </span><br><span class=\"line\">                                                    userInfo:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> addTrackingArea:<span class=\"keyword\">self</span>.trackingArea];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"NSCell困惑\"><a href=\"#NSCell困惑\" class=\"headerlink\" title=\"NSCell困惑\"></a>NSCell困惑</h4><p><code>AppKit</code> 的控件之前是由 <code>NSCell</code> 的子类驱动的，可以被所有同类型的控件重用。<br><code>AppKit</code> 最初区分 <code>view</code> 和 <code>cell</code> 是为了节省资源 - <code>view</code> 可以把所有的绘制工作代理给更轻量级的可以被所有同类型的 <code>view</code> 重用的 <code>cell</code> 对象。<br>不要混淆这些 <code>cell</code> 和 <code>UIKit</code> 里 <code>table view</code> 的 <code>cell</code> 及 <code>collection view</code> 的 <code>cell</code>。</p>\n<h5 id=\"自定义一个按钮控件\"><a href=\"#自定义一个按钮控件\" class=\"headerlink\" title=\"自定义一个按钮控件\"></a>自定义一个按钮控件</h5><p>Apple 正在一步步地抛弃这样的实现方法了，但是你还是会时不时碰到这样的问题。<br>举个例子，如果你想创建一个自定义的按钮，</p>\n<ol>\n<li>首先要继承 <code>NSButton</code> 和 <code>NSButtonCell</code></li>\n<li>然后在这个 <code>cell 子类</code>里面进行你自定义的绘制，</li>\n<li>然后通过重写 <code>+[NSControl cellClass]</code>方法告诉自定义按钮使用你的 <code>cell 子类</code></li>\n</ol>\n<h4 id=\"获取-Core-Graphics-上下文\"><a href=\"#获取-Core-Graphics-上下文\" class=\"headerlink\" title=\"获取 Core Graphics 上下文\"></a>获取 Core Graphics 上下文</h4><p>最后，如果你想知道在你自己的 <code>drawRect:</code> 方法里怎么获取当前的 <code>Core Graphics</code> 上下文，答案是 <code>NSGraphicsContext</code> 的 <code>graphicsPort</code> 属性。详细内容请查看 <a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CocoaDrawingGuide/\" target=\"_blank\" rel=\"noopener\">Cocoa Drawing Guide</a>。</p>\n<h2 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h2><p>如果你的 <code>view</code> 不是由 <code>layer</code> 驱动的，那你的动画自然是完全由 <code>CPU</code> 处理，这意味着动画的每一步都必须相应地绘制到 <code>window-backing store</code> 上。</p>\n<h3 id=\"对-layer-backed-view做动画\"><a href=\"#对-layer-backed-view做动画\" class=\"headerlink\" title=\"对 layer-backed view做动画\"></a>对 layer-backed view做动画</h3><p>正如上面说的，在 <code>AppKit</code> 中,这些 <code>layer</code> 由 <code>AppKit</code> 管理，你不应该修改 <code>layer-backed view</code> 中的 <code>layer</code>。 </p>\n<h4 id=\"几何属性\"><a href=\"#几何属性\" class=\"headerlink\" title=\"几何属性\"></a>几何属性</h4><p>与<code>iOS</code> 相反，<code>view</code> 的几何属性并不仅仅是对应的 <code>layer</code> 的几何属性的映射，但 <code>AppKit</code> 却会把 <code>view</code> 内部的几何属性同步到 <code>layer</code>。</p>\n<h4 id=\"的animator-proxy动画\"><a href=\"#的animator-proxy动画\" class=\"headerlink\" title=\"的animator proxy动画\"></a>的animator proxy动画</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view.animator.alphaValue = <span class=\"number\">.5</span>;</span><br></pre></td></tr></table></figure>\n<p>在幕后，这句代码会启用 <code>layer</code> 的隐式动画，设置其透明度，然后再次禁用 <code>layer</code> 的隐式动画。</p>\n<h4 id=\"NSAnimationContext动画\"><a href=\"#NSAnimationContext动画\" class=\"headerlink\" title=\"NSAnimationContext动画\"></a>NSAnimationContext动画</h4><ol>\n<li>结束回调<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSAnimationContext</span> runAnimationGroup:^(<span class=\"built_in\">NSAnimationContext</span> *context)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//持续时间</span></span><br><span class=\"line\">    context.duration = <span class=\"number\">1</span>;  </span><br><span class=\"line\">    <span class=\"comment\">//缓动类型</span></span><br><span class=\"line\">    context.timingFunction = [<span class=\"built_in\">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseIn];</span><br><span class=\"line\">    view.animator.alphaValue = <span class=\"number\">.5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; completionHandler:^&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;]; </span><br></pre></td></tr></table></figure></li>\n<li>无结束回调<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSAnimationContext</span> currentContext].duration = <span class=\"number\">1</span>;</span><br><span class=\"line\">view.animator.alphaValue = <span class=\"number\">.5</span>; </span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"启用隐式动画\"><a href=\"#启用隐式动画\" class=\"headerlink\" title=\"启用隐式动画\"></a>启用隐式动画</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSAnimationContext</span> currentContext].allowsImplicitAnimations = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">view.alphaValue = <span class=\"number\">.5</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"CAAnimations控制动画\"><a href=\"#CAAnimations控制动画\" class=\"headerlink\" title=\"CAAnimations控制动画\"></a>CAAnimations控制动画</h4><p>使用 <code>CAAnimation</code> 实例更全面地控制动画。和 <code>iOS</code> 相反，你不能直接把它们加到 <code>layer</code> 上（因为 <code>layer</code> 不应该由你来修改），不过你可以使用 <code>NSAnimatablePropertyContainer</code> 协议中定义的 <code>API</code>，<code>NSView</code> 和 <code>NSWindow</code> 已经实现了该协议。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CAKeyframeAnimation</span> *animation = [<span class=\"built_in\">CAKeyframeAnimation</span> animation];</span><br><span class=\"line\">animation.values = @[@<span class=\"number\">1</span>, @<span class=\"number\">.9</span>, @<span class=\"number\">.8</span>, @<span class=\"number\">.7</span>, @<span class=\"number\">.6</span>];</span><br><span class=\"line\">view.animations = @&#123;<span class=\"string\">@\"alphaValue\"</span>: animation&#125;;</span><br><span class=\"line\">view.animator.alphaValue = <span class=\"number\">.5</span>;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"帧动画\"><a href=\"#帧动画\" class=\"headerlink\" title=\"帧动画\"></a>帧动画</h5><p>对于帧动画来说，把 <code>view</code> 的 <code>layerContentsRedrawPolicy</code> 设置为 <code>NSViewLayerContentsRedrawOnSetNeedsDisplay</code> 是非常重要的，不然的话 <code>view</code> 的内容在每一帧都会被重绘。</p>\n<p>很遗憾，<code>NSView</code> 没有开放 <code>Core Animation layer</code> 所有可以进行动画的属性，<code>transform</code> 是其中最重要的例子。看看 Jonathan Willings 的这篇文章，它描述了你可以如何解决这些限制。不过注意，文章中的解决方案是不受官方支持的。</p>\n<p>上面提到的所有东西都适用于 <code>layer-backed view</code>。对于 l<code>ayer-hosting view</code> 来说，你可以直接对 <code>view</code> 的 <code>layer</code> 或者<code>子 layer</code> 使用 <code>CAAnimations</code>，因为你拥有它们的控制权。</p>\n<h3 id=\"文字系统\"><a href=\"#文字系统\" class=\"headerlink\" title=\"文字系统\"></a>文字系统</h3><p>有了 <code>TextKit</code>，<code>iOS 7</code> 终于有了和 <code>Mac</code> 上早就有了的 <code>Cocoa Text System</code> 等效的东西。但 Apple 并不仅仅是把文字系统从 Mac 上转移到 <code>iOS</code>；相反，Apple 对其做了些显著的改变。<br>举个例子，<code>AppKit</code> 开放 <code>NSTypesetter</code> 和 <code>NSGlyphGenerator</code>，你可以通过继承这两者来自定义它们的一些特性。<code>iOS</code> 并不开放这些类，但是你可以通过 <code>NSLayoutManagerDelegate</code> 协议达到定制的目的。<br>总体来说，两个平台的文字系统还是非常相似的，所有你在 <code>iOS</code> 上能做的在 <code>Mac</code> 上都可以做（甚至更多），但对于一些东西，你必须从不同的地方寻找合适的方法实现。</p>\n<h3 id=\"沙盒\"><a href=\"#沙盒\" class=\"headerlink\" title=\"沙盒\"></a>沙盒</h3><p>符合沙盒机制的 <code>Mac 应用</code>才能通过 <code>Mac App Store</code> 销售。然而，我们已经习惯了沙盒机制还没出现之前的 <code>Mac</code> 开发环境，所以有时候会忽视一些你想要实现的功能会和沙盒的限制出现冲突。<br>管理Mac应用对沙盒支持：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/sandbox.jpg?imageMogr2/2/w/800\"></p>\n<h2 id=\"独有特性\"><a href=\"#独有特性\" class=\"headerlink\" title=\"独有特性\"></a>独有特性</h2><p>有很多事情你只能在 Mac 上做，这主要是因为它不同的交互模型和它更为宽松的安全策略。在本期话题中，我们有一些文章深入探讨了其中的一些内容：<a href=\"http://objccn.io/issue-14-4/\" target=\"_blank\" rel=\"noopener\">进程间通讯</a>，<a href=\"http://objccn.io/issue-14-1/\" target=\"_blank\" rel=\"noopener\">使 Mac 应用脚本化</a>,<a href=\"http://objccn.io/issue-14-2/\" target=\"_blank\" rel=\"noopener\">在沙盒中脚本化其他应用</a> , <a href=\"http://objccn.io/issue-14-3/\" target=\"_blank\" rel=\"noopener\">为你的应用构建插件</a>。<br>当然，这只是 Mac 独有特性中很小的一部分，但这给了你一个很好的视角看待 iOS 8 从头开始打造其可扩展性和 app 间通讯。最后，还有很多东西等待你去探索：Drag and Drop，Printing，Bindings，OpenCL 等等，这里仅仅是举几个例子。</p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"视图","path":"api/categories/视图.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"混编","path":"api/tags/混编.json"}]},{"title":"UIStackView教程：了解Stack View","slug":"iOS/UIStackView教程了解StackView","date":"2017-02-24T18:12:14.000Z","updated":"2017-02-25T14:33:14.000Z","comments":true,"path":"api/articles/iOS/UIStackView教程了解StackView.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><a href=\"http://blog.csdn.net/kmyhy/article/details/50456444\" target=\"_blank\" rel=\"noopener\">原地址</a></p>\n<h2 id=\"UIStackView简单介绍\"><a href=\"#UIStackView简单介绍\" class=\"headerlink\" title=\"UIStackView简单介绍\"></a>UIStackView简单介绍</h2><p>一个Stack View能够将它所含的View以各种方式沿其轴向进行分布，同时也可以将View沿某个方向等距分布，要隐藏<code>Stack View</code>中的视图，你只需要设置该View的<code>Hidden</code>属性为<code>true</code>，剩下的工作Stack View会自己完成。。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0.png?imageMogr2/2/w/800\"><br>坐标（Axis）、间隔（Spacing）、对齐（Alignment）以及分布（Distribution ）等。<br>distribution属性：决定Stack View如何沿它轴向的水平方向摆放它的subview，当属性值是Fill，这表示subview会沿轴向完全占据Stack View。因此，Stack View会拉伸其中一个subview使其填充剩余空间，尤其是水平内容优先级最低的那个，如果所有subview优先级相同，则拉伸第一个subview。<br>Alignment属性：决定了Stack View如何沿它轴向的垂直方向摆放它的subview，对于一个垂直的Stack View，这个属性可以设置为Fill、Leading、Center和Trailing。<br>对于水平的Stack View，这个属性则稍有不同：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack006.png?imageMogr2/2/w/800\"><br>.Top取代了.Leading，.Bottom取代了.Trailing。此外，水平Stack View还多出了两个属性值：.FirstBaseLine和.LastBaseLine。<br>对于水平的Stack View，这个属性则稍有不同：<br>Fill:<br><img title=\"Fill\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack007.png?imageMogr2/2/w/800\"><br>Leading:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack008.png?imageMogr2/2/w/800\"><br>Center:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack009.png?imageMogr2/2/w/800\"><br>Trailing:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack000.png?imageMogr2/2/w/800\"></p>\n<p>布局方式对比<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack01.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"添加一个新的Stack-View\"><a href=\"#添加一个新的Stack-View\" class=\"headerlink\" title=\"添加一个新的Stack View\"></a>添加一个新的Stack View</h3><p>点击故事板画布左下角<code>Auto Layout工具栏</code>中的<code>Stack按钮</code>：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack3.png?imageMogr2/2/w/800\"><br>另一种解散的方法是选中Stack View，然后点击<code>Editor\\Emebed in\\stack view</code>菜单。</p>\n<h3 id=\"解散一个废弃的Stack-View\"><a href=\"#解散一个废弃的Stack-View\" class=\"headerlink\" title=\"解散一个废弃的Stack View\"></a>解散一个废弃的Stack View</h3><p>首先，选定想解散的Stack View。按下<code>Option键</code>，点击<code>Stack 按钮</code>。这将弹出一个上下文菜单，然后点击Unembed：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack001.png?imageMogr2/2/w/800\"><br>另一种解散的方法是选中Stack View，然后点击<code>Editor\\Unemebed</code>菜单。</p>\n<h2 id=\"使用场景描述\"><a href=\"#使用场景描述\" class=\"headerlink\" title=\"使用场景描述\"></a>使用场景描述</h2><p>当APP运行中增加或删除一个<code>view</code>时，需要重新调整邻近<code>view</code>的位置布局。<br>预见困境：</p>\n<ol>\n<li>在故事板中新建一些布局约束连接，以便能够安装或卸载其中的一些约束</li>\n<li>使用第三方库来实现</li>\n<li>根据任务复杂程度完全用代码实现<br>也许这个在视图附近的视图树中的所有View都不需要在运行时改变，但当你将新视图添加到故事板时，仍然要想方设法为它挤出空间来。</li>\n</ol>\n<p><code>UIStackView</code>提供了一个对多个视图进行水平或垂直布局的方法。通过对几个属性进行简单设置，比如对齐、分布和间距，可以让我们让其所包含的视图适应于其有效空间。</p>\n<h2 id=\"实现需求\"><a href=\"#实现需求\" class=\"headerlink\" title=\"实现需求\"></a>实现需求</h2><p>存在着这几方面的问题:</p>\n<h3 id=\"问题一：自适应横竖屏\"><a href=\"#问题一：自适应横竖屏\" class=\"headerlink\" title=\"问题一：自适应横竖屏\"></a>问题一：自适应横竖屏</h3><p>在横屏状态下（command+左箭头旋转为横屏），发现截图中的一排按钮位置无法适应屏幕宽度的变化。这时可以使用<code>UIStackView</code>来帮助实现自动适应横竖屏的效果。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/UIStackView.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"问题二：控件间留白不紧凑\"><a href=\"#问题二：控件间留白不紧凑\" class=\"headerlink\" title=\"问题二：控件间留白不紧凑\"></a>问题二：控件间留白不紧凑</h3><p>点击WEATHER旁边的Hide按钮。隐藏了下面的文本内容后，留下了一大块的空白区域。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/WEATHERhide.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"Storyboard引入界面\"><a href=\"#Storyboard引入界面\" class=\"headerlink\" title=\"Storyboard引入界面\"></a>Storyboard引入界面</h3><p>打开<code>Main.storyboard</code>，找到<code>Spot Info View Controller</code>这个Scene。将这些标签和按钮设为不同的背景色，是为了在运行时效果更直观。就是在故事板中，这也有助于看到<code>Stack View</code>属性的改变导致其内部视图的变化。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack1.png?imageMogr2/2/w/800\"><br>如果想在运行App时看见这些颜色，在<code>SpotInfoViewController</code>的<code>viewDidLoad()</code>方法中将下列语句注释：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 清空标签和按钮的背景色</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> view <span class=\"keyword\">in</span> backgroundColoredViews </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    view.backgroundColor = <span class=\"type\">UIColor</span>.clearColor()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Size类便于使用storyboard\"><a href=\"#Size类便于使用storyboard\" class=\"headerlink\" title=\"Size类便于使用storyboard\"></a>Size类便于使用storyboard</h3><p>在本案例中，故事板中Scene大小不是默认<code>600x600</code>，在这里Simulated Metrics下的Size属性被设置成iPhone 4-inch。Simulated Metrics属性在运行时并没有任何影响——不同设备上视图的大小仍然会自动改变。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/05-simulated-metrics-iphone-4-inch_639x173.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"创建水平UIStackView\"><a href=\"#创建水平UIStackView\" class=\"headerlink\" title=\"创建水平UIStackView\"></a>创建水平<code>UIStackView</code></h2><h3 id=\"按钮模块\"><a href=\"#按钮模块\" class=\"headerlink\" title=\"按钮模块\"></a>按钮模块</h3><ol>\n<li>选中按钮<br>用<code>Command+左键</code>同时选中<code>Spot Info View Controller</code>底下一排的所有按钮：<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack2.png?imageMogr2/2/w/800\"></li>\n<li>Stack按钮添加一个新的Stack View<br>点击故事板画布左下角<code>Auto Layout工具栏</code>中新增的<code>Stack按钮</code>：    </li>\n</ol>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/Stack按钮?imageMogr2/2/w/800\">\n<p>这些按钮被嵌到一个新的Stack View中：</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack4.png?imageMogr2/2/w/800\">\n<h4 id=\"给新的Stack-View添加布局约束\"><a href=\"#给新的Stack-View添加布局约束\" class=\"headerlink\" title=\"给新的Stack View添加布局约束\"></a>给新的Stack View添加布局约束</h4><p>要在故事板选取一个充满了子视图的Stack View还是比较难的，介绍两种选择技巧。<br>3.1 在<code>Outline视图</code>中选取Stack View</p>\n<img title=\"Outline视图\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack5.png?imageMogr2/2/w/800\">\n<p>3.2 Shift+右键调出View树<br>在Stack View 的任意地方按下<code>Shift+右键</code>或者<code>Control+Shift+左键</code>（如果你正在用触控板的话）。这时将弹出一个上下文菜单，列出了位于所点击的地方的View树，你可以在这个菜单中选择Stack View。</p>\n<img title=\"Shift+右键\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack6.png?imageMogr2/2/w/800\">\n<ol>\n<li>自动布局工具栏中的Pin按钮,添加一个约束<img title=\"自动布局工具栏中的Pin按钮\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack7.png?imageMogr2/2/w/800\">\n</li>\n</ol>\n<p>首先勾选Constrain to margins。然后在Stack View四周添加下列约束：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Top</span>: <span class=\"number\">20</span>, <span class=\"type\">Leading</span>: <span class=\"number\">0</span>, <span class=\"type\">Trailing</span>: <span class=\"number\">0</span>, <span class=\"type\">Bottom</span>: <span class=\"number\">0</span></span><br></pre></td></tr></table></figure><br>仔细检查top、leading、trailing、bottom中的数字并确保它们的I型柱都被选中。然后点击Add 4 Constraints：<br><img title=\"Add4Constraints\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack8.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"按钮等间距分布\"><a href=\"#按钮等间距分布\" class=\"headerlink\" title=\"按钮等间距分布\"></a>按钮等间距分布</h4><p>添加约束后，导致第一个按钮被拉伸：<br><img title=\"第一个按钮被拉伸填充所有剩余空间\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack9.png?imageMogr2/2/w/800\"></p>\n<h5 id=\"使用等宽约束的Spacer-View实现\"><a href=\"#使用等宽约束的Spacer-View实现\" class=\"headerlink\" title=\"使用等宽约束的Spacer View实现\"></a>使用等宽约束的<code>Spacer View</code>实现</h5><p>解决这个问题只能使用空白的View来分隔这些按钮，在按钮之间摆放上一些用于分隔空间的 Spacer View。所有的Spacer View都要添加等宽约束，以及许多额外的约束，才能将这些Spacer View布局正确。<br>这看起来如下图所示。为了直观起见，这些Spacer View的背景色设置成了浅灰色：<br><img title=\"SpacerView添加等宽约束实现\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack04.png?imageMogr2/2/w/800\"><br>如果要在运行时添加一个按钮或者隐藏/删除一个按钮时，要想调整这些Spacer View和约束就要命了。</p>\n<h5 id=\"Distribution属性：沿轴向水平分布\"><a href=\"#Distribution属性：沿轴向水平分布\" class=\"headerlink\" title=\"Distribution属性：沿轴向水平分布\"></a><code>Distribution</code>属性：沿轴向水平分布</h5><p>distribution属性：决定Stack View如何将它的subview沿轴向分布，当属性值是Fill，这表示subview会沿轴向完全占据Stack View。因此，Stack View会拉伸其中一个subview使其填充剩余空间，尤其是水平内容优先级最低的那个，如果所有subview优先级相同，则拉伸第一个subview。<br>打开Stack View属性面板。将<code>Distribution</code>属性由<code>Fill</code>修改为<code>Equal Spacing</code>：<br><img title=\"`Fill`修改为`Equal\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack02.png?imageMogr2/2/w/800\"><br>编译运行，点击某个单元格，旋转模拟器（⌘→）。你将看到最下一排按钮现在按照等间距排列了！<br><img title=\"`Distribution`属性值`Equal\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack03.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"Rating版块\"><a href=\"#Rating版块\" class=\"headerlink\" title=\"Rating版块\"></a>Rating版块</h3><p>选中RATING标签，以及旁边的显示为几个星形图标的标签：<br><img title=\"选中RATING标签\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack05.png?imageMogr2/2/w/800\"><br>然后点击Stack按钮将它们嵌到一个Stack View中：<br><img title=\"Stack按钮\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack3.png?imageMogr2/2/w/800\"><br><img title=\"RATING标签嵌到一个StackView中\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack06.png?imageMogr2/2/w/800\"><br>然后点击Pin按钮。勾选Constrain to margins，并添加如下约束：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Top</span>: <span class=\"number\">20</span>, <span class=\"type\">Leading</span>: <span class=\"number\">0</span>, <span class=\"type\">Bottom</span>: <span class=\"number\">20</span></span><br></pre></td></tr></table></figure><br><img title=\"添加约束\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack07.png?imageMogr2/2/w/800\"><br>打开属性面板，将间距设置为8：<br><img title=\"间距设置为8\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack08.png?imageMogr2/2/w/800\"><br>你可能会看到一个 Misplaced Views的布局约束警告，同时星星标签会显示将会被拉伸到视图之外：<br><img title=\"MisplacedViews的布局约束警告\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack09.png?imageMogr2/2/w/800\"><br>有时候Xcode会临时提示一些警告，或者显示Stack View的位置不正确，这些警告会在你添加其他约束后消失。你完全可以忽略这些警告。<br>要解决这个警告，我们可以修改一下Stack View的Frame然后又改回，或者临时修改它的一条布局约束。<br>让我们试一下。先将Alignment 属性从Fill修改为Top，然后又改回原来的Fill。你将看到这下星星标签显示正常了：<br><img title=\"布局约束警告消失\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack00.png?imageMogr2/2/w/800\"><br>编译运行，进行测试</p>\n<h2 id=\"创建垂直的Stack-View\"><a href=\"#创建垂直的Stack-View\" class=\"headerlink\" title=\"创建垂直的Stack View\"></a>创建垂直的Stack View</h2><p>Xcode会自动根据这两者的位置推断出这将是一个垂直的Stack View，Stack View没有添加任何约束时，会自动适应了两个标签中的最宽的一个的宽度。</p>\n<h3 id=\"WHY-VISIT模块\"><a href=\"#WHY-VISIT模块\" class=\"headerlink\" title=\"WHY VISIT模块\"></a>WHY VISIT模块</h3><p>选中WHY VISIT标签及下面的标签,创建一个垂直的Stack View：<br><img title=\"选中WHY\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack002.png?imageMogr2/2/w/800\"><br>点击Stack 按钮将二者嵌到一个Stack View：<br><img title=\"嵌到一个垂直的StackView\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack003.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"添加约束\"><a href=\"#添加约束\" class=\"headerlink\" title=\"添加约束\"></a>添加约束</h4><p>默认，约束是相对于距离最近的对象，对于Bottom约束来说就是距离它15像素的Hide按钮。但我们其实是想让约束相对于WEATHER标签。<br>选中Stack View，点击Pin按钮。勾选Constrain to margins，设置Top、Leading、Trainling为0。<br>然后，点击Bottom右边的下拉按钮，从列表中选择WEATHER（curent distance =20）：<br><img title=\"Top、Leading、Trainling为0\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack004.png?imageMogr2/2/w/800\"><br>最后点击Add 4 Constraints按钮。显示结果如下图所示：<br><img title=\"Top、Leading、Trainling为0\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack005.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"alignment属性：轴向的垂直方向\"><a href=\"#alignment属性：轴向的垂直方向\" class=\"headerlink\" title=\"alignment属性：轴向的垂直方向\"></a>alignment属性：轴向的垂直方向</h4><p>Stack View问题，它的右边对齐于View的右边。但是底下的标签仍然是原来的宽度。需要使用alignment属性解决这个问题。<br>当你测试完所有Alignment值的布局效果后，将Alignment修改为Fill：<br><img title=\"Top、Leading、Trainling为0\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0001.png?imageMogr2/2/w/800\"><br>将<code>Alignment</code>设置为<code>Fill</code>，表示所有View将沿与Stack View轴向垂直的方向进行全占式分布。这会让WHY VISIT标签扩展它的宽度到100%.</p>\n<p>如果我们只想让底下的标签将宽度扩展到100%怎么办？</p>\n<p>这个问题现在看来还不是多大的问题，因为两个标签在运行时的背景色都是透明的。但对于Weather版块来说就不同了。</p>\n<p>我们将用另外一个Stack View来说明这个问题。</p>\n<h2 id=\"垂直／水平Stack-View嵌套使用\"><a href=\"#垂直／水平Stack-View嵌套使用\" class=\"headerlink\" title=\"垂直／水平Stack View嵌套使用\"></a>垂直／水平Stack View嵌套使用</h2><h3 id=\"Weather版块\"><a href=\"#Weather版块\" class=\"headerlink\" title=\"Weather版块\"></a>Weather版块</h3><p>在Weather版块相对复杂一些，因为它多了一个Hide按钮。<br>要隐藏<code>Stack View</code>中的视图，你只需要设置该View的<code>Hidden</code>属性为<code>true</code>，剩下的工作Stack View会自己完成。这也是我们解决用户隐藏WEATHER标签下文本的主要思路。<br>一种方法是使用嵌套的Stack View，先将WEATHER标签和Hide按钮嵌到一个水平StackView，再将这个Stack View和标签嵌到一个垂直Stack View。<br><img title=\"垂直/水平StackView嵌套使用\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0002.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"垂直stackView\"><a href=\"#垂直stackView\" class=\"headerlink\" title=\"垂直stackView\"></a>垂直stackView</h4><p>注意Alignment属性负责Stack View轴向垂直的方向上的布局。所以，我们需要将Alignment属性设置为 Bottom：<br><img title=\"垂直/水平StackView嵌套使用\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0003.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"水平StackView中出现按钮拉伸标签的问题\"><a href=\"#水平StackView中出现按钮拉伸标签的问题\" class=\"headerlink\" title=\"水平StackView中出现按钮拉伸标签的问题\"></a>水平StackView中出现按钮拉伸标签的问题</h4><p>注意，WEATHER标签被拉伸为和Hide按钮一样高了。这并不合适，因为这会导致WEATHER标签和下面的文本之间多出了一些空间。<br>正确的方法是让 Hide 按钮不要和 Weather 版块呆在同一个Stack View中，或者任何别的Stack View中。<br>这样，在顶层View中还会保留一个subview，你将为它添加一个相对于WEATHER标签的约束——WEATHER标签嵌在Stack View里的。也就是说，你要为位于Stack View之外的按钮加一个约束，这个约束是相对于Stack View内的一个标签！</p>\n<h4 id=\"垂直stack-View1-嵌套WEATHER标签和标签\"><a href=\"#垂直stack-View1-嵌套WEATHER标签和标签\" class=\"headerlink\" title=\"垂直stack View1:嵌套WEATHER标签和标签\"></a>垂直stack View1:嵌套WEATHER标签和标签</h4><p>选中WEATHER标签和标签：<br><img title=\"选中嵌套标签\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0004.png?imageMogr2/2/w/800\"><br>点击 Stack 按钮：<br><img title=\"Stack按钮创建stackView\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0005.png?imageMogr2/2/w/800\"><br>点击Pin 按钮，勾上Constrain to margins，然后添加如下约束：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Top</span>: <span class=\"number\">20</span>, <span class=\"type\">Leading</span>: <span class=\"number\">0</span>, <span class=\"type\">Trailing</span>: <span class=\"number\">0</span>, <span class=\"type\">Bottom</span>: <span class=\"number\">20</span></span><br></pre></td></tr></table></figure><br>将Stack View的Alignment设为Fill：<br><img title=\"Alignment设为Fill\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0006.png?imageMogr2/2/w/800\"><br>我们需要在 Hide 按钮左边和WEATHER标签右边加一条约束，这样WEATHER 标签的宽度就不会拉满整个Stack View了。</p>\n<p>当然，底下的标签宽度还是需要100%占满的。</p>\n<p>我们是通过将WEATHER标签嵌到一个垂直Stack View 来实现的。注意，垂直Stack View的Alignment 属性可以设置为 .Leading，如果将Stack View拉宽，则它里面的View 会保持左对齐。</p>\n<h4 id=\"垂直stack-View2-仅嵌套WEATHER标签\"><a href=\"#垂直stack-View2-仅嵌套WEATHER标签\" class=\"headerlink\" title=\"垂直stack View2: 仅嵌套WEATHER标签\"></a>垂直stack View2: 仅嵌套WEATHER标签</h4><p>从Outline视图中选取WEATHER 标签，或者用Control+Shift+左键的方式选取WEATHER 标签：<br><img title=\"Stack按钮创建stackView\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0006.png?imageMogr2/2/w/800\"><br>然后点击Stack 按钮：<br><img title=\"Stack按钮创建stackView\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0007.png?imageMogr2/2/w/800\"><br>确保Axis 为 Vertical 的情况下，将Alignment 设置为 Leading：<br><img title=\"Alignment设置为Leading\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0008.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"按钮和WEATHER标签两个约束\"><a href=\"#按钮和WEATHER标签两个约束\" class=\"headerlink\" title=\"按钮和WEATHER标签两个约束\"></a>按钮和WEATHER标签两个约束</h4><p>从Hide 按钮用右键拖一条新的约束到 WEATHER 标签：<br><img title=\"AddConstraints\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0009.png?imageMogr2/2/w/800\"><br>按下Shift键，同时选择Horizontal Spacing 和 Baseline。然后点击 Add Constraints：<br><img title=\"AddConstraints\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0000.png?imageMogr2/2/w/800\"><br>编译运行。Hide 按钮的位置现在对了，而且当按下Hide 按钮，位于Stack View 中的标签被隐藏后，下面的视图也会被调整——根本不需要我们进行手动调整。<br><img title=\"编译运行\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack010.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"顶级-Stack-View\"><a href=\"#顶级-Stack-View\" class=\"headerlink\" title=\"顶级 Stack View\"></a>顶级 Stack View</h2><p>在Outline 视图中，用Command+左键选择5个最顶级的 Stack View：<br><img title=\"选中视图\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack011.png?imageMogr2/2/w/800\"><br>然后点击 Stack 按钮：<br><img title=\"Stack按钮\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack012.png?imageMogr2/2/w/800\"><br>点击Pin 按钮，勾上 Constrain to margins，将 4 个边的约束都设为0。然后将Spacing 设置为20，Alignment 设为 Fill。现在故事板会是这个样子：<br><img title=\"添加约束\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack013.png?imageMogr2/2/w/800\"><br>编译运行：<br><img title=\"编译运行\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack014.png?imageMogr2/2/w/800\"><br>噢！这个 Hide 按钮又失去了它 的约束！因为包含 WEATHER 标签的Stack View的外边又套了一层 Stack View。这不是什么大问题，就像之前你做过的那样，再重新为它添加约束就是了。</p>\n<p>右键从Hide 按钮拖一条约束到 WEATHER标签，按下 Shift 键，同时选择 Horizontal Spacing 和 Baseline。然后点击 Add Constraints：<br><img title=\"AddConstraints\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack015.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"重新调整视图位置\"><a href=\"#重新调整视图位置\" class=\"headerlink\" title=\"重新调整视图位置\"></a>重新调整视图位置</h2><p>现在，所有的版块都被嵌到一个顶级的 Stack View中了，我们想修改一下 what to see版块的位置，让它位于 weather 版块之后。</p>\n<p>从 Outline 视图中选择中间的的 Stack View，然后将它拖到第一、二个 Stack View 之间。<br>注意：让箭头稍微偏向你正在拖的Stack View左边一点，以便它能够作为外层 Stack View 的 subview 添加。蓝色的小圆圈应当位于两个 Stack View 之间的左端而不是右端：<br><img title=\"调整视图位置\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack016.png?imageMogr2/2/w/800\"></p>\n<p>现在，weather版块是从上到下的第三个版块，由于 Hide 按钮它并不是 Stack View的subview，所以它不会参与移动，它的frame当前是不正确的。</p>\n<p>点击 Hide 按钮，选中它：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack017.png?imageMogr2/2/w/800\"></p>\n<p>然后点击自动布局工具栏中的 Resolve Auto Layout Issues 按钮，选择 Update Frames：<br><img title=\"Update\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack018.png?imageMogr2/2/w/800\"><br>现在 Hide 按钮将回到正确的位置：<br><img title=\"UpdateHide按钮\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack019.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"基于配置的-Size-类\"><a href=\"#基于配置的-Size-类\" class=\"headerlink\" title=\"基于配置的 Size 类\"></a>基于配置的 Size 类</h2><p>最后还有一个任务没有完成。在横屏模式，垂直空间是比较珍贵的，你想将这些版块之间靠得更近一些。要实现这个，你需要判断当垂直Size类为compact时，将顶层 Stack View的 Spacing属性由 20 改成 10.</p>\n<p>选择顶层 Stack View，点击 Spacing 前面的+按钮：<br><img title=\"前面的+按钮Spacing\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack020.png?imageMogr2/2/w/800\"></p>\n<p>选择 Any Width &gt; Compact Height：<br><img title=\"CompactHeight\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack021.png?imageMogr2/2/w/800\"></p>\n<p>在新出现的 wAny hC 一栏中，将 Spacing 设为 10：<br><img title=\"Spacing设为10\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack022.png?imageMogr2/2/w/800\"><br>编译运行。在竖屏模式下Spacing不会改变。旋转模拟器（⌘←），你会看到各版块之间的间距减少了，现在底部按钮之间的空间也变大了：<br><img title=\"编译运行\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack023.png?imageMogr2/2/w/800\"><br>如果你没有添加最外层的 Stack View，你仍然可以使用 Size 类将每个版块之间的垂直间距设置为 10，但这就不是仅仅设置一个地方就能够办到的了。</p>\n<h2 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h2><p>现在，在隐藏和显示天气信息时仍然会觉得有一些突兀。你将增加一个动画使这个转换变得更平滑。</p>\n<p>Stack View完全支持 <code>UIView 动画</code>。也就是说要以动画方式显示/隐藏它所包含的subview，只需要简单地在一个动画块中切换它的 hidden 属性。</p>\n<p>让我们来看看代码怎么实现。打开 <code>SpotInfoViewController.Swift</code>，找到<br><code>updateWeatherInfoViews(hideWeatherInfo:animated:)</code>方法。</p>\n<p>将方法的最后一行：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br></pre></td></tr></table></figure><br>替换为：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> animated </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">UIView</span>.animateWithDuration(<span class=\"number\">0.3</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">else</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>编译运行，点击Hide 按钮或 Show 按钮。是不是加入动画之后看起来要好得多呢？</p>\n<p>除了对 Stack View 中的视图以动画的方式设置 hidden 属性，你也可以对 Stack View 自身的属性使用 UIView 动画，例如 Alignment 属性、 Distribution 属性、 Spacing 属性和 Axis 属性。<br><a href=\"http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Starter.zip\" target=\"_blank\" rel=\"noopener\">开始项目源码</a><br><a href=\"http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Complete.zip\" target=\"_blank\" rel=\"noopener\">完整项目源码</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2>","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"控件","path":"api/categories/控件.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"}]},{"title":"高期望实现异步单元测试","slug":"测试/高期望实现异步单元测试","date":"2017-02-20T23:09:30.000Z","updated":"2017-05-26T11:03:05.000Z","comments":true,"path":"api/articles/测试/高期望实现异步单元测试.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"异步单元测试\"><a href=\"#异步单元测试\" class=\"headerlink\" title=\"异步单元测试\"></a>异步单元测试</h2><p>在Xcode 6之前的版本里面并没有内置<code>XCTest</code>，只能是在主线程的<code>RunLoop</code>里面使用一个<code>while循环</code>,然后一直等待响应或者直到<code>timeout</code>.</p>\n<p>在Xcode 6里，苹果以<code>XCTestExpection类</code>的方式向<code>XCTest框架</code>里添加了<code>测试期望</code>(test expection)。<br>XCTest框架中相关的方法：设置期望，实现期望，通知期望，谓词计算期望等，以及期望的传递。</p>\n<h3 id=\"常规实现方式\"><a href=\"#常规实现方式\" class=\"headerlink\" title=\"常规实现方式\"></a>常规实现方式</h3><p>在主线程里，使用<code>while循环</code>每隔10毫秒会执行一次，直到有响应或者5秒之后超出响应时间限制才会跳出：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testAsyncTheOldWay</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timeoutDate = <span class=\"type\">Date</span>.<span class=\"keyword\">init</span>(timeIntervalSinceNow: <span class=\"number\">5.0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> responseHasArrived = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"type\">Alamofire</span>.request(<span class=\"string\">\"https://www.baidu.com\"</span>).responseData&#123;response <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"获取到的数据长度：\\(String(data: response.data!, </span></span><br><span class=\"line\"><span class=\"string\">                                   encoding:String.Encoding.utf8)!)\"</span>)</span><br><span class=\"line\">        responseHasArrived = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"type\">XCTAssert</span>((response.data?.<span class=\"built_in\">count</span>)! &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (responseHasArrived == <span class=\"literal\">false</span> </span><br><span class=\"line\">            &amp;&amp; (timeoutDate.timeIntervalSinceNow &gt; <span class=\"number\">0</span>)) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">CFRunLoopRunInMode</span>(<span class=\"type\">CFRunLoopMode</span>.defaultMode, <span class=\"number\">0.01</span>, <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (responseHasArrived == <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">XCTFail</span>(<span class=\"string\">\"Test timed out\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"XCTest相关API\"><a href=\"#XCTest相关API\" class=\"headerlink\" title=\"XCTest相关API\"></a>XCTest相关API</h2><p>在Xcode 6里，苹果以<code>XCTestExpection类</code>的方式向<code>XCTest框架</code>里添加了<code>测试期望</code>(test expection)。</p>\n<h3 id=\"XCTestExpection-高期望-High-Expectations-的实现和使用\"><a href=\"#XCTestExpection-高期望-High-Expectations-的实现和使用\" class=\"headerlink\" title=\"XCTestExpection:高期望(High Expectations)的实现和使用\"></a>XCTestExpection:高期望(High Expectations)的实现和使用</h3><p>设置期望，实现期望，通知期望，谓词计算期望等，以及期望的传递。</p>\n<h4 id=\"expectation-description-为XCTest测试单元设置期望\"><a href=\"#expectation-description-为XCTest测试单元设置期望\" class=\"headerlink\" title=\"expectation(description:):为XCTest测试单元设置期望\"></a><code>expectation(description:)</code>:为XCTest测试单元设置期望</h4><p>为XCTest单元测试，设置一个测试期望以及错误信息描述，并在某一时刻<code>fulfill</code>实现该期望对象<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//expectation(description: String) -&gt; XCTestExpectation</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> expection = expectation(description: <span class=\"string\">\"失败时显示原因\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"fulfill-调用它表示测试达到期望值\"><a href=\"#fulfill-调用它表示测试达到期望值\" class=\"headerlink\" title=\"fulfill():调用它表示测试达到期望值\"></a><code>fulfill()</code>:调用它表示测试达到期望值</h5><p>一般在单元测试通过时调用，告知测试已达期望，这一方法替代了<code>responseHasArrived</code>作为Flag的方式<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//- (void)fulfill;</span></span><br><span class=\"line\">expection.fulfill()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"waitForExpectations-timeout-handler-在方法底部设置测试期望的时效\"><a href=\"#waitForExpectations-timeout-handler-在方法底部设置测试期望的时效\" class=\"headerlink\" title=\"waitForExpectations(timeout:handler:):在方法底部设置测试期望的时效\"></a><code>waitForExpectations(timeout:handler:)</code>:在方法底部设置测试期望的时效</h4><p>在方法底部指定一个超时，如果测试条件不适合时间范围便会结束执行<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// open func waitForExpectations(timeout: TimeInterval, handler: XCTest.XCWaitCompletionHandler? = nil)</span></span><br><span class=\"line\">waitForExpectations(timeout: <span class=\"number\">5</span>) &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"错误信息:\\(error?.localizedDescription)\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如果完成处理的代码在指定时限里执行并调用了<code>fulfill()</code>方法，那么就说明所有的测试期望在此期间都已经被实现。否则就测试就被打断不再执行</p>\n<h4 id=\"expectation-forNotification-object-handler-通知期望\"><a href=\"#expectation-forNotification-object-handler-通知期望\" class=\"headerlink\" title=\"expectation(forNotification:object:handler:):通知期望\"></a>expectation(forNotification:object:handler:):通知期望</h4><p>该方法监听一个通知,如果在规定时间内正确收到通知则测试通过<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//expectation(forNotification notificationName: String, object objectToObserve: Any?, handler: XCTest.XCNotificationExpectationHandler? = nil) -&gt; XCTestExpectation</span></span><br><span class=\"line\"><span class=\"comment\">//设置一个测试通知期望</span></span><br><span class=\"line\">expectation(forNotification: <span class=\"string\">\"BLDownloadImageNotification\"</span>, </span><br><span class=\"line\">                     object: <span class=\"literal\">nil</span>) </span><br><span class=\"line\">&#123;(notification) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> userInfo = notification.userInfo <span class=\"keyword\">as</span>! [<span class=\"type\">String</span>:<span class=\"type\">String</span>]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name = userInfo[<span class=\"string\">\"name\"</span>]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"name:\\(name)\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">来定义一个通知并发送通知，来测试：</span><br><span class=\"line\"><span class=\"keyword\">let</span> notif =  <span class=\"type\">Notification</span>.<span class=\"type\">Name</span>(rawValue: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\"><span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.post(name: notif, object: <span class=\"keyword\">self</span>, userInfo: [<span class=\"string\">\"name\"</span>:<span class=\"string\">\"huosan\"</span>,<span class=\"string\">\"sex\"</span>:<span class=\"string\">\"man\"</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置延迟多少秒后，如果没有满足测试条件就报错</span></span><br><span class=\"line\">waitForExpectations(timeout: <span class=\"number\">3</span>, handler: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"使用expectation-description-实现\"><a href=\"#使用expectation-description-实现\" class=\"headerlink\" title=\"使用expectation(description:)实现\"></a>使用<code>expectation(description:)</code>实现</h5><p>帮助理解 <code>expectation(forNotification:object:handler:)</code> 方法和 <code>expectation(description:)</code> 的区别<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testAsynForNotificationWithExpectation</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> expectation = <span class=\"keyword\">self</span>.expectation(description: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> notif = <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>(rawValue: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sub = <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(forName: notif, object: <span class=\"literal\">nil</span>, queue: <span class=\"literal\">nil</span>) &#123; (notification) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        expectation.fulfill()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//发送一个通知</span></span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.post(name: notif, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//waitForExpectations</span></span><br><span class=\"line\">    waitForExpectations(timeout: <span class=\"number\">1</span>, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//移除通知</span></span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.removeObserver(sub)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"expectation-for-evaluatedWith-handler-谓词计算测试法\"><a href=\"#expectation-for-evaluatedWith-handler-谓词计算测试法\" class=\"headerlink\" title=\"expectation(for:evaluatedWith:handler:):谓词计算测试法\"></a>expectation(for:evaluatedWith:handler:):谓词计算测试法</h4><p>利用谓词计算，判断<code>button</code>的<code>backgroundImageForState</code>方法，是否正确的获得了<code>backgroundImage</code>，如果<code>20秒</code>内正确获得则通过测试，否则失败<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//open func expectation(for predicate: NSPredicate, evaluatedWith object: Any, handler: XCTest.XCPredicateExpectationHandler? = nil) -&gt; XCTestExpectation</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testThatBackgroundImageChanges</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> viewController = <span class=\"type\">OnclickLikeViewController</span>()</span><br><span class=\"line\">    <span class=\"comment\">//viewController.loadView()  //不执行viewDidload方法</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"number\">_</span> = viewController.view</span><br><span class=\"line\">    <span class=\"keyword\">let</span> button = viewController.button</span><br><span class=\"line\">    <span class=\"keyword\">let</span> img = button.backgroundImage(<span class=\"keyword\">for</span>: .normal)</span><br><span class=\"line\">    <span class=\"type\">XCTAssertNil</span>(img,<span class=\"string\">\"此时img不为nil,中止执行\"</span>)  <span class=\"comment\">//当img不是nil时，执行断言</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> predicate = <span class=\"type\">NSPredicate</span>.<span class=\"keyword\">init</span> &#123; (anyobject, bindings) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> button = anyobject <span class=\"keyword\">as</span>! <span class=\"type\">UIButton</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> button.backgroundImage(<span class=\"keyword\">for</span>: <span class=\"type\">UIControlState</span>()) != <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    expectation(<span class=\"keyword\">for</span>: predicate, evaluatedWith: button, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    waitForExpectations(timeout: <span class=\"number\">20</span>, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"使用expectation-description-实现-1\"><a href=\"#使用expectation-description-实现-1\" class=\"headerlink\" title=\"使用expectation(description:)实现\"></a>使用<code>expectation(description:)</code>实现</h5><p>帮助理解 <code>expectation(for:evaluatedWith:handler:)</code> 方法和 <code>expectation(description:)</code> 的区别<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testThatBackgroundImageChanges</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//设置期望</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> expectation = <span class=\"keyword\">self</span>.expectation(description: <span class=\"string\">\"backgroundImageForState\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> viewController = <span class=\"type\">OnclickLikeViewController</span>()</span><br><span class=\"line\">    <span class=\"comment\">//viewController.loadView()  //不执行viewDidload方法</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"number\">_</span> = viewController.view</span><br><span class=\"line\">    <span class=\"keyword\">let</span> button = viewController.button</span><br><span class=\"line\">    <span class=\"keyword\">let</span> img = button.backgroundImage(<span class=\"keyword\">for</span>: .normal)</span><br><span class=\"line\">    <span class=\"type\">XCTAssertNil</span>(img,<span class=\"string\">\"此时img不为nil,中止执行\"</span>)  <span class=\"comment\">//当img不是nil时，执行断言</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> predicate = <span class=\"type\">NSPredicate</span>.<span class=\"keyword\">init</span> &#123; (anyobject, bindings) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> button = anyobject <span class=\"keyword\">as</span>! <span class=\"type\">UIButton</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> button.backgroundImage(<span class=\"keyword\">for</span>: <span class=\"type\">UIControlState</span>()) != <span class=\"literal\">nil</span></span><br><span class=\"line\">        <span class=\"comment\">//实现测试期望</span></span><br><span class=\"line\">        expectation.fulfill()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//等待期望实现</span></span><br><span class=\"line\">    waitForExpectations(timeout: <span class=\"number\">20</span>, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传递expectation在目的方法中再fulfill-实现期望\"><a href=\"#传递expectation在目的方法中再fulfill-实现期望\" class=\"headerlink\" title=\"传递expectation在目的方法中再fulfill()实现期望\"></a>传递expectation在目的方法中再fulfill()实现期望</h3><p>例如将期望封装在字典中，通过通知来传递给异步下载的方法中调用该期望的<code>fulfill()</code>方法，实现单元测试的期望<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*/</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testAsynForNotificationWithExpectation2</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> expectation = <span class=\"keyword\">self</span>.expectation(description: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> notif = <span class=\"type\">Notification</span>.<span class=\"type\">Name</span>(rawValue: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(<span class=\"keyword\">self</span>, selector: #selector(<span class=\"type\">AsyncTheOldWayTest</span>.downLoadImage(<span class=\"number\">_</span>:)), name: notif, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//将期望封装在字典中传递</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> userInf = [<span class=\"string\">\"name\"</span>:<span class=\"string\">\"huosan\"</span>,<span class=\"string\">\"sex\"</span>:<span class=\"string\">\"man\"</span>,<span class=\"string\">\"expectation\"</span>:expectation]</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.post(name: notif, object: <span class=\"keyword\">self</span>, userInfo: userInf)</span><br><span class=\"line\">        <span class=\"comment\">//等待期望实现</span></span><br><span class=\"line\">        waitForExpectations(timeout: <span class=\"number\">1</span>, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.removeObserver(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">downLoadImage</span><span class=\"params\">(<span class=\"number\">_</span> notification:Notification)</span></span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> userInfo = notification.userInfo <span class=\"keyword\">as</span>! [<span class=\"type\">String</span>:<span class=\"type\">AnyObject</span>]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> name = userInfo[<span class=\"string\">\"name\"</span>]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> sex = userInfo[<span class=\"string\">\"sex\"</span>]</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"name:\\(name), sex = \\(sex)\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> expectation = userInfo[<span class=\"string\">\"expectation\"</span>] <span class=\"keyword\">as</span>! <span class=\"type\">XCTestExpectation</span></span><br><span class=\"line\">        expectation.fulfill()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"测试","path":"api/categories/测试.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"单元测试","path":"api/tags/单元测试.json"}]},{"title":"UI自动测试开发相关API","slug":"测试/UI自动测试学习","date":"2017-02-20T17:16:49.000Z","updated":"2017-05-26T11:03:05.000Z","comments":true,"path":"api/articles/测试/UI自动测试学习.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/XCUIElementAttributes.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"UI-Testing-和-Accessibility\"><a href=\"#UI-Testing-和-Accessibility\" class=\"headerlink\" title=\"UI Testing 和 Accessibility\"></a>UI Testing 和 Accessibility</h2><p>UI Accessibility 早在 iOS 3.0 就被引入了，用来辅助身体不便的人士使用 app。VoiceOver 是 Apple 的屏幕阅读技术，而 UI Accessibility 的基本原则就是对屏幕上的 UI 元素进行分类和标记。两者配合，通过阅读或者聆听这些元素，用户就可以在不接触屏幕的情况下通过声音来使用 app。</p>\n<p>Accessibility 的核心思想是对 UI 元素进行分类和标记 – 将屏幕上的 UI 分类为像是按钮，文本框，cell 或者是静态文本 (也就是 label) 这样的类型，然后使用 identifier 来区分不同的 UI 元素。用户可以通过语音控制 app 的按钮点击，或是询问某个 label 的内容等等，十分方便。iOS SDK 中的控件都实现了默认的 Accessibility 支持，而我们如果使用自定义的控件的话，则需要自行使用 Accessibility 的 API 来进行添加。</p>\n<h2 id=\"UI-Testing-API\"><a href=\"#UI-Testing-API\" class=\"headerlink\" title=\"UI Testing API\"></a>UI Testing API</h2><h3 id=\"XCUIApplication-获取APP实例\"><a href=\"#XCUIApplication-获取APP实例\" class=\"headerlink\" title=\"XCUIApplication()获取APP实例\"></a>XCUIApplication()获取APP实例</h3><p><code>XCUIApplication()</code>继承<code>XCUIElement</code>，这个类掌管应用程序的生命周期，里面包含两个主要方法<br><code>launch():</code>启动程序<br><code>terminate():</code>终止程序</p>\n<h3 id=\"获取XCUIElementQuery对象的四种方式\"><a href=\"#获取XCUIElementQuery对象的四种方式\" class=\"headerlink\" title=\"获取XCUIElementQuery对象的四种方式\"></a>获取<code>XCUIElementQuery</code>对象的四种方式</h3><h4 id=\"第一种简写形式：buttons-gt-XCUIElementQuery\"><a href=\"#第一种简写形式：buttons-gt-XCUIElementQuery\" class=\"headerlink\" title=\"第一种简写形式：buttons-&gt;XCUIElementQuery\"></a>第一种简写形式：<code>buttons-&gt;XCUIElementQuery</code></h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttons:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().buttons</span><br><span class=\"line\"><span class=\"keyword\">let</span> textFields:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().textFields</span><br></pre></td></tr></table></figure>\n<h4 id=\"三种通过XCUIElementType的枚举值\"><a href=\"#三种通过XCUIElementType的枚举值\" class=\"headerlink\" title=\"三种通过XCUIElementType的枚举值\"></a>三种通过<code>XCUIElementType</code>的枚举值</h4><p>通过<code>XCUIElementType</code>的枚举值来获取<code>XCUIElementQuery</code>对象，其中第二种是简写方式。<br><code>XCUIElementType</code>枚举声明如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">XCUIElementType</span> : <span class=\"title\">UInt</span> </span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">case</span> button</span><br><span class=\"line\">    <span class=\"keyword\">case</span> radioButton</span><br><span class=\"line\">    <span class=\"keyword\">case</span> textField</span><br><span class=\"line\">    <span class=\"keyword\">case</span> comboBox</span><br><span class=\"line\">    <span class=\"keyword\">case</span> menuButton</span><br><span class=\"line\">    <span class=\"keyword\">case</span> toolbarButton</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"第一种获取所有的元素：descendantsMatchingType-gt-XCUIElementQuery\"><a href=\"#第一种获取所有的元素：descendantsMatchingType-gt-XCUIElementQuery\" class=\"headerlink\" title=\"第一种获取所有的元素：descendantsMatchingType-&gt;XCUIElementQuery\"></a>第一种获取所有的元素：<code>descendantsMatchingType-&gt;XCUIElementQuery</code></h5><p>取某种类型的元素以及它的子类集合，能获取到系统级控件如<code>UIButton</code>，和用户自定义的UI控件<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttons:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().descendantsMatchingType(.<span class=\"type\">Button</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> textFields:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().descendantsMatchingType(.textField)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"第三种仅获取当前层级子元素：childrenMatchingType\"><a href=\"#第三种仅获取当前层级子元素：childrenMatchingType\" class=\"headerlink\" title=\"第三种仅获取当前层级子元素：childrenMatchingType\"></a>第三种仅获取当前层级子元素：<code>childrenMatchingType</code></h5><p>取某种类型的元素集合，不包含它的子类，即仅获取系统级控件如<code>UIButton</code>，不获取用户自定义的UI控件<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttons:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().childrenMatchingType(.<span class=\"type\">Button</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> textFields:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().childrenMatchingType(.textField)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"第四种所有包含的元素：containingType\"><a href=\"#第四种所有包含的元素：containingType\" class=\"headerlink\" title=\"第四种所有包含的元素：containingType\"></a>第四种所有包含的元素：<code>containingType</code></h5><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttons:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().containingType(.<span class=\"type\">Button</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> textFields:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().containingType(.textField)</span><br></pre></td></tr></table></figure>\n<h3 id=\"XCUIElement表示系统的各种UI控件\"><a href=\"#XCUIElement表示系统的各种UI控件\" class=\"headerlink\" title=\"XCUIElement表示系统的各种UI控件\"></a>XCUIElement表示系统的各种UI控件</h3><p><code>XCUIElement</code>UI控件在测试框架中的代理，继承<code>NSObject</code>，实现<code>XCUIElementAttributes</code>协议, <code>XCUIElementTypeQueryProvider</code>协议，可以表示系统的各种UI控件。</p>\n<ol>\n<li>XCUIElementAttributes协议：里面包含了UIAccessibility中的部分属性<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/XCUIElementAttributes.png?imageMogr2/2/w/800\">\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/UIAccessibility.jpg?imageMogr2/2/w/800\"></li>\n<li>XCUIElementTypeQueryProvider协议：包含了系统中大部分UI控件的类型，可通过读属性的方式取得某种类型的UI集合<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/XCUIElementTypeQueryProvider.png?imageMogr2/2/w/800\">\n</li>\n</ol>\n<h4 id=\"访问UI控件\"><a href=\"#访问UI控件\" class=\"headerlink\" title=\"访问UI控件\"></a>访问UI控件</h4><ol>\n<li><code>exist:</code>判断当前的UI元素是否存在，如果对一个不存在的元素进行操作，会导致测试组件抛出异常并中断测试.</li>\n<li><code>element()</code>／<code>下标方法</code>：<code>XCUIElementQuery</code>实例的方法获取UI控件，不能直接通过<code>XCUIElement</code> 来访问 app 中的元素，只能通过 <code>Accessibility</code> 中的像是 <code>identifier</code> 或者 <code>frame</code> 这样的属性来获取 UI 的信息。<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> userNameTextField:<span class=\"type\">XCUIElement</span> = app.textFields.element(boundBy: <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> userNameTextField:<span class=\"type\">XCUIElement</span> = app.textFields[<span class=\"string\">\"username\"</span>]</span><br></pre></td></tr></table></figure>\n对于 <code>XCUIElementQuery</code>，<code>Query</code>的执行是有延迟的，它和最后我们得到的 <code>XCUIElement</code> 并不是一一对应的。和 <code>NSURL</code> 与请求到的内容的关系类似，随着时间的变化，同一个 <code>URL</code> 有可能请求到不同的内容。<br>在拿到<code>Query</code>实例后，只有在通过<code>下标</code>或<code>访问方法</code>访问时，才会真正寻找对应的 <code>UI 控件</code>。这就是说，随着我们的 UI 的变化，同样的 <code>query</code> 也可能获取到不用的<code>UI控件</code>。为了获取UI元素准确：我们可以通过在 <code>Interface Builder</code> 或者<code>代码</code>中，对UI控件的 <code>identifier</code>属性进行设置，这样就可以使用下标的方式进行访问了。</li>\n</ol>\n<h4 id=\"设置UI控件触发事件和属性值\"><a href=\"#设置UI控件触发事件和属性值\" class=\"headerlink\" title=\"设置UI控件触发事件和属性值\"></a>设置UI控件<code>触发事件</code>和<code>属性值</code></h4><p>使用<code>typeText(text:String)</code>,<code>tap()</code>,<code>doubleTap()</code>等方法。<br>以获取userNameTextField控件为例：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> userNameTextField:<span class=\"type\">XCUIElement</span> = app.textFields.element(boundBy: <span class=\"number\">0</span>)</span><br><span class=\"line\">userNameTextField.tap()</span><br><span class=\"line\">userNameTextField.typeText(<span class=\"string\">\"文本内容\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"XCUIElementAttributes协议\"><a href=\"#XCUIElementAttributes协议\" class=\"headerlink\" title=\"XCUIElementAttributes协议\"></a>XCUIElementAttributes协议</h4><p>UI元素中包含的各个属性，<code>identifier</code>，<code>frame</code>,<code>title</code>,<code>label</code>等…</p>\n<ol>\n<li>使用: 可使用这些属性来获取UI元素对象。<figure class=\"highlight swift\"><figcaption><span>title获取</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> username = <span class=\"string\">\"hsg\"</span></span><br><span class=\"line\">userNameTextField.typeText(username)</span><br><span class=\"line\">app.textFields[username].tap()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><figcaption><span>identifier获取</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> identifier = <span class=\"string\">\"hsg\"</span></span><br><span class=\"line\">userNameTextField.typeText(username)</span><br><span class=\"line\">app.textFields[username].tap()</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"测试","path":"api/categories/测试.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"单元测试","path":"api/tags/单元测试.json"}]},{"title":"整理iOS中几种常用的展示型视图控制器","slug":"iOS中几种常用的展示控制器使用","date":"2017-02-16T17:53:18.000Z","updated":"2017-02-16T21:56:31.000Z","comments":true,"path":"api/articles/iOS中几种常用的展示控制器使用.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/iPhoneipadalert.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><a href=\"https://www.dropbox.com/s/4gj6levvlav2xzc/PresentationsDemoStart.zip?dl=0\" target=\"_blank\" rel=\"noopener\">开始项目</a><br><a href=\"https://github.com/appcoda/Presentation-Controllers-Demo\" target=\"_blank\" rel=\"noopener\">完整项目</a></p>\n<h2 id=\"UIAlertController\"><a href=\"#UIAlertController\" class=\"headerlink\" title=\"UIAlertController\"></a>UIAlertController</h2><p>在iOS8中，提供<code>UIAlertController</code>控制器代替<code>UIAlertView</code>和<code>UIActionSheet</code>两个控件。给用户展示提示信息的新的一种方式。</p>\n<h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><ol>\n<li>能够自适应的（在iPad上，an <code>action sheet</code> style alert will present itself in a popover），</li>\n<li>显示方式：可以轻松切换<code>Action sheets</code>和<code>alert view</code>两种显示样式<code>alert view</code>被以modal态显示presenting视图控制器上，<code>Action sheets</code>被固定在以屏幕底部。 </li>\n<li>按钮事件实现：使用闭包的方式来处理，相较之前通过实现代理的方式要简单很多。</li>\n<li>子控件支持：<code>Alert view</code>支持按钮和输入框两种，Action sheets仅支持按钮一种控件。</li>\n<li>不同于以往的两类<code>UIAlertController</code>继承自<code>UIViewController</code>。这意味着可以使用视图控制器提供展示信息的功能。</li>\n</ol>\n<h3 id=\"创建使用UIAlertController\"><a href=\"#创建使用UIAlertController\" class=\"headerlink\" title=\"创建使用UIAlertController\"></a>创建使用UIAlertController</h3><p>用<code>title</code>，<code>message</code>参数来实例化<code>alertController</code>实例，然后在实例中添加两个闭包的按钮<br><figure class=\"highlight swift\"><figcaption><span>showAlertWasTapped</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@IBAction</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">showAlertWasTapped</span><span class=\"params\">(sender: UIButton)</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> alertController = <span class=\"type\">UIAlertController</span>(title: <span class=\"string\">\"Appcoda\"</span>, message: <span class=\"string\">\"Message in alert dialog\"</span>, preferredStyle: <span class=\"type\">UIAlertControllerStyle</span>.<span class=\"type\">Alert</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> deleteAction = <span class=\"type\">UIAlertAction</span>(title: <span class=\"string\">\"Delete\"</span>, style: <span class=\"type\">UIAlertActionStyle</span>.<span class=\"type\">Destructive</span>, handler: &#123;(alert :<span class=\"type\">UIAlertAction</span>!) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"built_in\">println</span>(<span class=\"string\">\"Delete button tapped\"</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    alertController.addAction(deleteAction)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> okAction = <span class=\"type\">UIAlertAction</span>(title: <span class=\"string\">\"OK\"</span>, style: <span class=\"type\">UIAlertActionStyle</span>.<span class=\"type\">Default</span>, handler: &#123;(alert :<span class=\"type\">UIAlertAction</span>!) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"built_in\">println</span>(<span class=\"string\">\"OK button tapped\"</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    alertController.addAction(okAction)</span><br><span class=\"line\"></span><br><span class=\"line\">    presentViewController(alertController, animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>运行效果：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/iPhoneipadalert.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"UIAlertControllerStyle枚举：Alert切换ActionSheet\"><a href=\"#UIAlertControllerStyle枚举：Alert切换ActionSheet\" class=\"headerlink\" title=\"UIAlertControllerStyle枚举：Alert切换ActionSheet\"></a>UIAlertControllerStyle枚举：<code>Alert</code>切换<code>ActionSheet</code></h3><p>在<code>UIAlertController</code>之前，切换<code>alert</code>和<code>action sheet</code>需要重写大量的代码，但现在只需要改变一个枚举值<code>UIAlertControllerStyle.Alert</code>为<code>UIAlertControllerStyle.ActionSheet</code>.<br><figure class=\"highlight swift\"><figcaption><span>UIAlertControllerStyle.ActionSheet</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> alertController = <span class=\"type\">UIAlertController</span>(title: <span class=\"string\">\"Appcoda\"</span>, message: <span class=\"string\">\"Message in alert dialog\"</span>, preferredStyle: <span class=\"type\">UIAlertControllerStyle</span>.<span class=\"type\">ActionSheet</span>)</span><br></pre></td></tr></table></figure><br>在iPhone上，屏幕底部显示一个<code>action sheet</code>。<br>问题：在iPad上，点击上面的按钮崩溃，需要定义锚点位置。</p>\n<h3 id=\"popoverPresentationController锚点：sourceView-sourceRect\"><a href=\"#popoverPresentationController锚点：sourceView-sourceRect\" class=\"headerlink\" title=\"popoverPresentationController锚点：sourceView/sourceRect\"></a>popoverPresentationController锚点：sourceView/sourceRect</h3><p><code>popover controller</code>在<code>alertController</code>视图内展示，需要一个<code>popover箭头</code>指向<code>alertController</code>视图的某一位置。<br>通过设置<code>sourceView</code>来确定<code>popover箭头</code>位置，这个<code>popover</code>以及<code>popover箭头</code>指向的矩形区域都在这个<code>sourceView</code>上。<br>在调用<code>presentViewController()</code>之前添加代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alertController.popoverPresentationController?.sourceView = view</span><br><span class=\"line\">alertController.popoverPresentationController?.sourceRect = sender.frame</span><br></pre></td></tr></table></figure><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/popover箭头.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"UIPopoverPresentationController\"><a href=\"#UIPopoverPresentationController\" class=\"headerlink\" title=\"UIPopoverPresentationController\"></a>UIPopoverPresentationController</h2><p><code>Alert</code>主要用于显示用户的提示信息，当展示的信息很多时，就需要借助<code>popover presentation controller</code>。</p>\n<h3 id=\"在compact和regular两种屏幕中显示模态视图\"><a href=\"#在compact和regular两种屏幕中显示模态视图\" class=\"headerlink\" title=\"在compact和regular两种屏幕中显示模态视图\"></a>在compact和regular两种屏幕中显示模态视图</h3><p>在<code>storyboard</code>文件，设置视图的<code>storyboard ID</code>:<code>PopoverViewController</code>，设置模态视图展示样式，展示在<code>compact-width</code>和<code>regular-width</code>的两种设备屏幕上。<br>实现如下：<br><figure class=\"highlight swift\"><figcaption><span>actionWasTapped</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@IBAction</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">actionWasTapped</span><span class=\"params\">(sender: UIBarButtonItem)</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> storyboard : <span class=\"type\">UIStoryboard</span> = <span class=\"type\">UIStoryboard</span>(name: <span class=\"string\">\"Main\"</span>, bundle: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> vc = storyboard.instantiateViewControllerWithIdentifier(<span class=\"string\">\"PopoverViewController\"</span>) <span class=\"keyword\">as</span>! <span class=\"type\">UIViewController</span></span><br><span class=\"line\">    vc.modalPresentationStyle = <span class=\"type\">UIModalPresentationStyle</span>.<span class=\"type\">Popover</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> popover: <span class=\"type\">UIPopoverPresentationController</span> = vc.popoverPresentationController!</span><br><span class=\"line\">    popover.barButtonItem = sender  <span class=\"comment\">//`popover箭头`锚的位置</span></span><br><span class=\"line\">    presentViewController(vc, animated: <span class=\"literal\">true</span>, completion:<span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"设置锚点四种方式\"><a href=\"#设置锚点四种方式\" class=\"headerlink\" title=\"设置锚点四种方式\"></a>设置锚点四种方式</h4><ol>\n<li>barButtonItem<br>先获取该视图控制器的<code>popoverPresentationController</code>控制器，通过<code>popover</code>控制器的<code>barButtonItem</code>属性来设置锚点控件。当弹出时<code>popover箭头</code>就指向这个barButtonItem控件。</li>\n<li>通过指定<code>sourceView</code>和<code>sourceRect</code>两个属性，就像前面例子中一样来指定锚点位置。</li>\n<li>通过其他属性来实现，例如：<code>permittedArrowDirections</code>，也能够指定锚点。</li>\n<li>如果在在展示过程中，无法确定箭头的方向时，就是用默认值：<code>UIPopoverArrowDirection.Any</code>.<br>在iPad显示：</li>\n</ol>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/UIPopoverArrowDirection.png?imageMogr2/2/w/800\">\n<p>在iPhone上以模态显示：</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/iPhonemodally.png?imageMogr2/2/w/800\">\n<h3 id=\"在iPhone设备上dissmiss模态视图\"><a href=\"#在iPhone设备上dissmiss模态视图\" class=\"headerlink\" title=\"在iPhone设备上dissmiss模态视图\"></a>在iPhone设备上dissmiss模态视图</h3><p>要在iPhone设备上，实现模态视图dissmiss功能，需要借助导航控制器，同时这个模态视图需要遵循<code>UIPopoverPresentationController</code>协议，实现两个代理方法</p>\n<h4 id=\"实现UIPopoverPresentationController协议\"><a href=\"#实现UIPopoverPresentationController协议\" class=\"headerlink\" title=\"实现UIPopoverPresentationController协议\"></a>实现<code>UIPopoverPresentationController</code>协议</h4><ol>\n<li><code>PopoverViewController</code>类定义修改如下:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PopoverViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">UIPopoverPresentationControllerDelegate</span> </span>&#123;</span><br></pre></td></tr></table></figure></li>\n<li>在actionWasTapped()函数中调用<code>presentViewController()</code>之前添加：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">popover.delegate = <span class=\"keyword\">self</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法一：返回自适应设备的视图展示样式\"><a href=\"#方法一：返回自适应设备的视图展示样式\" class=\"headerlink\" title=\"方法一：返回自适应设备的视图展示样式\"></a>方法一：返回自适应设备的视图展示样式</h4>当APP在<code>compact-width</code>设备上弹出一个视图时调用.这个方法告诉OS系统使用的视图展示样式。<br>这里OS系统被告知在<code>compact-width</code>设备上，使用全屏的样式展示视图。<figure class=\"highlight swift\"><figcaption><span>adaptivePresentationStyleForPresentationController()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">adaptivePresentationStyleForPresentationController</span><span class=\"params\">(controller: UIPresentationController)</span></span> -&gt; <span class=\"type\">UIModalPresentationStyle</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">UIModalPresentationStyle</span>.<span class=\"type\">FullScreen</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二：返回自定义的视图控制器\"><a href=\"#方法二：返回自定义的视图控制器\" class=\"headerlink\" title=\"方法二：返回自定义的视图控制器\"></a>方法二：返回自定义的视图控制器</h4>当前展现的视图和原来的展示方式不同时调用.我们设置这个视图的<code>Popover presentation</code>展示方式，但是我们指定在<code>compact-width</code>设备上，这样它会以full screen样式展示。在这个函数中，样式切换发生时，会return自定义的视图控制器。<figure class=\"highlight swift\"><figcaption><span>presentationController(_:viewControllerForAdaptivePresentationStyle)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationController</span><span class=\"params\">(controller: UIPresentationController, viewControllerForAdaptivePresentationStyle style: UIModalPresentationStyle)</span></span> -&gt; <span class=\"type\">UIViewController</span>? </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> navigationController = <span class=\"type\">UINavigationController</span>(rootViewController: controller.presentedViewController)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> btnDone = <span class=\"type\">UIBarButtonItem</span>(title: <span class=\"string\">\"Done\"</span>, style: .<span class=\"type\">Done</span>, target: <span class=\"keyword\">self</span>, action: <span class=\"string\">\"dismiss\"</span>)</span><br><span class=\"line\">    navigationController.topViewController.navigationItem.rightBarButtonItem = btnDone</span><br><span class=\"line\">    <span class=\"keyword\">return</span> navigationController</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"Done按钮的dismiss事件\"><a href=\"#Done按钮的dismiss事件\" class=\"headerlink\" title=\"Done按钮的dismiss事件\"></a><code>Done</code>按钮的dismiss事件</h4><p>在导航控制器中国封装这个视图，在导航条上添加一个<code>Done</code>按钮，点击<code>Done</code>dismiss这个视图<br><figure class=\"highlight swift\"><figcaption><span>dismiss</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dismiss</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.dismissViewControllerAnimated(<span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在iPhone上，显示修改后的视图控制器，多出带按钮的导航栏。<br>在iPad上，视图控制器显示没有导航控制器，因为它不使用全屏幕显示。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/adaptivePresentationStyleForPresentationController.png?imageMogr2/2/w/800\"><br>如果想让iPhone像iPad一样显示一个Popover，只<code>adaptivePresentationStyleForPresentationController</code>返回：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"type\">UIModalPresentationStyle</span>.<span class=\"type\">None</span></span><br></pre></td></tr></table></figure><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/UIModalPresentationStyle.None.png?imageMogr2/2/w/800\"></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"转场","path":"api/categories/转场.json"}],"tags":[{"name":"动画","path":"api/tags/动画.json"},{"name":"转场","path":"api/tags/转场.json"},{"name":"UI","path":"api/tags/UI.json"}]},{"title":"macOS之PDFKit基础","slug":"macOS/macOS之PDFKit基础","date":"2017-02-14T14:29:18.000Z","updated":"2018-01-08T14:10:41.000Z","comments":true,"path":"api/articles/macOS/macOS之PDFKit基础.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/view_vspage_space.gif?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>一个PDF的基本构建块是Documents本身。Documents通常作为文件存储在磁盘上。<br>作为文件版本，可以支持元数据标记如作者，创建日期，等等。<br>一个文件可以加密，需要密码才能查看它。两级加密存在：</p>\n<ul>\n<li>用户级加密：如果用户成功地获得用户级权限，他或她可以查看文档，但可以限制打印或复制文档。</li>\n<li>所有者级别加密：获得所有者级别权限的用户可以查看文档并具有完全使用权限。<br>许多加密的PDF文件有一个“dummy”的用户密码为<code>空字符串</code>。大多数PDF文档解析器（包括PDF套件）自动尝试空字符串密码加密后的文件，如果成功，只显示文档。因此，在技术上加密的文档不一定提示用户口令。</li>\n</ul>\n<h2 id=\"PDF页面\"><a href=\"#PDF页面\" class=\"headerlink\" title=\"PDF页面\"></a>PDF页面</h2><p>一个PDF文档由若干页面组成。这个页面看起来就像一本物理书页面显示在屏幕上。同时PDF页面可以包含<code>超链接</code>和<code>注释</code>。页面可以支持<code>裁剪</code>，还有其他使用功能：例如隐藏多余的部分（如注册标记）。</p>\n<h3 id=\"view-VS-page空间坐标\"><a href=\"#view-VS-page空间坐标\" class=\"headerlink\" title=\"view VS page空间坐标\"></a>view VS page空间坐标</h3><p>页面上的大多数对象都是在<code>page</code>空间中指定的，而不是在<code>view</code>空间中。<br>也就是说，坐标系统是在点（每英寸72点），<code>坐标原点</code>在page左侧底部，而不是<code>view</code>。<code>page</code>空间不关心缩放，显示模式等等。一个有<code>bounds</code>的item，比如说32points，保留这些界限，无论显示大小。<br>图view和page坐标系比较<br><img title=\"view和page坐标系比较\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/view_vspage_space.gif?imageMogr2/2/w/800\"><br><code>PDFView class</code>包含几个转换方法，将坐标系统从<code>view space</code>的<code>page space</code>，反之亦然。</p>\n<h2 id=\"PDF-Kit-Classes\"><a href=\"#PDF-Kit-Classes\" class=\"headerlink\" title=\"PDF Kit Classes\"></a>PDF Kit Classes</h2><p><code>PDF Kit</code>套件提供了几个不同功能的<code>类</code>。<br><code>PDFView</code>和<code>PDFSelection</code>除外，这些<code>类</code>大致对应着各个<code>对象</code>在PDF格式的规范需求。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/pdfkit_inheritancehierarchy.gif?imageMogr2/2/w/800\"></p>\n<h3 id=\"PDFView-Class\"><a href=\"#PDFView-Class\" class=\"headerlink\" title=\"PDFView Class\"></a>PDFView Class</h3><p><code>PDFView类</code>，就好比Web工具包的<code>WebView类</code>，源于<code>Application Kit</code>中的<code>NSView类</code>。在项目开发中，你可以使用<code>Interface Builder</code>轻松拖动一个<code>PDFView对象</code>放在一个window中。<del>从/Developer/Extras/Palettes/PDFKit.palette得到调色板。</del><br><code>PDFView</code>可能是<code>PDF Kit</code>中唯一个需要你自定义的的类。在APP中显示PDF数据，允许用户选择文档内容和导航浏览PDF文档，设置缩放级别，复制文本内容到剪贴板。用户可以拖放PDF文档到<code>PDFView</code>。<br><code>PDFView</code>能通过调用其他<code>PDF实用类</code>来实现其大部分功能。如果要添加特殊功能，则需要用户自定义<code>实用类</code>的子类来扩展其特殊功能。<br>Utility classes as used by PDFView<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/pdfkit_uses_hierarchy.gif?imageMogr2/2/w/800\"></p>\n<h3 id=\"PDF-Kit-Utility-Classes\"><a href=\"#PDF-Kit-Utility-Classes\" class=\"headerlink\" title=\"PDF Kit Utility Classes\"></a>PDF Kit Utility Classes</h3><p>PDF套件工具类提供一种混合的<code>Foundation-like</code>和<code>Application Kit-like</code>的行为。他们有类似的<code>NSString类</code>和<code>NSString Additions</code>方法。这些类都系橙自<code>NSObject</code><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/pdfkit_inheritancehierarchy.gif?imageMogr2/2/w/800\"></p>\n<h4 id=\"PDF-Document\"><a href=\"#PDF-Document\" class=\"headerlink\" title=\"PDF Document\"></a>PDF Document</h4><p><code>PDFDocument</code>是<code>PDF kit工具类</code>中重要类，代表着PDF data或PDF文件。其他实用工具类一般都在<code>PDFDocument</code>方法中的实例化。是<code>PDFPage</code>和<code>PDFOutline</code>；或相关支持操作：<code>PDFSelection</code>和<code>PDFDestination</code>。<br>你<code>PDFDocument对象</code>初始化，需要一个<code>PDF数据</code>或一个指向PDF文件的<code>URL</code>。实例化之后就可以访问<code>页数</code>，<code>添加</code>或<code>删除</code>页面，对所选内容为<code>NSString对象</code>进行<code>查找</code>或<code>分析</code>。</p>\n<h4 id=\"PDFPage\"><a href=\"#PDFPage\" class=\"headerlink\" title=\"PDFPage\"></a>PDFPage</h4><p><code>PDFPage</code>代表一个PDF文档的页面。你的应用程序获取一个<code>PDFPage</code>对象必须通过从<code>PDFDocument</code>对象来实例化。<code>PDFPage</code>对象是用户所看到的屏幕，和一个<code>view</code>可以同时显示多个<code>page</code>。你可以使用<code>PDFPage</code>把PDF文档内容渲染到屏幕上，添加<code>注释</code>，<code>计数字符串</code>，定义<code>选择</code>，获取一个<code>page</code>中的文本内容作为<code>NSString对象</code>或<code>NSAttributedString对象</code>。</p>\n<h4 id=\"PDFOutline\"><a href=\"#PDFOutline\" class=\"headerlink\" title=\"PDFOutline\"></a>PDFOutline</h4><p>除了显示实际的文件内容，<code>PDF Kit</code>也能呈现<code>PDFOutline</code>信息，前提是PDF文档中存在目录结构。在目录结构中，一个<code>PDFOutline对象</code>代表一个<code>父目录</code>或<code>子目录</code>。<br>目录是由一个层次的<code>PDFOutline对象</code>组层。顶层是<code>根目录对象</code>，它仅作为其他目录对象的容器。用户的<code>根目录</code>是不可见的。</p>\n<h4 id=\"PDFSelection\"><a href=\"#PDFSelection\" class=\"headerlink\" title=\"PDFSelection\"></a>PDFSelection</h4><p>一个<code>PDFSelection</code>对象包含一个跨PDF文档中文本。你不要直接创建<code>PDFSelection</code>。<code>PDFSelection</code>对象是作为返回值来实例化的。例如：通过调用<code>PDFPage</code>或<code>PDFDocument</code>对象中的selection方法，并从成功搜索的返回值来实例化<code>PDFSelection</code>对象。<br>在同时显示多个<code>PDFPage</code>的<code>PDFView</code>中，<code>PDFSelection</code>可以是不连续的，或两者兼具的。例如，可以选择在一个单柱连续两列页面的文本。可以在任何方向从一个选择区, 合并选择区, 或扩展选择区中得到文本和网页覆盖。</p>\n<h4 id=\"PDFAnnotation\"><a href=\"#PDFAnnotation\" class=\"headerlink\" title=\"PDFAnnotation\"></a>PDFAnnotation</h4><p>一个<code>PDFAnnotation</code>对象可以表示多种内容以外，在一个PDF文件的主要文本内容：链接、表单元素，突出圈子，等等。每个注释与页面上的特定位置相关，并且可以与用户提供交互性。<br><code>PDFAnnotation</code>是如图所示的具体类的抽象类。各种具体类代表<code>PDF Kit</code>支持的注释类型。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/annotations.gif?imageMogr2/2/w/800\"></p>\n<h4 id=\"PDFBorder\"><a href=\"#PDFBorder\" class=\"headerlink\" title=\"PDFBorder\"></a>PDFBorder</h4><p><code>PDFBorder</code>对象封装的拉伸<code>PDFAnnotation</code>对象边框的行为。可以定义一个PDF的bord线的风格属性（例如，固体，破灭，或斜面），bord线的宽度，和圆角半径。</p>\n<p>过期:<del>从/Developer/Extras/Palettes/PDFKit.palette得到调色板。</del><br>Here’s what Apple says about it:<br><blockquote><p>“To add the PDFKit palette in Interface Builder, select the Palettes tab in the Preferences panel. Click the Add<br>button, navigate to the /Developer/Extras/Palettes folder, and select the PDFKit palette. Next, select the Customize Toolbar menu item in the Tools/Palettes menu and drag the PDFKit palette to the toolbar to make it visible.”</p>\n<footer><strong>老文档</strong><cite><a href=\"http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Conceptual/PDFKitGuide/PDFKit_Prog_Tasks/PDFKit_Prog_Tasks.html\" target=\"_blank\" rel=\"noopener\">PDFKit_Prog_Tasks</a></cite></footer></blockquote><br>So:<br>there’s no Palettes tab anywhere in the Preferences panel and the Xcode Help return a blank when searching for it.<br>There’s no PDFKit.palette file anywhere on my HD (says Spotlight).<br>I guess these instructions are for an older version of XCode but it’s all Apple seemed to have on it…</p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"PDF","path":"api/categories/PDF.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"PDF","path":"api/tags/PDF.json"},{"name":"阅读器","path":"api/tags/阅读器.json"}]},{"title":"UIImage的渲染模式","slug":"iOS/UIImage的渲染模式","date":"2015-11-26T16:15:11.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/UIImage的渲染模式.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>设置UIImage的渲染模式：UIImage.renderingMode<br>在 iOS 7 中 UIImage 添加了一个 <code>renderingMode</code> 属性。我们可以使用 <code>imageWithRenderingMode:</code>并传入一个合适的<code>UIImageRenderingMode</code> 来指定这个 image 要不要以 Template 的方式进行渲染。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIImageRenderingModeAutomatic</span> <span class=\"comment\">// 根据图片的使用环境和所处的绘图上下文自动调整渲染模式。</span></span><br><span class=\"line\"><span class=\"built_in\">UIImageRenderingModeAlwaysOriginal</span> <span class=\"comment\">// 始终绘制图片原始状态，不使用Tint Color。</span></span><br><span class=\"line\"><span class=\"built_in\">UIImageRenderingModeAlwaysTemplate</span> <span class=\"comment\">// 始终根据Tint Color绘制图片，忽略图片的颜色信息。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UIImage</span> *img = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"myimage\"</span>];</span><br><span class=\"line\">img = [img imageWithRenderingMode:<span class=\"built_in\">UIImageRenderingModeAlwaysTemplate</span>];</span><br><span class=\"line\"><span class=\"comment\">//实际效果，效果依旧显示为baritem的Tint Color</span></span><br><span class=\"line\"><span class=\"built_in\">UIBarButtonItem</span> *barButtonItem = [[<span class=\"built_in\">UIBarButtonItem</span> alloc] initWithImage:setImage</span><br><span class=\"line\">                                                   style:<span class=\"built_in\">UIBarButtonItemStylePlain</span></span><br><span class=\"line\">                                                  target:<span class=\"keyword\">self</span></span><br><span class=\"line\">                                                  action:<span class=\"keyword\">@selector</span>(setAction:)];</span><br><span class=\"line\">```    </span><br><span class=\"line\">在新的 Xcode 中，我们可以直接在 Image Asset 里的 Render As 选项来指定是不是需要作为 template 使用。相应的，在`<span class=\"built_in\">UIApperance</span>`中，Apple 也为我们对于 `Size Classes` 添加了相应的方法。使用 `+appearanceForTraitCollection:` 方法，我们就可以针对不同 trait 下的应用的 apperance 进行很简单的设定。</span><br><span class=\"line\"></span><br><span class=\"line\">```objc</span><br><span class=\"line\"><span class=\"built_in\">UIView</span>.appearanceForTraitCollection(<span class=\"built_in\">UITraitCollection</span>(verticalSizeClass:.Compact)).tintColor = <span class=\"built_in\">UIColor</span>.redColor()  </span><br><span class=\"line\"><span class=\"built_in\">UIView</span>.appearanceForTraitCollection(<span class=\"built_in\">UITraitCollection</span>(verticalSizeClass:.Regular)).tintColor = <span class=\"built_in\">UIColor</span>.greenColor()</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"控件","path":"api/categories/控件.json"}],"tags":[{"name":"UI","path":"api/tags/UI.json"},{"name":"坑","path":"api/tags/坑.json"}]},{"title":"calabash一款跨平台UI测试工具初探","slug":"测试/calabash一款跨平台UI测试工具初探","date":"2015-10-06T08:32:41.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/测试/calabash一款跨平台UI测试工具初探.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>参考：<a href=\"http://blog.csdn.net/zangcw/article/details/25299243\" target=\"_blank\" rel=\"noopener\">使用jenkins+calabash+cocoapods搭建ios持续集成环境</a></p>\n<ol>\n<li>calabash  是一款开源的跨平台UI测试工具，目前支持iOS和Android。它使用Cucumber作为测试核心，Cucumber是一个在敏捷团队十分流行的自动化的功能测试工具，它使用接近于自然语言的特性文档进行用例的书写和测试，支持多语言和多平台。</li>\n<li><p>安装Calabash  </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem install calabash-cucumber</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装Calabash中文支持包  </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem install calabash-cucumber-cn</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"For-automatic-setup\"><a href=\"#For-automatic-setup\" class=\"headerlink\" title=\"For automatic setup:\"></a>For automatic setup:</h4><ol>\n<li><p>In a terminal, go to your iOS project  </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\tcd path-to-my-ios-project (i.e. directory containing .xcodeproj file)</span><br><span class=\"line\">\t```  </span><br><span class=\"line\">2. Install calabash-cucumber gem (this make take some time because of dependencies)</span><br></pre></td></tr></table></figure>\n<p> gem install calabash-cucumber</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3. Setup your project for Calabash-iOS.</span><br></pre></td></tr></table></figure>\n<p> calabash-ios setup  //Answer the questions and read the output :)</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4. Generate a skeleton features folder for your tests</span><br></pre></td></tr></table></figure>\n<p> calabash-ios gen</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5. In Xcode, build your project using the -cal scheme</span><br><span class=\"line\"></span><br><span class=\"line\">6. Run the generated test!</span><br></pre></td></tr></table></figure>\n<p> cucumber</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">If all goes well, you are now ready to write your first test. Start by editing the file features/my_first.feature.</span><br><span class=\"line\">&lt;!--more--&gt;</span><br><span class=\"line\">#### [cucumber官网](https://cukes.info/)   </span><br><span class=\"line\"></span><br><span class=\"line\">\t\t* Feature（功能）  </span><br><span class=\"line\">\t\t* Scenario（情景）  </span><br><span class=\"line\">\t\t*  Given（给定）  </span><br><span class=\"line\">\t\t*  When（当）  </span><br><span class=\"line\">\t\t*  Then（则） </span><br><span class=\"line\">#####[运行原理](http://www.educity.cn/se/619226.html)  </span><br><span class=\"line\">![image](http://img.educity.cn/img_7/262/2013122000/125005907.jpg)  </span><br><span class=\"line\">cucumber是一种BDD测试框架，核心为cucumber的calabash的脚本在运行测试的时候会在虚拟机/真机上预装一个web服务器，这个web服务器就是解释calabash的脚本，将其解释为robotium的脚本，然后这个web服务器会想测试app发送robotium的脚本，测试app拿到robotium脚本后，将其解释为instumentation命令向被测试的app发送这些命令，被测试的app执行这些命令，然后将结果返回给测试app，然后一级一级返得到最后的测试结果。    </span><br><span class=\"line\">#####结构框架</span><br><span class=\"line\">calabash完全采用了cucumber的结构模式，calabash是脚本与TC分离设计，在业务变化的情况下，只要功能存在基本只需要修改TC逻辑，在业务不变，功能变化的情况下，基本只需要修改脚本。   </span><br><span class=\"line\">![image](http://img.educity.cn/img_7/262/2013122000/126005907.jpg)  </span><br><span class=\"line\">feature为主件夹，step_definitions目录内是你封装的脚本，my_first.feature文件就是你的TC逻辑。  </span><br><span class=\"line\">再看一下其中的内容：</span><br><span class=\"line\"></span><br><span class=\"line\">\t　　my_first.feature</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　Feature： 登陆</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　Scenario： 输入正确的用户名密码能够正常登陆</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　When 打开登陆页面</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　And    输入用户名XXX输入密码XXX</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　And   点击登陆</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　Then  验证登陆成功</span><br><span class=\"line\"></span><br><span class=\"line\">　　看起来很简单吧，想要验证其他功能也是类似的语言描述即可。  </span><br><span class=\"line\">如果你没有用过cucumber或者calabash那么你肯定现在有一个疑问，计算机怎么能识别汉字来进行测试的呢，  </span><br><span class=\"line\">那么看一下step_definition，以 输入用户名XXX输入密码XXX为例：</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tWhen /^ 输入用户名\\&quot;([^\\\\\\&quot;]*)\\&quot; 输入密码\\&quot;([^\\\\\\&quot;]*)\\&quot;  $/ do |username，password|</span><br><span class=\"line\">\t\tperformAction(&apos;enter_text_into_numbered_field&apos;，username，1)</span><br><span class=\"line\">\t\tperformAction(&apos;enter_text_into_numbered_field&apos;，password，2)</span><br><span class=\"line\">\t\tend</span><br><span class=\"line\">现在应该能明白为什么你需要写汉字的脚本就可以了吧。  </span><br><span class=\"line\">在这里解释一下为什么如果业务存在功能修改这种情况，自动化脚本的修改量会小。  </span><br><span class=\"line\">还是以这个登录脚本为例：</span><br><span class=\"line\"></span><br><span class=\"line\">\t假如现在输入用户名和密码的输入框顺序变了，在你的页面显示上，可能是从左下角移到中间了，这种变化，那么feature文件你不用改，只需要改step_definition脚本就好了</span><br><span class=\"line\">#####运行报告</span><br><span class=\"line\">alabash-android支持很多报告生成模式，支持html，json，junit等等报告模式，只需要你在run的时候添加-f参数-o参数就可以了。</span><br><span class=\"line\"></span><br><span class=\"line\">　　例如 calabash-android run xxxx.apk -f html -o l，上图展示一下强大html报告  </span><br><span class=\"line\">　　![image](http://img.educity.cn/img_7/262/2013122000/127005907.jpg)</span><br><span class=\"line\"></span><br><span class=\"line\">[【cucumber解析features文件】](http://blog.csdn.net/qs_csu/article/details/9000262) \t\t</span><br><span class=\"line\">1. my_first.feature: 描述在这个条件下需要做什么事情；</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFeature: Running a test  </span><br><span class=\"line\">\t\t  As an iOS developer  </span><br><span class=\"line\">\t\t  I want to have a sample feature file  </span><br><span class=\"line\">\t\t  So I can begin testing quickly  </span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\tScenario: Example steps1  </span><br><span class=\"line\">\t\t  Given I am on the Welcome Screen  </span><br><span class=\"line\">\t\t  Then I swipe left  </span><br><span class=\"line\">\t\t  And I wait until I don&apos;t see &quot;Please swipe left&quot;  </span><br><span class=\"line\">\t\t  And take picture  </span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\tScenario: Example steps2  </span><br><span class=\"line\">\t\t  Given I am on the Welcome Screen  </span><br><span class=\"line\">\t\t #ASSERTION  </span><br><span class=\"line\">\t\t  Then I should see a &quot;login&quot; button  </span><br><span class=\"line\">\t\t #INPUT TEXT  </span><br><span class=\"line\">\t\t  Then I enter &quot;my_username&quot; into text field number 1  </span><br><span class=\"line\">\t\t#  Then I touch &quot;Return&quot;  </span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\t #TOGGLE SWITCH  </span><br><span class=\"line\">\t\t  Then I toggle the switch  </span><br><span class=\"line\">\t\t  Then I touch &quot;Login&quot;  </span><br><span class=\"line\">\t\t  And I touch &quot;Second&quot;  </span><br><span class=\"line\">\t\t  And take picture  </span><br><span class=\"line\">\t该文件描述了在“on the Welcome Screen”这个Step中需要做的事情，两个场景:steps1 和 steps2. </span><br><span class=\"line\"></span><br><span class=\"line\">2. my_first_step.rb: 解释了Given的具体条件</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tGiven /^I am on the Welcome Screen$/ do  </span><br><span class=\"line\">\t\t  element_exists(&quot;view&quot;)  </span><br><span class=\"line\">\t\t  check_element_exists(&quot;label text:&apos;First View&apos;&quot;)  </span><br><span class=\"line\">\t\t  sleep(STEP_PSEAU)  </span><br><span class=\"line\">\t\tend</span><br><span class=\"line\">\t这个语句，判定了当前条件&quot;on the Welcome Screen&quot;是否满足，如果element存在，则就在&quot;Welcome Screen&quot;</span><br><span class=\"line\">\t</span><br><span class=\"line\">[更多的测试框架](http://www.infoq.com/cn/articles/build-ios-continuous-integration-platform-part2)</span><br><span class=\"line\"></span><br><span class=\"line\">UIAutomation</span><br><span class=\"line\"></span><br><span class=\"line\">UIAutomation是随着iOS SDK 4.0引入，帮助开发者在真实设备和模拟器上执行自动化的UI测试。其本质上是一个Javascript的类库，通过 界面上的标签和值的访问性来获得UI元素，完成相应的交互操作，从而达到测试的目的，类似于Web世界的Selenium。</span><br><span class=\"line\"></span><br><span class=\"line\">通过上面的描述，可以得知，使用UIAutomation做测试时，开发者必须掌握两件事：</span><br><span class=\"line\"></span><br><span class=\"line\">- 如何找到界面上的一个UI元素</span><br><span class=\"line\">- 如何指定针对一个UI元素的操作</span><br><span class=\"line\"></span><br><span class=\"line\">在UIAutomation中，界面就是由一堆UI元素构建的层级结构，所有UI元素都继承对象UIAElement ，该对象提供了每个UI元素必须具备的一些属性：</span><br><span class=\"line\"></span><br><span class=\"line\">- name</span><br><span class=\"line\">- value</span><br><span class=\"line\">- elements</span><br><span class=\"line\">- parent</span><br><span class=\"line\">- …</span><br><span class=\"line\"></span><br><span class=\"line\">而整个界面的层级结构如下：</span><br><span class=\"line\"></span><br><span class=\"line\">\target（设备级别的UI，用于支持晃动，屏幕方向变动等操作）</span><br><span class=\"line\">\t    Application（设备上的应用，比方说Status Bar，keyboard等）</span><br><span class=\"line\">\t      Main window（应用的界面，比方说导航条）</span><br><span class=\"line\">\t        View（界面下的View，比方说UITableView）</span><br><span class=\"line\">\t           Element（View下的一个元素）</span><br><span class=\"line\">\t              Child element(元素下的一个子元素)</span><br><span class=\"line\">下面是一个访问到Child element的例子：</span><br><span class=\"line\"></span><br><span class=\"line\">\tUIATarget.localTarget().HamcrestDemo().tableViews()[0].cells()[0].elements()</span><br><span class=\"line\">开发者还可以通过“UIATarget.localTarget().logElementTree()”在控制台打印出该target下所有的的elements。</span><br><span class=\"line\"></span><br><span class=\"line\">找到UI元素之后，开发者可以基于该UI元素做期望的操作，UIAutomation作为原生的UI测试框架，基本上支持iOS上的所有UI元素和操作，比方说：</span><br><span class=\"line\"></span><br><span class=\"line\">- 点击按钮，例: ***.buttons[“add”].tap()</span><br><span class=\"line\">- 输入文本, 例:***.textfields[0].setValue(“new”)</span><br><span class=\"line\">- 滚动屏幕，例:***.scrollToElementWithPredicate(“name begin with ’test’”)</span><br><span class=\"line\">- ……</span><br><span class=\"line\">关于使用UIAutomation做UI测试，推荐大家一定要看一下2010的WWDC的Session 306：[Automating User Interface Testing with Instruments](https://developer.apple.com/videos/wwdc/2010/?id=306)。 另外，这儿还有一篇很好的博客，详细的讲解了[如何使用UIAutomation做UI自动化测试](http://blog.manbolo.com/2012/04/08/ios-automated-tests-with-uiautomation)  </span><br><span class=\"line\">Apple通过Instruments为UIAutomation测试用例的命令行运行提供了支持，这样就为UIAutomation和CI服务器的集成提供了便利。开发者可以通过如下的步骤在命令行中运行UIAutomation测试脚本:</span><br><span class=\"line\">1. 指定目标设备，构建被测应用，该应用会被安装到指定的DSTROOT目录下</span><br><span class=\"line\">```ruby</span><br><span class=\"line\">xcodebuild</span><br><span class=\"line\">-project &quot;/Users/twer/Documents/xcodeworkspace/AudioDemo/AudioDemo.xcodeproj&quot; </span><br><span class=\"line\">-schemeAudioDemo</span><br><span class=\"line\">-sdk iphonesimulator6.1 </span><br><span class=\"line\">-configuration Release SYMROOT=&quot;/Users/twer/Documents/xcodeworkspace/</span><br><span class=\"line\">AudioDemo/build&quot; DSTROOT=&quot;/Users/twer/Documents/xcodeworkspace/AudioDemo/</span><br><span class=\"line\">build&quot; TARGETED_DEVICE_FAMILY=&quot;1&quot; </span><br><span class=\"line\">install</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动Instruments，基于第一步生成的应用运行UIAutomation测试</p>\n<pre><code class=\"ruby\">instruments\n-t  <span class=\"string\">\"/Applications/Xcode.app/Contents/Applications/Instruments.app/</span>\n<span class=\"string\">Contents/PlugIns/AutomationInstrument.bundle/Contents/Resources/</span>\n<span class=\"string\">Automation.tracetemplate\"</span> <span class=\"string\">\"/Users/twer/Documents/xcodeworkspace/AudioDemo</span>\n<span class=\"string\">/build/Applications/TestExample.app\"</span>\n-e UIASCRIPT &lt;absolute_path_to_the_test_file&gt;\n</code></pre>\n<p>为了更好的展示测试效果以及与CI服务器集成，活跃的社区开发者们还尝试把UIAutomation和Jasmine集成: <a href=\"https://github.com/shaune/jasmine-ios-acceptance-tests\" target=\"_blank\" rel=\"noopener\">https://github.com/shaune/jasmine-ios-acceptance-tests</a></p>\n</li>\n</ol>\n<p>UIAutomation因其原生支持，并且通过和Instruments的绝佳配合，开发者可以非常方便的使用录制操作自动生成测试脚本，赢得了很多开发者的支持，但是因苹果公司的基因，其系统非常封闭，导致开发者难以扩展，于是活跃的社区开发者们开始制造自己的轮子，<a href=\"https://gorillalogic.com/fonemonkey-0-7-1-released/\" target=\"_blank\" rel=\"noopener\">Fone Monkey,最新版本更新于2010年，估计过时</a>就是其中的一个优秀成果。</p>\n","raw":null,"categories":[{"name":"工具","path":"api/categories/工具.json"},{"name":"集成","path":"api/categories/集成.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"测试","path":"api/tags/测试.json"}]}]}