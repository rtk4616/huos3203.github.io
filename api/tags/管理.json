{"name":"管理","postlist":[{"title":"搞定1无压工作的艺术","slug":"阅读/搞定1无压工作的艺术","date":"2017-06-13T10:34:26.000Z","updated":"2017-06-26T17:12:48.000Z","comments":true,"path":"api/articles/阅读/搞定1无压工作的艺术.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/理清工作流程图.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><h2 id=\"第一部分-通向从容之道\"><a href=\"#第一部分-通向从容之道\" class=\"headerlink\" title=\"第一部分 通向从容之道\"></a>第一部分 通向从容之道</h2><h3 id=\"第1章-新情况，新做法\"><a href=\"#第1章-新情况，新做法\" class=\"headerlink\" title=\"第1章 新情况，新做法\"></a>第1章 新情况，新做法</h3><ol>\n<li>如何回归“心如止水”的境界<br>在知识工作的环境下（信息大爆炸，事物繁杂的特点），传统时间管理法逐渐无法达到心如止水的境界，</li>\n</ol>\n<h3 id=\"第2章-掌控生活：横向管理工作流程的5个步骤\"><a href=\"#第2章-掌控生活：横向管理工作流程的5个步骤\" class=\"headerlink\" title=\"第2章 掌控生活：横向管理工作流程的5个步骤\"></a>第2章 掌控生活：横向管理工作流程的5个步骤</h3><p>横向管理的5个步骤</p>\n<ol>\n<li>收集：把一切会引起大脑注意的事务，不分轻重缓急（潜在的重要信息／任务／想法／行动／安排）一律从大脑中清空，作为原始材料放置工作篮中。</li>\n<li>理清：它是什么？检查工作篮的材料，理清它们的意义，扔掉垃圾事件</li>\n<li>整理：理清流程图和整理流程图一样，2分钟原则</li>\n<li>回顾：思考回顾体现了GTD的最核心</li>\n<li>执行：<br> 策划行动的三个方法：</li>\n<li>四标准法：情境，时间，精力，重要性</li>\n<li>每日工作三分类法：事先计划的事，突发事件，安排自己的事</li>\n<li>检视工作的六层次法：<br> 当前行动，当前项目，关注及责任范围，目标，愿景，目的和原则<br>流程图如下：   <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/理清工作流程图.png?imageMogr2/2/w/800\">\n衍生的清单：<br>项目清单<br>下一步行动<br>将要／也许清单<br>孵化清单</li>\n</ol>\n<h3 id=\"第3章-控制项目：纵向管理项目计划的5个阶段\"><a href=\"#第3章-控制项目：纵向管理项目计划的5个阶段\" class=\"headerlink\" title=\"第3章 控制项目：纵向管理项目计划的5个阶段\"></a>第3章 控制项目：纵向管理项目计划的5个阶段</h3><h2 id=\"第二部分-远离压力，提高效率\"><a href=\"#第二部分-远离压力，提高效率\" class=\"headerlink\" title=\"第二部分 远离压力，提高效率\"></a>第二部分 远离压力，提高效率</h2><h3 id=\"第4章-准备工作：确定时间、空间和工具\"><a href=\"#第4章-准备工作：确定时间、空间和工具\" class=\"headerlink\" title=\"第4章 准备工作：确定时间、空间和工具\"></a>第4章 准备工作：确定时间、空间和工具</h3><h3 id=\"第5章-收集阶段：归拢材料\"><a href=\"#第5章-收集阶段：归拢材料\" class=\"headerlink\" title=\"第5章 收集阶段：归拢材料\"></a>第5章 收集阶段：归拢材料</h3><h3 id=\"第6章-处理阶段：清空工作篮\"><a href=\"#第6章-处理阶段：清空工作篮\" class=\"headerlink\" title=\"第6章 处理阶段：清空工作篮\"></a>第6章 处理阶段：清空工作篮</h3><h3 id=\"第7章-组织整理：建立好清单\"><a href=\"#第7章-组织整理：建立好清单\" class=\"headerlink\" title=\"第7章 组织整理：建立好清单\"></a>第7章 组织整理：建立好清单</h3><h3 id=\"第8章-检查回顾：保障系统的有效运行\"><a href=\"#第8章-检查回顾：保障系统的有效运行\" class=\"headerlink\" title=\"第8章 检查回顾：保障系统的有效运行\"></a>第8章 检查回顾：保障系统的有效运行</h3><h3 id=\"第9章-执行阶段：选择最合适的行动\"><a href=\"#第9章-执行阶段：选择最合适的行动\" class=\"headerlink\" title=\"第9章 执行阶段：选择最合适的行动\"></a>第9章 执行阶段：选择最合适的行动</h3><h3 id=\"第10章-学会控制项目\"><a href=\"#第10章-学会控制项目\" class=\"headerlink\" title=\"第10章 学会控制项目\"></a>第10章 学会控制项目</h3><h2 id=\"第三部分-三个关键原则\"><a href=\"#第三部分-三个关键原则\" class=\"headerlink\" title=\"第三部分 三个关键原则\"></a>第三部分 三个关键原则</h2><h3 id=\"第11章-原则一：养成收集的习惯\"><a href=\"#第11章-原则一：养成收集的习惯\" class=\"headerlink\" title=\"第11章 原则一：养成收集的习惯\"></a>第11章 原则一：养成收集的习惯</h3><h3 id=\"第12章-原则二：确定“下一步行动”\"><a href=\"#第12章-原则二：确定“下一步行动”\" class=\"headerlink\" title=\"第12章 原则二：确定“下一步行动”\"></a>第12章 原则二：确定“下一步行动”</h3><h3 id=\"第13章-原则三：学会关注结果\"><a href=\"#第13章-原则三：学会关注结果\" class=\"headerlink\" title=\"第13章 原则三：学会关注结果\"></a>第13章 原则三：学会关注结果</h3><h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2>\n\n\t<div class=\"row\">\n    <embed src=\"/images/搞定1无压工作的艺术.pdf\" width=\"100%\" height=\"550\" type=\"application/pdf\">\n\t</div>\n\n\n\n","raw":null,"categories":[{"name":"阅读","path":"api/categories/阅读.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"}]},{"title":"WacomSlate笔记本使用","slug":"WacomSlate笔记本使用","date":"2017-06-03T23:32:45.000Z","updated":"2017-06-04T23:55:12.000Z","comments":true,"path":"api/articles/WacomSlate笔记本使用.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>梳理任务列表，整理阅读笔记和思维导图，来配合iPad完成每日工作任务</p>\n<h3 id=\"使用效率\"><a href=\"#使用效率\" class=\"headerlink\" title=\"使用效率\"></a>使用效率</h3><p>按时出图，分解任务，规划职业</p>\n<h3 id=\"带来的回报\"><a href=\"#带来的回报\" class=\"headerlink\" title=\"带来的回报\"></a>带来的回报</h3><p>### </p>\n<h3 id=\"Starter-playgroundbook\"><a href=\"#Starter-playgroundbook\" class=\"headerlink\" title=\"Starter.playgroundbook\"></a>Starter.playgroundbook</h3><p>iPad学习开发swift<br>第一步：创建书本的结构（参考模版）<a href=\"\">Starter.playgroundbook</a><br>第二步：了解模版的结构<br>第三步：增删改模版，增加个人的书本内容<br>官方建议流程：<br>Make targeted changes to the book’s content and structure in Xcode.<br>Transfer the updated book into Swift Playgrounds using iCloud or AirDrop.<br>只能使用iCloud和AirDrop来同步swift书籍同步到iPad上。<br>Open the updated book and test the changes.<br>Note any additional changes that are needed, and return to step 1.</p>\n<p>最终使用方法：<br>是在iPad上的一款应用，支持swift快速开发，只需要在appStore中下载Swift Playgrounds程序。<br>在这个这个程序中有精选栏，和我的Playgorund</p>\n<ol>\n<li>精选：就是内置了一些有趣的swift学习编程，从基础进阶再探索，简单易学的教学</li>\n<li>我的Playground：有新建，分享，编辑三个按钮，和自己的程序书架。<br>有两种方式开始编程：</li>\n<li>新建一个空白的playgroundbook</li>\n<li>通过iCloud 云同步已有的playgroundbook，这也是和mac端共享代码的途径（airdrop暂时没有测通，Mac端开启airdrop却看不到ipad设备），也可以通过第三方来同步，比如sync<br>源码分享：</li>\n<li>点击分享按钮，再点击要分享的playgroundbook文件，然后通过airdrop方式同 Mac共享文件。不过暂时没测通。如果使用微信，qq分享似乎发送到Mac端显示的是目录，无法通过打开方式来使用swift playground 程序<br>效果分享：</li>\n<li>在playgroundbook编辑页面，点击”。。。”弹出下拉列表页，提供fenxiang四种方式<ul>\n<li>拍照</li>\n<li>创建PDF</li>\n<li>录制影片</li>\n<li>实时直播（需要第三方直播软件，暂时没测试）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"激活iPad拥有自己的工作空间\"><a href=\"#激活iPad拥有自己的工作空间\" class=\"headerlink\" title=\"激活iPad拥有自己的工作空间\"></a>激活iPad拥有自己的工作空间</h3><ol>\n<li>激活iPad，安装自己喜欢的几款APP</li>\n<li>测试电耗，连续使用8个小时，89%到30%，耗损50%，按工作场景应该能续航16小时左右</li>\n<li>尝试键盘连接，使用外设键盘编辑文本还是比较舒服的，便捷，坐等移动键盘到手</li>\n<li>摸索iPad使用场景 <ol>\n<li>第一屏为咨询APP主页，在这里将发现更多新的东西，和未知的兴趣点，并同步至Pocker中，即搜集箱，充满期待</li>\n<li>第二屏为下一步行动列表页，将第一屏搜集到的原材料，参考四象限法则，整理筛选排优先级，加工成可执行的下一步行动，过滤不能行动的事件</li>\n<li>第三屏将行动导图梳理规范化，提高趣味性，增强行动动力，自我鼓励督促完成任务，培养自觉性和对承诺的责任心，逐步养成生活习惯\n　</li>\n</ol>\n</li>\n</ol>\n","raw":null,"categories":[],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"}]},{"title":"麦步M1s加强版体验第一天","slug":"麦步第一天体验","date":"2017-06-02T14:39:46.000Z","updated":"2017-06-22T11:25:09.000Z","comments":true,"path":"api/articles/麦步第一天体验.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/calendar2.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"开源\"><a href=\"#开源\" class=\"headerlink\" title=\"开源\"></a>开源</h3><p><a href=\"http://dev.maibu.cc/sdk/watch\" target=\"_blank\" rel=\"noopener\">开发文档</a><br><a href=\"https://github.com/maibu/Maibu\" target=\"_blank\" rel=\"noopener\">gitHub源码库</a>   </p>\n<h3 id=\"效率\"><a href=\"#效率\" class=\"headerlink\" title=\"效率\"></a>效率</h3><h4 id=\"可用功能\"><a href=\"#可用功能\" class=\"headerlink\" title=\"可用功能\"></a>可用功能</h4><p>滴答清单，同步神速，可以使用麦步来标记完成任务</p>\n<p>表盘：纯黑背景比较适合，内置白底表盘无法卸载<br>工具：计步准确，睡眠监测还行，久坐提醒不错 </p>\n<h4 id=\"思考功能\"><a href=\"#思考功能\" class=\"headerlink\" title=\"思考功能\"></a>思考功能</h4><p>怎样充分使用麦步，融入到现有的时间管理习惯中</p>\n<ol>\n<li>开发一款麦步trello清单APP<br>需求：麦步app获取到当天的trello清单，支持查看和完成操作<br>预研：麦步无须APP账号绑定等，仅凭蓝牙是如何获取到滴答清单的？<br>原理：<br>结果：开发一款trello清单是否可行<br>1.2 文档分析：<br>在第二步：编译及打包环境<ol>\n<li>gcc-arm-none-eabi-4_7-2014q2-20140408-win32.exe 编译环境</li>\n<li>IDE工具Visual MWatch.exe执行编译操作。<br>可见暂时仅支持win系统开发。</li>\n</ol>\n</li>\n</ol>\n<ol>\n<li>借助IFTTT工具是否能将trello清单同步至麦步中<br>2.1 中间APP 选择系统提醒APP/(日历APP支持时间设置)<br>原理： 通过IFTTT工具将trello清单同步到提醒APP中，然后滴答清单读取提醒清单同步到麦步上。<br>缺点：trello开始与截止日期等属性无法同步至提醒app，由于麦步仅同步滴答清单的当天任务列表，中间必须认为设置起始时间等。</li>\n</ol>\n<p>日历属于一块圣地，不要轻易设置日程安排。他应该是第三象限不急重要的事情。当指定时间地点时，优先级立即为最高</p>\n<ol>\n<li>trello创建人物是否能讲日期同步到系统提醒APP中，不可行的话，就需要单独对任务指定开始和截止时间。</li>\n</ol>\n<h3 id=\"提醒\"><a href=\"#提醒\" class=\"headerlink\" title=\"提醒\"></a>提醒</h3><p>麦步获取信息的通道：蓝牙<br>平台区别：<br>Apple手机全局提醒，安卓可以过滤app</p>\n<p>针对性个例：滴答清单<br>麦步是如何针对性滴答清单，获取APP内部信息的。</p>\n<p>其中的原理，涉及到，如果开发一款trello清单是否可行。</p>\n<h3 id=\"耗电：\"><a href=\"#耗电：\" class=\"headerlink\" title=\"耗电：\"></a>耗电：</h3><p>使用计步表盘，及时更新数据，相较普通时钟表盘，电耗是否一致，差距在哪？</p>\n<h3 id=\"trello日历订阅源\"><a href=\"#trello日历订阅源\" class=\"headerlink\" title=\"trello日历订阅源\"></a>trello日历订阅源</h3><p>滴答清单订阅日历功能：设置—安全与数据—订阅日历 (普通用户仅支持订阅系统日历)</p>\n<h4 id=\"获取从trello看板中生成订阅源\"><a href=\"#获取从trello看板中生成订阅源\" class=\"headerlink\" title=\"获取从trello看板中生成订阅源\"></a>获取从trello看板中生成订阅源</h4><p>普通用户的看板限制的Power-Ups的一个数<br>两步设置：</p>\n<ol>\n<li>第一步：启动日历<br>看板的菜单项—Power-Ups—Calendar–点击启动—出现设置图标按钮，如图：<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/calendar2.png?imageMogr2/2/w/800\">     </li>\n<li>第二步：开启日历订阅功能（默认关闭）<br>点击设置按钮，并启动订阅功能，自动生成订阅路径    <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/calendar4.png?imageMogr2/2/w/800\">   \n</li>\n</ol>\n<h4 id=\"添加日历订阅源\"><a href=\"#添加日历订阅源\" class=\"headerlink\" title=\"添加日历订阅源\"></a>添加日历订阅源</h4><p>iPhone日历订阅需要通过通过Mac实现 <a href=\"https://support.apple.com/zh-cn/HT202361\" target=\"_blank\" rel=\"noopener\">使用 iCloud 日历订阅</a><br>滴答清单订阅日历功能：设置—安全与数据—订阅日历 (普通用户仅支持订阅系统日历)</p>\n<p>可以通过监听事件来同步trello看板中的所有信息</p>\n","raw":null,"categories":[{"name":"设备","path":"api/categories/设备.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"}]},{"title":"搞定书籍目录","slug":"阅读/搞定书籍目录","date":"2017-05-28T12:04:28.000Z","updated":"2017-09-09T18:56:18.000Z","comments":true,"path":"api/articles/阅读/搞定书籍目录.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"《搞定I》\"><a href=\"#《搞定I》\" class=\"headerlink\" title=\"《搞定I》\"></a>《搞定I》</h2><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><h3 id=\"第一部分-通向从容之道？\"><a href=\"#第一部分-通向从容之道？\" class=\"headerlink\" title=\"第一部分 通向从容之道？\"></a>第一部分 通向从容之道？</h3><pre><code>第1章 新情况，新做法？  \n    收集存档清空大脑，万物皆于此，\n    2分钟法则整理可立刻执行的有效清单，不做材料清单\n第2章 掌控生活：横向管理工作流程的5个阶段\n\n第3章 控制项目：纵向管理项目计划的5个阶段\n</code></pre><h3 id=\"第二部分-远离压力，提高效率\"><a href=\"#第二部分-远离压力，提高效率\" class=\"headerlink\" title=\"第二部分 远离压力，提高效率\"></a>第二部分 远离压力，提高效率</h3><pre><code>第4章 准备工作：确定时间、空间和工具\n第5章 收集阶段：归拢材料\n第6章 处理阶段：清空工作篮\n第7章 组织整理：建立好清单\n第8章 检查回顾：保障系统的有效运行\n第9章 执行阶段：选择最合适的行动\n第10章 学会控制项目\n</code></pre><h3 id=\"第三部分-三个关键原则\"><a href=\"#第三部分-三个关键原则\" class=\"headerlink\" title=\"第三部分 三个关键原则\"></a>第三部分 三个关键原则</h3><pre><code>第11章 原则一：养成收集的习惯\n第12章 原则二：确定“下一步行动”\n第13章 原则三：学会关注结果\n</code></pre><h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3>","raw":null,"categories":[{"name":"阅读","path":"api/categories/阅读.json"}],"tags":[{"name":"管理","path":"api/tags/管理.json"}]},{"title":"痛定思痛的项目管理弊病","slug":"个人项目/痛定思痛的项目管理弊病","date":"2017-05-27T15:06:17.000Z","updated":"2017-06-06T23:05:17.000Z","comments":true,"path":"api/articles/个人项目/痛定思痛的项目管理弊病.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><hr>\n<p>现状：两个项目源码存在八成为同样的代码，管理在两个SVN库中。<br>背景：从一个SVN项目分裂成两个独立项目（PBB_2/Reader_v2）对应延伸出来SVN库，随后在两个库中开发不同的功能版本（PBB_7/Reader_v9）。<br>需求：现在准备将两项目中新增的功能重新合并起来，即将PBB_v7合并到Reader_v9中。<br>分析：需要把PBB_v3–PBB_v7的5个提交，合并到Reader_v9中</p>\n<p>对PBB迭代的十几个版本中新增的功能涉及面太广，手动合并出错率高，协作难度大，纯劳力搬砖着实要命。<br>以下总结几条建议</p>\n<h3 id=\"方案一：打补丁法合并源码\"><a href=\"#方案一：打补丁法合并源码\" class=\"headerlink\" title=\"方案一：打补丁法合并源码\"></a>方案一：打补丁法合并源码</h3><hr>\n<p>注：仅适用于同一个库使用</p>\n<p>实现步骤：</p>\n<ol>\n<li>git-svn命令把svn库转为git库</li>\n<li>将5个提交重演到Reader_v9版中</li>\n</ol>\n<p>重演方案：</p>\n<ol>\n<li>打补丁法：通过压缩提交法把PBB_v7若干提交整合成一个提交，再创建一个补丁，重演到Reader_v9上<ol>\n<li>交互变基压缩法，压缩成一个提交</li>\n<li>reset压缩提交法，将提交压缩 git reset –soft 1bf27c6a33d87c2e36fa75431224124f91d8b482</li>\n</ol>\n</li>\n</ol>\n<p>案例：在大型项目中，贡献者常以使用补丁文件贡献代码<br>结论：打补丁法的前提打补丁的宿主库必须和将要应用补丁的库为同一库源。故使用版本库来合并两个独立不想关的svn库，无法通过打补丁法实现合并。</p>\n<h3 id=\"方案二：项目模块化合并\"><a href=\"#方案二：项目模块化合并\" class=\"headerlink\" title=\"方案二：项目模块化合并\"></a>方案二：项目模块化合并</h3><hr>\n<p>在PBB Reader中通过项目依赖整合IJK／mupdf／maker</p>\n<ol>\n<li>操作<ol>\n<li>取消Maker原有IJK，mupdf的依赖</li>\n<li>在PBB Reader中配置Maker依赖 ：隐私空间涉及到的阅读功能在Reader中实现</li>\n<li>新需求开发</li>\n</ol>\n</li>\n<li>好处 <ol>\n<li>源码隔离，功能共享，对现有功能的源码无要做任何修改</li>\n<li>项目之间相互独立，便于后续拆分或整合</li>\n<li>更多精力专注代码优化</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"否决方案二，采用手动合并\"><a href=\"#否决方案二，采用手动合并\" class=\"headerlink\" title=\"否决方案二，采用手动合并\"></a>否决方案二，采用手动合并</h4><p>Reader本属于一个播放器，是从PBB应用的lite版，主要业务都是在PBB中实现的，当前需求是让PBB集成到Reader中，如何使用PBB Framework集成，需要暴漏大量的接口，业务层的高耦合性已经违背了封装原则。故作罢。</p>\n<p>突破了合并时遇到的棘手问题，加密崩溃，最终排查出socker传输结构体导致的异常，maker和Reader之间的差异导致合并过程更加困难，最终采用对讲maker中对加密实现文件的封装，在集成到Reader中，即隔离冲突，暴露功能，程序架构集成过程中更便捷合理化。</p>\n<hr>\n<p>相关知识：</p>\n<p>引用日志：<br>git reflog<br>引用日志只存在本地仓库中，只记录第一次clone到之后，在本地仓库中的操作日志，服务器端不会同步这些引用记录，所以在本地无法查看别人的引用日志。</p>\n<h3 id=\"祖先引用\"><a href=\"#祖先引用\" class=\"headerlink\" title=\"祖先引用\"></a>祖先引用</h3><p>几种表达式含义</p>\n<ul>\n<li><p>第一种：^/^^^(多个)<br>HEAD^:指向祖先提交<br>hash值^（^^^） :指向该引用的上一个提交，几个符号就是指向上几个提交<br>^数字:只适用于合并（merge）提交，有多个父提交。如：hash值^2表示第二父提交。第一父提交是指合并时所在的分支，第二父提交是指合并进来的分支。</p>\n</li>\n<li><p>第二种：~数字<br>HEAD~: 指向祖先提交<br>HEAD~数字:指向指向上几个提交<br>hash值^数字:指向该引用的上几个提交</p>\n</li>\n</ul>\n","raw":null,"categories":[{"name":"项目","path":"api/categories/项目.json"},{"name":"重构","path":"api/categories/重构.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"命令","path":"api/tags/命令.json"}]},{"title":"升职必备的技能修炼二 以道御术","slug":"阅读/修炼升职必备的技能二","date":"2017-05-25T18:09:00.000Z","updated":"2017-05-25T18:15:01.000Z","comments":true,"path":"api/articles/阅读/修炼升职必备的技能二.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>“老付”谈论的是目标，所有的方法都是为目标服务的，目标统率人的行为。    </p>\n<ul>\n<li>怎样规划自己的人生？</li>\n<li>怎样树立自己的目标？</li>\n<li>怎样把目标转化成实际的行动？</li>\n<li>怎样提高自己实现目标的能力？</li>\n</ul>\n","raw":null,"categories":[{"name":"阅读","path":"api/categories/阅读.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"}]},{"title":"升职必备的技能修炼","slug":"阅读/修炼升职必备的技能","date":"2017-05-25T16:40:42.000Z","updated":"2017-05-26T11:03:05.000Z","comments":true,"path":"api/articles/阅读/修炼升职必备的技能.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/衣柜整理法.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>焦虑是由于缺乏控制力，以及组织管理、准备和行动不足所造成的。</p>\n<h2 id=\"四象限\"><a href=\"#四象限\" class=\"headerlink\" title=\"四象限\"></a>四象限</h2><p>走出第三象限，将工作重心放进第二象限</p>\n<ol>\n<li>第二象限法则   </li>\n<li>猴子法则：屏蔽干扰的伎俩   </li>\n</ol>\n<h3 id=\"项目与行动的区别\"><a href=\"#项目与行动的区别\" class=\"headerlink\" title=\"项目与行动的区别\"></a>项目与行动的区别</h3><p>项目需要分解为可执行的行动  </p>\n<ol>\n<li>以动词开头的行动  </li>\n<li>添加行动的预期效果  </li>\n</ol>\n<p>下一步行动法，驱动项目的进行。</p>\n<h2 id=\"时间投资\"><a href=\"#时间投资\" class=\"headerlink\" title=\"时间投资\"></a>时间投资</h2><h2 id=\"衣柜整理法\"><a href=\"#衣柜整理法\" class=\"headerlink\" title=\"衣柜整理法\"></a>衣柜整理法</h2><img title=\"衣柜整理法\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/衣柜整理法.png?imageMogr2/2/w/800\">\n<p>收集，处理，组织，回顾，行动<br>2分钟法则<br>无论在什么情况下，我们在工作时都将经历这五个阶段：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/衣柜整理法流程图.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"收集篮：收集一切引起我们注意的事情。\"><a href=\"#收集篮：收集一切引起我们注意的事情。\" class=\"headerlink\" title=\"收集篮：收集一切引起我们注意的事情。\"></a>收集篮：收集一切引起我们注意的事情。</h3><pre><code>收集的关键是将‘一切引起我们注意的东西’放在‘收集篮’里，在清空大脑的同时达到‘心如止水’的境界。\n</code></pre><p>工具军规</p>\n<ol>\n<li>收集工具越少越好</li>\n<li>保证5秒钟内拿出工具</li>\n<li>定期清空工具： 今日事今日毕 ，定期清空，比如每周五清空所有事件迎接周末</li>\n</ol>\n<h3 id=\"处理收集篮：加工处理后，确定它们的实质以及解决方法。\"><a href=\"#处理收集篮：加工处理后，确定它们的实质以及解决方法。\" class=\"headerlink\" title=\"处理收集篮：加工处理后，确定它们的实质以及解决方法。\"></a>处理收集篮：加工处理后，确定它们的实质以及解决方法。</h3><p>2分钟突击原则：指定任务可行性标签<br>不可行：  1. 垃圾事件 2. 将来某时／也许事件  3. 参考资料（处理方法就是分类归档）<br>可执行： 1. 2分钟事件（专治拖延症） 2. 项目事件 3. 委托事件  4. 预约事件  5.待办事件</p>\n<p>原则：  </p>\n<ol>\n<li>从最上面一项开始处理   </li>\n<li>一次只处理一件事情   </li>\n<li>永远不要再放回收集篮（被迫中断的事情除外），争取一次做好   </li>\n</ol>\n<h3 id=\"组织：组织整理，得出结论\"><a href=\"#组织：组织整理，得出结论\" class=\"headerlink\" title=\"组织：组织整理，得出结论\"></a>组织：组织整理，得出结论</h3><p>‘3+1’组合的清单系统<br>材料，<br>收集篮清单（做到每日清理）<br>将某时／也许清单<br>待办事清单<br>项目清单（多任务集合，多个下一步行动）一般会放在待办清单中<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/3+1.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"回顾：\"><a href=\"#回顾：\" class=\"headerlink\" title=\"回顾：\"></a>回顾：</h3><p>解决盲目的问题，我们还需要做到对任务进行回顾。</p>\n<ol>\n<li>让灵感应运而生<br>周回顾的时候恰恰是这样一种状态，对所有的一切都了如指掌，对所有的一切都做了充足的准备。  </li>\n<li>站在3万米的高度去看待问题<br>通过对自己一周工作的重新审视，向自己发问：到底哪些事有利于我更好地接近目标？今后遇到类似的事情应该如何取舍？当我们站在一个新的高度去看待现在的人和事，你会有前所未有的发现。</li>\n<li><p>孵化和修剪你的任务及目标</p>\n</li>\n<li><p>把它们列为我们行动的选择方案。</p>\n</li>\n</ol>\n<h2 id=\"行动：选择最佳方案\"><a href=\"#行动：选择最佳方案\" class=\"headerlink\" title=\"行动：选择最佳方案\"></a>行动：选择最佳方案</h2><p>利用一个月的时间去思考自己的未来发展，然后制定一个‘自上而下’的职业规划；当这个规划确定之后，我会‘自下而上’地搞定自己的工作，并且在工作的过程中随时修订自己的规划，这就是我的工作方式。</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/人生规划的六个高度.png?imageMogr2/2/w/800\">\n<h3 id=\"‘自上而下’的目标系统\"><a href=\"#‘自上而下’的目标系统\" class=\"headerlink\" title=\"‘自上而下’的目标系统\"></a>‘自上而下’的目标系统</h3><p>大卫·艾伦的六个高度去进行检视和规划：  </p>\n<ol>\n<li>原则 （五万米）<br>你首先必须要找个时间好好地思考一下自己的价值观、原则和目标，这是你工作的灵魂所在。如果你以前没有思考过这些，建议你现在就开始思考。我可以和你分享一下我的原则：工作是谋求更好生活的途径，追求无压、流畅、高效的工作。</li>\n<li>愿景（四万米）<br>这里面包含3—5年的工作目标，可以是职位的，也可以是组织能力、协调能力等。在这个层面你需要问自己<br> ◎我的目标是什么？<br> ◎哪些人已经达到了我的这个目标？<br> ◎他们是如何达到目标的？<br> ◎达到这个目标之后我的工作和生活会是怎样的？</li>\n<li><p>目标（三万米）<br>目标是比愿景更细化的东西，通常在一年内就可以有一个阶段性的成果。比如说我现在的目标就是：</p>\n<p> ◎每周通过参加商务聚会来扩展自己的人脉，主动给朋友们打电话来巩固自己的人脉；<br> ◎参加管理学的培训课程或者是参加MBA学习来提高自己的综合能力；<br> ◎每天坚持阅读40分钟，以扩充自己的知识面，并且更深层次地研究自己所在的专属领域。</p>\n</li>\n<li>责任范围（两万米）<br>工作上的角色：如销售、管理、产品开发等；<br>生活中的角色：如家庭、个人财务、精神层面等。<br>要把每一个角色扮演好，就需要执行一些任务，以拉近现实和期望的距离。比如在这个层面我会拿出我负责的项目和产品，看看在开发、销售、管理上是否还有提升的可能性，因为毕竟要把自己责任范围内的事情做得漂亮，才有可能升职或者有其他进一步的发展。</li>\n<li>任务（一万米）<br>所有需要一步以上完成的事情都是一个任务，虽然我们已经有了一个‘自上而下’的目标系统，但是我们仍然要将注意力放在眼前的任务上，比如‘新产品的营销策略’等。</li>\n<li>下一步行动（跑道）<br>这是最细枝末节的事件，我们要将它们全部放进我们的清单，然后逐一完成。谁更关注细节，谁就能获得更大的成功。刚开始我们都在同一个跑道里面绕圈，但是最终只有职业规划清晰的人才会驾车进入快车道，直奔目标而去。”</li>\n</ol>\n","raw":null,"categories":[{"name":"管理","path":"api/categories/管理.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"经历","path":"api/tags/经历.json"}]},{"title":"calibre一站式电子书解决方案","slug":"工具/calibre一站式电子书解决方案","date":"2017-05-25T14:26:15.000Z","updated":"2017-06-28T15:57:36.000Z","comments":true,"path":"api/articles/工具/calibre一站式电子书解决方案.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/calibre.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>Calibre，是一个免费的开源的“一站式”的电子书解决方案，它可以全面满足你的电子书需求。Calibre 是免费的，源代码开放，拥有跨平台的设计。它是一个完整的电子图书馆，包括图书管理，格式转换，新闻，将材料转换为电子书，以及电子书阅读器同步功能、整合进电子图书阅读器。当然它也内置了一个 ePub 格式电子书编辑工具以满足修改电子书的需要。   </p>\n<p>感兴趣的几个功能点：</p>\n<ol>\n<li><p>爬虫功能，即可以支持一键抓取新闻，根据指定的feed订阅源，来制作书籍。<br> 这样便可每天爬取最新消息，发到kindle上看新闻</p>\n</li>\n<li><p>支持kindle书籍，相比kindle应用，它能自由复制书本内容，便于笔记整理。</p>\n</li>\n</ol>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/calibre.png?imageMogr2/2/w/800\">\n","raw":null,"categories":[{"name":"工具","path":"api/categories/工具.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"}]},{"title":"iOS和OSX集成gitAPI","slug":"开源库/iOS和OSX集成gitAPI","date":"2017-05-17T17:33:46.000Z","updated":"2017-09-24T09:18:26.000Z","comments":true,"path":"api/articles/开源库/iOS和OSX集成gitAPI.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/ObjectiveGitxiaoguo.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>在项目中使用git submodule工具集成子项目ObjectiveGit</p>\n<h4 id=\"在新项目中使用git-submodule集成gitAPI\"><a href=\"#在新项目中使用git-submodule集成gitAPI\" class=\"headerlink\" title=\"在新项目中使用git submodule集成gitAPI\"></a>在新项目中使用git submodule集成gitAPI</h4><p>参考官方提供的两个demo</p>\n<ul>\n<li><p>OS X: <a href=\"https://github.com/Abizern/CommitViewer\" target=\"_blank\" rel=\"noopener\">CommitViewer</a>   </p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/ObjectiveGitxiaoguo.png?imageMogr2/2/w/800\">\n</li>\n<li><p>iOS: <a href=\"https://github.com/Raekye/ObjectiveGit-iOS-Example\" target=\"_blank\" rel=\"noopener\">ObjectiveGit iOS Example</a></p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule add https://github.com/libgit2/objective-git.git External/ObjectiveGit</span><br><span class=\"line\">如果之前配置过，直接更新：</span><br><span class=\"line\">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>cd External/ObjectiveGit</code>，然后执行<code>./script/bootstrap</code>安装相关依赖.</li>\n<li>拖动 <code>ObjectiveGitFramework.xcodeproj</code> 文件 到iOS/OSX项目导航窗口 .</li>\n<li>在build Phases中配置APP的依赖，根据平台添加<code>ObjectiveGit-Mac</code> or <code>ObjectiveGit-iOS</code>.</li>\n<li>APP通过连接器链接 <code>ObjectiveGit.framework</code>.</li>\n<li>在build setting中“Header Search Paths” (<code>HEADER_SEARCH_PATHS</code>)设置<code>libgit2</code>头文件在项目的路径，例如：<code>External/ObjectiveGit/External/libgit2/include</code>. </li>\n<li>Add a new “Copy Files” build phase, set the destination to “Frameworks” and add <code>ObjectiveGit.framework</code> to the list. This will package the framework with your application as an embedded private framework.</li>\n</ol>\n<ul>\n<li>It’s hard to tell the difference between the platforms, but the Mac framework is in <code>build/Debug</code> whereas the iOS framework is in <code>build/Debug-iphoneos</code></li>\n</ul>\n<ol>\n<li>Don’t forget to <code>#import &lt;ObjectiveGit/ObjectiveGit.h&gt;</code> or <code>@import ObjectiveGit;</code> as you would with any other framework.</li>\n</ol>\n<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ul>\n<li>类变量关联.xib控件text值    </li>\n<li>字体样式菜单来改变字体样式    <h4 id=\"在OSX中设置控件的Bindings代替IBOutlet\"><a href=\"#在OSX中设置控件的Bindings代替IBOutlet\" class=\"headerlink\" title=\"在OSX中设置控件的Bindings代替IBOutlet\"></a>在OSX中设置控件的Bindings代替IBOutlet</h4></li>\n</ul>\n<p>先关联再使用属性依赖特性来同步数据</p>\n<h5 id=\"类变量关联-xib控件text值\"><a href=\"#类变量关联-xib控件text值\" class=\"headerlink\" title=\"类变量关联.xib控件text值\"></a>类变量关联.xib控件text值</h5><p><a href=\"http://stackoverflow.com/questions/8161012/referencing-bindings-in-connections-inspector\" target=\"_blank\" rel=\"noopener\">相关参考</a>      </p>\n<ol>\n<li>选中NSTextField的bindings检查器面板   </li>\n<li>在<code>value</code>单元内设置bind to 的值，通过下拉框选中 <code>Delegate</code>      </li>\n<li>Model key Path:输入类变量的名称。    <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/NSTextFieldBindings.png?imageMogr2/2/w/800\">   </li>\n<li>切换到 NSTextField／Delegate的Connections检查器面板,就会看到已经建立了关联：     <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/textFieldConections.png?imageMogr2/2/w/800\">   <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/delegatebinding.png?imageMogr2/2/w/800\">   \n</li>\n</ol>\n<h5 id=\"依赖属性\"><a href=\"#依赖属性\" class=\"headerlink\" title=\"依赖属性\"></a>依赖属性</h5><p>Foundation 框架提供的表示属性依赖的机制如下：<br>参考<a href=\"https://github.com/huos3203/BookObjc/blob/master/publish/issue7/issue-7-3-DJBen.md#依赖的属性\" target=\"_blank\" rel=\"noopener\">属性的依赖</a><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class=\"built_in\">NSString</span> *)key</span><br><span class=\"line\"></span><br><span class=\"line\">或</span><br><span class=\"line\">+ (<span class=\"built_in\">NSSet</span> *)keyPathsForValuesAffecting&lt;键名&gt;</span><br></pre></td></tr></table></figure></p>\n<p>将属性关联起来，这样就可以将类变量的值同步至UI控件中了：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class=\"built_in\">NSString</span> *)key </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSSet</span> *keySet = [<span class=\"built_in\">NSSet</span> setWithObjects:<span class=\"string\">@\"commit\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([key isEqualToString:<span class=\"string\">@\"messageTitle\"</span>] ||</span><br><span class=\"line\">        [key isEqualToString:<span class=\"string\">@\"messageDetails\"</span>] ||</span><br><span class=\"line\">        [key isEqualToString:<span class=\"string\">@\"author\"</span>] ||</span><br><span class=\"line\">        [key isEqualToString:<span class=\"string\">@\"date\"</span>])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> keySet;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"实现字体样式菜单来改变字体样式\"><a href=\"#实现字体样式菜单来改变字体样式\" class=\"headerlink\" title=\"实现字体样式菜单来改变字体样式\"></a>实现字体样式菜单来改变字体样式</h4><ol>\n<li>在xib中拖一个Object并设置为NSFontManager.h类的实现。   </li>\n<li>选中NSFontManager.h的connections面板，将Received Actions关联到对应的菜单项即可  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/fontManage.png?imageMogr2/2/w/800\">\n</li>\n</ol>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"API","path":"api/categories/API.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"}]},{"title":"使用sourceTree与git-subtree工具","slug":"git/使用sourceTree与git-subtree工具","date":"2017-05-17T11:23:22.000Z","updated":"2017-05-17T17:52:28.000Z","comments":true,"path":"api/articles/git/使用sourceTree与git-subtree工具.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/gittree.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"git-subtree-合并\"><a href=\"#git-subtree-合并\" class=\"headerlink\" title=\"git subtree 合并\"></a>git subtree 合并</h3><p>git subtree：合并策略，通过git subtree命令能将依赖库某分支合并到主项目的分支中，在开发过程中，只需对主项目分支进行统一管理。</p>\n<h4 id=\"创建合并subtree-add命令\"><a href=\"#创建合并subtree-add命令\" class=\"headerlink\" title=\"创建合并subtree add命令\"></a>创建合并subtree add命令</h4><p>命令如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;git subtree&apos; add -P &lt;prefix&gt; &lt;commit&gt;</span><br><span class=\"line\">&apos;git subtree&apos; add -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"两步走\"><a href=\"#两步走\" class=\"headerlink\" title=\"两步走\"></a>两步走</h5><p>先fetch库再subtree add合并</p>\n<ol>\n<li><p>先将依赖库fetch到本地仓库中</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建lib的远程版本库: </span><br><span class=\"line\">git init --bare lib-rep</span><br><span class=\"line\"><span class=\"comment\">#-f：远端库添加后立即执行fetch操作</span></span><br><span class=\"line\">git remote add -f librepo ../lib-rep</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过git subtree命令将依赖库合并到主项目中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git subtree add -P lib librepo master</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"squash合并法\"><a href=\"#squash合并法\" class=\"headerlink\" title=\"squash合并法\"></a>squash合并法</h5><p><code>--squash</code>: 适用于add/pull/merge子命令。先合并引用库的更新记录，将合并结果并到主项目中。<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git subtree add --prefix=themes/jacman --squash https://huos3203@github.com/huos3203/jacman.git master</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"subtree其他命令\"><a href=\"#subtree其他命令\" class=\"headerlink\" title=\"subtree其他命令\"></a>subtree其他命令</h4><p>git subtree支持创建(add)之外,还支持更新(pull),推送(push),合并(merge),抽离(split)以下命令:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'git subtree'</span> pull -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br><span class=\"line\"><span class=\"string\">'git subtree'</span> push -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br><span class=\"line\"><span class=\"string\">'git subtree'</span> merge -P &lt;prefix&gt; &lt;commit&gt;</span><br><span class=\"line\"><span class=\"string\">'git subtree'</span> split -P &lt;prefix&gt; [OPTIONS] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure></p>\n<p>从子树库中拉取最新代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git subtree pull --prefix=themes/jacman --squash https://huos3203@github.com/huos3203/jacman.git master</span><br></pre></td></tr></table></figure></p>\n<p>将自己的代码发布到子树库:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git subtree push --prefix=themes/jacman --squash https://huos3203@github.com/huos3203/jacman.git master</span><br></pre></td></tr></table></figure></p>\n<p>相关参数：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-q | --quiet</span><br><span class=\"line\">-d | --debug</span><br><span class=\"line\">-P &lt;prefix&gt; | --prefix=&lt;prefix&gt;      引用库对应的本地目录</span><br><span class=\"line\">-m &lt;message&gt; | --message=&lt;message&gt;   适用于add/pull/merge子命令。设置产生的合并提交的说明文本</span><br><span class=\"line\">--squash                             适用于add/pull/merge子命令。先合并引用库的更新记录，将合并结果并到主项目中。</span><br><span class=\"line\">使用此选项时，subtree add/pull会产生两个提交版本：一个是子项目的历史记录，一个是Merge操作。好处是可以让主项目历史记录很规整，缺点是子项目更新时常常需要解决冲突。一个更好的解决方案是：单独建一个分支进行--no-squash的subtree更新，然后再--squash合并到主分支。每次在此分支做操作前都需要先把主分支合并进来。参考：http://www.fwolf.com/blog/post/246</span><br></pre></td></tr></table></figure></p>\n<p>split子命令选项：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--annotate=&lt;annotation&gt;              创建合成历史时有可能形成内容不同但提交信息完全相同的提交版本，使用这个选项在每个提交消息前加上此前缀用来区分。</span><br><span class=\"line\">-b &lt;branch&gt; | --branch=&lt;branch&gt;      创建合成的提交历史时，创建此参数指定的新分支包含生成的合成历史。&lt;branch&gt;必须是还不存在的。</span><br><span class=\"line\">--onto=&lt;onto&gt;</span><br><span class=\"line\">--rejoin</span><br><span class=\"line\">--ignore-joins</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用sourcetree管理\"><a href=\"#使用sourcetree管理\" class=\"headerlink\" title=\"使用sourcetree管理\"></a>使用sourcetree管理</h4><ol>\n<li>配置 subtree<br>菜单：Repository -&gt; Add/Link subtree…(添加／链接子树…)<br>在左边栏的SUBTREES(子树)中显示：<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/gittree.png?imageMogr2/2/w/800\"></li>\n<li>拉取依赖库的最新代码<br>在右边栏右击已存在的subtree，并选择 pull subtree…菜单项：<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/gitsubtreepull.png?imageMogr2/2/w/800\">\n第二步的功能代码如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git -c subtree pull -P themes/.jacman --squash https://huos3203@github.com/huos3203/jacman.git master</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"submodule嵌套\"><a href=\"#submodule嵌套\" class=\"headerlink\" title=\"submodule嵌套\"></a>submodule嵌套</h3><p>git submodule：嵌套策略，将依赖库直接clone到主项目目录中，通过配置.submodule文件来隔离管理主项目／子依赖库的版本。<br>添加子模块：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule add https://github.com/libgit2/objective-git.git External/ObjectiveGit</span><br></pre></td></tr></table></figure></p>\n<p>更新子模块：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>submodule那样每次子项目修改了后要init和update.万一哪次没update就直接”commit -a” 或者 “add .” 全commit上去就悲剧了。</p>\n</blockquote>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"IDE","path":"api/categories/IDE.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"}]},{"title":"使用Cocoapods创建私有podspec","slug":"工具/使用Cocoapods创建私有podspec","date":"2017-02-28T15:46:16.000Z","updated":"2018-06-21T21:43:37.000Z","comments":true,"path":"api/articles/工具/使用Cocoapods创建私有podspec.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/repo目录.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"创建一个版本库来托管pod索引-pod-repo-add命令\"><a href=\"#创建一个版本库来托管pod索引-pod-repo-add命令\" class=\"headerlink\" title=\"创建一个版本库来托管pod索引:pod repo add命令\"></a>创建一个版本库来托管pod索引:pod repo add命令</h2><p>第一步：在github登录个人账号，创建一个库作为pod索引托管库。也可根据具体情况可以选择：<code>github</code>、<code>CODING</code>、<code>开源中国</code>、<code>Bitbucket</code>以及<code>CSDN</code>等，代码托管平台。<br>当索引库托管在github私有的仓库时，如果有其他同事共同开发维护，则需要配置Git仓库的权限。<br>第二步：pod化版本库，使其专门用户管理个人的<code>*podspec</code>索引文件<br><figure class=\"highlight ruby\"><figcaption><span>repo add命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># pod repo add [Private Repo Name] [GitHub HTTPS clone URL]</span></span><br><span class=\"line\">$ pod repo add PodRepo <span class=\"symbol\">https:</span>/<span class=\"regexp\">/github.com/huos</span>3203/PodRepo.git</span><br><span class=\"line\"><span class=\"comment\">#输出：</span></span><br><span class=\"line\">&gt; Cloning spec repo <span class=\"string\">`PodRepo`</span> from <span class=\"string\">`https://github.com/huos3203/PodRepo.git`</span></span><br></pre></td></tr></table></figure><br>此时在本地会生成<code>~/.cocoapods/repos/PodRepo</code>目录，这个目录就可以用来存储你所有的开源包。<br>每当一个或多个<code>*.podspec</code>文件测试无误时，就可以使用<code>pod repo push</code>命令向私有索引库中提交该文件。<br><figure class=\"highlight ruby\"><figcaption><span>lib create命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod repo push PodRepo LogSwift.podspec  <span class=\"comment\">#PodRepo是本地Repo名字 后面是podspec名字</span></span><br></pre></td></tr></table></figure><br>完成之后这个组件库就添加到私有索引库中，自动生成的<code>pod 库</code>标准结构：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/repo目录.png?imageMogr2/2/w/800\"><br>同时<code>push命令</code>会将新增的索引目录推送至自己的远程仓库中，即索引托管库<code>PodRepo.git</code>中。</p>\n<p>下面详述<code>podspec文件</code>的配置，检测，使用的过程。</p>\n<h2 id=\"使用模板命令创建Pod工程项目-lib-create\"><a href=\"#使用模板命令创建Pod工程项目-lib-create\" class=\"headerlink\" title=\"使用模板命令创建Pod工程项目 lib create\"></a>使用模板命令创建Pod工程项目 lib create</h2><p>初始化Pod模板项目：<br><figure class=\"highlight ruby\"><figcaption><span>lib create命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod lib create LogSwift</span><br></pre></td></tr></table></figure><br>有以下五步命令行交互：<br><figure class=\"highlight ruby\"><figcaption><span>交互</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">What is your email?</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">What language <span class=\"keyword\">do</span> you want to use?? [ Swift / ObjC ]</span><br><span class=\"line\">&gt;Swift</span><br><span class=\"line\">Would you like to <span class=\"keyword\">include</span> a demo application with your library? [ Yes / No ]</span><br><span class=\"line\">&gt;Yes</span><br><span class=\"line\">Which testing frameworks will you use? [ Quick / None ]</span><br><span class=\"line\">&gt;Quick</span><br><span class=\"line\">Would you like to <span class=\"keyword\">do</span> view based testing? [ Yes / No ]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure><br>会自动执行<code>pod install</code>命令创建项目并生成依赖。</p>\n<h3 id=\"添加库文件和资源\"><a href=\"#添加库文件和资源\" class=\"headerlink\" title=\"添加库文件和资源\"></a>添加库文件和资源</h3><p>例如：把一个网络模块的共有组件放入<code>Pod/Classes</code>中，然后进入<code>Example</code>文件夹执行<code>pod update</code>命令，再打开项目工程可以看到，刚刚添加的组件已经在<code>Pods</code>子工程下<code>Development Pods/PodTestLibrary</code>中了，然后编辑demo工程，测试组件。<br>测试无误后需要将该项目添加并推送到远端仓库，并编辑podspec文件。</p>\n<h3 id=\"配置podspec文件及验证命令lib-lint\"><a href=\"#配置podspec文件及验证命令lib-lint\" class=\"headerlink\" title=\"配置podspec文件及验证命令lib lint\"></a>配置podspec文件及验证命令lib lint</h3><h4 id=\"打tag号作为podspec版本号\"><a href=\"#打tag号作为podspec版本号\" class=\"headerlink\" title=\"打tag号作为podspec版本号\"></a>打tag号作为podspec版本号</h4><p>因为<code>podspec文件</code>中获取<code>Git版本控制</code>的项目还需要<code>tag号</code>，所以我们要打上一个<code>tag</code><br><figure class=\"highlight ruby\"><figcaption><span>打标签</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -m <span class=\"string\">\"first release\"</span> <span class=\"number\">0</span>.<span class=\"number\">1.0</span></span><br><span class=\"line\">$ git push --tags     <span class=\"comment\">#推送tag到远端仓库</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"编辑podspec文件\"><a href=\"#编辑podspec文件\" class=\"headerlink\" title=\"编辑podspec文件\"></a>编辑podspec文件</h4><p><code>podspec文件</code>是一个Ruby格式：<br><figure class=\"highlight ruby\"><figcaption><span>podspec文件</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pod::Spec.new <span class=\"keyword\">do</span> <span class=\"params\">|s|</span></span><br><span class=\"line\">s.name             = <span class=\"string\">\"PodTestLibrary\"</span>    <span class=\"comment\">#名称</span></span><br><span class=\"line\">s.version          = <span class=\"string\">\"0.1.0\"</span>             <span class=\"comment\">#版本号</span></span><br><span class=\"line\">s.summary          = <span class=\"string\">\"Just Testing.\"</span>     <span class=\"comment\">#简短介绍，下面是详细介绍</span></span><br><span class=\"line\">s.description      = <span class=\"string\">&lt;&lt;-DESC</span></span><br><span class=\"line\"><span class=\"string\">Testing Private Podspec.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* Markdown format.</span></span><br><span class=\"line\"><span class=\"string\">* Don't worry about the indent, we strip it!</span></span><br><span class=\"line\"><span class=\"string\">DESC</span></span><br><span class=\"line\">s.homepage         = <span class=\"string\">\"https://coding.net/u/boyers/p/podTestLibrary\"</span>                           <span class=\"comment\">#主页,这里要填写可以访问到的地址，不然验证不通过</span></span><br><span class=\"line\"><span class=\"comment\"># s.screenshots     = \"www.example.com/screenshots_1\", \"www.example.com/screenshots_2\"           #截图</span></span><br><span class=\"line\">s.license          = <span class=\"string\">'MIT'</span>              <span class=\"comment\">#开源协议</span></span><br><span class=\"line\">s.author           = &#123; <span class=\"string\">\"boyers\"</span> =&gt; <span class=\"string\">\"boyers@foxmail.com\"</span> &#125;  <span class=\"comment\">#作者信息</span></span><br><span class=\"line\">s.source           = &#123; <span class=\"symbol\">:git</span> =&gt; <span class=\"string\">\"https://coding.net/boyers/podTestLibrary.git\"</span>, <span class=\"symbol\">:tag</span> =&gt; <span class=\"string\">\"0.1.0\"</span> &#125;      <span class=\"comment\">#项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS</span></span><br><span class=\"line\"><span class=\"comment\"># s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;'                       #多媒体介绍地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.platform     = <span class=\"symbol\">:ios</span>, <span class=\"string\">'7.0'</span>            <span class=\"comment\">#支持的平台及版本</span></span><br><span class=\"line\">s.requires_arc = <span class=\"literal\">true</span>                   <span class=\"comment\">#是否使用ARC，如果指定具体文件，则具体的问题使用ARC</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.source_files = <span class=\"string\">'Pod/Classes/**/*'</span>     <span class=\"comment\">#代码源文件地址，**/*表示Classes目录及其子目录下所有文件，如果有多个目录下则用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置</span></span><br><span class=\"line\">s.resource_bundles = &#123;</span><br><span class=\"line\"><span class=\"string\">'PodTestLibrary'</span> =&gt; [<span class=\"string\">'Pod/Assets/*.png'</span>]</span><br><span class=\"line\">&#125;                                       <span class=\"comment\">#资源文件地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.public_header_files = <span class=\"string\">'Pod/Classes/**/*.h'</span>   <span class=\"comment\">#公开头文件地址</span></span><br><span class=\"line\">s.frameworks = <span class=\"string\">'UIKit'</span>                  <span class=\"comment\">#所需的framework，多个用逗号隔开</span></span><br><span class=\"line\">s.dependency <span class=\"string\">'AFNetworking'</span>, <span class=\"string\">'~&gt; 2.3'</span>   <span class=\"comment\">#依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependency</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"验证podspec文件可用性\"><a href=\"#验证podspec文件可用性\" class=\"headerlink\" title=\"验证podspec文件可用性\"></a>验证podspec文件可用性</h4><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod lib lint</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">-&gt; PodTestLibrary (<span class=\"number\">0</span>.<span class=\"number\">1.0</span>)</span><br><span class=\"line\">PodTestLibrary passed validation.</span><br></pre></td></tr></table></figure>\n<p>说明验证通过了，不过这只是这个<code>podspec文件</code>是合格的，不一定说明这个Pod是可以用的，Pod需要在本地做一下验证。</p>\n<h3 id=\"将源码托管到远程仓库\"><a href=\"#将源码托管到远程仓库\" class=\"headerlink\" title=\"将源码托管到远程仓库\"></a>将源码托管到远程仓库</h3><p>通过<code>Cocoapods</code>创建出来的目录本身就在本地的<code>Git</code>管理下，我们需要做的就是给它添加远端仓库，同样去<code>GitHub</code>或其他的Git服务提供商那里创建一个<code>私有的仓库</code>，拿到<code>SSH地址</code>，然后<code>cd</code>到<code>LogSwift</code>目录<br><figure class=\"highlight ruby\"><figcaption><span>添加到远程仓库</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -s -m <span class=\"string\">\"Initial Commit of Library\"</span></span><br><span class=\"line\">$ git remote add origin <span class=\"symbol\">https:</span>/<span class=\"regexp\">/coding.net/git</span><span class=\"regexp\">/LogSwift.git   #添加远端仓库</span></span><br><span class=\"line\"><span class=\"regexp\">$ git push origin master        #提交到远端仓库</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"手动配置Pod私库项目支持：spec-create\"><a href=\"#手动配置Pod私库项目支持：spec-create\" class=\"headerlink\" title=\"手动配置Pod私库项目支持：spec create\"></a>手动配置Pod私库项目支持：spec create</h2><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod spec create LogSwift git@coding.<span class=\"symbol\">net:</span>boyers/LogSwift.git</span><br></pre></td></tr></table></figure>\n<p>执行完之后，就创建了一个<code>podspec文件</code>，他其中会包含很多内容，可以按照我之前介绍的进行编辑，没用的删掉。编辑完成之后使用验证命令<code>pod lib lint</code>验证一下。</p>\n<h2 id=\"path-gt-在新项目配置检测podspec文件\"><a href=\"#path-gt-在新项目配置检测podspec文件\" class=\"headerlink\" title=\":path =&gt; 在新项目配置检测podspec文件\"></a>:path =&gt; 在新项目配置检测podspec文件</h2><p>在这个项目的<code>Podfile</code>文件中直接指定刚才创建编辑好的<code>podspec文件</code>，看是否可用。</p>\n<ol>\n<li>指定本地依赖的两种方式:<figure class=\"highlight ruby\"><figcaption><span>Podfile</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">platform <span class=\"symbol\">:ios</span>, <span class=\"string\">'7.0'</span></span><br><span class=\"line\">pod <span class=\"string\">'LogSwift'</span>, <span class=\"symbol\">:path</span> =&gt; <span class=\"string\">'~/code/Cocoapods/podTest/LogSwift'</span>      <span class=\"comment\"># 指定路径</span></span><br><span class=\"line\">pod <span class=\"string\">'LogSwift'</span>, <span class=\"symbol\">:podspec</span> =&gt; <span class=\"string\">'~/code/Cocoapods/podTest/LogSwift/LogSwift.podspec'</span>  <span class=\"comment\"># 指定podspec文件</span></span><br></pre></td></tr></table></figure></li>\n<li>指定源码的远程仓库作为依赖<br>前提时索引文件中指定的tag版本的源码必须推送到远程仓库<figure class=\"highlight ruby\"><figcaption><span>Podfile</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">platform <span class=\"symbol\">:ios</span>, <span class=\"string\">'7.0'</span></span><br><span class=\"line\">pod <span class=\"string\">'MusicLrc'</span>, <span class=\"symbol\">:git</span> =&gt; <span class=\"string\">'https://github.com/huos3203/MusicLrcTest.git'</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>然后执行<code>pod install</code>命令安装依赖，打开项目工程，可以看到<code>库文件</code>和<code>资源</code>都被加载到<code>Pods子项目</code>中了，不过它们并没有在<code>Pods目录</code>下，而是跟测试项目一样存在于<code>Development Pods/LogSwift</code>中，这是因为我们是在本地测试，而没有把<code>podspec文件</code>添加到<code>Spec Repo</code>中的缘故。</p>\n<h2 id=\"万事具备，向私有索引库中提交podspec文件：repo-push\"><a href=\"#万事具备，向私有索引库中提交podspec文件：repo-push\" class=\"headerlink\" title=\"万事具备，向私有索引库中提交podspec文件：repo push\"></a>万事具备，向私有索引库中提交podspec文件：repo push</h2><p>每当一个或多个<code>*.podspec</code>文件测试无误时，就可以使用<code>pod repo push</code>命令向私有索引库中提交该文件。<br><figure class=\"highlight ruby\"><figcaption><span>lib create命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod repo push PodRepo LogSwift.podspec  <span class=\"comment\">#PodRepo是本地Repo名字 后面是podspec名字</span></span><br></pre></td></tr></table></figure><br>完成之后这个组件库就添加到私有索引库中，自动生成的<code>pod 库</code>标准结构：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/repo目录.png?imageMogr2/2/w/800\"><br>同时<code>push命令</code>会将新增的索引目录推送至自己的远程仓库中，即索引托管库<code>PodRepo.git</code>中。</p>\n<h2 id=\"trunk-push-添加到Cocoapods的官方索引库\"><a href=\"#trunk-push-添加到Cocoapods的官方索引库\" class=\"headerlink\" title=\"trunk push 添加到Cocoapods的官方索引库\"></a>trunk push 添加到Cocoapods的官方索引库</h2><h3 id=\"注册trunk，邮箱验证\"><a href=\"#注册trunk，邮箱验证\" class=\"headerlink\" title=\"注册trunk，邮箱验证\"></a>注册trunk，邮箱验证</h3><p>在注册trunk之前，我们需要确认当前的CocoaPods版本是否足够新:<br>sudo gem install cocoapods<br>开始注册trunk：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod trunk register boyer@163.com <span class=\"string\">'boyers1250'</span>  --verbose</span><br></pre></td></tr></table></figure><br><code>-verbose</code>参数是为了便于输出注册过程中的调试信息。<br>执行上面的语句后，你的邮箱将会受到一封带有验证链接的邮件，如果没有请去垃圾箱找找，有可能被屏蔽了。点击邮件的链接就完成了trunk注册流程。<br>使用下面的命令可以向trunk服务器查询自己的注册信息：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod trunk me</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"通过trunk推送podspec文件\"><a href=\"#通过trunk推送podspec文件\" class=\"headerlink\" title=\"通过trunk推送podspec文件\"></a>通过trunk推送podspec文件</h3><p>现在我们已经有了自己的podspec文件，但是在推送podspec文件之前你需要确认以下几点：</p>\n<ol>\n<li>确保你的源码已经push到Github上。</li>\n<li>确保你所push的代码已经打上”version tag”版本号标签：<br>只有确保了以上两点，CocoaPods才能更准确地找到你的repo。<br>现在我们开始通过trunk上传你的podspec文件。先cd到podspec文件所在目录，执行：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod trunk push WZLBadge.podspec</span><br></pre></td></tr></table></figure>\n执行上面的push操作，就相当于你把你的源代码提交给CocoaPods团队审核了，CocoaPods审核只需要几秒钟或者几分钟就可以完成。</li>\n</ol>\n<h2 id=\"使用远程的私有Pod库\"><a href=\"#使用远程的私有Pod库\" class=\"headerlink\" title=\"使用远程的私有Pod库\"></a>使用远程的私有Pod库</h2><p>我们的这个组件库就已经制作添加完成了，现在可以<code>pod search</code>命令查到这个库，当使用时配置Podfile依赖文件即可。</p>\n<ol>\n<li>pod search 查找库<figure class=\"highlight ruby\"><figcaption><span>查找库</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod search PodTestLibrary</span><br><span class=\"line\"></span><br><span class=\"line\">-&gt; PodTestLibrary (<span class=\"number\">0</span>.<span class=\"number\">1.0</span>)</span><br><span class=\"line\">Just Testing.</span><br><span class=\"line\">pod <span class=\"string\">'PodTestLibrary'</span>, <span class=\"string\">'~&gt; 0.1.0'</span></span><br><span class=\"line\">- <span class=\"symbol\">Homepage:</span> <span class=\"symbol\">https:</span>/<span class=\"regexp\">/coding.net/u</span><span class=\"regexp\">/boyers/p</span><span class=\"regexp\">/podTestLibrary</span></span><br><span class=\"line\"><span class=\"regexp\">- Source:   https:/</span><span class=\"regexp\">/coding.net/boyers</span><span class=\"regexp\">/podTestLibrary.git</span></span><br><span class=\"line\"><span class=\"regexp\">- Versions: 0.1.0 [WTSpecs repo]</span></span><br></pre></td></tr></table></figure></li>\n<li>在Podfile文件中配置库依赖<figure class=\"highlight ruby\"><figcaption><span>配置库依赖</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod <span class=\"string\">'PodTestLibrary'</span>, <span class=\"string\">'~&gt; 0.1.0'</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"更新维护podspec文件配置，升级库版本\"><a href=\"#更新维护podspec文件配置，升级库版本\" class=\"headerlink\" title=\"更新维护podspec文件配置，升级库版本\"></a>更新维护podspec文件配置，升级库版本</h2><p><code>subspec</code>特性，可以在库原有基础上，添加更多的模块，相应创建了多个子目录。现在尝试添加包括<code>工具类</code>，底层<code>Model</code>及<code>UIKit</code>扩展等。</p>\n<h3 id=\"添加模块库文件和资源\"><a href=\"#添加模块库文件和资源\" class=\"headerlink\" title=\"添加模块库文件和资源\"></a>添加模块库文件和资源</h3><p>具体做法是先将源文件添加到<code>Pod/Classes</code>中，然后按照不同的模块对文件目录进行整理，因为我有四个模块，所以在<code>Pod/Classes</code>下有创建了四个子目录</p>\n<h3 id=\"打tag号作为podspec版本号-1\"><a href=\"#打tag号作为podspec版本号-1\" class=\"headerlink\" title=\"打tag号作为podspec版本号\"></a>打tag号作为podspec版本号</h3><p>因为<code>podspec文件</code>中获取<code>Git版本控制</code>的项目还需要<code>tag号</code>，所以我们要打上一个<code>tag</code><br><figure class=\"highlight ruby\"><figcaption><span>打标签</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -m <span class=\"string\">\"first release\"</span> <span class=\"number\">0</span>.<span class=\"number\">1.0</span></span><br><span class=\"line\">$ git push --tags     <span class=\"comment\">#推送tag到远端仓库</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"更新podspec配置文件\"><a href=\"#更新podspec配置文件\" class=\"headerlink\" title=\"更新podspec配置文件\"></a>更新podspec配置文件</h3><p>当创建了<code>subspec</code>，之前项目整体的依赖<code>dependency</code>:</p>\n<ol>\n<li>源文件:<code>source_files</code></li>\n<li>头文件:<code>public_header_files</code></li>\n<li>资源文件:<code>resource</code><br>都移动到了各自的<code>subspec</code>中，每个<code>subspec</code>之间也可以有相互的依赖关系，比如<code>UIKitAdditio</code>n就依赖于<code>CommonTools</code>。<figure class=\"highlight ruby\"><figcaption><span>更新podspec配置文件</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pod::Spec.new <span class=\"keyword\">do</span> <span class=\"params\">|s|</span></span><br><span class=\"line\">s.name             = <span class=\"string\">\"PodTestLibrary\"</span></span><br><span class=\"line\">s.version          = <span class=\"string\">\"1.0.0\"</span></span><br><span class=\"line\">s.summary          = <span class=\"string\">\"Just Testing.\"</span></span><br><span class=\"line\">s.description      = <span class=\"string\">&lt;&lt;-DESC</span></span><br><span class=\"line\"><span class=\"string\">                         Testing Private Podspec.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">                        * Markdown format.</span></span><br><span class=\"line\"><span class=\"string\">                        * Don't worry about the indent, we strip it!</span></span><br><span class=\"line\"><span class=\"string\">                    DESC</span></span><br><span class=\"line\">s.homepage         = <span class=\"string\">\"https://coding.net/u/boyers/p/podTestLibrary\"</span></span><br><span class=\"line\"><span class=\"comment\"># s.screenshots     = \"www.example.com/screenshots_1\", \"www.example.com/screenshots_2\"</span></span><br><span class=\"line\">s.license          = <span class=\"string\">'MIT'</span></span><br><span class=\"line\">s.author           = &#123; <span class=\"string\">\"boyers\"</span> =&gt; <span class=\"string\">\"boyers@foxmail.com\"</span> &#125;</span><br><span class=\"line\">s.source           = &#123; <span class=\"symbol\">:git</span> =&gt; <span class=\"string\">\"https://coding.net/boyers/podTestLibrary.git\"</span>, <span class=\"symbol\">:tag</span> =&gt; <span class=\"string\">\"1.0.0\"</span> &#125;</span><br><span class=\"line\"><span class=\"comment\"># s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;'</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.platform     = <span class=\"symbol\">:ios</span>, <span class=\"string\">'7.0'</span></span><br><span class=\"line\">s.requires_arc = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#s.source_files = 'Pod/Classes/**/*'</span></span><br><span class=\"line\"><span class=\"comment\">#s.resource_bundles = &#123; 'PodTestLibrary' =&gt; ['Pod/Assets/*.png'] &#125;</span></span><br><span class=\"line\"><span class=\"comment\">#s.public_header_files = 'Pod/Classes/**/*.h'</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.subspec <span class=\"string\">'NetWorkEngine'</span> <span class=\"keyword\">do</span> <span class=\"params\">|networkEngine|</span></span><br><span class=\"line\">    networkEngine.source_files = <span class=\"string\">'Pod/Classes/NetworkEngine/**/*'</span></span><br><span class=\"line\">    networkEngine.public_header_files = <span class=\"string\">'Pod/Classes/NetworkEngine/**/*.h'</span></span><br><span class=\"line\">    networkEngine.dependency <span class=\"string\">'AFNetworking'</span>, <span class=\"string\">'~&gt; 2.3'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.subspec <span class=\"string\">'DataModel'</span> <span class=\"keyword\">do</span> <span class=\"params\">|dataModel|</span></span><br><span class=\"line\">    dataModel.source_files = <span class=\"string\">'Pod/Classes/DataModel/**/*'</span></span><br><span class=\"line\">    dataModel.public_header_files = <span class=\"string\">'Pod/Classes/DataModel/**/*.h'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.subspec <span class=\"string\">'CommonTools'</span> <span class=\"keyword\">do</span> <span class=\"params\">|commonTools|</span></span><br><span class=\"line\">    commonTools.source_files = <span class=\"string\">'Pod/Classes/CommonTools/**/*'</span></span><br><span class=\"line\">    commonTools.public_header_files = <span class=\"string\">'Pod/Classes/CommonTools/**/*.h'</span></span><br><span class=\"line\">    commonTools.dependency <span class=\"string\">'OpenUDID'</span>, <span class=\"string\">'~&gt; 1.0.0'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.subspec <span class=\"string\">'UIKitAddition'</span> <span class=\"keyword\">do</span> <span class=\"params\">|ui|</span></span><br><span class=\"line\">    ui.source_files = <span class=\"string\">'Pod/Classes/UIKitAddition/**/*'</span></span><br><span class=\"line\">    ui.public_header_files = <span class=\"string\">'Pod/Classes/UIKitAddition/**/*.h'</span></span><br><span class=\"line\">    ui.resource = <span class=\"string\">\"Pod/Assets/MLSUIKitResource.bundle\"</span></span><br><span class=\"line\">    ui.dependency <span class=\"string\">'PodTestLibrary/CommonTools'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.frameworks = <span class=\"string\">'UIKit'</span></span><br><span class=\"line\">    <span class=\"comment\">#s.dependency 'AFNetworking', '~&gt; 2.3'</span></span><br><span class=\"line\">    <span class=\"comment\">#s.dependency 'OpenUDID', '~&gt; 1.0.0'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n编辑完成之后，在测试项目里<code>pod update</code>一下，几个子项目都被加进项目工程了，写代码验证无误之后，就可以将这个工程push到远端仓库，并打上新的<code>tag-&gt;1.0.0</code>。<blockquote>\n<p>但是如果你的代码版本号没变(podspec里的version自然也没变)就会提示push失败，即使你更改了podspec的其他地方，pod也会认为这两个文件是同一个。 我目前为止找不到trunk的相关update接口，所以只能顺水推舟，更新源代码版本号（如：1.1.1-&gt;1.1.2），重新push version tag，然后再执行pod trunk push操作。</p>\n</blockquote>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"工具","path":"api/categories/工具.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"pod","path":"api/tags/pod.json"},{"name":"私库","path":"api/tags/私库.json"}]},{"title":"JavaScript自动化组件OC桥接","slug":"macOS/JavaScript自动化组件OC桥接","date":"2017-02-15T17:19:30.000Z","updated":"2017-02-16T13:43:01.000Z","comments":true,"path":"api/articles/macOS/JavaScript自动化组件OC桥接.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><a href=\"https://developer.apple.com/library/content/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/OSX10-10.html#//apple_ref/doc/uid/TP40014508-CH109-SW8\" target=\"_blank\" rel=\"noopener\">文档</a><br><code>JavaScript自动化</code>有一个内置的<code>Objective-C Bridge</code>，使您能够访问文件系统，创建Cocoa应用程序。<br><code>Objective-C Bridge</code>的主要接入点是全局属性<code>objc</code>和<code>$</code>。</p>\n<h2 id=\"Frameworks\"><a href=\"#Frameworks\" class=\"headerlink\" title=\"Frameworks\"></a>Frameworks</h2><p><code>Foundation framework</code>中的语法默认支持<code>JavaScript自动化</code>。也可以通过使用<code>ObjC.import()</code>方法导入其他Frameworks 和 libraries。<br>例如，使用<code>Cocoa框架</code>中的<code>NSBeep()</code>函数，需要导入<code>Cocoa框架</code><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjC.import(<span class=\"string\">'Cocoa'</span>)</span><br><span class=\"line\">$.NSBeep()</span><br></pre></td></tr></table></figure><br>除了系统框架之外，一些系统库的功能也被暴露出来。这个功能可以通过<code>头文件</code>的名称来暴漏出来（不带.h）<br>例如：<br>arpa/inet, asl, copyfile, dispatch, dyld, errno, getopt, glob, grp, ifaddrs, launch, membership, netdb, netinet/in, notify, objc, paths, pwd, readline, removefile, signal, spawn, sqlite3, stdio, stdlib, string, sys/fcntl, sys/file, sys/ioctl, sys/mount, sys/param, sys/resource, sys/socket, sys/stat, sys/sysctl, sys/time, sys/times, sys/types, sys/wait, sys/xattr, syslog, time, unistd, uuid/uuid, vImage, vecLib, vmnet, xpc, 和 zlib.<br>导入框架时，系统将参考桥接支持文件。除了内置的框架和库，您可以导入任何具有桥接支持的框架，只需要将完整路径传递给框架，如下示例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjC.import(<span class=\"string\">'/Library/Frameworks/Awesome.framework'</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>原始的<code>JavaScript数据类型</code>映射到<code>C数据类型</code>。例如，一个<code>JavaScript字符串</code>映射为<code>char *</code>，而<code>JavaScript整数</code>映射到<code>int</code>。使用<code>objc API</code>返回一个<code>char *</code>时，会得到一个<code>JS 字符串</code></p>\n<p>原始的<code>JavaScript数据类型</code>将被自动转换为<code>ObjC对象类型</code>，并能作为一个预期的对象类型的参数传递给ObjC方法。<br>例如，一个<code>JS字符串</code>将被转换为一个<code>NSString对象</code>如果是什么方法签名说应该是输入。</p>\n<blockquote>\n<p>注意，然而，ObjC方法返回的ObjC对象类型是不会自动转换为原始的JavaScript的数据类型。</p>\n</blockquote>\n<h2 id=\"实例化的类和调用方法\"><a href=\"#实例化的类和调用方法\" class=\"headerlink\" title=\"实例化的类和调用方法\"></a>实例化的类和调用方法</h2><p>所有类都定义为<code>$对象</code>的属性。ObjC对象的方法有两种方式调用，根据是否需要参数的方法。<br>如果ObjC方法不带参数，然后调用<code>JavaScript属性名</code>访问<code>属性值</code>。这个例子中实例化一个空的字符串。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = $.NSMutableString.alloc.init</span><br></pre></td></tr></table></figure><br>如果ObjC方法不带参数，根据<code>JSExport</code>规范来命名，通过JavaScript的方法调用（function-typed property）；<br>对于多参数的方法，Objective-C的方法每个部分都合并在一起，冒号后的字母变为大写并移除冒号。比如下边协议中的方法，在JavaScript调用就是：doFooWithBar(foo, bar);<br>这个例子说明<code>JavaScript字符串</code>转为<code>NSString</code>然后写入到一个文件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = $.NSString.alloc.initWithUTF8String(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\">str.writeToFileAtomically(<span class=\"string\">'/tmp/foo'</span>, <span class=\"literal\">true</span>)</span><br></pre></td></tr></table></figure></p>\n<p>如果你调用一个方法，如<code>-intValue</code>，返回<code>C数据类型</code>而不是一个对象，然后你会回到原始的<code>JavaScript数据类型</code>。<br>此示例返回原始的JavaScript的整数，99。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.NSNumber.numberWithInt(<span class=\"number\">99</span>).intValue</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"访问-ObjC-Properties\"><a href=\"#访问-ObjC-Properties\" class=\"headerlink\" title=\"访问 ObjC Properties\"></a>访问 ObjC Properties</h3><p><code>ObjC属性</code>也可以通过<code>JavaScript属性</code>来访问，很像调用无参数方法。<br>当一个<code>桥接对象属性</code>的被访问时，ObjC属性列表是第一参考，如果列表中存在该名称对应的属性，那么就调用相应属性的<code>getter</code>或<code>setter</code>选择器。如果该名称的ObjC属性不在类中属性的列表中，那么该属性名称就作为<code>方法选择器</code>来调用。<br>使用自定义<code>getter</code>名定义一个属性，你可以使用<code>属性</code>名 或 <code>getter</code>名，并得到相同的结果。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task = $.NSTask.alloc.init</span><br><span class=\"line\">task.running == task.isRunning</span><br></pre></td></tr></table></figure><br>另外，不同的参数方法，<code>桥接对象属性</code>映射到<code>ObjC属性</code>也可以设置为（read/write属性）。下面的两行定义了一个ObjC属性：<code>launchPath</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task.launchPath = <span class=\"string\">'/bin/sleep'</span></span><br><span class=\"line\">task.setLaunchPath(<span class=\"string\">'/bin/sleep'</span>)</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"JS","path":"api/categories/JS.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"混编","path":"api/tags/混编.json"}]},{"title":"shell命令+AppleScript脚本+Swift代码相互调用","slug":"macOS/shell命令+AppleScript脚本+Swift代码相互调用","date":"2017-02-15T17:19:30.000Z","updated":"2017-02-15T17:19:30.000Z","comments":true,"path":"api/articles/macOS/shell命令+AppleScript脚本+Swift代码相互调用.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>当想让自己的app支持播放，但有没有足够的时间来开发自己的播放器，可以先考虑用mpv播放器来实现相关功能，这是<code>AppleScript</code>作为互通的桥梁。</p>\n<h2 id=\"NSTask调用AppleScript\"><a href=\"#NSTask调用AppleScript\" class=\"headerlink\" title=\"NSTask调用AppleScript\"></a><code>NSTask</code>调用<code>AppleScript</code></h2><h3 id=\"调用脚本文件main-scpt\"><a href=\"#调用脚本文件main-scpt\" class=\"headerlink\" title=\"调用脚本文件main.scpt\"></a>调用脚本文件<code>main.scpt</code></h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//let bundle = NSBundle.init(forClass: self.dynamicType)</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bundle = <span class=\"type\">NSBundle</span>.mainBundle()</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> scriptPath = bundle.pathForResource(<span class=\"string\">\"main\"</span>, ofType: <span class=\"string\">\"scpt\"</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> paths = [scriptPath]</span><br><span class=\"line\">    <span class=\"type\">NSTask</span>.launchedTaskWithLaunchPath(<span class=\"string\">\"/usr/bin/osascript\"</span>, arguments: paths)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"调用APPleScript脚本片段\"><a href=\"#调用APPleScript脚本片段\" class=\"headerlink\" title=\"调用APPleScript脚本片段\"></a>调用<code>APPleScript脚本片段</code></h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bundle = <span class=\"type\">NSBundle</span>.mainBundle()</span><br><span class=\"line\"><span class=\"keyword\">let</span> videoPath = bundle.pathForResource(<span class=\"string\">\"BigBuck\"</span>, ofType: <span class=\"string\">\"m4v\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//https://developer.apple.com/library/mac/technotes/tn2084/_index.html</span></span><br><span class=\"line\"><span class=\"comment\">//open -na /Applications/mpv.app命令行必须是 -na 才能调用当前指定的播放器，否则会调用系统默认播发器</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAppleScript = <span class=\"string\">\"on run\\ndo shell script \\\"open -na /Applications/mpv.app \\(videoPath!)\\\"\\ntell application \\\"mpv\\\" to activate\\n end run\"</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(myAppleScript)</span><br><span class=\"line\"><span class=\"keyword\">var</span> error: <span class=\"type\">NSDictionary</span>?</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> scriptObject = <span class=\"type\">NSAppleScript</span>(source: myAppleScript) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> output: <span class=\"type\">NSAppleEventDescriptor</span> = scriptObject.executeAndReturnError(</span><br><span class=\"line\">    &amp;error) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(output.stringValue)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (error != <span class=\"literal\">nil</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"error: \\(error)\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"AppleScript调用shell\"><a href=\"#AppleScript调用shell\" class=\"headerlink\" title=\"AppleScript调用shell\"></a><code>AppleScript</code>调用<code>shell</code></h2><p>AppleScript语句中为on run {变量名称，逗号隔开} 以endrun结束。中间为AppleScript语句。</p>\n<h3 id=\"do-shell-script\"><a href=\"#do-shell-script\" class=\"headerlink\" title=\"do shell script\"></a>do shell script</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on run [变量1,变量2...]  #开始 多个变量名称，用逗号隔开</span><br><span class=\"line\">    do shell script \"open -n /Applications/mpv.app\" #AppleScript语句  </span><br><span class=\"line\">end run #结束</span><br></pre></td></tr></table></figure>\n<h2 id=\"终端osascript调用AppleScript\"><a href=\"#终端osascript调用AppleScript\" class=\"headerlink\" title=\"终端osascript调用AppleScript\"></a>终端<code>osascript</code>调用<code>AppleScript</code></h2><p><a href=\"http://www.hackmac.org/tutorials/run-applescript-from-the-command-line/\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">osascript -e 'applescript command' #单引号</span><br></pre></td></tr></table></figure>\n<h3 id=\"打开Finder窗口\"><a href=\"#打开Finder窗口\" class=\"headerlink\" title=\"打开Finder窗口\"></a>打开Finder窗口</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">osascript -e 'tell app \"Finder\" to make new Finder window'</span><br></pre></td></tr></table></figure>\n<h3 id=\"打开某个程序同时弹出”Hello-World”提示框\"><a href=\"#打开某个程序同时弹出”Hello-World”提示框\" class=\"headerlink\" title=\"打开某个程序同时弹出”Hello World”提示框\"></a>打开某个程序同时弹出”Hello World”提示框</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">osascript -e <span class=\"string\">'tell app \"applicationname\" to display dialog \"Hello World\"'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"设置音量，音量大小范围（0-7）\"><a href=\"#设置音量，音量大小范围（0-7）\" class=\"headerlink\" title=\"设置音量，音量大小范围（0-7）\"></a>设置音量，音量大小范围（0-7）</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">osascript -e <span class=\"string\">\"set volume number\"</span></span><br></pre></td></tr></table></figure>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"JS","path":"api/categories/JS.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"混编","path":"api/tags/混编.json"},{"name":"脚本","path":"api/tags/脚本.json"},{"name":"AppleScript","path":"api/tags/AppleScript.json"},{"name":"shell","path":"api/tags/shell.json"}]},{"title":"macOS支持JavaScript自动化组件基础","slug":"macOS/macOS支持JavaScript自动化组件基础","date":"2017-02-15T17:19:30.000Z","updated":"2017-02-16T13:43:01.000Z","comments":true,"path":"api/articles/macOS/macOS支持JavaScript自动化组件基础.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>苹果 <code>OS X Yosemite系统</code>把 <code>JavaScript</code>作为<code>AppleScript</code>的另一选择。<code>Automation</code> 是 <code>OS X 10.10版本</code>中的新特性，苹果在官网发布<a href=\"https://developer.apple.com/library/prerelease/mac/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/index.html#//apple_ref/doc/uid/TP40014508\" target=\"_blank\" rel=\"noopener\">JavaScript for Automation Release Notes</a>有篇文章介绍了用<code>JavaScript</code>写自动化<code>Automation</code>脚本。<br><code>JavaScript</code>凭借其简单的语法，良好的性能，超轻量的框架，极小耦合的模块系统等等优势已经吸引了很多大厂的关注。<br>再加上<code>JavaScript</code>先天开放且无版权专利纠纷的问题，拥有非常广泛的开发者（开源）群体，苹果将其引入<code>OS X平台</code>代替私有的<code>AppleScript</code>，可能也有着一部分开放性平台的考虑，从而吸引广泛的第三方开发者。<br>资源<br><a href=\"https://github.com/tylergaw/js-osx-app-examples\" target=\"_blank\" rel=\"noopener\">JavaScript OS X App Examples</a><br><a href=\"https://github.com/dtinth/JXA-Cookbook\" target=\"_blank\" rel=\"noopener\">JavaScript for Automation Cookbook</a></p>\n<h2 id=\"OSA框架-Open-Scripting-Architecture\"><a href=\"#OSA框架-Open-Scripting-Architecture\" class=\"headerlink\" title=\"OSA框架:Open Scripting Architecture\"></a>OSA框架:<code>Open Scripting Architecture</code></h2><p><code>OSA</code>组件用于实现MacAPP自动化操作。这些框架组件使用场景包括：<code>Script Editor</code>编辑器，全系统的<code>Script菜单</code>，<code>Run JavaScript Automator</code>命令的操作，<code>applets</code>小程序，命令行<code>osascript</code>工具，<code>NSUserScriptTask API</code>中，还可以运用在其他的<code>OSA</code>组件中例如：<code>AppleScript</code>。这也就包括了<code>Mail</code>规则、<code>Folder</code>操作、<code>Address Book</code>插件、日历闹钟和消息触发器。</p>\n<h2 id=\"脚本字典\"><a href=\"#脚本字典\" class=\"headerlink\" title=\"脚本字典\"></a>脚本字典</h2><p>脚本字典详细介绍APP的对象模型。在脚本字典映射到有效的JavaScript标识符遵循一套规范的术语。在<code>Script Editor</code>脚本字典浏览器已经更新到显示术语<code>AppleScript</code>，<code>JavaScript</code>和O<code>bjective-C</code>（Scripting Bridge framework）格式。</p>\n<h3 id=\"打开脚本字典\"><a href=\"#打开脚本字典\" class=\"headerlink\" title=\"打开脚本字典\"></a>打开脚本字典</h3><p>启动<code>Script Editor</code> (/Applications/Utilities/) –&gt;<code>File &gt; Open Dictionary or Window &gt; Library</code>。</p>\n<h2 id=\"object-specifier\"><a href=\"#object-specifier\" class=\"headerlink\" title=\"object specifier\"></a>object specifier</h2><p>在<code>JavaScript自动化主机</code>环境中的大部分对象指的是外部实例，如：其他APP，window或在这些APP的相关数据。当访问一个APP对象或APP中的某个元素的<code>JavaScript属性</code>时，会返回一个新的<code>object specifier</code>，也就是这个对象的<code>specifier 属性</code>。</p>\n<blockquote>\n<p>object specifier不是外部实例属性的实际值，是这个对象的引用指针。如果要获取这个属性的实际值，使用get／set方法。</p>\n</blockquote>\n<h2 id=\"访问APP\"><a href=\"#访问APP\" class=\"headerlink\" title=\"访问APP\"></a>访问APP</h2><p>六种方式:<br><figure class=\"highlight js\"><figcaption><span>By name</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application(<span class=\"string\">'Mail'</span>)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><figcaption><span>By bundle ID</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application(<span class=\"string\">'com.apple.mail'</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>By path</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application(<span class=\"string\">'/Applications/Mail.app'</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>By process ID</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application(<span class=\"number\">763</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>On a remote machine</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application(<span class=\"string\">'eppc://127.0.0.1/Mail'</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>currentApplication</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application.currentApplication()</span><br></pre></td></tr></table></figure>\n<h2 id=\"语法示例\"><a href=\"#语法示例\" class=\"headerlink\" title=\"语法示例\"></a>语法示例</h2><figure class=\"highlight js\"><figcaption><span>Access properties</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.name</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>Access elements</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.outgoingMessages[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>Call commands</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.open(...)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>Create new objects</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.OutgoingMessage(...)</span><br></pre></td></tr></table></figure>\n<h3 id=\"属性的get-set方法\"><a href=\"#属性的get-set方法\" class=\"headerlink\" title=\"属性的get/set方法\"></a>属性的get/set方法</h3><p>点运算符访问脚本对象，是JavaScript语法特性之一。<br>如上所述，返回的对象是一个<code>object specifier</code>是一个对象的引用，而不是属性实际值。<br>当访问属性时，会作为一个get函数，返回实际值：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subject = Mail.inbox.messages[<span class=\"number\">0</span>].subject()</span><br></pre></td></tr></table></figure><br>当赋值属性时，会作为一个set函数，把参数赋值该属性：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.outgoingMessages[<span class=\"number\">0</span>].subject = <span class=\"string\">'Hello world'</span></span><br></pre></td></tr></table></figure><br>获取数组中的每个元素属性（在这种情况下，得到邮件收件箱中的每份邮件的标题）<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subjects = Mail.inbox.messages.subject()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"元素数组\"><a href=\"#元素数组\" class=\"headerlink\" title=\"元素数组\"></a>元素数组</h3><p>通过在数组中调用特定元素检索方法，或使用方括号并指定要检索的元素的名称或索引来访问数组中的元素。返回值是对象相关，与自己的属性和元素，引用数组元素。他们可以访问<br><figure class=\"highlight js\"><figcaption><span>索引</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span> = Mail.windows.at(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">window</span> = Mail.windows[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure><br><figure class=\"highlight js\"><figcaption><span>name</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span> = Mail.windows.byName(<span class=\"string\">'New Message'</span>)</span><br><span class=\"line\"><span class=\"built_in\">window</span> = Mail.windows[<span class=\"string\">'New Message'</span>]</span><br></pre></td></tr></table></figure><br><figure class=\"highlight js\"><figcaption><span>ID</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span> = Mail.windows.byId(<span class=\"number\">412</span>)</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Note: 使用ID来访问不是方括号[]而是().</p>\n</blockquote>\n<h3 id=\"调用命令\"><a href=\"#调用命令\" class=\"headerlink\" title=\"调用命令\"></a>调用命令</h3><p>命令被称为函数。</p>\n<ol>\n<li>直接参数的函数，该参数作为命令的第一个参数传递。</li>\n<li>如果函数需要带参数名的参数，那么这个参数可以接受一个键值对对象。</li>\n<li>如果函数需要一个直接参数，就需要传递一个带参数名的参数作为第二个参数。</li>\n<li>如果函数不存在直接参数，那么带参数名的参数作为第一个参数传递，并且唯一参数。</li>\n<li>直接参数是可选的，可以不用传递任何值，当第一个参数存在参数名时，则传递NULL作为第一个参数。<figure class=\"highlight js\"><figcaption><span>无参数命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message.open()</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>无参数名的命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.open(message)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>带参数名的命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response = message.reply(&#123;</span><br><span class=\"line\">replayAll: <span class=\"literal\">true</span>,</span><br><span class=\"line\">openingWindow: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>Command with direct parameter and named parameters</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Safari.doJavaScript(<span class=\"string\">'alert(\"Hello world\")'</span>, &#123;</span><br><span class=\"line\"><span class=\"keyword\">in</span>: Safari.windows[<span class=\"number\">0</span>].tabs[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Creating-Objects\"><a href=\"#Creating-Objects\" class=\"headerlink\" title=\"Creating Objects\"></a>Creating Objects</h2><p>通过调用<code>类构造函数</code>初始化<code>属性</code>和<code>数据</code>来创建新对象。<br>在创建对象时,需要执行的其中步骤：</p>\n<ol>\n<li><code>make()</code>方法：调用对象上的<code>make()</code>方法来实例化对象。</li>\n<li><code>push()</code>方法：调用对象数组上的<code>push</code>方法来实例化对象。<br>在调用这些方法中的一个之前，对象实际上并不存在于应用程序中。</li>\n</ol>\n<h3 id=\"Create-a-new-object\"><a href=\"#Create-a-new-object\" class=\"headerlink\" title=\"Create a new object.\"></a>Create a new object.</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message = Mail.OutgoingMessage().make()</span><br></pre></td></tr></table></figure>\n<h3 id=\"Create-a-new-object-with-properties\"><a href=\"#Create-a-new-object-with-properties\" class=\"headerlink\" title=\"Create a new object with properties.\"></a>Create a new object with properties.</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message = Mail.OutgoingMessage(&#123;</span><br><span class=\"line\">subject: <span class=\"string\">'Hello world'</span>,</span><br><span class=\"line\">visible: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Mail.outgoingMessages.push(message)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Create-a-new-object-with-data\"><a href=\"#Create-a-new-object-with-data\" class=\"headerlink\" title=\"Create a new object with data.\"></a>Create a new object with data.</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">para = TextEdit.Paragraph(&#123;&#125;, <span class=\"string\">'Some text'</span>)</span><br><span class=\"line\">TextEdit.documents[<span class=\"number\">0</span>].paragraphs.push(para)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用对象\"><a href=\"#使用对象\" class=\"headerlink\" title=\"使用对象\"></a>使用对象</h3><p>一旦你在应用程序中创建一个新的对象（通过调用<code>make</code>或<code>push</code>），可以像任何现有的应用程序对象一样进行交互。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message = Mail.OutgoingMessage().make()</span><br><span class=\"line\">message.subject = <span class=\"string\">'Hello world'</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Scripting-Additions\"><a href=\"#Scripting-Additions\" class=\"headerlink\" title=\"Scripting Additions\"></a>Scripting Additions</h3><p>使用脚本添加（脚本插件）来增强应用程序的功能。操作系统有一套标准的脚本添加提供speak text,展示用户交互对话，等。<br>使用这些，必须明确设置<code>includeStandardAdditions</code>的<code>flag</code>为 <code>true</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app = Application.currentApplication()</span><br><span class=\"line\">app.includeStandardAdditions = <span class=\"literal\">true</span></span><br><span class=\"line\">app.say(<span class=\"string\">'Hello world'</span>)</span><br><span class=\"line\">app.displayDialog(<span class=\"string\">'Please enter your email address'</span>, &#123;</span><br><span class=\"line\">withTitle: <span class=\"string\">'Email'</span>,</span><br><span class=\"line\">defaultAnswer: <span class=\"string\">'your_email@site.com'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Applets\"><a href=\"#Applets\" class=\"headerlink\" title=\"Applets\"></a>Applets</h2><p>在<code>Script Editor</code>编写脚本并保存为一个应用程序，且可以被双击独立运行的程序称为<code>Applet</code>。<br>程序支持以下事件处理：<br>当Applet运行时，<code>run</code>处理事件被调用：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<p>用于拖放操作的<code>openDocuments</code>处理事件程序包配置小程序，当文档被拖放到该小程序上时，这个处理操作将被执行：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">openDocuments</span>(<span class=\"params\">docs</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><br>传递的参数是一个文件路径字符串数组。<br><a href=\"https://developer.apple.com/library/content/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/OSX10-10.html#//apple_ref/doc/uid/TP40014508-CH109-SW8\" target=\"_blank\" rel=\"noopener\">更多样例</a></p>\n<h2 id=\"UI-Automation\"><a href=\"#UI-Automation\" class=\"headerlink\" title=\"UI Automation\"></a>UI Automation</h2><p>通过编写系统事件应用程序，可以自动化应用程序的用户界面。在脚本编辑器<code>Script Editor</code>中浏览<code>System Events</code>的脚本字典，特别是进程套件<code>Processes Suite</code>，以查看支持此类型自动化的应用程序接口元素的列表。<br>下面的示例使用UI脚本创建Notes中的新注释。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Notes = Application(<span class=\"string\">'Notes'</span>)</span><br><span class=\"line\">Notes.activate()</span><br><span class=\"line\"></span><br><span class=\"line\">delay(<span class=\"number\">1</span>)</span><br><span class=\"line\">SystemEvents = Application(<span class=\"string\">'System Events'</span>)</span><br><span class=\"line\">Notes = SystemEvents.processes[<span class=\"string\">'Notes'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">Notes.windows[<span class=\"number\">0</span>].splitterGroups[<span class=\"number\">0</span>].groups[<span class=\"number\">1</span>].groups[<span class=\"number\">0</span>].buttons[<span class=\"number\">0</span>].click()</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"JS","path":"api/categories/JS.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"混编","path":"api/tags/混编.json"},{"name":"JavaScript","path":"api/tags/JavaScript.json"}]},{"title":"Fabric对macOS系统的支持","slug":"macOS/Fabric对macOS系统的支持调研","date":"2017-02-14T11:14:35.000Z","updated":"2017-02-14T14:33:17.000Z","comments":true,"path":"api/articles/macOS/Fabric对macOS系统的支持调研.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"Fabric\"><a href=\"#Fabric\" class=\"headerlink\" title=\"Fabric\"></a>Fabric</h2><p><code>Fabric</code> 是Twitter的移动应用开发平台，一个模块化、跨平台的移动开发套件，该博文主要研究<code>crashlytics</code>在app中的运用。<br><a href=\"https://try.crashlytics.com/\" target=\"_blank\" rel=\"noopener\">注册新的账户</a>登录，审核通过时间为几个小时或者1到2天不等。然后注册时候输入的邮箱就会收到如下的邀请涵<br><a href=\"https://docs.fabric.io/apple/crashlytics/os-x.html#macos-support\" target=\"_blank\" rel=\"noopener\">浏览官方文档</a></p>\n<h3 id=\"crashlytics支持macOS\"><a href=\"#crashlytics支持macOS\" class=\"headerlink\" title=\"crashlytics支持macOS\"></a>crashlytics支持macOS</h3><p>对<code>macOS</code>的支持中出现的问题<br>问题：<code>NSApplicationCrashOnExceptions</code> is not set. This will result in poor <code>top-level</code> uncaught exception reporting<br>官方解释：<br><blockquote><p>Uncaught Exceptions<br>Intercepting and reporting uncaught exceptions on macOS is more complex than it is on iOS. On macOS, AppKit will catch exceptions thrown on the main thread, preventing the application from crashing, but also preventing Crashlytics from reporting them. To make matters worse, Apple’s frameworks are not exception safe. This means that while AppKit will prevent your app from crashing, it will also likely corrupt your process’s state, often including AppKit itself. Typically, once an exception involving UI interaction is thrown, it will prevent your app from working correctly from that moment on.<br>Thankfully, AppKit has a little-known feature you can turn on to make the behavior much more predictable. We strongly recommend that you do the following in your application, right before you initialize Crashlytics.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] registerDefaults:@&#123; <span class=\"string\">@”NSApplicationCrashOnExceptions”</span>: @YES &#125;];</span><br></pre></td></tr></table></figure>\n\n<p>This will make your application’s behavior much closer to iOS. It will mean that your app will crash on uncaught exceptions, and will also allow Crashlytics to report them with useful stack traces. It will also give you the ability to override this behavior with the user defaults system, even on per-user basis.<br>Of course, this is all optional. Crashlytics will warn about NSApplicationCrashOnExceptions not being set, but will otherwise preserve normal AppKit behavior by default.</p>\n<footer><strong>官方文档</strong><cite><a href=\"https://docs.fabric.io/apple/crashlytics/os-x.html#macos-support\" target=\"_blank\" rel=\"noopener\">macOS Support</a></cite></footer></blockquote><br>拦截和报告未捕获的异常在MacOS比iOS更复杂。在MacOS，AppKit会抓住扔在主线程异常，防止应用程序崩溃，也防止crashlytics报告他们。更糟糕的是，Apple’s frameworks也不例外。这意味着AppKit可以防止你的应用程序崩溃，也可能破坏你的进程的状态，包括AppKit本身。通常情况下，一旦涉及到用户界面交互的异常被抛出，它将阻止您的应用程序从正确的工作从那一刻起。<br>以上情况，可以通过设置：<code>NSApplicationCrashOnExceptions</code> 改变系统默认的值，达到像iOS端一样抓去异常。如果没有设置会提示：NSApplicationCrashOnExceptions not set</p>\n<h3 id=\"Cause-a-Test-Crash教程\"><a href=\"#Cause-a-Test-Crash教程\" class=\"headerlink\" title=\"Cause a Test Crash教程\"></a><a href=\"https://docs.fabric.io/apple/crashlytics/test-crash.html\" target=\"_blank\" rel=\"noopener\">Cause a Test Crash教程</a></h3><p>崩溃日志是在重启APP程序的同时进行的，要确保程序在前台全屏显示。<br>Xcode调试器会阻止我们捕捉崩溃报告，所以在抓取崩溃报告时，要保证在非调试状态下进行。如果你的移动设备连接到Mac机上，Xcode仍然可以进入调试状态。</p>\n<ol>\n<li><code>run</code>在模拟器上安装运行APP</li>\n<li>点击<code>Stop</code>断开Xcode和模拟器，确保在非调试状态</li>\n<li>在模拟器上启动APP，并执行崩溃操作</li>\n<li>在Xcode上点击<code>run</code><br>在Xcode的控制台console中输出显示奔溃报告，以及上传日志的相关提示。<br>macOS系统中的日志目录：<br>运行日志目录：/private/var/log/system.log<br>奔溃日志目录：/Users/pyc/Library/Logs/DiagnosticReports/APPNAME_2016-11-10-165115.crash</li>\n</ol>\n<blockquote><p>It’s possible, but rare, that we are missing a dSYM to symbolicate any crash reports. There will be an alert on your dashboard if this is the case. Click through to upload the missing dSYM. Keep in mind that exceptions are not guaranteed to crash. The full code path, including code in system libraries, matters here. If you aren’t seeing the dSYM alert, you can go to your app’s settings page, and append “/mappings” to the URL to reach it, e.g. <a href=\"https://fabric.io/settings/apps/some_app_id/mappings\" target=\"_blank\" rel=\"noopener\">https://fabric.io/settings/apps/some_app_id/mappings</a></p>\n<footer><strong>官方文档</strong><cite><a href=\"https://docs.fabric.io/apple/crashlytics/test-crash.html\" target=\"_blank\" rel=\"noopener\">Cause a Test Crash教程</a></cite></footer></blockquote>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"调试","path":"api/categories/调试.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"SDK","path":"api/tags/SDK.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"发布","path":"api/tags/发布.json"},{"name":"macOS","path":"api/tags/macOS.json"}]},{"title":"思维导图之开发实践篇","slug":"导图/思维导图之开发实践篇","date":"2017-02-13T17:11:26.000Z","updated":"2017-06-24T15:32:42.000Z","comments":true,"path":"api/articles/导图/思维导图之开发实践篇.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/需求速记.jpg?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"阅读书籍\"><a href=\"#阅读书籍\" class=\"headerlink\" title=\"阅读书籍\"></a>阅读书籍</h2><ul>\n<li>5种图表解决工作中的12大难题</li>\n<li>你的第一本思维导图操作书</li>\n<li>5分钟手绘彩色圆珠笔涂鸦集</li>\n<li>如果阅读一本书</li>\n</ul>\n<p>使用思维导图的场景无处不在，无论是做产品还是做设计，我们都需要清晰的思路，明确自己需要做些什么，最后需要达到什么效果，这时候，如果有一张清晰的思维导图，就能很快的理清自己的思路。作为互联网公司自称是产品型设计师（也就是既需要帮助老板整理需求梳理产品，也要设计漂亮的界面）的我更是如此。 </p>\n<p>目的：通过学习在该文章中讲到的开发设计案例，站在项目开发角度，了解从速记到思维导图再到实际开发的过程。<br>从产品、设计等方面谈谈我是如何运用思维导图的。</p>\n<h2 id=\"需求分析——完善最初的想法\"><a href=\"#需求分析——完善最初的想法\" class=\"headerlink\" title=\"需求分析——完善最初的想法\"></a>需求分析——完善最初的想法</h2><p>一般老板只会告诉我们大概需要一个什么东西，具体的细节还需要我们去整理。这时候，我会把大概涉及到的基本点写在纸上，想到一条写一条，特别是一些需要注意的地方。</p>\n<h3 id=\"需求速记法\"><a href=\"#需求速记法\" class=\"headerlink\" title=\"需求速记法\"></a>需求速记法</h3><p>先用纸笔速记的方式，把临时能想到的点记录下来<br><img title=\"需求速记\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/需求速记.jpg?imageMogr2/2/w/800\"><br>在纸上列得差不多了，再新建一个 <code>XMind</code> 文档，把之前列的一些点一一转到电脑上，然后整理分类。</p>\n<h3 id=\"功能结构图案例\"><a href=\"#功能结构图案例\" class=\"headerlink\" title=\"功能结构图案例\"></a>功能结构图案例</h3><ol>\n<li>码市逻辑图<br>通过思维导图能够一目了然的看到码市的功能<img src=\"https://dn-coding-net-production-pp.qbox.me/fa34c949-b36d-4c86-a1be-a6f6c5459f3e.png\"></li>\n<li>网站功能逻辑图<br>通过功能主干图直观显示了一个网站或者 APP 整体大功能组成部分，一般在写产品需求文档时需要的功能逻辑图。<img src=\"https://dn-coding-net-production-pp.qbox.me/535567ad-e51f-43b9-aa66-8b98fc719dc6.png\">\n<h2 id=\"产品设计——通过画原型来完善功能结构\"><a href=\"#产品设计——通过画原型来完善功能结构\" class=\"headerlink\" title=\"产品设计——通过画原型来完善功能结构\"></a>产品设计——通过画原型来完善功能结构</h2><code>梳理功能结构和画原型是产品设计中相互迭代的过程</code>，在画原型时会具体到每个元素的交互过程，一旦发现功能结构导图的不合理，就要及时调整思路，做到一边画原型一边更新功能结构。<h3 id=\"悬赏功能结构图\"><a href=\"#悬赏功能结构图\" class=\"headerlink\" title=\"悬赏功能结构图\"></a>悬赏功能结构图</h3>为产品原型图考虑，在梳理整理产品功能结构图时，尽可能包括页面上所有需要展示的内容以及基本的交互流程等。<br>下面这个图是码市功能结构中的发布悬赏功能部分：<img src=\"https://dn-coding-net-production-pp.qbox.me/4b1d61b9-c558-4afc-9aed-54dd47b440be.png\" class=\"码市悬赏功能结构\" title=\"悬赏功能结构\">\n有了功能结构图，就可以一一对照来做原型了。<h3 id=\"原型图\"><a href=\"#原型图\" class=\"headerlink\" title=\"原型图\"></a>原型图</h3>正如前面所说：<code>梳理功能结构和画原型是产品设计中相互迭代的过程</code>，在画原型时会具体到每个元素的交互过程，一旦发现功能导图的不合理，就要及时调整思路，做到一边画原型一边更新功能结构。<br>然后得到下面的原型：<img src=\"https://dn-coding-net-production-pp.qbox.me/eb4feccf-3514-41ac-b4de-222db74ef1d9.png\">\n</li>\n</ol>\n<h2 id=\"写文章时用到的思维导图\"><a href=\"#写文章时用到的思维导图\" class=\"headerlink\" title=\"写文章时用到的思维导图\"></a>写文章时用到的思维导图</h2><p><a href=\"https://blog.coding.net/blog/coding-mindmap\" target=\"_blank\" rel=\"noopener\">原文</a><br>把想到的先列出来，慢慢整理调整，梳理出写作思路。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/QbMJNrM.png!web.png?imageMogr2/2/w/800\"><br>演变过程：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/vIfAjiY.png!web.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"微信推出应用号的处境：\"><a href=\"#微信推出应用号的处境：\" class=\"headerlink\" title=\"微信推出应用号的处境：\"></a>微信推出应用号的处境：</h3><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/QQ20160114-1.png?imageMogr2/2/w/800\">\n","raw":null,"categories":[{"name":"导图","path":"api/categories/导图.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"思维导图","path":"api/tags/思维导图.json"}]},{"title":"Crash文件分析方法","slug":"调试/Crash文件分析方法","date":"2017-02-07T12:38:58.000Z","updated":"2017-05-26T11:03:05.000Z","comments":true,"path":"api/articles/调试/Crash文件分析方法.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>第一步：在任意目录创建调试crash的目录</p>\n<p>第二步：将之前Archive的文件copy到crash目录里面,其中包括两个文件.app和.app.dSYM</p>\n<p>第三步：将symbolicatecrash工具copy到crash目录<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /Applications/Xcode.app -name symbolicatecrash -type f</span><br></pre></td></tr></table></figure></p>\n<p>2.用命令将symbolicatecrash拷贝到桌面的crash文件夹里面，与.app和.app.dSYM放一起<br>拷贝到crash目录：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /Applications/Xcode.app/.../symbolicatecrash /Users/Desktop/crash</span><br></pre></td></tr></table></figure></p>\n<p>第四步：执行symbolicatecrash<br>1.打开终端用命令切换到桌面的crash目录下：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /Users/你的电脑名称/Desktop/crash</span><br></pre></td></tr></table></figure></p>\n<p>2.执行命令<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./symbolicatecrash /Users/Desktop/crash/PBB.crash /Users/Desktop/crash/Control.app.dSYM &gt; Control_symbol.crash</span><br></pre></td></tr></table></figure></p>\n<p>这时候终端有可能会出现：<code>Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 60.</code></p>\n<p>3.输入命令：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> DEVELOPER_DIR=<span class=\"string\">\"/Applications/XCode.app/Contents/Developer\"</span></span><br></pre></td></tr></table></figure></p>\n<p>4.再执行 2.的命令行</p>\n<p>5.将终端完成以后，在crash文件夹里面会多出一个文件Control_symbol.crash。<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Unsupported crash <span class=\"built_in\">log</span> version: 12 at ./symbolicatecrash line 614.</span><br></pre></td></tr></table></figure></p>\n<p>第五步：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dwarfdump --lookup 0x000cf358 --arch armv7 appname.app.dSYM/</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"调试","path":"api/categories/调试.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"测试","path":"api/tags/测试.json"}]},{"title":"迁移SVN库到git库保留branchs和tags","slug":"git/迁移SVN库到git库保留branchs和tags","date":"2017-01-18T12:21:46.000Z","updated":"2017-02-17T16:28:51.000Z","comments":true,"path":"api/articles/git/迁移SVN库到git库保留branchs和tags.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>SVN was a great advance in its day, but it’s now clear that distributed version control systems are the way forward and that Git is the de facto standard. Having helped many clients migrate from SVN to Git, here are my notes for a pain-free transition that will preserve the tags and branches in your SVN repository.</p>\n<h2 id=\"首先导入一个本地存储库\"><a href=\"#首先导入一个本地存储库\" class=\"headerlink\" title=\"首先导入一个本地存储库\"></a>首先导入一个本地存储库</h2><h3 id=\"在本地创建一个存储库的目录\"><a href=\"#在本地创建一个存储库的目录\" class=\"headerlink\" title=\"在本地创建一个存储库的目录\"></a>在本地创建一个存储库的目录</h3><figure class=\"highlight bash\"><figcaption><span>新建目录</span><a href=\"http://www.sailmaker.co.uk/blog/2013/05/05/migrating-from-svn-to-git-preserving-branches-and-tags-3/#import-staging\" target=\"_blank\" rel=\"noopener\">Create a local staging directory</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">mkdir staging</span><br><span class=\"line\"><span class=\"built_in\">cd</span> staging</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：staging 可以用任何你喜欢的字符串命名，也可以放在本地的任何目录中。</p>\n</blockquote>\n<h3 id=\"初始化git-svn\"><a href=\"#初始化git-svn\" class=\"headerlink\" title=\"初始化git svn\"></a>初始化git svn</h3><h4 id=\"使用SVN标准库结构初始化\"><a href=\"#使用SVN标准库结构初始化\" class=\"headerlink\" title=\"使用SVN标准库结构初始化\"></a>使用SVN标准库结构初始化</h4><figure class=\"highlight bash\"><figcaption><span>标准初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git svn init SVNRepo_ROOT_URL --stdlayout --prefix=svn/</span><br></pre></td></tr></table></figure>\n<p><code>SVNRepo_ROOT_URL</code>: 这里svn_url是完全限定的URL下的标准目录，其目录下包括三个目录：<code>trunk</code>，<code>branches</code>， <code>tags</code>。<br><code>--prefix</code>: 强烈建议使用<code>svn/</code>作为分支和标签的前缀：设置为 <code>--prefix=svn/</code>. 这样有助于防止Git用户混淆原声的Git分支和标签。</p>\n<h4 id=\"使用SVN自定义库结构初始化\"><a href=\"#使用SVN自定义库结构初始化\" class=\"headerlink\" title=\"使用SVN自定义库结构初始化\"></a>使用SVN自定义库结构初始化</h4><p>使用非标准的svn layout 来新建svn库，即可以根据自己喜好来自定义分支，标签目录：<br><figure class=\"highlight bash\"><figcaption><span>非标准化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git svn init SVN_URL -T Trunk -b Branches -t Tags --prefix=svn/</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"查看配置信息\"><a href=\"#查看配置信息\" class=\"headerlink\" title=\"查看配置信息\"></a>查看配置信息</h3><ol>\n<li><code>review</code>命令<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">review the config</span><br></pre></td></tr></table></figure>\n会有以下信息输出：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn-remote.svn.url=svn://svn.example.com</span><br><span class=\"line\">svn-remote.svn.fetch=some/path/trunk:refs/remotes/svn/trunk</span><br><span class=\"line\">svn-remote.svn.tags=some/path/tags/*:refs/remotes/svn/tags/*</span><br></pre></td></tr></table></figure>\n高级用户可以在执行之前，修改相关配置。</li>\n<li><code>git config</code>命令<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --local --list </span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">core.repositoryformatversion=0</span><br><span class=\"line\">core.filemode=true</span><br><span class=\"line\">core.bare=false</span><br><span class=\"line\">core.logallrefupdates=true</span><br><span class=\"line\">core.ignorecase=true</span><br><span class=\"line\">core.precomposeunicode=true</span><br><span class=\"line\">svn-remote.svn.url=https://huoshuguang@192.168.85.6/svn/PBBReader_Mac</span><br><span class=\"line\">svn-remote.svn.fetch=trunk:refs/remotes/origin/trunk</span><br><span class=\"line\">svn-remote.svn.branches=branches/*:refs/remotes/origin/*</span><br><span class=\"line\">svn-remote.svn.tags=tags/*:refs/remotes/origin/tags/*</span><br><span class=\"line\">remote.PBBReader.url=https://git.oschina.net/huosan/PBBReader.git</span><br><span class=\"line\">remote.PBBReader.fetch=+refs/heads/*:refs/remotes/PBBReader/*</span><br><span class=\"line\">branch.master.remote=PBBReader</span><br><span class=\"line\">branch.master.merge=refs/heads/master</span><br><span class=\"line\">remote.server.url=https://server.local/git/PBBReader.git</span><br><span class=\"line\">remote.server.fetch=+refs/heads/*:refs/remotes/server/*</span><br><span class=\"line\">branch.v34.remote=PBBReader</span><br><span class=\"line\">branch.v34.merge=refs/heads/v28</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"从远程SVN服务器拉取代码到新建的本地存储库\"><a href=\"#从远程SVN服务器拉取代码到新建的本地存储库\" class=\"headerlink\" title=\"从远程SVN服务器拉取代码到新建的本地存储库\"></a>从远程SVN服务器拉取代码到新建的本地存储库</h3><figure class=\"highlight bash\"><figcaption><span>拉取</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git svn fetch</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看本地库状态\"><a href=\"#查看本地库状态\" class=\"headerlink\" title=\"查看本地库状态\"></a>查看本地库状态</h2><h3 id=\"status\"><a href=\"#status\" class=\"headerlink\" title=\"status\"></a>status</h3><figure class=\"highlight bash\"><figcaption><span>status</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight bash\"><figcaption><span>内容</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"查看分支信息\"><a href=\"#查看分支信息\" class=\"headerlink\" title=\"查看分支信息\"></a>查看分支信息</h3><figure class=\"highlight bash\"><figcaption><span>branch</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -a</span><br></pre></td></tr></table></figure>\n<p>输出:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* master</span><br><span class=\"line\">remotes/svn/tags/0.1.0</span><br><span class=\"line\">remotes/svn/trunk</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意：SVN标记和分支（在这种情况下，没有任何分支机构）仅作为远程引用存在。</p>\n</blockquote>\n<h2 id=\"SVN分支和标签转为本地git仓库中的标签和分支\"><a href=\"#SVN分支和标签转为本地git仓库中的标签和分支\" class=\"headerlink\" title=\"SVN分支和标签转为本地git仓库中的标签和分支\"></a>SVN分支和标签转为本地git仓库中的标签和分支</h2><h3 id=\"SVN分支迁移\"><a href=\"#SVN分支迁移\" class=\"headerlink\" title=\"SVN分支迁移\"></a>SVN分支迁移</h3><p>把远程svn分支转换为本地git仓库中的分支：<br><figure class=\"highlight bash\"><figcaption><span>分支转分支</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> branch <span class=\"keyword\">in</span> `git branch -r | grep <span class=\"string\">\"branches/\"</span> | sed <span class=\"string\">'s/ branches\\///'</span>`; <span class=\"keyword\">do</span></span><br><span class=\"line\">git branch <span class=\"variable\">$branch</span> refs/remotes/<span class=\"variable\">$branch</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"SVN标签迁移\"><a href=\"#SVN标签迁移\" class=\"headerlink\" title=\"SVN标签迁移\"></a>SVN标签迁移</h3><ol>\n<li>把远程svn标签转换为本地git仓库中的标签 :<figure class=\"highlight bash\"><figcaption><span>tags转换tags</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> tag <span class=\"keyword\">in</span> `git branch -r | grep <span class=\"string\">\"tags/\"</span> | sed <span class=\"string\">'s/ tags\\///'</span>`; <span class=\"keyword\">do</span></span><br><span class=\"line\">git tag -a -m<span class=\"string\">\"Converting SVN tags\"</span> <span class=\"variable\">$tag</span> refs/remotes/<span class=\"variable\">$tag</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"SVN标签转为本地git分支\"><a href=\"#SVN标签转为本地git分支\" class=\"headerlink\" title=\"SVN标签转为本地git分支\"></a>SVN标签转为本地git分支</h3><ol>\n<li>把远程svn标签转换为本地git仓库中的分支:<figure class=\"highlight bash\"><figcaption><span>标签转分支</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> tag <span class=\"keyword\">in</span> `git branch -r | grep <span class=\"string\">\"tags/\"</span> | sed <span class=\"string\">'s/ tags\\///'</span>`; <span class=\"keyword\">do</span></span><br><span class=\"line\">git branch <span class=\"variable\">$tag</span> refs/remotes/<span class=\"variable\">$tag</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"在本地测试git命令push和clone操作\"><a href=\"#在本地测试git命令push和clone操作\" class=\"headerlink\" title=\"在本地测试git命令push和clone操作\"></a>在本地测试git命令push和clone操作</h2><p>在推送到正式远程库之前，可以通过向本地git库中推送和clone操作。</p>\n<h3 id=\"创建一个临时的git库，用于测试push和clone测试\"><a href=\"#创建一个临时的git库，用于测试push和clone测试\" class=\"headerlink\" title=\"创建一个临时的git库，用于测试push和clone测试\"></a>创建一个临时的git库，用于测试push和clone测试</h3><p>在git中的说法，<code>bare</code>库是一个不存在工作空间备份的库。<br><figure class=\"highlight bash\"><figcaption><span>bare创建</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">mkdir <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"built_in\">test</span></span><br><span class=\"line\">git init --bare</span><br></pre></td></tr></table></figure><br>这样，在<code>~/test</code>就生成了一个<code>bare</code>git库。</p>\n<h3 id=\"push-测试\"><a href=\"#push-测试\" class=\"headerlink\" title=\"push 测试\"></a>push 测试</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~/staging</span><br><span class=\"line\">git remote add <span class=\"built_in\">test</span> `~/<span class=\"built_in\">test</span>`</span><br><span class=\"line\">git push --all <span class=\"built_in\">test</span></span><br><span class=\"line\">git push --tags <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<p>把<code>~/test</code>的放在反引号中，反引号在命令行中会<code>~</code>自动补全为一个绝对路径。如果你给一个绝对路径或URL，可以省略反引号。<br>尽管它的名字，<code>--all</code>选项不推送<code>tags</code>，所以需要对标签单独push操作。</p>\n<h3 id=\"clone-测试\"><a href=\"#clone-测试\" class=\"headerlink\" title=\"clone 测试\"></a>clone 测试</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">mkdir aclone</span><br><span class=\"line\"><span class=\"built_in\">cd</span> aclone</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> ~/<span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<p>There should now be a clone with a working copy in ~/aclone/test.<br>在<code>~/aclone/test</code>目录中将会clone出一个工作空间备份，检查确保一切OK，这样就可以向正式服务器上推送。</p>\n<h3 id=\"Push到正式git库中\"><a href=\"#Push到正式git库中\" class=\"headerlink\" title=\"Push到正式git库中\"></a>Push到正式git库中</h3><p>如果你是正式库服务器（github，coding）的管理员，为本地git库设置一个空的git库。<br>以<code>Unfuddle</code>为例,路径如下：<br><code>git@example.unfuddle.com:example/blah.git</code><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~/staging</span><br><span class=\"line\">git remote add unfuddle REAL_HOST_URL</span><br><span class=\"line\">git push --all unfuddle</span><br><span class=\"line\">git push --tags unfuddle</span><br></pre></td></tr></table></figure><br>在上面的例子中，制定了远程名：<code>unfuddle</code>而不是默认的<code>origin</code>。当然，你可以使用任何你喜欢的名字。</p>\n<h2 id=\"清理操作\"><a href=\"#清理操作\" class=\"headerlink\" title=\"清理操作\"></a>清理操作</h2><h3 id=\"删除临时git库\"><a href=\"#删除临时git库\" class=\"headerlink\" title=\"删除临时git库\"></a>删除临时git库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~/staging</span><br><span class=\"line\">git remote rm <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<p><code>staging</code>库忽略<code>test</code>远程仓库.</p>\n<h3 id=\"清除clone生成的库\"><a href=\"#清除clone生成的库\" class=\"headerlink\" title=\"清除clone生成的库\"></a>清除clone生成的库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">rm -rf aclone</span><br><span class=\"line\">rm -rf <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Either-keep-or-delete-the-staging-repo\"><a href=\"#Either-keep-or-delete-the-staging-repo\" class=\"headerlink\" title=\"Either keep or delete the staging repo\"></a>Either keep or delete the staging repo</h3><ol>\n<li>如果需要Git和SVN之间频繁交互，建议保留<code>staging</code>库这会节省你非常耗时的初始化：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git svn fetch</span><br></pre></td></tr></table></figure></li>\n<li>如果你确信svn是报废的，你可以删除：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">rm -rf staging</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"题外小贴士\"><a href=\"#题外小贴士\" class=\"headerlink\" title=\"题外小贴士\"></a>题外小贴士</h1><p>在局域网内访问server搭建服务器提供的git服务：<br><figure class=\"highlight bash\"><figcaption><span>小贴士</span><a href=\"https://confluence.atlassian.com/fishkb/unable-to-clone-git-repository-due-to-self-signed-certificate-376838977.html\" target=\"_blank\" rel=\"noopener\">SSL证书问题</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://.../git/mupdf.git</span><br><span class=\"line\">错误：fatal: unable to access <span class=\"string\">'https://..../git/mupdf.git/'</span>: SSL certificate problem: Invalid certificate chain</span><br></pre></td></tr></table></figure><br>解决：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global http.sslVerify <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"svn","path":"api/categories/svn.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"git","path":"api/tags/git.json"},{"name":"svn","path":"api/tags/svn.json"},{"name":"git-svn","path":"api/tags/git-svn.json"}]},{"title":"GTD任务清单整理技巧","slug":"导图/GTD任务清单整理技巧","date":"2016-01-07T16:00:53.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/导图/GTD任务清单整理技巧.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/6w1h.jpg?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>什么是GTD？<br>GTD 的基本理论是把一个人所要要完成的任务和事件全部从大脑中移出来，记录到纸上。这样，大脑便会不被多余的事情打搅而集中于现在所需完成的事情上面。</p>\n<h2 id=\"GTD守则：\"><a href=\"#GTD守则：\" class=\"headerlink\" title=\"GTD守则：\"></a>GTD守则：</h2><pre><code>收集任务  设置每天最重要的任务  \n（把所有你需要做的和需要完成的事情全部记录下来，放在一个“收集箱”里）  \n↓  \n过程  \n（每次按照顺序，一次只做一件事）  \n↓  \n管理任务  \n（列出有详细内容的to-do列表）  \n↓  \n复习任务   \n（复习你所有完成的任务，计划方案和等待完成的事情。确保每一件新进入的任务都有很好的安排）  \n↓  \n开始行动！  \n</code></pre><h3 id=\"建立有强行动性的任务清单\"><a href=\"#建立有强行动性的任务清单\" class=\"headerlink\" title=\"建立有强行动性的任务清单\"></a>建立有强行动性的任务清单</h3><p>任务清单（To-do List）的重要性毋庸置疑，建立有强行动性的任务清单可以让你更清楚地明白自己需要完成的任务，同时还保持了你去完成任务的激情和动力。</p>\n<ol>\n<li>分解任务：就像走远路时，以每一段路程为目标，让人更有动力去追求一样。如果你要阅读一本书，便可以将任务分成“读完第一章”，“读完第二章”等等。</li>\n<li>使用有力的动词：比如说联系某个人，就要写上“给某某打电话”或者“发邮件给某某”而不是写“联系某某”。</li>\n<li>有限的清单：谁都不希望有一张写满几大页的任务清单，你需要找出那些有强动力的行动。</li>\n<li>清理已完成的任务：已完成的任务要及时清理，否者会阻碍你的下一步行动任务。<!--nore-->\n</li>\n</ol>\n<h2 id=\"7W3H\"><a href=\"#7W3H\" class=\"headerlink\" title=\"7W3H\"></a>7W3H</h2><p>7W3H是一个用于项目规划和管理的专业术语。公司管理者邀请相关员工一起进行分析讨论，按照7W3H进行各述己见，收集、归纳、再收集、再归纳，这样一种互动、发散性思维的工作方法极大调动下属员工的积极性、责任感。否则，公司管理者单方面出台项目计划，对下属员工解释耗费时力不说，项目计划的有效性、完善性、可行性也都可能存在质疑。</p>\n<h3 id=\"7W\"><a href=\"#7W\" class=\"headerlink\" title=\"7W\"></a>7W</h3><pre><code>what 指目标与内容，包括主体，目标，机能，性能等\nwhy 指原因，包括任务，期望，背景，技术等\nwho 指人员，包括制造，行销，流通，负责的主体等\nwhere 指地点类，包括 环境，市场，区域，渠道等\nwhen 指时间，包括期限，时机，预期等\nwhom 买家，消费者，接收者\nwhich 附属品\n</code></pre><h3 id=\"3H\"><a href=\"#3H\" class=\"headerlink\" title=\"3H\"></a>3H</h3><pre><code>how to 如何做，指方式和手段，包括集体方案，详实计划，战略方针\nhow much 价格成本，投入产出，综效成果\nhow many 负面效益，各种量（问题，业务，工作）\n</code></pre><h3 id=\"案例6W1H\"><a href=\"#案例6W1H\" class=\"headerlink\" title=\"案例6W1H\"></a>案例6W1H</h3><p>截自《5个图表解决12大难题》<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/6w1h.jpg?imageMogr2/2/w/800\"></p>\n<h2 id=\"十二个赛博学习问题\"><a href=\"#十二个赛博学习问题\" class=\"headerlink\" title=\"十二个赛博学习问题\"></a><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NjA3OTM0MA==&amp;mid=403475231&amp;idx=1&amp;sn=bbf21f2e37e91fc10d1a48285e8abefd&amp;scene=23&amp;srcid=0115194ziliaGGBscdYC3N0d#rd\" target=\"_blank\" rel=\"noopener\">十二个赛博学习问题</a></h2><p>赛博学习法是一种动态的学习过程，在这个过程中你（不是你的老师，也不是某些教科书的作者）会掌握控制权，成为你自己教育的“引航员”。<br>这种方法的第一步是对话：你会针对正在学习的材料，提出一系列具体的问题。慢慢地，通过信息的整理和再整理，以及在新材料与你学过的知识之间建立新的联系，你将真正理解材料。<br>用这种方法改进你的笔记，只要回答12个问题就能掌握科教书的要点：<br><img title=\"用更短的时间达到更佳效果和更好成绩用更短的时间达到更佳效果和更好成绩\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/IMG_0028.JPG?imageMogr2/2/w/800\"></p>\n<h2 id=\"个人常用的工具类\"><a href=\"#个人常用的工具类\" class=\"headerlink\" title=\"个人常用的工具类\"></a>个人常用的工具类</h2><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/IFTTT.jpg?imageMogr2/2/w/800\">\n","raw":null,"categories":[{"name":"导图","path":"api/categories/导图.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"逻辑思维","path":"api/tags/逻辑思维.json"}]},{"title":"产品领导者的五种特质","slug":"管理/产品领导者的五种特质","date":"2015-11-27T10:24:44.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/管理/产品领导者的五种特质.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"1-善于观察\"><a href=\"#1-善于观察\" class=\"headerlink\" title=\"1.善于观察\"></a>1.善于观察</h4><p>他们一直在观察用户，不仅仅是借助指标和仪表盘。他们对每件小事情感到好奇：</p>\n<ul>\n<li>用户正尝试完成什么？  </li>\n<li>为什么用户选择这款产品而非其它产品？  </li>\n<li>他们在和这款产品交互之前、之中和之后，做了什么。  </li>\n</ul>\n<p>他们查看收到的每一条反馈，对每个客户问题做出响应。他们创建让人愉悦的调查，知道该问什么，什么时候该倾听或无视。他们在 Facebook 上和用户交朋友——他们能叫得出用户名字。他们深知，核心用户会成为产品本身的一部分。</p>\n<p>他们痴迷于研究。他们知道市场的运作方式、未来走向以及竞争要做什么。他们密切注视着一切，除了没有创建一个显而易见的版本。</p>\n<a id=\"more\"></a>\n<h4 id=\"2-技术\"><a href=\"#2-技术\" class=\"headerlink\" title=\"2.技术\"></a>2.技术</h4><p>他们或许没有计算机科学学位，但是凭借其悟性，足以解释事物运作的方式。他们理解软件开发的过程（和复杂度），打造增量改变的文化，还能借助可用的数据点清晰明了地交流。他们对优先级毫不留情。</p>\n<p>他们是脚本瘾君子——他们能够不依赖工程师而自动化很多工作。为了检查产品，他们创造工具，最终成为每个人手头最重要的工具。</p>\n<p>他们在工程师圈子里保持良好联系——知道从哪儿得到某些工程师的快速帮助、或雇佣到全职的明星工程师。</p>\n<p>他们明白，写代码除了开发产品——还能节约大量时间。</p>\n<h4 id=\"3-分析\"><a href=\"#3-分析\" class=\"headerlink\" title=\"3.分析\"></a>3.分析</h4><p>他们或许不是正式的数据科学家，但他们是数据狂热者。他们理解大数据和不良数据的差异。他们对各种分析工具一点儿也不陌生，为了捕捉到有意义的数据，他们知道该增加什么或何时增加。</p>\n<p>他们熟悉足够多的数据工具和框架，能够快速分析，并找到见解。他们总是寻找盲点。他们做出数据启迪、而非数据驱动的决定。</p>\n<p>他们和数据科学社区保持良好联系——他们知道从哪儿能得到快速的数据科学方面的帮助，以及雇佣到明星数据科学家。</p>\n<p>他们明白，大量的数据分析只用 web 浏览器就能快速搞定。</p>\n<h4 id=\"4-聚焦设计\"><a href=\"#4-聚焦设计\" class=\"headerlink\" title=\"4.聚焦设计\"></a>4.聚焦设计</h4><p>他们可能不是视觉设计师，但是理解设计的真谛及其重要性。他们知道，好的设计不单单取决于优秀的设计师，而要在团队内部打造一种强烈的设计文化。他们理解，好的设计花费时间，也知道良好、完美与完成之间的区别。</p>\n<p>他们熟悉快速设计的工具，除了编写产品说明，还能够清晰地为振奋人心的想法和概念添加插图。他们不断地寻找设计灵感，他们激发着设计师。</p>\n<p>他们和设计社区保持良好联系——他们知道从哪儿能得到快速的兼职设计方面的帮助，以及雇佣到优秀的全职设计师。</p>\n<p>他们明白，设计不单单是设计师的工作——它是团队每个人的心态和文化。</p>\n<h4 id=\"5-企业家精神\"><a href=\"#5-企业家精神\" class=\"headerlink\" title=\"5.企业家精神\"></a>5.企业家精神</h4><p>他们或许还没有打造过十亿美元的业务，但是已经上线了、并使得至少一款产品取得了增长（他们自己出钱），并以此为荣，即使没有上线亦如此。他们乐于介绍过程——为什么世界需要他们的产品、他们怎样获取用户、效果不佳的问题在哪儿。</p>\n<p>他们相信，世界真的是平的，渴望成功。他们以之前的作品为荣，但是在内心深处藏着更大的欲望，那就是为十亿用户开发产品，让世界变得更美好。</p>\n<p>他们明白，在拥有的全部技能中，勇气和坚持不懈才是最重要的两个特点。</p>\n","raw":null,"categories":[{"name":"管理","path":"api/categories/管理.json"}],"tags":[{"name":"管理","path":"api/tags/管理.json"}]}]}