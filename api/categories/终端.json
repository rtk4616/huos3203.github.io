{"name":"终端","postlist":[{"title":"Perfect开发天气接口API","slug":"macOS/Perfect开发天气接口API","date":"2017-06-26T17:01:24.000Z","updated":"2017-06-26T17:12:47.000Z","comments":true,"path":"api/articles/macOS/Perfect开发天气接口API.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"Perfect介绍\"><a href=\"#Perfect介绍\" class=\"headerlink\" title=\"Perfect介绍\"></a>Perfect介绍</h2><p>Perfect提供一系列代表请求和响应的对象组件，并允许在服务器上增加管理句柄用于产生页面内容。<br>所有对象都是在服务器对象创建后开始工作。服务器对象会被执行配置，随后会根据配置绑定并监听特定端口。一旦出现连接，服务器会读取请求数据，请求数据读取完成后，服务器会将request object请求对象传递给请求过滤器。</p>\n<h3 id=\"请求过滤器\"><a href=\"#请求过滤器\" class=\"headerlink\" title=\"请求过滤器\"></a>请求过滤器</h3><p>过滤器可能会根据需要修改查询请求。服务器会使用请求的URI路径检索routing请求／响应路由以获取处理该请求的具体句柄。如果找到了合适的处理句柄，服务器会传递给句柄对应的response object响应对象。当句柄反馈响应完成时，响应对象会被传递给响应过滤器。这些过滤器会根据需要修改最终输出的数据内容。最后响应结果数据会被推送给客户端浏览器，而客户端到服务器的连接或者被关闭、或者被拒绝维持HTTP持久连接、或者为后续请求和响应维持HTTP活动连接。</p>\n<h3 id=\"HTTP请求-响应路由\"><a href=\"#HTTP请求-响应路由\" class=\"headerlink\" title=\"HTTP请求/响应路由\"></a>HTTP请求/响应路由</h3><p>HTTP请求/响应路由是用于决定在当前请求下，哪一个句柄去接收和响应。</p>\n<ol>\n<li><code>句柄</code>:可以是一个函数、过程或者方法，只要能够接收特定类型的请求并做出反应即可。</li>\n<li><p><code>路由</code>:主要依据请求的方法<code>HTTP request method</code>和请求内容包括的<code>路径信息</code>来决定的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">routes.add(method: .post, uris: [<span class=\"string\">\"HostMonitor/client/log/addLog\"</span>])&#123;</span><br><span class=\"line\">    (request,response) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\">//处理请求,并响应请求</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>URI路由变量<br>URI变量是用于处理动态请求的好方法。比如，一个包含用户id的URL可以用该方法实现相关请求的用户管理。<br>每个变量组件是通过一个<code>程序块{ }</code>声明的。在程序块中是变量名称。每个变量名称都可以使用出了括号<code>}</code>之外的任何字符。变量名有点像单功能通配符一样，这样就可以匹配任何符合变量模式的路径。<br><code>变量值</code>:在匹配该模式下URL能够通过<code>HTTPRequest.urlVariables</code>字典查询变量值。该字典是[String:String]类型。</p>\n</li>\n</ol>\n<h3 id=\"请求对象HTTPRequest\"><a href=\"#请求对象HTTPRequest\" class=\"headerlink\" title=\"请求对象HTTPRequest\"></a>请求对象HTTPRequest</h3><p>当处理一个HTTP请求时，所有客户端的互动操作都是通过HTTPRequest请求对象和HTTPResponse响应对象实现的。<br>HTTPRequest对象包含了客户端浏览器发过来的全部数据，包括请求消息头、查询参数、POST表单数据以及其它所有相关信息，比如客户IP地址和URL变量。</p>\n<p>HTTPRequest对象将采用application/x-www-form-urlencoded编码格式对客户请求进行解析解码。而如果请求中采用multipart/form-data“多段”编码方式，则HTTP请求可以把各种未处理的原始格式表单传输过来。当处理“多段”表单数据时，HTTPRequest对象会为请求上传的文件自动创建临时目录并执行解码。这些文件会在请求过程中一直保持直到请求处理完毕，随后自动被删除。</p>\n<p>以上涉及到的各种属性和函数都是HTTPRequest请求协议的部分内容。</p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"终端","path":"api/categories/终端.json"}],"tags":[]},{"title":"Perfect服务器开发环境搭建","slug":"macOS/Perfect服务器开发环境搭建","date":"2017-06-25T09:21:56.000Z","updated":"2017-06-25T09:21:56.000Z","comments":true,"path":"api/articles/macOS/Perfect服务器开发环境搭建.json","excerpt":null,"keywords":null,"cover":"http://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIhEpimhI2nAp5KeoIp9INNABqf9BNBEpyalKYXAJU422oeKbsUcbRpOk_x9xcrFUrgVhrluV4BRqvahkFAJibAJInI20tpXpFpIekJKOXWt834vEp4zbOiBAgwWgmLIRVLiruJd2ngVxfhC1LK1atYoR-wBhTEUxsu1MiK5bxHIo4lCJLMmLL1wkN3dyzdhdaxeLKAI1FebFRMa62J_PDVofvCRqUHJKWjIyr9Iyv8pKo6Aa2nHua8upah1EIUn6Am4xa0bBWUWNc180G00","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>Perfect是一组完整、强大的工具箱、软件框架体系和Web应用服务器，可以在Linux、iOS和macOS (OS X)上使用。该软件体系为Swift工程师量身定制了一整套用于开发轻量、易维护、规模可扩展的Web应用及其它REST服务的解决方案，这样Swift工程师就可以实现同时在服务器和客户端上采用同一种语言开发软件项目。</p>\n<p>由于建立在一个高性能异步网络引擎基础上，Perfect还能够在FastCGI上运行，支持安全套接字加密（SSL）。该软件体系还包含很多其它互联网服务器所需要的特点，包括WebSockets和iOS消息推送，而且很快会有更多强大的功能支持。</p>\n<h2 id=\"SPM-软件包管理器编译项目\"><a href=\"#SPM-软件包管理器编译项目\" class=\"headerlink\" title=\"SPM:软件包管理器编译项目\"></a>SPM:软件包管理器编译项目</h2><p><a href=\"https://github.com/PerfectlySoft/PerfectDocs/blob/master/guide.zh_CN/buildingWithSPM.md\" target=\"_blank\" rel=\"noopener\">https://github.com/PerfectlySoft/PerfectDocs/blob/master/guide.zh_CN/buildingWithSPM.md</a><br>在Perfect Template项目模板是一个标准的SPM项目：</p>\n<ol>\n<li><code>Sources</code> 目录: 包含了所有Perfect项目的Swift源程序文件</li>\n<li><code>Package.swift</code>SPM文件管理清单: 包含了整个项目对其它库函数的依存关系<br>所有的SPM项目至少要包括一个 Sources 目录和一个 Package.swift 文件。而项目模板中目前只有一个依存关系：Perfect-HTTPServer服务器项目<br><img src=\"http://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIhEpimhI2nAp5KeoIp9INNABqf9BNBEpyalKYXAJU422oeKbsUcbRpOk_x9xcrFUrgVhrluV4BRqvahkFAJibAJInI20tpXpFpIekJKOXWt834vEp4zbOiBAgwWgmLIRVLiruJd2ngVxfhC1LK1atYoR-wBhTEUxsu1MiK5bxHIo4lCJLMmLL1wkN3dyzdhdaxeLKAI1FebFRMa62J_PDVofvCRqUHJKWjIyr9Iyv8pKo6Aa2nHua8upah1EIUn6Am4xa0bBWUWNc180G00\"><h3 id=\"swift-SPM文件管理清单\"><a href=\"#swift-SPM文件管理清单\" class=\"headerlink\" title=\"swift SPM文件管理清单\"></a>swift SPM文件管理清单</h3>参数配置的相关含义:<br><code>name</code>: 当前项目的目标名称，可执行文件的名字也会按照这个名称进行编译。<br><code>dependencies[]</code>:依存关系清单组。该内容说明了您的应用程序需要的所有子项目列表，在这个数组中其中每一个条目都包含了一个“.Package”软件包，及其来源URL和版本。<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> PackageDescription</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> package = <span class=\"type\">Package</span>(</span><br><span class=\"line\">    name: <span class=\"string\">\"PerfectTemplate\"</span>, <span class=\"comment\">// 当前项目的目标名称，可执行文件的名字也会按照这个名称进行编译。</span></span><br><span class=\"line\">    targets: [],</span><br><span class=\"line\">    dependencies: [</span><br><span class=\"line\">        .<span class=\"type\">Package</span>(url: <span class=\"string\">\"https://github.com/PerfectlySoft/Perfect-HTTPServer.git\"</span>, majorVersion: <span class=\"number\">2</span>, minor: <span class=\"number\">0</span>),</span><br><span class=\"line\">        .<span class=\"type\">Package</span>(url: <span class=\"string\">\"https://github.com/PerfectlySoft/Perfect-CURL.git\"</span>, majorVersion: <span class=\"number\">2</span>, minor: <span class=\"number\">0</span>),</span><br><span class=\"line\">        .<span class=\"type\">Package</span>(url: <span class=\"string\">\"https://github.com/iamjono/JSONConfig.git\"</span>, majorVersion: <span class=\"number\">0</span>, minor: <span class=\"number\">1</span>),</span><br><span class=\"line\">        .<span class=\"type\">Package</span>(url: <span class=\"string\">\"https://github.com/PerfectlySoft/Perfect-libcurl.git\"</span>, majorVersion: <span class=\"number\">2</span>, minor: <span class=\"number\">0</span>),</span><br><span class=\"line\">        <span class=\"comment\">//        .Package(url: \"https://github.com/dabfleming/Perfect-RequestLogger.git\", majorVersion: 0)</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"SPM项目编译命令\"><a href=\"#SPM项目编译命令\" class=\"headerlink\" title=\"SPM项目编译命令\"></a>SPM项目编译命令</h3><p>SPM提供以下命令用于编译项目，并且清理旧的编译结果</p>\n<ol>\n<li><p>初始化项目，开始编译调试版本<br>先自动下载需要的依存文件，再开始编译，默认生成是调试版本</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swift build</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动调试版本<br>默认编译生成的调试程序在<code>.build/debug/</code>目录下</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.build/debug/PerfectTemplate</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译发行版本<br>执行后可发行版本的可执行程序所在的目录<code>.build/release/</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swift build -c release</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>clean 编译命令<br>删除.build目录，然后重新开始一个全新的编译</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swift build --clean</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>clean磁盘命令<br>删除.build目录和Packages目录，重新下载所有依存关系以获得最新版本对项目的支持。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swift build --clean=dist</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>支持Xcode调试项目命令<br>在同一目录下生成xcode项目，该项目允许编译和调试</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swift package generate-xcodeproj</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>最好不要在这个Xcode项目上直接编辑或增加文件。如果需要更多的依存关系，或者需要下载更新的版本，您需要重新生成这个Xcode项目。因此，在之前您做的任何修改都会被Xcode覆盖。</p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"终端","path":"api/categories/终端.json"}],"tags":[]},{"title":"swift开发macOS系统的终端命令行应用","slug":"macOS/swift开发macOS系统的终端命令行应用","date":"2017-05-29T13:00:08.000Z","updated":"2017-05-29T13:00:08.000Z","comments":true,"path":"api/articles/macOS/swift开发macOS系统的终端命令行应用.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h3><p><a href=\"https://www.raywenderlich.com:443/128039/command-line-programs-macos-tutorial\" target=\"_blank\" rel=\"noopener\">命令行程序MacOS的教程</a></p>\n<p>使用swift创建一个命令行程序，相比其他语言如C、Perl、Ruby或java。<br>选用SWIFT的理由：<br>Swift可以用作解释脚本语言，也可以用作编译语言。这使您具有脚本语言的优势，如零编译时间和易于维护，以及选择编译应用程序，以提高执行时间或捆绑出售给公众。</p>\n<h3 id=\"main-swift主体\"><a href=\"#main-swift主体\" class=\"headerlink\" title=\"main.swift主体\"></a>main.swift主体</h3><p>许多C语言的main函数作为切入点，例如当操作系统调用这个程序时执行的代码入口。这意味着程序的执行始于这个函数的第一行。<br>Swift没有一个main函数，而是main.swift文件。这样在运行Swift项目时，直接运行的事main.swift文件，执行入口开始于第一行代码。</p>\n<h3 id=\"终端调用程序\"><a href=\"#终端调用程序\" class=\"headerlink\" title=\"终端调用程序\"></a>终端调用程序</h3><p>命令行可分两种模式</p>\n<ul>\n<li>静态可执行模式：通过终端app直接运行命令行工具，执行固有功能。</li>\n<li>交互命令行模式 ：需要用户通过使用说明信息，对命令行程序输入交互命令，执行相应的功能。</li>\n</ul>\n<ol>\n<li><p>在同一个目录下执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./Panagram</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>相对路径执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Debug/Panagram</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"终端","path":"api/categories/终端.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"}]}]}