{"name":"SB","postlist":[{"title":"Xcode8中SB适配横竖屏按钮VaryforTraits","slug":"xcode/Xcode8中SB适配横竖屏按钮VaryforTraits","date":"2017-06-13T17:33:59.000Z","updated":"2017-06-23T10:51:21.000Z","comments":true,"path":"api/articles/xcode/Xcode8中SB适配横竖屏按钮VaryforTraits.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/TraitVariations.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>升级xcode8之后，打开storyboard发现xcode7适配界面的size class被Trait Variations所取代:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TraitVariations.png?imageMogr2/2/w/800\"><br>Trait Variations只是size class的直观表现方式，改善了原本九宫格选取过于抽象的问题，直接选机型很清晰直观，但本质未变。</p>\n<h3 id=\"添加竖屏约束\"><a href=\"#添加竖屏约束\" class=\"headerlink\" title=\"添加竖屏约束\"></a>添加竖屏约束</h3><p>xcode8版本的选择器，由原来的九宫格形式，改进为机型选择器：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/VaryforTraits.png?imageMogr2/2/w/800\">   </p>\n<p>以前版本：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/sizeclass.png?imageMogr2/2/w/800\">   </p>\n<h4 id=\"Vary-for-Traits\"><a href=\"#Vary-for-Traits\" class=\"headerlink\" title=\"Vary for Traits\"></a>Vary for Traits</h4><p>对不同设备和方向上添加约束</p>\n<ol>\n<li>点击右侧的Vary for Traits 会弹出选择Width／Height或组合, 左边的会立即显示将适配的所有机型和方向，即此时新增的约束应用到的不同方向的所有机型<br>假如：选width，会发现约束会同时应用到iPhone的横竖屏：<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/VaryforTraits.png?imageMogr2/2/w/800\">   \n选中了Height之后（这里Width选不选中都是可以的），会发现左侧横屏的设备消失，接下来添加的约束就只会运用到竖屏界面上了<br>接下来为竖屏状态的界面添加约束，</li>\n<li>点击Done Varying按钮完成对约束的添加   </li>\n</ol>\n<h3 id=\"iPad适配时无法区分横竖屏\"><a href=\"#iPad适配时无法区分横竖屏\" class=\"headerlink\" title=\"iPad适配时无法区分横竖屏\"></a>iPad适配时无法区分横竖屏</h3><p>对比iPhone横竖屏：<br>竖屏状态是wC：hR 横屏下是wC：hC (w是width h是height，C是Compact R是Regular) ，所以可以方便横竖屏俩套UI是由于横竖屏的size class是不同的。<br>但iPad横竖屏都是wR：hR, 所以在竖屏设置的约束同样会应用到横屏上。<br>所以iPad横竖屏布局还得监听屏幕旋转更改约束，或者在layoutSubview中修改frame了。所以就目前而言一套界面同时适配iPhone与iPad横竖屏这4种界面还是有些困难，也很少(没有？)有应用这样干，大多数应用还是单独做了HD版本，或者直接用iPhone的布局方案。</p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"SB","path":"api/categories/SB.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"}]},{"title":"代码实现AutoLayout相关特性","slug":"iOS/代码实现AutoLayout相关特性","date":"2014-09-02T15:53:11.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/代码实现AutoLayout相关特性.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/runbtn1.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"按比例缩放\"><a href=\"#按比例缩放\" class=\"headerlink\" title=\"按比例缩放\"></a>按比例缩放</h2><p>按比例缩放，这是在Interface Builder中无法设置的内容。<br>而在代码中，有如下两种实现方式:</p>\n<ol>\n<li>使用<code>NSLayoutConstraint</code>类型的初始化函数中的<code>multiplier</code>参数就可以非常简单的设置按比例缩放。  </li>\n<li>同时也可以设置不同<code>NSLayoutAttribute</code>参数来达到意想不到的效果，比如“A的Width等于B的Height的2倍”这样的效果。  </li>\n</ol>\n<p>现在就拿一个简单的<strong><code>UIButton</code></strong>做示例，在ViewController中创建一个UIButton字段：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIButton</span> *btn;  </span><br></pre></td></tr></table></figure>  </p>\n<h4 id=\"需求-1：\"><a href=\"#需求-1：\" class=\"headerlink\" title=\"需求 1：\"></a>需求 1：</h4><ol>\n<li>要求<strong><code>UIButton</code></strong>水平居中，始终距离父View底部<strong>20</strong>单位，其高度是父View高度的三分之一。</li>\n<li>使用<strong>KVO</strong>来监控<strong><code>UIButton</code></strong>的大小并实时输出到屏幕上。  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建UIButton，不需要设置frame</span></span><br><span class=\"line\">    btn = [<span class=\"built_in\">UIButton</span> buttonWithType:<span class=\"built_in\">UIButtonTypeRoundedRect</span>];</span><br><span class=\"line\">    [btn setTitle:<span class=\"string\">@\"mgen\"</span> forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">    btn.backgroundColor = [<span class=\"built_in\">UIColor</span> greenColor];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:btn];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//禁止自动转换AutoresizingMask</span></span><br><span class=\"line\">    btn.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//居中</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addConstraint:[<span class=\"built_in\">NSLayoutConstraint</span></span><br><span class=\"line\">                              constraintWithItem:btn</span><br><span class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeCenterX</span></span><br><span class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></span><br><span class=\"line\">                              toItem:<span class=\"keyword\">self</span>.view</span><br><span class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeCenterX</span></span><br><span class=\"line\">                              multiplier:<span class=\"number\">1</span></span><br><span class=\"line\">                              constant:<span class=\"number\">0</span>]];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//距离底部20单位</span></span><br><span class=\"line\">    <span class=\"comment\">//注意NSLayoutConstraint创建的constant是加在toItem参数的，所以需要-20。</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addConstraint:[<span class=\"built_in\">NSLayoutConstraint</span></span><br><span class=\"line\">                              constraintWithItem:btn</span><br><span class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeBottom</span></span><br><span class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></span><br><span class=\"line\">                              toItem:<span class=\"keyword\">self</span>.view</span><br><span class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeBottom</span></span><br><span class=\"line\">                              multiplier:<span class=\"number\">1</span></span><br><span class=\"line\">                              constant:<span class=\"number\">-20</span>]];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//定义高度是父View的三分之一</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addConstraint:[<span class=\"built_in\">NSLayoutConstraint</span></span><br><span class=\"line\">                              constraintWithItem:btn</span><br><span class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeHeight</span></span><br><span class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></span><br><span class=\"line\">                              toItem:<span class=\"keyword\">self</span>.view</span><br><span class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeHeight</span></span><br><span class=\"line\">                              multiplier:<span class=\"number\">0.3</span></span><br><span class=\"line\">                              constant:<span class=\"number\">0</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//注册KVO方法</span></span><br><span class=\"line\">    [btn addObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"bounds\"</span> options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span> | <span class=\"built_in\">NSKeyValueObservingOptionInitial</span> context:<span class=\"literal\">nil</span>];    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;!--more--&gt;</span><br><span class=\"line\"><span class=\"comment\">//KVO回调</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"keyword\">id</span>)object change:(<span class=\"built_in\">NSDictionary</span> *)change context:(<span class=\"keyword\">void</span> *)context</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (object == btn &amp;&amp; [keyPath isEqualToString:<span class=\"string\">@\"bounds\"</span>])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [btn setTitle:<span class=\"built_in\">NSStringFromCGSize</span>(btn.bounds.size) forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  \n运行结果：  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/runbtn1.png?imageMogr2/2/w/800\"><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/runbtn2.png?imageMogr2/2/w/800\">\n<a id=\"more\"></a>\n<h4 id=\"需求-2：\"><a href=\"#需求-2：\" class=\"headerlink\" title=\"需求 2：\"></a>需求 2：</h4></li>\n<li>在横向的显示中，Button的高度只有96，所以要求Button的最小高度为150。   </li>\n</ol>\n<p>涉及到的相关特性：</p>\n<ul>\n<li><strong>优先级</strong>：当两个<strong><code>Constraint</code></strong>同时作用在一个控件时，在某些情况下是有冲突的，可以通过设置<strong><code>Constraint</code></strong>的优先级来解决。<br>优先级对应<strong><code>NSLayoutConstraint</code></strong>类型的<strong><code>priority</code></strong>属性，默认值是<strong><code>UILayoutPriorityRequired</code></strong>，数值上等于<strong>1000</strong>. 设置一个低的值代表更低的优先级。  </li>\n<li><strong>最小值的定义</strong>：使用<strong><code>NSLayoutRelationGreaterThanOrEqual</code></strong>作为<strong><code>NSLayoutConstraint</code></strong>类型创建时的<strong><code>relatedBy</code></strong>参数。</li>\n</ul>\n<p>修改上面的比例Constraint，并在下方加入一个新的限制最小值的Constraint，代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义高度是父View的三分之一</span></span><br><span class=\"line\"><span class=\"comment\">//设置优先级低于UILayoutPriorityRequired(1000)，UILayoutPriorityDefaultHigh是750</span></span><br><span class=\"line\"><span class=\"built_in\">NSLayoutConstraint</span> *con = [<span class=\"built_in\">NSLayoutConstraint</span></span><br><span class=\"line\">                          constraintWithItem:btn</span><br><span class=\"line\">                          attribute:<span class=\"built_in\">NSLayoutAttributeHeight</span></span><br><span class=\"line\">                          relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></span><br><span class=\"line\">                          toItem:<span class=\"keyword\">self</span>.view</span><br><span class=\"line\">                          attribute:<span class=\"built_in\">NSLayoutAttributeHeight</span></span><br><span class=\"line\">                          multiplier:<span class=\"number\">0.3</span></span><br><span class=\"line\">                          constant:<span class=\"number\">0</span>];</span><br><span class=\"line\">con.priority = <span class=\"built_in\">UILayoutPriorityDefaultHigh</span>;</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:con];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置btn最小高度为150</span></span><br><span class=\"line\">[btn addConstraint:[<span class=\"built_in\">NSLayoutConstraint</span></span><br><span class=\"line\">                    constraintWithItem:btn</span><br><span class=\"line\">                    attribute:<span class=\"built_in\">NSLayoutAttributeHeight</span></span><br><span class=\"line\">                    relatedBy:<span class=\"built_in\">NSLayoutRelationGreaterThanOrEqual</span></span><br><span class=\"line\">                    toItem:<span class=\"literal\">nil</span></span><br><span class=\"line\">                    attribute:<span class=\"built_in\">NSLayoutAttributeNotAnAttribute</span></span><br><span class=\"line\">                    multiplier:<span class=\"number\">1</span></span><br><span class=\"line\">                    constant:<span class=\"number\">150</span>]];</span><br></pre></td></tr></table></figure><br>运行后，横向屏幕中的Button高度成了150：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/runbtn3.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"intrinsicContentSize-控件的内置大小\"><a href=\"#intrinsicContentSize-控件的内置大小\" class=\"headerlink\" title=\"intrinsicContentSize 控件的内置大小\"></a>intrinsicContentSize 控件的内置大小</h4><p>控件的内置大小是由控件本身的内容所决定的，比如一个<code>UILabel</code>的文字很长，那么该<code>UILabel</code>的内置大小自然会很长。<br>在代码中获取控件的内置大小的方法：  </p>\n<ol>\n<li>通过<code>UIView</code>的<code>intrinsicContentSize</code>属性来获取；</li>\n<li>通过<code>invalidateIntrinsicContentSize</code>方法来在下次UI规划事件中重新计算<code>intrinsicContentSize</code>。  </li>\n</ol>\n<p>注意：如果直接创建一个原始的UIView对象，它的内置大小为0。  </p>\n<p>先写一个辅助方法来快速设置UIView的边距限制：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设置Autolayout中的边距辅助方法</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setEdge:(<span class=\"built_in\">UIView</span>*)superview view:(<span class=\"built_in\">UIView</span>*)view attr:(<span class=\"built_in\">NSLayoutAttribute</span>)attr constant:(<span class=\"built_in\">CGFloat</span>)constant</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [superview addConstraint:[<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t    attribute:attr </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t    relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t       toItem:superview</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t    attribute:attr </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t   multiplier:<span class=\"number\">1.0</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t     constant:constant]</span><br><span class=\"line\">    ];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>接下来，创建一个UIView，利用上面的辅助方法快速设置其在父控件的左，上，右边距为20单位。如下代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//view1</span></span><br><span class=\"line\"><span class=\"built_in\">UIView</span> *view1 = [<span class=\"built_in\">UIView</span> new];</span><br><span class=\"line\">view1.backgroundColor = [<span class=\"built_in\">UIColor</span> yellowColor];</span><br><span class=\"line\"><span class=\"comment\">//不允许AutoresizingMask转换成Autolayout</span></span><br><span class=\"line\">view1.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:view1];</span><br><span class=\"line\"><span class=\"comment\">//设置左，上，右边距为20.</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> setEdge:<span class=\"keyword\">self</span>.view view:view1 attr:<span class=\"built_in\">NSLayoutAttributeLeft</span> constant:<span class=\"number\">20</span>];</span><br><span class=\"line\">[<span class=\"keyword\">self</span> setEdge:<span class=\"keyword\">self</span>.view view:view1 attr:<span class=\"built_in\">NSLayoutAttributeTop</span> constant:<span class=\"number\">20</span>];</span><br><span class=\"line\">[<span class=\"keyword\">self</span> setEdge:<span class=\"keyword\">self</span>.view view:view1 attr:<span class=\"built_in\">NSLayoutAttributeRight</span> constant:<span class=\"number\">-20</span>];</span><br></pre></td></tr></table></figure><br>但是运行后会发现，界面上不会显示任何东西。原因就是上面讲的，<code>UIView</code>默认是没有<strong><code>intrinsicContentSize</code></strong>的。</p>\n<p>创建一个自定义的<code>UIView</code>来改写<strong><code>intrinsicContentSize</code></strong>：MyView:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/MyView.png?imageMogr2/2/w/800\"><br>然后在.m文件中改写<strong>intrinsicContentSize</strong>方法，并返回有效值，比如这样：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//改写UIView的intrinsicContentSize</span></span><br><span class=\"line\">- (<span class=\"built_in\">CGSize</span>)intrinsicContentSize</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">70</span>, <span class=\"number\">40</span>);</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure><br>接着修改最上面的代码，把上面view1变量的类型从UIView替换成我们自定义的View：MyView类型：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyView *view1 = [MyView new];  </span><br></pre></td></tr></table></figure><br>再次运行代码，View会按照要求显示在屏幕上：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/Myview2.png?imageMogr2/2/w/800\"><br>按照同样的方式，在下方添加另一个<code>MyView</code>，要求其距离父控件边距左，下，右各为<strong>20</strong>，代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//view2  </span></span><br><span class=\"line\">MyView *view2 = [MyView new];  </span><br><span class=\"line\">view2.backgroundColor = [<span class=\"built_in\">UIColor</span> yellowColor];  </span><br><span class=\"line\"><span class=\"comment\">//不允许AutoresizingMask转换成Autolayout  </span></span><br><span class=\"line\">view2.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>;  </span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:view2];  </span><br><span class=\"line\"><span class=\"comment\">//设置左，下，右边距为20.  </span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> setEdge:<span class=\"keyword\">self</span>.view view:view2 attr:<span class=\"built_in\">NSLayoutAttributeLeft</span> constant:<span class=\"number\">20</span>];  </span><br><span class=\"line\">[<span class=\"keyword\">self</span> setEdge:<span class=\"keyword\">self</span>.view view:view2 attr:<span class=\"built_in\">NSLayoutAttributeBottom</span> constant:<span class=\"number\">-20</span>];  </span><br><span class=\"line\">[<span class=\"keyword\">self</span> setEdge:<span class=\"keyword\">self</span>.view view:view2 attr:<span class=\"built_in\">NSLayoutAttributeRight</span> constant:<span class=\"number\">-20</span>];  </span><br></pre></td></tr></table></figure><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/myview4.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"需求：\"><a href=\"#需求：\" class=\"headerlink\" title=\"需求：\"></a>需求：</h4><ol>\n<li><p>通过代码加入Autolayout中的间距，命令view1和view2上下必须间隔20个单位。 </p>\n<ol>\n<li><ul>\n<li>这里要求view2在view1之下的<strong>20</strong>单位，所以创建<strong>NSLayoutConstraint</strong>中view2参数在前面。  </li>\n</ul>\n</li>\n<li><ul>\n<li>view2的<strong><code>attribute</code></strong>参数是<strong><code>NSLayoutAttributeTop</code></strong>，而view1的<strong><code>attribute</code></strong>参数是<strong><code>NSLayoutAttributeBottom</code></strong>  </li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>拉伸view2,而不拉伸view1。  </p>\n<ol>\n<li><ul>\n<li>控件的<strong><code>Content Hugging Priority</code></strong>拒绝拉伸的优先级，优先级越高，控件会越不容易被拉伸。    </li>\n</ul>\n</li>\n<li><ul>\n<li>控件的<strong><code>Content Compression Resistance Priority</code></strong>拒绝压缩内置空间(<code>intrinsicContentSize</code>)的优先级。优先级越高，控件的内置空间(<code>intrinsicContentSize</code>)会越不容易被压缩。  </li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设置两个View上下间距为20</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:[<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view2 </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\tattribute:<span class=\"built_in\">NSLayoutAttributeTop</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\trelatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t   toItem:view1</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t    attribute:<span class=\"built_in\">NSLayoutAttributeBottom</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t   multiplier:<span class=\"number\">1.0</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t constant:<span class=\"number\">20</span>]</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t];</span><br></pre></td></tr></table></figure>  \n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/view1Toview2.png?imageMogr2/2/w/800\">\n<p>OK，的确，此时view1和view2相互间隔20单位，但是view1被拉伸了。</p>\n<p>使用控件的<strong><code>Content Hugging Priority</code></strong>，如下图：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/ContentHuggingPriority.png?imageMogr2/2/w/800\"><br>如图,把view1（上图中被拉伸的，在上面的View）的<strong><code>Content Hugging Priority</code></strong>设置一个更高的值，那么当<code>Autolayout</code>遇到这种决定谁来拉伸的情况时，view1不会被优先拉伸，而优先级稍低的view2才会被拉伸。<br>可以直接通过UIView的<code>setContentHuggingPriority:forAxis</code>方法来设置控件的<strong><code>Content Hugging Priority</code></strong>，其中<code>forAxis</code>参数代表横向和纵向，本例中只需要设置纵向，所以传入<strong><code>UILayoutConstraintAxisVertical</code></strong>。整句代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//提高view1的Content Hugging Priority</span></span><br><span class=\"line\">[view1 setContentHuggingPriority:<span class=\"built_in\">UILayoutPriorityDefaultHigh</span> forAxis:<span class=\"built_in\">UILayoutConstraintAxisVertical</span>];</span><br></pre></td></tr></table></figure><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/runview1.png?imageMogr2/2/w/800\"></p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"SB","path":"api/categories/SB.json"}],"tags":[{"name":"Storyboard","path":"api/tags/Storyboard.json"},{"name":"AutoLayout","path":"api/tags/AutoLayout.json"},{"name":"布局","path":"api/tags/布局.json"}]},{"title":"Storyboard之Segue","slug":"iOS/Storyboard之Segue","date":"2014-07-22T10:59:49.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/Storyboard之Segue.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h5 id=\"Segue原理\"><a href=\"#Segue原理\" class=\"headerlink\" title=\"Segue原理:\"></a>Segue原理:</h5><p>在iOS开发中，segue用来实现storyboard中源视图控制器和目标视图控制器连接，当segue被触发时，系统将完成下列操作：</p>\n<ol>\n<li>实例化目标视图控制器</li>\n<li>实例化一个新segue对象，该对象持有所有的信息</li>\n<li>调用源视图控制器的prepareForSegue:sender:方法，</li>\n<li>调用segue的 perform 方法将目标控制器带到屏幕上。<br>这个动作行为依赖segue的类型如modal,push,custom,modal segue告诉源视图控制器present目标视图控制器。</li>\n</ol>\n<p>在源视图控制器的prepareForSegue:sender:的方法中，执行对目标视图控制器所有必要的属性配置，包括委托设置（如目标视图控制器有协议）。<br><a id=\"more\"></a><br>在apple的文档库中第二个示例应用开发文档中，介绍了这样一个segue的使用例子。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>) prepareForSegue:(<span class=\"built_in\">UIStoryboardSegue</span> *)segue sender:(<span class=\"keyword\">id</span>)sender  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([[segue identifier] isEqualToString:<span class=\"string\">@\"ShowSightingsDetails\"</span>])  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">    <span class=\"comment\">//当用户选择表视图中的一行时，触发**segue**事件，传输数据到目标视图控制器，使目标控制器上能显示`sighting`</span></span><br><span class=\"line\">        DetailViewController *detailViewController = [segue destinationViewController];  </span><br><span class=\"line\">        detailViewController.sighting = [<span class=\"keyword\">self</span>.dataController objectInListAtIndex:[<span class=\"keyword\">self</span>.tableView indexPathForSelectedRow].row];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([[segue identifier] isEqualToString:<span class=\"string\">@\"ShowAddSightingView\"</span>])  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        AddSightingViewController *addSightingViewController = [[[segue destinationViewController] viewControllers] objectAtIndex:<span class=\"number\">0</span>];  </span><br><span class=\"line\">        addSightingViewController.delegate = <span class=\"keyword\">self</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure><br>在<code>storyboard</code>中，这个实现方法代码是用来处理从主视图控制器到两个不同的目标视图控制器的<strong>segue</strong>。这两个<strong>segue</strong>通过它们的<code>identifier</code>属性进行判断，具体解释如下：  </p>\n<ul>\n<li><p><code>identifier</code>为”<strong>ShowSightingsDetails</strong>“时，目标视图控制器是一个展示明细信息的视图控制器,使用的<strong>segue</strong>类型为<code>push</code>。这种通常用于<strong>navigator</strong>视图控制器中。  </p>\n</li>\n<li><p>在<code>identifier</code>为”<strong>ShowAddSightingView</strong>“时，目标视图控制器管理的是一个新加的<strong>sighting</strong>信息视图，我们称之为<strong>add</strong>视图控制器。它是不需要从主视图控制器（源）传什么数据过来的。但是，主视图控制器需要获取在add视图控制器（目标）上输入的数据。  </p>\n<ul>\n<li><ul>\n<li>实现方式是采用<code>delegate</code>，将主视图控制器设置为add视图控制器(目标)的委托。在add目标视图控制器上执行它的委托中方法，该方法需要先在主视图控制器的实现代码中实现，方法包括如何读取add视图控制器的数据，并dismiss掉add视图控制器。  </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>在add视图控制器上，有两个按钮，用于执行<strong>cancel</strong>和<strong>done</strong>操作。这两个按钮操作的方法在主视图控制器中实现。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)addSightingViewControllerDidCancel:(AddSightingViewController *)controller  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">\t[<span class=\"keyword\">self</span> dismissViewControllerAnimated:<span class=\"literal\">YES</span> completion:<span class=\"literal\">NULL</span>];  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)addSightingViewControllerDidFinish:(AddSightingViewController *)controller name:(<span class=\"built_in\">NSString</span> *)name location:(<span class=\"built_in\">NSString</span> *)location &#123;  </span><br><span class=\"line\"><span class=\"keyword\">if</span> ([name length] || [location length]) &#123;  </span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.dataController addBirdSightingWithName:name location:location];  </span><br><span class=\"line\">\t[[<span class=\"keyword\">self</span> tableView] reloadData];  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">\t[<span class=\"keyword\">self</span> dismissModalViewControllerAnimated:<span class=\"literal\">YES</span>];  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在add视图控制器实现代码中，调用它的委托中这两个方法。  </p>\n<h5 id=\"segue三种类型-modal-segue、push-segue、custom-segue\"><a href=\"#segue三种类型-modal-segue、push-segue、custom-segue\" class=\"headerlink\" title=\"segue三种类型:modal segue、push segue、custom segue\"></a>segue三种类型:modal segue、push segue、custom segue</h5><ul>\n<li><h6 id=\"modal-segue\"><a href=\"#modal-segue\" class=\"headerlink\" title=\"modal segue\"></a>modal segue</h6>是一个视图控制器（源）为了完成一个任务而模态地（<strong>modally</strong>）呈现另一个视图控制器（目标）。这个目标视图控制器不是导航视图控制器(<strong>navigation view controller</strong>)的栈中的一部分。<br>在任务完成后，使用<code>delegate</code>将呈现的视图控制器（目标）释放掉，应用界面切换到原来的视图控制器（源）上。  </li>\n</ul>\n<p>这个过程的实现代码可以看成是<code>present</code>和<code>dismiss</code>两个操作。  </p>\n<ul>\n<li><h6 id=\"push-segue\"><a href=\"#push-segue\" class=\"headerlink\" title=\"push segue\"></a>push segue</h6>是将另一个视图控制器压入到导航控制器的栈中。它通常和导航视图控制器(<strong>navigation view controller</strong>)一起使用。<br>新压入的视图控制器会有一个回退按钮，可以退回来上一层。</li>\n</ul>\n<p>这个过程的实现代码可以看成是<code>push</code>和<code>pop</code>两个操作。</p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"SB","path":"api/categories/SB.json"}],"tags":[{"name":"转场","path":"api/tags/转场.json"},{"name":"Storyboard","path":"api/tags/Storyboard.json"}]}]}