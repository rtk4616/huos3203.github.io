{"name":"工具","postlist":[{"title":"Xcode8中SB适配横竖屏按钮VaryforTraits","slug":"xcode/Xcode8中SB适配横竖屏按钮VaryforTraits","date":"2017-06-13T17:33:59.000Z","updated":"2017-06-23T10:51:21.000Z","comments":true,"path":"api/articles/xcode/Xcode8中SB适配横竖屏按钮VaryforTraits.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/TraitVariations.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>升级xcode8之后，打开storyboard发现xcode7适配界面的size class被Trait Variations所取代:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TraitVariations.png?imageMogr2/2/w/800\"><br>Trait Variations只是size class的直观表现方式，改善了原本九宫格选取过于抽象的问题，直接选机型很清晰直观，但本质未变。</p>\n<h3 id=\"添加竖屏约束\"><a href=\"#添加竖屏约束\" class=\"headerlink\" title=\"添加竖屏约束\"></a>添加竖屏约束</h3><p>xcode8版本的选择器，由原来的九宫格形式，改进为机型选择器：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/VaryforTraits.png?imageMogr2/2/w/800\">   </p>\n<p>以前版本：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/sizeclass.png?imageMogr2/2/w/800\">   </p>\n<h4 id=\"Vary-for-Traits\"><a href=\"#Vary-for-Traits\" class=\"headerlink\" title=\"Vary for Traits\"></a>Vary for Traits</h4><p>对不同设备和方向上添加约束</p>\n<ol>\n<li>点击右侧的Vary for Traits 会弹出选择Width／Height或组合, 左边的会立即显示将适配的所有机型和方向，即此时新增的约束应用到的不同方向的所有机型<br>假如：选width，会发现约束会同时应用到iPhone的横竖屏：<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/VaryforTraits.png?imageMogr2/2/w/800\">   \n选中了Height之后（这里Width选不选中都是可以的），会发现左侧横屏的设备消失，接下来添加的约束就只会运用到竖屏界面上了<br>接下来为竖屏状态的界面添加约束，</li>\n<li>点击Done Varying按钮完成对约束的添加   </li>\n</ol>\n<h3 id=\"iPad适配时无法区分横竖屏\"><a href=\"#iPad适配时无法区分横竖屏\" class=\"headerlink\" title=\"iPad适配时无法区分横竖屏\"></a>iPad适配时无法区分横竖屏</h3><p>对比iPhone横竖屏：<br>竖屏状态是wC：hR 横屏下是wC：hC (w是width h是height，C是Compact R是Regular) ，所以可以方便横竖屏俩套UI是由于横竖屏的size class是不同的。<br>但iPad横竖屏都是wR：hR, 所以在竖屏设置的约束同样会应用到横屏上。<br>所以iPad横竖屏布局还得监听屏幕旋转更改约束，或者在layoutSubview中修改frame了。所以就目前而言一套界面同时适配iPhone与iPad横竖屏这4种界面还是有些困难，也很少(没有？)有应用这样干，大多数应用还是单独做了HD版本，或者直接用iPhone的布局方案。</p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"SB","path":"api/categories/SB.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"}]},{"title":"搞定1无压工作的艺术","slug":"阅读/搞定1无压工作的艺术","date":"2017-06-13T10:34:26.000Z","updated":"2017-06-26T17:12:48.000Z","comments":true,"path":"api/articles/阅读/搞定1无压工作的艺术.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/理清工作流程图.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><h2 id=\"第一部分-通向从容之道\"><a href=\"#第一部分-通向从容之道\" class=\"headerlink\" title=\"第一部分 通向从容之道\"></a>第一部分 通向从容之道</h2><h3 id=\"第1章-新情况，新做法\"><a href=\"#第1章-新情况，新做法\" class=\"headerlink\" title=\"第1章 新情况，新做法\"></a>第1章 新情况，新做法</h3><ol>\n<li>如何回归“心如止水”的境界<br>在知识工作的环境下（信息大爆炸，事物繁杂的特点），传统时间管理法逐渐无法达到心如止水的境界，</li>\n</ol>\n<h3 id=\"第2章-掌控生活：横向管理工作流程的5个步骤\"><a href=\"#第2章-掌控生活：横向管理工作流程的5个步骤\" class=\"headerlink\" title=\"第2章 掌控生活：横向管理工作流程的5个步骤\"></a>第2章 掌控生活：横向管理工作流程的5个步骤</h3><p>横向管理的5个步骤</p>\n<ol>\n<li>收集：把一切会引起大脑注意的事务，不分轻重缓急（潜在的重要信息／任务／想法／行动／安排）一律从大脑中清空，作为原始材料放置工作篮中。</li>\n<li>理清：它是什么？检查工作篮的材料，理清它们的意义，扔掉垃圾事件</li>\n<li>整理：理清流程图和整理流程图一样，2分钟原则</li>\n<li>回顾：思考回顾体现了GTD的最核心</li>\n<li>执行：<br> 策划行动的三个方法：</li>\n<li>四标准法：情境，时间，精力，重要性</li>\n<li>每日工作三分类法：事先计划的事，突发事件，安排自己的事</li>\n<li>检视工作的六层次法：<br> 当前行动，当前项目，关注及责任范围，目标，愿景，目的和原则<br>流程图如下：   <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/理清工作流程图.png?imageMogr2/2/w/800\">\n衍生的清单：<br>项目清单<br>下一步行动<br>将要／也许清单<br>孵化清单</li>\n</ol>\n<h3 id=\"第3章-控制项目：纵向管理项目计划的5个阶段\"><a href=\"#第3章-控制项目：纵向管理项目计划的5个阶段\" class=\"headerlink\" title=\"第3章 控制项目：纵向管理项目计划的5个阶段\"></a>第3章 控制项目：纵向管理项目计划的5个阶段</h3><h2 id=\"第二部分-远离压力，提高效率\"><a href=\"#第二部分-远离压力，提高效率\" class=\"headerlink\" title=\"第二部分 远离压力，提高效率\"></a>第二部分 远离压力，提高效率</h2><h3 id=\"第4章-准备工作：确定时间、空间和工具\"><a href=\"#第4章-准备工作：确定时间、空间和工具\" class=\"headerlink\" title=\"第4章 准备工作：确定时间、空间和工具\"></a>第4章 准备工作：确定时间、空间和工具</h3><h3 id=\"第5章-收集阶段：归拢材料\"><a href=\"#第5章-收集阶段：归拢材料\" class=\"headerlink\" title=\"第5章 收集阶段：归拢材料\"></a>第5章 收集阶段：归拢材料</h3><h3 id=\"第6章-处理阶段：清空工作篮\"><a href=\"#第6章-处理阶段：清空工作篮\" class=\"headerlink\" title=\"第6章 处理阶段：清空工作篮\"></a>第6章 处理阶段：清空工作篮</h3><h3 id=\"第7章-组织整理：建立好清单\"><a href=\"#第7章-组织整理：建立好清单\" class=\"headerlink\" title=\"第7章 组织整理：建立好清单\"></a>第7章 组织整理：建立好清单</h3><h3 id=\"第8章-检查回顾：保障系统的有效运行\"><a href=\"#第8章-检查回顾：保障系统的有效运行\" class=\"headerlink\" title=\"第8章 检查回顾：保障系统的有效运行\"></a>第8章 检查回顾：保障系统的有效运行</h3><h3 id=\"第9章-执行阶段：选择最合适的行动\"><a href=\"#第9章-执行阶段：选择最合适的行动\" class=\"headerlink\" title=\"第9章 执行阶段：选择最合适的行动\"></a>第9章 执行阶段：选择最合适的行动</h3><h3 id=\"第10章-学会控制项目\"><a href=\"#第10章-学会控制项目\" class=\"headerlink\" title=\"第10章 学会控制项目\"></a>第10章 学会控制项目</h3><h2 id=\"第三部分-三个关键原则\"><a href=\"#第三部分-三个关键原则\" class=\"headerlink\" title=\"第三部分 三个关键原则\"></a>第三部分 三个关键原则</h2><h3 id=\"第11章-原则一：养成收集的习惯\"><a href=\"#第11章-原则一：养成收集的习惯\" class=\"headerlink\" title=\"第11章 原则一：养成收集的习惯\"></a>第11章 原则一：养成收集的习惯</h3><h3 id=\"第12章-原则二：确定“下一步行动”\"><a href=\"#第12章-原则二：确定“下一步行动”\" class=\"headerlink\" title=\"第12章 原则二：确定“下一步行动”\"></a>第12章 原则二：确定“下一步行动”</h3><h3 id=\"第13章-原则三：学会关注结果\"><a href=\"#第13章-原则三：学会关注结果\" class=\"headerlink\" title=\"第13章 原则三：学会关注结果\"></a>第13章 原则三：学会关注结果</h3><h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2>\n\n\t<div class=\"row\">\n    <embed src=\"/images/搞定1无压工作的艺术.pdf\" width=\"100%\" height=\"550\" type=\"application/pdf\">\n\t</div>\n\n\n\n","raw":null,"categories":[{"name":"阅读","path":"api/categories/阅读.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"}]},{"title":"WacomSlate笔记本使用","slug":"WacomSlate笔记本使用","date":"2017-06-03T23:32:45.000Z","updated":"2017-06-04T23:55:12.000Z","comments":true,"path":"api/articles/WacomSlate笔记本使用.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>梳理任务列表，整理阅读笔记和思维导图，来配合iPad完成每日工作任务</p>\n<h3 id=\"使用效率\"><a href=\"#使用效率\" class=\"headerlink\" title=\"使用效率\"></a>使用效率</h3><p>按时出图，分解任务，规划职业</p>\n<h3 id=\"带来的回报\"><a href=\"#带来的回报\" class=\"headerlink\" title=\"带来的回报\"></a>带来的回报</h3><p>### </p>\n<h3 id=\"Starter-playgroundbook\"><a href=\"#Starter-playgroundbook\" class=\"headerlink\" title=\"Starter.playgroundbook\"></a>Starter.playgroundbook</h3><p>iPad学习开发swift<br>第一步：创建书本的结构（参考模版）<a href=\"\">Starter.playgroundbook</a><br>第二步：了解模版的结构<br>第三步：增删改模版，增加个人的书本内容<br>官方建议流程：<br>Make targeted changes to the book’s content and structure in Xcode.<br>Transfer the updated book into Swift Playgrounds using iCloud or AirDrop.<br>只能使用iCloud和AirDrop来同步swift书籍同步到iPad上。<br>Open the updated book and test the changes.<br>Note any additional changes that are needed, and return to step 1.</p>\n<p>最终使用方法：<br>是在iPad上的一款应用，支持swift快速开发，只需要在appStore中下载Swift Playgrounds程序。<br>在这个这个程序中有精选栏，和我的Playgorund</p>\n<ol>\n<li>精选：就是内置了一些有趣的swift学习编程，从基础进阶再探索，简单易学的教学</li>\n<li>我的Playground：有新建，分享，编辑三个按钮，和自己的程序书架。<br>有两种方式开始编程：</li>\n<li>新建一个空白的playgroundbook</li>\n<li>通过iCloud 云同步已有的playgroundbook，这也是和mac端共享代码的途径（airdrop暂时没有测通，Mac端开启airdrop却看不到ipad设备），也可以通过第三方来同步，比如sync<br>源码分享：</li>\n<li>点击分享按钮，再点击要分享的playgroundbook文件，然后通过airdrop方式同 Mac共享文件。不过暂时没测通。如果使用微信，qq分享似乎发送到Mac端显示的是目录，无法通过打开方式来使用swift playground 程序<br>效果分享：</li>\n<li>在playgroundbook编辑页面，点击”。。。”弹出下拉列表页，提供fenxiang四种方式<ul>\n<li>拍照</li>\n<li>创建PDF</li>\n<li>录制影片</li>\n<li>实时直播（需要第三方直播软件，暂时没测试）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"激活iPad拥有自己的工作空间\"><a href=\"#激活iPad拥有自己的工作空间\" class=\"headerlink\" title=\"激活iPad拥有自己的工作空间\"></a>激活iPad拥有自己的工作空间</h3><ol>\n<li>激活iPad，安装自己喜欢的几款APP</li>\n<li>测试电耗，连续使用8个小时，89%到30%，耗损50%，按工作场景应该能续航16小时左右</li>\n<li>尝试键盘连接，使用外设键盘编辑文本还是比较舒服的，便捷，坐等移动键盘到手</li>\n<li>摸索iPad使用场景 <ol>\n<li>第一屏为咨询APP主页，在这里将发现更多新的东西，和未知的兴趣点，并同步至Pocker中，即搜集箱，充满期待</li>\n<li>第二屏为下一步行动列表页，将第一屏搜集到的原材料，参考四象限法则，整理筛选排优先级，加工成可执行的下一步行动，过滤不能行动的事件</li>\n<li>第三屏将行动导图梳理规范化，提高趣味性，增强行动动力，自我鼓励督促完成任务，培养自觉性和对承诺的责任心，逐步养成生活习惯\n　</li>\n</ol>\n</li>\n</ol>\n","raw":null,"categories":[],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"}]},{"title":"麦步M1s加强版体验第一天","slug":"麦步第一天体验","date":"2017-06-02T14:39:46.000Z","updated":"2017-06-22T11:25:09.000Z","comments":true,"path":"api/articles/麦步第一天体验.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/calendar2.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"开源\"><a href=\"#开源\" class=\"headerlink\" title=\"开源\"></a>开源</h3><p><a href=\"http://dev.maibu.cc/sdk/watch\" target=\"_blank\" rel=\"noopener\">开发文档</a><br><a href=\"https://github.com/maibu/Maibu\" target=\"_blank\" rel=\"noopener\">gitHub源码库</a>   </p>\n<h3 id=\"效率\"><a href=\"#效率\" class=\"headerlink\" title=\"效率\"></a>效率</h3><h4 id=\"可用功能\"><a href=\"#可用功能\" class=\"headerlink\" title=\"可用功能\"></a>可用功能</h4><p>滴答清单，同步神速，可以使用麦步来标记完成任务</p>\n<p>表盘：纯黑背景比较适合，内置白底表盘无法卸载<br>工具：计步准确，睡眠监测还行，久坐提醒不错 </p>\n<h4 id=\"思考功能\"><a href=\"#思考功能\" class=\"headerlink\" title=\"思考功能\"></a>思考功能</h4><p>怎样充分使用麦步，融入到现有的时间管理习惯中</p>\n<ol>\n<li>开发一款麦步trello清单APP<br>需求：麦步app获取到当天的trello清单，支持查看和完成操作<br>预研：麦步无须APP账号绑定等，仅凭蓝牙是如何获取到滴答清单的？<br>原理：<br>结果：开发一款trello清单是否可行<br>1.2 文档分析：<br>在第二步：编译及打包环境<ol>\n<li>gcc-arm-none-eabi-4_7-2014q2-20140408-win32.exe 编译环境</li>\n<li>IDE工具Visual MWatch.exe执行编译操作。<br>可见暂时仅支持win系统开发。</li>\n</ol>\n</li>\n</ol>\n<ol>\n<li>借助IFTTT工具是否能将trello清单同步至麦步中<br>2.1 中间APP 选择系统提醒APP/(日历APP支持时间设置)<br>原理： 通过IFTTT工具将trello清单同步到提醒APP中，然后滴答清单读取提醒清单同步到麦步上。<br>缺点：trello开始与截止日期等属性无法同步至提醒app，由于麦步仅同步滴答清单的当天任务列表，中间必须认为设置起始时间等。</li>\n</ol>\n<p>日历属于一块圣地，不要轻易设置日程安排。他应该是第三象限不急重要的事情。当指定时间地点时，优先级立即为最高</p>\n<ol>\n<li>trello创建人物是否能讲日期同步到系统提醒APP中，不可行的话，就需要单独对任务指定开始和截止时间。</li>\n</ol>\n<h3 id=\"提醒\"><a href=\"#提醒\" class=\"headerlink\" title=\"提醒\"></a>提醒</h3><p>麦步获取信息的通道：蓝牙<br>平台区别：<br>Apple手机全局提醒，安卓可以过滤app</p>\n<p>针对性个例：滴答清单<br>麦步是如何针对性滴答清单，获取APP内部信息的。</p>\n<p>其中的原理，涉及到，如果开发一款trello清单是否可行。</p>\n<h3 id=\"耗电：\"><a href=\"#耗电：\" class=\"headerlink\" title=\"耗电：\"></a>耗电：</h3><p>使用计步表盘，及时更新数据，相较普通时钟表盘，电耗是否一致，差距在哪？</p>\n<h3 id=\"trello日历订阅源\"><a href=\"#trello日历订阅源\" class=\"headerlink\" title=\"trello日历订阅源\"></a>trello日历订阅源</h3><p>滴答清单订阅日历功能：设置—安全与数据—订阅日历 (普通用户仅支持订阅系统日历)</p>\n<h4 id=\"获取从trello看板中生成订阅源\"><a href=\"#获取从trello看板中生成订阅源\" class=\"headerlink\" title=\"获取从trello看板中生成订阅源\"></a>获取从trello看板中生成订阅源</h4><p>普通用户的看板限制的Power-Ups的一个数<br>两步设置：</p>\n<ol>\n<li>第一步：启动日历<br>看板的菜单项—Power-Ups—Calendar–点击启动—出现设置图标按钮，如图：<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/calendar2.png?imageMogr2/2/w/800\">     </li>\n<li>第二步：开启日历订阅功能（默认关闭）<br>点击设置按钮，并启动订阅功能，自动生成订阅路径    <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/calendar4.png?imageMogr2/2/w/800\">   \n</li>\n</ol>\n<h4 id=\"添加日历订阅源\"><a href=\"#添加日历订阅源\" class=\"headerlink\" title=\"添加日历订阅源\"></a>添加日历订阅源</h4><p>iPhone日历订阅需要通过通过Mac实现 <a href=\"https://support.apple.com/zh-cn/HT202361\" target=\"_blank\" rel=\"noopener\">使用 iCloud 日历订阅</a><br>滴答清单订阅日历功能：设置—安全与数据—订阅日历 (普通用户仅支持订阅系统日历)</p>\n<p>可以通过监听事件来同步trello看板中的所有信息</p>\n","raw":null,"categories":[{"name":"设备","path":"api/categories/设备.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"}]},{"title":"swift开发macOS系统的终端命令行应用","slug":"macOS/swift开发macOS系统的终端命令行应用","date":"2017-05-29T13:00:08.000Z","updated":"2017-05-29T13:00:08.000Z","comments":true,"path":"api/articles/macOS/swift开发macOS系统的终端命令行应用.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h3><p><a href=\"https://www.raywenderlich.com:443/128039/command-line-programs-macos-tutorial\" target=\"_blank\" rel=\"noopener\">命令行程序MacOS的教程</a></p>\n<p>使用swift创建一个命令行程序，相比其他语言如C、Perl、Ruby或java。<br>选用SWIFT的理由：<br>Swift可以用作解释脚本语言，也可以用作编译语言。这使您具有脚本语言的优势，如零编译时间和易于维护，以及选择编译应用程序，以提高执行时间或捆绑出售给公众。</p>\n<h3 id=\"main-swift主体\"><a href=\"#main-swift主体\" class=\"headerlink\" title=\"main.swift主体\"></a>main.swift主体</h3><p>许多C语言的main函数作为切入点，例如当操作系统调用这个程序时执行的代码入口。这意味着程序的执行始于这个函数的第一行。<br>Swift没有一个main函数，而是main.swift文件。这样在运行Swift项目时，直接运行的事main.swift文件，执行入口开始于第一行代码。</p>\n<h3 id=\"终端调用程序\"><a href=\"#终端调用程序\" class=\"headerlink\" title=\"终端调用程序\"></a>终端调用程序</h3><p>命令行可分两种模式</p>\n<ul>\n<li>静态可执行模式：通过终端app直接运行命令行工具，执行固有功能。</li>\n<li>交互命令行模式 ：需要用户通过使用说明信息，对命令行程序输入交互命令，执行相应的功能。</li>\n</ul>\n<ol>\n<li><p>在同一个目录下执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./Panagram</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>相对路径执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Debug/Panagram</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"终端","path":"api/categories/终端.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"}]},{"title":"痛定思痛的项目管理弊病","slug":"个人项目/痛定思痛的项目管理弊病","date":"2017-05-27T15:06:17.000Z","updated":"2017-06-06T23:05:17.000Z","comments":true,"path":"api/articles/个人项目/痛定思痛的项目管理弊病.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><hr>\n<p>现状：两个项目源码存在八成为同样的代码，管理在两个SVN库中。<br>背景：从一个SVN项目分裂成两个独立项目（PBB_2/Reader_v2）对应延伸出来SVN库，随后在两个库中开发不同的功能版本（PBB_7/Reader_v9）。<br>需求：现在准备将两项目中新增的功能重新合并起来，即将PBB_v7合并到Reader_v9中。<br>分析：需要把PBB_v3–PBB_v7的5个提交，合并到Reader_v9中</p>\n<p>对PBB迭代的十几个版本中新增的功能涉及面太广，手动合并出错率高，协作难度大，纯劳力搬砖着实要命。<br>以下总结几条建议</p>\n<h3 id=\"方案一：打补丁法合并源码\"><a href=\"#方案一：打补丁法合并源码\" class=\"headerlink\" title=\"方案一：打补丁法合并源码\"></a>方案一：打补丁法合并源码</h3><hr>\n<p>注：仅适用于同一个库使用</p>\n<p>实现步骤：</p>\n<ol>\n<li>git-svn命令把svn库转为git库</li>\n<li>将5个提交重演到Reader_v9版中</li>\n</ol>\n<p>重演方案：</p>\n<ol>\n<li>打补丁法：通过压缩提交法把PBB_v7若干提交整合成一个提交，再创建一个补丁，重演到Reader_v9上<ol>\n<li>交互变基压缩法，压缩成一个提交</li>\n<li>reset压缩提交法，将提交压缩 git reset –soft 1bf27c6a33d87c2e36fa75431224124f91d8b482</li>\n</ol>\n</li>\n</ol>\n<p>案例：在大型项目中，贡献者常以使用补丁文件贡献代码<br>结论：打补丁法的前提打补丁的宿主库必须和将要应用补丁的库为同一库源。故使用版本库来合并两个独立不想关的svn库，无法通过打补丁法实现合并。</p>\n<h3 id=\"方案二：项目模块化合并\"><a href=\"#方案二：项目模块化合并\" class=\"headerlink\" title=\"方案二：项目模块化合并\"></a>方案二：项目模块化合并</h3><hr>\n<p>在PBB Reader中通过项目依赖整合IJK／mupdf／maker</p>\n<ol>\n<li>操作<ol>\n<li>取消Maker原有IJK，mupdf的依赖</li>\n<li>在PBB Reader中配置Maker依赖 ：隐私空间涉及到的阅读功能在Reader中实现</li>\n<li>新需求开发</li>\n</ol>\n</li>\n<li>好处 <ol>\n<li>源码隔离，功能共享，对现有功能的源码无要做任何修改</li>\n<li>项目之间相互独立，便于后续拆分或整合</li>\n<li>更多精力专注代码优化</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"否决方案二，采用手动合并\"><a href=\"#否决方案二，采用手动合并\" class=\"headerlink\" title=\"否决方案二，采用手动合并\"></a>否决方案二，采用手动合并</h4><p>Reader本属于一个播放器，是从PBB应用的lite版，主要业务都是在PBB中实现的，当前需求是让PBB集成到Reader中，如何使用PBB Framework集成，需要暴漏大量的接口，业务层的高耦合性已经违背了封装原则。故作罢。</p>\n<p>突破了合并时遇到的棘手问题，加密崩溃，最终排查出socker传输结构体导致的异常，maker和Reader之间的差异导致合并过程更加困难，最终采用对讲maker中对加密实现文件的封装，在集成到Reader中，即隔离冲突，暴露功能，程序架构集成过程中更便捷合理化。</p>\n<hr>\n<p>相关知识：</p>\n<p>引用日志：<br>git reflog<br>引用日志只存在本地仓库中，只记录第一次clone到之后，在本地仓库中的操作日志，服务器端不会同步这些引用记录，所以在本地无法查看别人的引用日志。</p>\n<h3 id=\"祖先引用\"><a href=\"#祖先引用\" class=\"headerlink\" title=\"祖先引用\"></a>祖先引用</h3><p>几种表达式含义</p>\n<ul>\n<li><p>第一种：^/^^^(多个)<br>HEAD^:指向祖先提交<br>hash值^（^^^） :指向该引用的上一个提交，几个符号就是指向上几个提交<br>^数字:只适用于合并（merge）提交，有多个父提交。如：hash值^2表示第二父提交。第一父提交是指合并时所在的分支，第二父提交是指合并进来的分支。</p>\n</li>\n<li><p>第二种：~数字<br>HEAD~: 指向祖先提交<br>HEAD~数字:指向指向上几个提交<br>hash值^数字:指向该引用的上几个提交</p>\n</li>\n</ul>\n","raw":null,"categories":[{"name":"项目","path":"api/categories/项目.json"},{"name":"重构","path":"api/categories/重构.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"命令","path":"api/tags/命令.json"}]},{"title":"升职必备的技能修炼二 以道御术","slug":"阅读/修炼升职必备的技能二","date":"2017-05-25T18:09:00.000Z","updated":"2017-05-25T18:15:01.000Z","comments":true,"path":"api/articles/阅读/修炼升职必备的技能二.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>“老付”谈论的是目标，所有的方法都是为目标服务的，目标统率人的行为。    </p>\n<ul>\n<li>怎样规划自己的人生？</li>\n<li>怎样树立自己的目标？</li>\n<li>怎样把目标转化成实际的行动？</li>\n<li>怎样提高自己实现目标的能力？</li>\n</ul>\n","raw":null,"categories":[{"name":"阅读","path":"api/categories/阅读.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"}]},{"title":"升职必备的技能修炼","slug":"阅读/修炼升职必备的技能","date":"2017-05-25T16:40:42.000Z","updated":"2017-05-26T11:03:05.000Z","comments":true,"path":"api/articles/阅读/修炼升职必备的技能.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/衣柜整理法.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>焦虑是由于缺乏控制力，以及组织管理、准备和行动不足所造成的。</p>\n<h2 id=\"四象限\"><a href=\"#四象限\" class=\"headerlink\" title=\"四象限\"></a>四象限</h2><p>走出第三象限，将工作重心放进第二象限</p>\n<ol>\n<li>第二象限法则   </li>\n<li>猴子法则：屏蔽干扰的伎俩   </li>\n</ol>\n<h3 id=\"项目与行动的区别\"><a href=\"#项目与行动的区别\" class=\"headerlink\" title=\"项目与行动的区别\"></a>项目与行动的区别</h3><p>项目需要分解为可执行的行动  </p>\n<ol>\n<li>以动词开头的行动  </li>\n<li>添加行动的预期效果  </li>\n</ol>\n<p>下一步行动法，驱动项目的进行。</p>\n<h2 id=\"时间投资\"><a href=\"#时间投资\" class=\"headerlink\" title=\"时间投资\"></a>时间投资</h2><h2 id=\"衣柜整理法\"><a href=\"#衣柜整理法\" class=\"headerlink\" title=\"衣柜整理法\"></a>衣柜整理法</h2><img title=\"衣柜整理法\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/衣柜整理法.png?imageMogr2/2/w/800\">\n<p>收集，处理，组织，回顾，行动<br>2分钟法则<br>无论在什么情况下，我们在工作时都将经历这五个阶段：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/衣柜整理法流程图.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"收集篮：收集一切引起我们注意的事情。\"><a href=\"#收集篮：收集一切引起我们注意的事情。\" class=\"headerlink\" title=\"收集篮：收集一切引起我们注意的事情。\"></a>收集篮：收集一切引起我们注意的事情。</h3><pre><code>收集的关键是将‘一切引起我们注意的东西’放在‘收集篮’里，在清空大脑的同时达到‘心如止水’的境界。\n</code></pre><p>工具军规</p>\n<ol>\n<li>收集工具越少越好</li>\n<li>保证5秒钟内拿出工具</li>\n<li>定期清空工具： 今日事今日毕 ，定期清空，比如每周五清空所有事件迎接周末</li>\n</ol>\n<h3 id=\"处理收集篮：加工处理后，确定它们的实质以及解决方法。\"><a href=\"#处理收集篮：加工处理后，确定它们的实质以及解决方法。\" class=\"headerlink\" title=\"处理收集篮：加工处理后，确定它们的实质以及解决方法。\"></a>处理收集篮：加工处理后，确定它们的实质以及解决方法。</h3><p>2分钟突击原则：指定任务可行性标签<br>不可行：  1. 垃圾事件 2. 将来某时／也许事件  3. 参考资料（处理方法就是分类归档）<br>可执行： 1. 2分钟事件（专治拖延症） 2. 项目事件 3. 委托事件  4. 预约事件  5.待办事件</p>\n<p>原则：  </p>\n<ol>\n<li>从最上面一项开始处理   </li>\n<li>一次只处理一件事情   </li>\n<li>永远不要再放回收集篮（被迫中断的事情除外），争取一次做好   </li>\n</ol>\n<h3 id=\"组织：组织整理，得出结论\"><a href=\"#组织：组织整理，得出结论\" class=\"headerlink\" title=\"组织：组织整理，得出结论\"></a>组织：组织整理，得出结论</h3><p>‘3+1’组合的清单系统<br>材料，<br>收集篮清单（做到每日清理）<br>将某时／也许清单<br>待办事清单<br>项目清单（多任务集合，多个下一步行动）一般会放在待办清单中<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/3+1.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"回顾：\"><a href=\"#回顾：\" class=\"headerlink\" title=\"回顾：\"></a>回顾：</h3><p>解决盲目的问题，我们还需要做到对任务进行回顾。</p>\n<ol>\n<li>让灵感应运而生<br>周回顾的时候恰恰是这样一种状态，对所有的一切都了如指掌，对所有的一切都做了充足的准备。  </li>\n<li>站在3万米的高度去看待问题<br>通过对自己一周工作的重新审视，向自己发问：到底哪些事有利于我更好地接近目标？今后遇到类似的事情应该如何取舍？当我们站在一个新的高度去看待现在的人和事，你会有前所未有的发现。</li>\n<li><p>孵化和修剪你的任务及目标</p>\n</li>\n<li><p>把它们列为我们行动的选择方案。</p>\n</li>\n</ol>\n<h2 id=\"行动：选择最佳方案\"><a href=\"#行动：选择最佳方案\" class=\"headerlink\" title=\"行动：选择最佳方案\"></a>行动：选择最佳方案</h2><p>利用一个月的时间去思考自己的未来发展，然后制定一个‘自上而下’的职业规划；当这个规划确定之后，我会‘自下而上’地搞定自己的工作，并且在工作的过程中随时修订自己的规划，这就是我的工作方式。</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/人生规划的六个高度.png?imageMogr2/2/w/800\">\n<h3 id=\"‘自上而下’的目标系统\"><a href=\"#‘自上而下’的目标系统\" class=\"headerlink\" title=\"‘自上而下’的目标系统\"></a>‘自上而下’的目标系统</h3><p>大卫·艾伦的六个高度去进行检视和规划：  </p>\n<ol>\n<li>原则 （五万米）<br>你首先必须要找个时间好好地思考一下自己的价值观、原则和目标，这是你工作的灵魂所在。如果你以前没有思考过这些，建议你现在就开始思考。我可以和你分享一下我的原则：工作是谋求更好生活的途径，追求无压、流畅、高效的工作。</li>\n<li>愿景（四万米）<br>这里面包含3—5年的工作目标，可以是职位的，也可以是组织能力、协调能力等。在这个层面你需要问自己<br> ◎我的目标是什么？<br> ◎哪些人已经达到了我的这个目标？<br> ◎他们是如何达到目标的？<br> ◎达到这个目标之后我的工作和生活会是怎样的？</li>\n<li><p>目标（三万米）<br>目标是比愿景更细化的东西，通常在一年内就可以有一个阶段性的成果。比如说我现在的目标就是：</p>\n<p> ◎每周通过参加商务聚会来扩展自己的人脉，主动给朋友们打电话来巩固自己的人脉；<br> ◎参加管理学的培训课程或者是参加MBA学习来提高自己的综合能力；<br> ◎每天坚持阅读40分钟，以扩充自己的知识面，并且更深层次地研究自己所在的专属领域。</p>\n</li>\n<li>责任范围（两万米）<br>工作上的角色：如销售、管理、产品开发等；<br>生活中的角色：如家庭、个人财务、精神层面等。<br>要把每一个角色扮演好，就需要执行一些任务，以拉近现实和期望的距离。比如在这个层面我会拿出我负责的项目和产品，看看在开发、销售、管理上是否还有提升的可能性，因为毕竟要把自己责任范围内的事情做得漂亮，才有可能升职或者有其他进一步的发展。</li>\n<li>任务（一万米）<br>所有需要一步以上完成的事情都是一个任务，虽然我们已经有了一个‘自上而下’的目标系统，但是我们仍然要将注意力放在眼前的任务上，比如‘新产品的营销策略’等。</li>\n<li>下一步行动（跑道）<br>这是最细枝末节的事件，我们要将它们全部放进我们的清单，然后逐一完成。谁更关注细节，谁就能获得更大的成功。刚开始我们都在同一个跑道里面绕圈，但是最终只有职业规划清晰的人才会驾车进入快车道，直奔目标而去。”</li>\n</ol>\n","raw":null,"categories":[{"name":"管理","path":"api/categories/管理.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"经历","path":"api/tags/经历.json"}]},{"title":"calibre一站式电子书解决方案","slug":"工具/calibre一站式电子书解决方案","date":"2017-05-25T14:26:15.000Z","updated":"2017-06-28T15:57:36.000Z","comments":true,"path":"api/articles/工具/calibre一站式电子书解决方案.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/calibre.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>Calibre，是一个免费的开源的“一站式”的电子书解决方案，它可以全面满足你的电子书需求。Calibre 是免费的，源代码开放，拥有跨平台的设计。它是一个完整的电子图书馆，包括图书管理，格式转换，新闻，将材料转换为电子书，以及电子书阅读器同步功能、整合进电子图书阅读器。当然它也内置了一个 ePub 格式电子书编辑工具以满足修改电子书的需要。   </p>\n<p>感兴趣的几个功能点：</p>\n<ol>\n<li><p>爬虫功能，即可以支持一键抓取新闻，根据指定的feed订阅源，来制作书籍。<br> 这样便可每天爬取最新消息，发到kindle上看新闻</p>\n</li>\n<li><p>支持kindle书籍，相比kindle应用，它能自由复制书本内容，便于笔记整理。</p>\n</li>\n</ol>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/calibre.png?imageMogr2/2/w/800\">\n","raw":null,"categories":[{"name":"工具","path":"api/categories/工具.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"}]},{"title":"腾讯云docker服务器上部署jira系统","slug":"远程操作mysql数据库","date":"2017-05-24T17:07:47.000Z","updated":"2017-05-24T17:49:46.000Z","comments":true,"path":"api/articles/远程操作mysql数据库.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"腾讯云服务器\"><a href=\"#腾讯云服务器\" class=\"headerlink\" title=\"腾讯云服务器\"></a>腾讯云服务器</h2><ol>\n<li><p>申请账户，体验5天，搭建一个jira服务，还有微信小程序服务</p>\n</li>\n<li><p>需要在服务器上安装docker （腾讯服务器提供了一款支持docker的Ubuntu系统）</p>\n</li>\n<li>想使用daocloud加速器，就要更新docker版本<br>docker run –detach –publish 8080:8080 cptactionhank/atlassian-jira:latest<br><a href=\"http://[dockerhost]:8080\" target=\"_blank\" rel=\"noopener\">http://[dockerhost]:8080</a> and finish the configuration</li>\n</ol>\n<h3 id=\"远程服务器的基本操作\"><a href=\"#远程服务器的基本操作\" class=\"headerlink\" title=\"远程服务器的基本操作\"></a>远程服务器的基本操作</h3><ol>\n<li>登录：<code>ssh -l username 服务ip／域名</code><br> ssh ubuntu@123.<strong><em>.</em>.<em>6   5<em>*</em></em></strong>RtH<br> sudo docker pull cptactionhank/atlassian-jira</li>\n<li>服务器端拷贝文件目录<br> scp -i localDir serveruser@serverip:serverDir</li>\n</ol>\n<h3 id=\"docker下安装mysql数据库镜像\"><a href=\"#docker下安装mysql数据库镜像\" class=\"headerlink\" title=\"docker下安装mysql数据库镜像\"></a>docker下安装mysql数据库镜像</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker pull mysql </span><br><span class=\"line\">sudo docker run --name jiradb -e MYSQL_ROOT_PASSWORD=jiradb -d mysql/mysql-server:latest</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>-name : 容器名<br>MYSQL_ROOT_PASSWORD : 数据库密码<br>-d : 镜像名:tag 版本</p>\n</blockquote>\n<h4 id=\"终端：单行登录mysql\"><a href=\"#终端：单行登录mysql\" class=\"headerlink\" title=\"终端：单行登录mysql\"></a>终端：单行登录mysql</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker exec -it jiradb mysql -ujira -pjira</span><br></pre></td></tr></table></figure>\n<h4 id=\"进入mysql终端-访问数据库\"><a href=\"#进入mysql终端-访问数据库\" class=\"headerlink\" title=\"进入mysql终端,访问数据库\"></a>进入mysql终端,访问数据库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker exec -it jiradb bash</span><br><span class=\"line\">#登录数据库  默认用户root 密码为空，如果前边设置了MYSQL_ROOT_PASSWORD的值，则需要密码</span><br><span class=\"line\">mysql -uroot -p   #登录本地数据库 可以 省略-h参数 -h 127.0.0.1</span><br><span class=\"line\">回车</span><br><span class=\"line\">输入密码：jiradb  #就是$MYSQL_ROOT_PASSWORD的值</span><br><span class=\"line\">即登录</span><br></pre></td></tr></table></figure>\n<h4 id=\"用户权限控制\"><a href=\"#用户权限控制\" class=\"headerlink\" title=\"用户权限控制\"></a>用户权限控制</h4><ol>\n<li><p>查看sql服务器的状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">status;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建用户名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create user jira identified by &apos;jira&apos;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>赋予权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grant all privileges on *.* to &apos;jira&apos;@&apos;%&apos; identified by &apos;jira&apos; with grant option;</span><br><span class=\"line\">grant all privileges on *.* to &apos;jira&apos;@&apos;localhost&apos; identified by &apos;jira&apos; with grant option;</span><br><span class=\"line\">flush privileges;</span><br><span class=\"line\">quit;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"数据库操作\"><a href=\"#数据库操作\" class=\"headerlink\" title=\"数据库操作\"></a>数据库操作</h4><ol>\n<li><p>创建数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create database jiradb character set &apos;UTF8&apos;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看当前数据库名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select database();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>切换指定数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use jiradb;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看数据库表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show tables;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>创建表</p>\n<h5 id=\"jira和数据库关联结果\"><a href=\"#jira和数据库关联结果\" class=\"headerlink\" title=\"jira和数据库关联结果\"></a>jira和数据库关联结果</h5><p>无法通过 docker 中mysql镜像的盒子来实现jira和数据库关联：<br>从另一个容器中的应用来访问jiradb容器中的mysql服务：没成功<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Connect to MySQL from an application in another Docker container</span><br><span class=\"line\">sudo docker run --name jirad --link jiradb:mysql/mysql-server -d cptactionhank/atlassian-jira:latest</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure></p>\n<p>最终采用在ubuntu系统中安装mysql：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$sudo apt-get -y install mysql-server</span><br></pre></td></tr></table></figure></p>\n<p>##问题：Could not reach any registry endpoint<br>安装Linux加速器：<br>curl -sSL <a href=\"https://get.daocloud.io/daotools/set_mirror.sh\" target=\"_blank\" rel=\"noopener\">https://get.daocloud.io/daotools/set_mirror.sh</a> | sh -s <a href=\"http://142900b5.m.daocloud.io\" target=\"_blank\" rel=\"noopener\">http://142900b5.m.daocloud.io</a><br>该脚本可以将 –registry-mirror 加入到你的 Docker 配置文件 /etc/default/docker 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。<br>ubuntu 系统安装daocloud检测工具：<br>curl -sSL <a href=\"https://get.daocloud.io/daomonit/install.sh\" target=\"_blank\" rel=\"noopener\">https://get.daocloud.io/daomonit/install.sh</a> | sh -s d0312f829e9807ee0bf157cdc9c9cca42380395c </p>\n<h3 id=\"更新服务器上的docker\"><a href=\"#更新服务器上的docker\" class=\"headerlink\" title=\"更新服务器上的docker\"></a>更新服务器上的docker</h3><p><a href=\"https://docs.docker.com/engine/installation/linux/ubuntulinux/#/prerequisites-by-ubuntu-version\" target=\"_blank\" rel=\"noopener\">官网教程</a></p>\n<h3 id=\"Update-your-apt-sources\"><a href=\"#Update-your-apt-sources\" class=\"headerlink\" title=\"Update your apt sources\"></a>Update your apt sources</h3><p>To set APT to use packages from the Docker repository:</p>\n<ol>\n<li>Log into your machine as a user with sudo or root privileges.</li>\n<li>Open a terminal window.</li>\n<li><p>Update package information, ensure that APT works with the https method, and that CA certificates are installed.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install apt-transport-https ca-certificates</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Docker资源库<br>|Ubuntu version|    Repository|<br>|—|—-|<br>|Precise 12.04 (LTS)|deb <a href=\"https://apt.dockerproject.org/repo\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo</a> ubuntu-precise main|<br>|Trusty 14.04 (LTS)    |deb <a href=\"https://apt.dockerproject.org/repo\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo</a> ubuntu-trusty main|<br>|Wily 15.10         |deb <a href=\"https://apt.dockerproject.org/repo\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo</a> ubuntu-wily main|<br>|Xenial 16.04 (LTS)    |deb <a href=\"https://apt.dockerproject.org/repo\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo</a> ubuntu-xenial main|</p>\n<blockquote>\n<p>Note: Docker does not provide packages for all architectures. Binary artifacts are built nightly, and you can download them from <a href=\"https://master.dockerproject.org\" target=\"_blank\" rel=\"noopener\">https://master.dockerproject.org</a>. To install docker on a multi-architecture system, add an [arch=…] clause to the entry. Refer to Debian Multiarch wiki for details.</p>\n</blockquote>\n</li>\n<li>导入库<br><repo> = deb <a href=\"https://apt.dockerproject.org/repo\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo</a> ubuntu-precise main<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">\"&lt;REPO&gt;\"</span> | sudo tee /etc/apt/sources.list.d/docker.list</span><br></pre></td></tr></table></figure>\n</repo></li>\n</ol>\n<p>`<br>6.Update the APT package index.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br></pre></td></tr></table></figure></p>\n<p>7.Verify that APT is pulling from the right repository.<br>When you run the following command, an entry is returned for each version of Docker that is available for you to install. Each entry should have the URL <a href=\"https://apt.dockerproject.org/repo/\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo/</a>. The version currently installed is marked with <em>*</em>.The output below is truncated.</p>\n<p>$ apt-cache policy docker-engine</p>\n<p>docker-engine:<br>Installed: 1.12.2-0~trusty<br>Candidate: 1.12.2-0~trusty<br>Version table:<br><em>*</em> 1.12.2-0~trusty 0<br>500 <a href=\"https://apt.dockerproject.org/repo/\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo/</a> ubuntu-trusty/main amd64 Packages<br>100 /var/lib/dpkg/status<br>1.12.1-0~trusty 0<br>500 <a href=\"https://apt.dockerproject.org/repo/\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo/</a> ubuntu-trusty/main amd64 Packages<br>1.12.0-0~trusty 0<br>500 <a href=\"https://apt.dockerproject.org/repo/\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo/</a> ubuntu-trusty/main amd64 Packages</p>\n<p>From now on when you run apt-get upgrade, APT pulls from the new repository.</p>\n<p>To upgrade your kernel and install the additional packages, do the following:</p>\n<p>Open a terminal on your Ubuntu host.<br>Update your package manager.<br>$ sudo apt-get update<br>Install both the required and optional packages.<br>$ sudo apt-get install linux-image-generic-lts-trusty<br>Repeat this step for other packages you need to install.<br>Reboot your host to use the updated kernel.<br>$ sudo reboot<br>After your system reboots, go ahead and install Docker.</p>\n<p>Install the latest version<br>Make sure you have satisfied all the prerequisites, then follow these steps.</p>\n<p>Note: For production systems, it is recommended that you install a specific version so that you do not accidentally update Docker. You should plan upgrades for production systems carefully.<br>Log into your Ubuntu installation as a user with sudo privileges.<br>Update your APT package index.<br>$ sudo apt-get update<br>Install Docker.<br>$ sudo apt-get install docker-engine<br>Start the docker daemon.<br>$ sudo service docker start<br>Verify that docker is installed correctly by running the hello-world image.<br>$ sudo docker run hello-world<br>This command downloads a test image and runs it in a container. When the container runs, it prints an informational message and exits.</p>\n","raw":null,"categories":[{"name":"docker","path":"api/categories/docker.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"}]},{"title":"iOS和OSX集成gitAPI","slug":"开源库/iOS和OSX集成gitAPI","date":"2017-05-17T17:33:46.000Z","updated":"2017-09-24T09:18:26.000Z","comments":true,"path":"api/articles/开源库/iOS和OSX集成gitAPI.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/ObjectiveGitxiaoguo.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>在项目中使用git submodule工具集成子项目ObjectiveGit</p>\n<h4 id=\"在新项目中使用git-submodule集成gitAPI\"><a href=\"#在新项目中使用git-submodule集成gitAPI\" class=\"headerlink\" title=\"在新项目中使用git submodule集成gitAPI\"></a>在新项目中使用git submodule集成gitAPI</h4><p>参考官方提供的两个demo</p>\n<ul>\n<li><p>OS X: <a href=\"https://github.com/Abizern/CommitViewer\" target=\"_blank\" rel=\"noopener\">CommitViewer</a>   </p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/ObjectiveGitxiaoguo.png?imageMogr2/2/w/800\">\n</li>\n<li><p>iOS: <a href=\"https://github.com/Raekye/ObjectiveGit-iOS-Example\" target=\"_blank\" rel=\"noopener\">ObjectiveGit iOS Example</a></p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule add https://github.com/libgit2/objective-git.git External/ObjectiveGit</span><br><span class=\"line\">如果之前配置过，直接更新：</span><br><span class=\"line\">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>cd External/ObjectiveGit</code>，然后执行<code>./script/bootstrap</code>安装相关依赖.</li>\n<li>拖动 <code>ObjectiveGitFramework.xcodeproj</code> 文件 到iOS/OSX项目导航窗口 .</li>\n<li>在build Phases中配置APP的依赖，根据平台添加<code>ObjectiveGit-Mac</code> or <code>ObjectiveGit-iOS</code>.</li>\n<li>APP通过连接器链接 <code>ObjectiveGit.framework</code>.</li>\n<li>在build setting中“Header Search Paths” (<code>HEADER_SEARCH_PATHS</code>)设置<code>libgit2</code>头文件在项目的路径，例如：<code>External/ObjectiveGit/External/libgit2/include</code>. </li>\n<li>Add a new “Copy Files” build phase, set the destination to “Frameworks” and add <code>ObjectiveGit.framework</code> to the list. This will package the framework with your application as an embedded private framework.</li>\n</ol>\n<ul>\n<li>It’s hard to tell the difference between the platforms, but the Mac framework is in <code>build/Debug</code> whereas the iOS framework is in <code>build/Debug-iphoneos</code></li>\n</ul>\n<ol>\n<li>Don’t forget to <code>#import &lt;ObjectiveGit/ObjectiveGit.h&gt;</code> or <code>@import ObjectiveGit;</code> as you would with any other framework.</li>\n</ol>\n<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ul>\n<li>类变量关联.xib控件text值    </li>\n<li>字体样式菜单来改变字体样式    <h4 id=\"在OSX中设置控件的Bindings代替IBOutlet\"><a href=\"#在OSX中设置控件的Bindings代替IBOutlet\" class=\"headerlink\" title=\"在OSX中设置控件的Bindings代替IBOutlet\"></a>在OSX中设置控件的Bindings代替IBOutlet</h4></li>\n</ul>\n<p>先关联再使用属性依赖特性来同步数据</p>\n<h5 id=\"类变量关联-xib控件text值\"><a href=\"#类变量关联-xib控件text值\" class=\"headerlink\" title=\"类变量关联.xib控件text值\"></a>类变量关联.xib控件text值</h5><p><a href=\"http://stackoverflow.com/questions/8161012/referencing-bindings-in-connections-inspector\" target=\"_blank\" rel=\"noopener\">相关参考</a>      </p>\n<ol>\n<li>选中NSTextField的bindings检查器面板   </li>\n<li>在<code>value</code>单元内设置bind to 的值，通过下拉框选中 <code>Delegate</code>      </li>\n<li>Model key Path:输入类变量的名称。    <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/NSTextFieldBindings.png?imageMogr2/2/w/800\">   </li>\n<li>切换到 NSTextField／Delegate的Connections检查器面板,就会看到已经建立了关联：     <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/textFieldConections.png?imageMogr2/2/w/800\">   <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/delegatebinding.png?imageMogr2/2/w/800\">   \n</li>\n</ol>\n<h5 id=\"依赖属性\"><a href=\"#依赖属性\" class=\"headerlink\" title=\"依赖属性\"></a>依赖属性</h5><p>Foundation 框架提供的表示属性依赖的机制如下：<br>参考<a href=\"https://github.com/huos3203/BookObjc/blob/master/publish/issue7/issue-7-3-DJBen.md#依赖的属性\" target=\"_blank\" rel=\"noopener\">属性的依赖</a><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class=\"built_in\">NSString</span> *)key</span><br><span class=\"line\"></span><br><span class=\"line\">或</span><br><span class=\"line\">+ (<span class=\"built_in\">NSSet</span> *)keyPathsForValuesAffecting&lt;键名&gt;</span><br></pre></td></tr></table></figure></p>\n<p>将属性关联起来，这样就可以将类变量的值同步至UI控件中了：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class=\"built_in\">NSString</span> *)key </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSSet</span> *keySet = [<span class=\"built_in\">NSSet</span> setWithObjects:<span class=\"string\">@\"commit\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([key isEqualToString:<span class=\"string\">@\"messageTitle\"</span>] ||</span><br><span class=\"line\">        [key isEqualToString:<span class=\"string\">@\"messageDetails\"</span>] ||</span><br><span class=\"line\">        [key isEqualToString:<span class=\"string\">@\"author\"</span>] ||</span><br><span class=\"line\">        [key isEqualToString:<span class=\"string\">@\"date\"</span>])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> keySet;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"实现字体样式菜单来改变字体样式\"><a href=\"#实现字体样式菜单来改变字体样式\" class=\"headerlink\" title=\"实现字体样式菜单来改变字体样式\"></a>实现字体样式菜单来改变字体样式</h4><ol>\n<li>在xib中拖一个Object并设置为NSFontManager.h类的实现。   </li>\n<li>选中NSFontManager.h的connections面板，将Received Actions关联到对应的菜单项即可  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/fontManage.png?imageMogr2/2/w/800\">\n</li>\n</ol>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"API","path":"api/categories/API.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"}]},{"title":"使用sourceTree与git-subtree工具","slug":"git/使用sourceTree与git-subtree工具","date":"2017-05-17T11:23:22.000Z","updated":"2017-05-17T17:52:28.000Z","comments":true,"path":"api/articles/git/使用sourceTree与git-subtree工具.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/gittree.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"git-subtree-合并\"><a href=\"#git-subtree-合并\" class=\"headerlink\" title=\"git subtree 合并\"></a>git subtree 合并</h3><p>git subtree：合并策略，通过git subtree命令能将依赖库某分支合并到主项目的分支中，在开发过程中，只需对主项目分支进行统一管理。</p>\n<h4 id=\"创建合并subtree-add命令\"><a href=\"#创建合并subtree-add命令\" class=\"headerlink\" title=\"创建合并subtree add命令\"></a>创建合并subtree add命令</h4><p>命令如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;git subtree&apos; add -P &lt;prefix&gt; &lt;commit&gt;</span><br><span class=\"line\">&apos;git subtree&apos; add -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"两步走\"><a href=\"#两步走\" class=\"headerlink\" title=\"两步走\"></a>两步走</h5><p>先fetch库再subtree add合并</p>\n<ol>\n<li><p>先将依赖库fetch到本地仓库中</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建lib的远程版本库: </span><br><span class=\"line\">git init --bare lib-rep</span><br><span class=\"line\"><span class=\"comment\">#-f：远端库添加后立即执行fetch操作</span></span><br><span class=\"line\">git remote add -f librepo ../lib-rep</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过git subtree命令将依赖库合并到主项目中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git subtree add -P lib librepo master</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"squash合并法\"><a href=\"#squash合并法\" class=\"headerlink\" title=\"squash合并法\"></a>squash合并法</h5><p><code>--squash</code>: 适用于add/pull/merge子命令。先合并引用库的更新记录，将合并结果并到主项目中。<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git subtree add --prefix=themes/jacman --squash https://huos3203@github.com/huos3203/jacman.git master</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"subtree其他命令\"><a href=\"#subtree其他命令\" class=\"headerlink\" title=\"subtree其他命令\"></a>subtree其他命令</h4><p>git subtree支持创建(add)之外,还支持更新(pull),推送(push),合并(merge),抽离(split)以下命令:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'git subtree'</span> pull -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br><span class=\"line\"><span class=\"string\">'git subtree'</span> push -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br><span class=\"line\"><span class=\"string\">'git subtree'</span> merge -P &lt;prefix&gt; &lt;commit&gt;</span><br><span class=\"line\"><span class=\"string\">'git subtree'</span> split -P &lt;prefix&gt; [OPTIONS] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure></p>\n<p>从子树库中拉取最新代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git subtree pull --prefix=themes/jacman --squash https://huos3203@github.com/huos3203/jacman.git master</span><br></pre></td></tr></table></figure></p>\n<p>将自己的代码发布到子树库:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git subtree push --prefix=themes/jacman --squash https://huos3203@github.com/huos3203/jacman.git master</span><br></pre></td></tr></table></figure></p>\n<p>相关参数：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-q | --quiet</span><br><span class=\"line\">-d | --debug</span><br><span class=\"line\">-P &lt;prefix&gt; | --prefix=&lt;prefix&gt;      引用库对应的本地目录</span><br><span class=\"line\">-m &lt;message&gt; | --message=&lt;message&gt;   适用于add/pull/merge子命令。设置产生的合并提交的说明文本</span><br><span class=\"line\">--squash                             适用于add/pull/merge子命令。先合并引用库的更新记录，将合并结果并到主项目中。</span><br><span class=\"line\">使用此选项时，subtree add/pull会产生两个提交版本：一个是子项目的历史记录，一个是Merge操作。好处是可以让主项目历史记录很规整，缺点是子项目更新时常常需要解决冲突。一个更好的解决方案是：单独建一个分支进行--no-squash的subtree更新，然后再--squash合并到主分支。每次在此分支做操作前都需要先把主分支合并进来。参考：http://www.fwolf.com/blog/post/246</span><br></pre></td></tr></table></figure></p>\n<p>split子命令选项：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--annotate=&lt;annotation&gt;              创建合成历史时有可能形成内容不同但提交信息完全相同的提交版本，使用这个选项在每个提交消息前加上此前缀用来区分。</span><br><span class=\"line\">-b &lt;branch&gt; | --branch=&lt;branch&gt;      创建合成的提交历史时，创建此参数指定的新分支包含生成的合成历史。&lt;branch&gt;必须是还不存在的。</span><br><span class=\"line\">--onto=&lt;onto&gt;</span><br><span class=\"line\">--rejoin</span><br><span class=\"line\">--ignore-joins</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用sourcetree管理\"><a href=\"#使用sourcetree管理\" class=\"headerlink\" title=\"使用sourcetree管理\"></a>使用sourcetree管理</h4><ol>\n<li>配置 subtree<br>菜单：Repository -&gt; Add/Link subtree…(添加／链接子树…)<br>在左边栏的SUBTREES(子树)中显示：<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/gittree.png?imageMogr2/2/w/800\"></li>\n<li>拉取依赖库的最新代码<br>在右边栏右击已存在的subtree，并选择 pull subtree…菜单项：<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/gitsubtreepull.png?imageMogr2/2/w/800\">\n第二步的功能代码如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git -c subtree pull -P themes/.jacman --squash https://huos3203@github.com/huos3203/jacman.git master</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"submodule嵌套\"><a href=\"#submodule嵌套\" class=\"headerlink\" title=\"submodule嵌套\"></a>submodule嵌套</h3><p>git submodule：嵌套策略，将依赖库直接clone到主项目目录中，通过配置.submodule文件来隔离管理主项目／子依赖库的版本。<br>添加子模块：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule add https://github.com/libgit2/objective-git.git External/ObjectiveGit</span><br></pre></td></tr></table></figure></p>\n<p>更新子模块：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>submodule那样每次子项目修改了后要init和update.万一哪次没update就直接”commit -a” 或者 “add .” 全commit上去就悲剧了。</p>\n</blockquote>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"IDE","path":"api/categories/IDE.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"}]},{"title":"Xcode8插件制作替代Alcatraz","slug":"xcode/Xcode8插件制作替代Alcatraz","date":"2017-05-15T14:09:30.000Z","updated":"2017-06-23T10:51:21.000Z","comments":true,"path":"api/articles/xcode/Xcode8插件制作替代Alcatraz.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/插件架构图.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><ol>\n<li>Xcode7插件工具Alcatraz<br>开发者可以在Xcode运行的时候通过注入代码去实现插件的功能。插件可以在一个Alcatraz这个优秀的APP上面提交和分发。</li>\n<li>Xcode8编辑源码的插件Xcode source editor extensions<br>Xcode 8验证每个库和包，以防止恶意代码未经您的许可运行。苹果公司在今年的WWDC上宣布了可以通过开发<code>Xcode source editor extensions</code>来扩展现有的源代码编辑功能。<br>当Xcode启动的时候，先前通过<code>Alcatraz</code>安装的插件不会再被加载。</li>\n</ol>\n<h2 id=\"源码编辑器插件\"><a href=\"#源码编辑器插件\" class=\"headerlink\" title=\"源码编辑器插件\"></a>源码编辑器插件</h2><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/插件架构图.png?imageMogr2/2/w/800\">\n<h3 id=\"Info-plist文件\"><a href=\"#Info-plist文件\" class=\"headerlink\" title=\"Info.plist文件\"></a>Info.plist文件</h3><p>Source Editor Command是命令默认的名字。开发者可以在extension的Info.plist文件里面修改。打开之后修改为 Clean Syntax</p>\n<h3 id=\"解析插件启动类SourceEditorExtension-swift\"><a href=\"#解析插件启动类SourceEditorExtension-swift\" class=\"headerlink\" title=\"解析插件启动类SourceEditorExtension.swift\"></a>解析插件启动类SourceEditorExtension.swift</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Foundation</span><br><span class=\"line\"><span class=\"keyword\">import</span> XcodeKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SourceEditorExtension</span>: <span class=\"title\">NSObject</span>, <span class=\"title\">XCSourceEditorExtension</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1. 启动extension被调用，自定义相关操作</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">extensionDidFinishLaunching</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//commandDefinitions属性的getter方法可以动态的展示或是隐藏特定的指令</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> commandDefinitions: [[<span class=\"type\">XCSourceEditorCommandDefinitionKey</span>: <span class=\"type\">AnyObject</span>]]&#123;<span class=\"keyword\">return</span> []&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"解析插件核心类SourceEditorCommand-swift\"><a href=\"#解析插件核心类SourceEditorCommand-swift\" class=\"headerlink\" title=\"解析插件核心类SourceEditorCommand.swift\"></a>解析插件核心类SourceEditorCommand.swift</h3><p>在这个文件里面可以实现extension的相关逻辑<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SourceEditorCommand</span>: <span class=\"title\">NSObject</span>, <span class=\"title\">XCSourceEditorCommand</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//当通过Xcode菜单键调用插件时调用，实现插件功能的主体</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">perform</span><span class=\"params\">(with invocation: XCSourceEditorCommandInvocation,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               completionHandler: @escaping <span class=\"params\">(Error?)</span></span></span> -&gt; <span class=\"type\">Void</span> ) -&gt; <span class=\"type\">Void</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 正则匹配含有 闭包 的文本</span></span><br><span class=\"line\">       <span class=\"keyword\">var</span> updatedLineIndexes = [<span class=\"type\">Int</span>]()</span><br><span class=\"line\">       <span class=\"keyword\">for</span> lineIndex <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; invocation.buffer.lines.<span class=\"built_in\">count</span></span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           <span class=\"keyword\">let</span> line = invocation.buffer.lines[lineIndex] <span class=\"keyword\">as</span>! <span class=\"type\">NSString</span></span><br><span class=\"line\">           <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">let</span> results = <span class=\"keyword\">try</span> findClosureSyntax(line: line)</span><br><span class=\"line\">               <span class=\"comment\">//简化所有闭包语法格式：移除闭包里面括号</span></span><br><span class=\"line\">               <span class=\"number\">_</span> = results.<span class=\"built_in\">map</span> &#123; result <span class=\"keyword\">in</span></span><br><span class=\"line\">                   <span class=\"keyword\">let</span> cleanLine = line.remove(characters: [<span class=\"string\">\"(\"</span>, <span class=\"string\">\")\"</span>], <span class=\"keyword\">in</span>: result.range)</span><br><span class=\"line\">                   updatedLineIndexes.append(lineIndex)</span><br><span class=\"line\">                   invocation.buffer.lines[lineIndex] = cleanLine</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">               completionHandler(error <span class=\"keyword\">as</span> <span class=\"type\">NSError</span>)</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       completionHandler(<span class=\"literal\">nil</span>)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">//使用正则表达式去遍历每一行代码是否含有闭包</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findClosureSyntax</span><span class=\"params\">(line:NSString)</span></span> <span class=\"keyword\">throws</span> -&gt;[<span class=\"type\">NSTextCheckingResult</span>]</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       <span class=\"keyword\">let</span> regex =  <span class=\"keyword\">try</span> <span class=\"type\">NSRegularExpression</span>(pattern: <span class=\"string\">\"\\\\&#123;.*\\\\(.+\\\\).+in\"</span>, options: .caseInsensitive)</span><br><span class=\"line\">       <span class=\"keyword\">let</span> range = <span class=\"type\">NSRange</span>(<span class=\"number\">0</span> ..&lt; line.length)</span><br><span class=\"line\">       <span class=\"keyword\">return</span> regex.matches(<span class=\"keyword\">in</span>: line <span class=\"keyword\">as</span> <span class=\"type\">String</span>, options: .reportProgress, range: range)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"一个方法两个参数\"><a href=\"#一个方法两个参数\" class=\"headerlink\" title=\"一个方法两个参数\"></a>一个方法两个参数</h4><ol>\n<li><p>方法<br>当通过Xcode菜单键调用插件时：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perform(with:completionHandler:)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>两个参数<br><code>buffer</code>属性：访问当前选中的文件源代码，<code>XCSourceEditorCommandInvocation</code>对象的<code>buffer</code>属性；<br><code>completionhandler</code>：将会以参数为nil进行调用，否则将会给它传递一个<code>NSError</code>实例作为参数。</p>\n</li>\n</ol>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><ol>\n<li>选择scheme后编译运行自定义的extensions插件</li>\n<li>选择测试安装插件的Xcode<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/extensionsApp.png?imageMogr2/2/w/800\"></li>\n<li>点击run按钮会单独启动一个全新的Xcode<br>在新的Xcode实例中，创建一个新的工程或是打开一个存在的工程。</li>\n<li>然后执行Editor &gt; Clean Closure &gt; Source Editor Command，需要确保在当前的文件里面含有一个闭包。这样就可以看到如下的效果，刚才开发的extension工作了！<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcodeAPP.gif?imageMogr2/2/w/800\">\n</li>\n</ol>\n<h2 id=\"命令快捷键\"><a href=\"#命令快捷键\" class=\"headerlink\" title=\"命令快捷键\"></a>命令快捷键</h2><p>设置快捷键去自动调用Clean Syntax命令</p>\n<ol>\n<li>打开Xcode的Preferences，选择Key Bindings ;</li>\n<li>搜索Clean Syntax，点击右边然后输入快捷键，例如：Command-Alt-Shift-+。<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/KeyBindings.png?imageMogr2/2/w/800\">\n</li>\n</ol>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"插件","path":"api/categories/插件.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"}]},{"title":"RxSwift基本概念","slug":"开源库/RxSwift基本概念","date":"2017-03-03T13:01:41.000Z","updated":"2017-09-24T09:18:26.000Z","comments":true,"path":"api/articles/开源库/RxSwift基本概念.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"FRP函数式反应型编程\"><a href=\"#FRP函数式反应型编程\" class=\"headerlink\" title=\"FRP函数式反应型编程\"></a>FRP函数式反应型编程</h2><p>Functional Reactive Programming ， 缩写为 FRP</p>\n<h2 id=\"函数编程\"><a href=\"#函数编程\" class=\"headerlink\" title=\"函数编程\"></a>函数编程</h2><h3 id=\"函数是第一等公民\"><a href=\"#函数是第一等公民\" class=\"headerlink\" title=\"函数是第一等公民\"></a>函数是第一等公民</h3><p>所谓 第一等公民 (first class) ，指的是函数与其他数据类型一样，处于平等地位。既可以赋值给其他变量，也可以作为参数传入另一个函数，或者作为别的函数的返回值。<br>将数组通过指定的函数映射成另一个数组，例如将<code>increment函数</code>作为参数传入数组的<code>map函数</code>:<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> increment = &#123; <span class=\"keyword\">return</span> $<span class=\"number\">0</span> + <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].<span class=\"built_in\">map</span>(increment)  <span class=\"comment\">// [2,3,4]</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"函数式的函数\"><a href=\"#函数式的函数\" class=\"headerlink\" title=\"函数式的函数\"></a>函数式的函数</h3><h4 id=\"map-映射函数\"><a href=\"#map-映射函数\" class=\"headerlink\" title=\"map 映射函数\"></a>map 映射函数</h4><p><code>map</code> 可以把一个数组按照一定的规则转换成另一个数组，定义如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">map</span>&lt;U&gt;<span class=\"params\">(transform: <span class=\"params\">(T)</span></span></span> -&gt; <span class=\"type\">U</span>) -&gt; <span class=\"type\">U</span>[]</span><br><span class=\"line\"><span class=\"comment\">//效果</span></span><br><span class=\"line\">[ x1, x2, ... , xn].<span class=\"built_in\">map</span>(f) -&gt; [f(x1), f(x2), ... , f(xn)]</span><br></pre></td></tr></table></figure><br><code>map</code>接受一个把 <code>T</code> 类型的转换成 <code>U</code> 类型的<code>transform</code>函数，最终返回的是 <code>U 类型的集合</code>。</p>\n<h4 id=\"filter-筛选函数\"><a href=\"#filter-筛选函数\" class=\"headerlink\" title=\"filter 筛选函数\"></a>filter 筛选函数</h4><p><code>filter</code>通过在闭包中对每个元素进行逻辑运算，来排除为<code>false</code>的元素<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">filter</span><span class=\"params\">(includeElement: <span class=\"params\">(T)</span></span></span> -&gt; <span class=\"type\">Bool</span>) -&gt; [<span class=\"type\">T</span>]</span><br><span class=\"line\"><span class=\"comment\">//实现</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oldArray = [<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">45</span>,<span class=\"number\">32</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> filteredArray  = oldArray.<span class=\"built_in\">filter</span>(&#123; <span class=\"keyword\">return</span> $<span class=\"number\">0</span> &gt; <span class=\"number\">30</span> &#125;)</span><br><span class=\"line\"><span class=\"built_in\">println</span>(filteredArray) <span class=\"comment\">// [45, 32]</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"reduce-迭代函数\"><a href=\"#reduce-迭代函数\" class=\"headerlink\" title=\"reduce 迭代函数\"></a>reduce 迭代函数</h4><p><code>reduce</code>函数把<code>U</code>类型集合中的所有元素，以<code>initial</code>为初始值，按照<code>combine</code>规则，逐个迭代并返回一个U类型的对象。<br>定义如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reduce</span>&lt;U&gt;<span class=\"params\">(initial: U, combine: <span class=\"params\">(U, T)</span></span></span> -&gt; <span class=\"type\">U</span>) -&gt; <span class=\"type\">U</span></span><br></pre></td></tr></table></figure><br>reduce 有两个参数，<code>initial</code>是初始值，<code>combine</code>定义规则闭包，闭包有两个输入的参数，一个是原始值，一个是新进来的值，闭包返回的新值作为下一轮循环中的<code>initial</code>值。<br>写几个小例子试一下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> oldArray = [<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">45</span>,<span class=\"number\">32</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"number\">0</span></span><br><span class=\"line\">sum = oldArray.<span class=\"built_in\">reduce</span>(<span class=\"number\">0</span>,&#123;$<span class=\"number\">0</span> + $<span class=\"number\">1</span>&#125;) <span class=\"comment\">// 0+10+20+45+32 = 107</span></span><br><span class=\"line\">sum = oldArray.<span class=\"built_in\">reduce</span>(<span class=\"number\">1</span>,&#123;$<span class=\"number\">0</span> + $<span class=\"number\">1</span>&#125;) <span class=\"comment\">// 1+10+20+45+32 = 108</span></span><br><span class=\"line\">sum = oldArray.<span class=\"built_in\">reduce</span>(<span class=\"number\">5</span>,&#123;$<span class=\"number\">0</span> * $<span class=\"number\">1</span>&#125;) <span class=\"comment\">// 5*10*20*45*32 = 1440000</span></span><br><span class=\"line\">sum = oldArray.<span class=\"built_in\">reduce</span>(<span class=\"number\">0</span>,+) <span class=\"comment\">// 0+10+20+45+32 = 107</span></span><br><span class=\"line\"><span class=\"built_in\">println</span>(sum)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"函数式和指令式的比较\"><a href=\"#函数式和指令式的比较\" class=\"headerlink\" title=\"函数式和指令式的比较\"></a>函数式和指令式的比较</h3><h2 id=\"响应式编程-Reactive\"><a href=\"#响应式编程-Reactive\" class=\"headerlink\" title=\"响应式编程 - Reactive\"></a>响应式编程 - Reactive</h2><p>在日常开发中，我们经常需要监听某个属性，并且针对该属性的变化做一些处理。比如以下几个场景：</p>\n<ol>\n<li>用户在输入邮箱的时候，监测输入的内容并在界面上提示是否符合邮箱规范。</li>\n<li>用户在修改用户名之后，所有显示用户名的界面都要改为新的用户名。<br>外部输入信号的变化、事件的发生，这些都是典型的外部环境变化。根据外部环境的变化进行响应处理，直观上来讲像是一种自然地反应。我们可以将这种自动对变化作出响应的能力称为反应能力 (Reactive) 。</li>\n</ol>\n<p>那么什么是反应型编程呢？</p>\n<pre><code>Reactive programming is programming with asynchronous data streams.\n反应型编程是异步数据流的编程。\n</code></pre><p>对于移动端来说，异步数据流的概念并不陌生，变量、点击事件、属性、缓存，这些就可以成为数据流。<br>我们可以通过一些简单的 ASCII 字符来演示如何将事件转换成数据流：<br>    –a—b-c—d—X—|–&gt;<br>    a, b, c, d 是具体的值，代表了某个事件<br>    X 表示发生了一个错误<br>    | 是这个流已经结束了的标记<br>    ———-&gt; 是时间轴<br>比如我们要统计用户点击鼠标的次数，那么可以这样：<br>clickStream:    —c—-c–c—-c——c–&gt;<br>                vvvvv map(c becomes 1) vvvv<br>                —1—-1–1—-1——1–&gt;<br>                vvvvvvvvv scan(+) vvvvvvvvv<br>counterStream:  —1—-2–3—-4——5–&gt;<br>反应型编程就是基于这些数据流的编程。而函数式编程则相当于提供了一个工具箱，可以方便的对数据流进行合并、创建和过滤等操作。</p>\n<h2 id=\"swift-函数式编程\"><a href=\"#swift-函数式编程\" class=\"headerlink\" title=\"swift 函数式编程\"></a>swift 函数式编程</h2><p>Swift 是苹果公司在 2014 年推出的编程语言，用于编写 iOS 和 OS X 应用程序。它吸收了很多其它语言的语法特性，例如闭包、元组、泛型、结构体等等，这使得它的语法简洁而灵活。<br>Swift 本身并不是一门函数式语言，不过有一些函数式的方法和特性</p>\n<ol>\n<li>map reduce 等函数式函数</li>\n<li>函数是一等公民</li>\n<li>模式匹配<br>我们并不能因为 Swift 中的一些函数式特性就把它归为函数式语言，但是我们可以利用这些特性进行函数式 Style 的编程。</li>\n</ol>\n<h1 id=\"RxSwift-响应式编程\"><a href=\"#RxSwift-响应式编程\" class=\"headerlink\" title=\"RxSwift 响应式编程\"></a>RxSwift 响应式编程</h1><p><a href=\"https://github.com/ReactiveX/RxSwift/tree/master/Rx.playground\" target=\"_blank\" rel=\"noopener\">Rx.playground</a></p>\n<h2 id=\"Observable观察者模式\"><a href=\"#Observable观察者模式\" class=\"headerlink\" title=\"Observable观察者模式\"></a>Observable观察者模式</h2><p>Rx 的基础：<code>Observable</code> ， <code>Observable&lt;Element&gt;</code> 是观察者模式中可观察的对象，相当于一个事件序列 (GeneratorType)。<br>支持订阅的事件序列，在下文简称为<code>订阅源</code>或<code>可观察者</code>。<br>订阅源的事件队列中包括三种事件类型：</p>\n<ol>\n<li><code>.Next(value)</code>: 表示新的事件数据。</li>\n<li><code>.Completed</code>: 表示事件序列的完结。</li>\n<li><code>.Error</code>: 同样表示完结，但是代表异常导致的完结。</li>\n</ol>\n<h3 id=\"新建订阅源几种快捷方法\"><a href=\"#新建订阅源几种快捷方法\" class=\"headerlink\" title=\"新建订阅源几种快捷方法\"></a>新建订阅源几种快捷方法</h3><ol>\n<li><code>empty</code>是一个空的序列，它只发送 <code>.Completed</code> 消息。<figure class=\"highlight swift\"><figcaption><span>Observable+Creation.swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">empty</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Observable</span>&lt;<span class=\"type\">E</span>&gt;</span><br><span class=\"line\">example(<span class=\"string\">\"empty\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> emptySequence: <span class=\"type\">Observable</span>&lt;<span class=\"type\">Int</span>&gt; = empty()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> subscription = emptySequence.subscribe &#123; event <span class=\"keyword\">in</span></span><br><span class=\"line\">                                                <span class=\"built_in\">print</span>(event)</span><br><span class=\"line\">                                            &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- empty example ---</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure></li>\n<li><code>never</code> 是没有任何元素、也不会发送任何事件的空序列。<figure class=\"highlight swift\"><figcaption><span>Observable+Creation.swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">- returns: An observable sequence whose observers will never get called.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">never</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Observable</span>&lt;<span class=\"type\">E</span>&gt;</span><br></pre></td></tr></table></figure></li>\n<li><code>just</code> 是只包含一个元素的序列，它会先发送 <code>.Next(value)</code> ，然后发送 <code>.Completed</code><figure class=\"highlight swift\"><figcaption><span>Observable+Creation.swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">Returns an observable sequence that contains a single element.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">just</span><span class=\"params\">(<span class=\"number\">_</span> element: E)</span></span> -&gt; <span class=\"type\">Observable</span>&lt;<span class=\"type\">E</span>&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"type\">Just</span>(element: element)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>sequenceOf</code> 可以把一系列元素转换成订阅源<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sequenceOfElements<span class=\"comment\">/* : Observable&lt;Int&gt; */</span> = sequenceOf(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure></li>\n<li><code>asObservable方法</code> 将遵守<code>ObservableType</code>协议的对象转为可观察者序列<figure class=\"highlight swift\"><figcaption><span>ObservableType.swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">ObservableType</span> : <span class=\"title\">ObservableConvertibleType</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//Default implementation of converting `ObservableType` to `Observable`.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">asObservable</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Observable</span>&lt;<span class=\"type\">E</span>&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> sequenceFromArray = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].asObservable()</span><br></pre></td></tr></table></figure></li>\n<li><code>failWith</code>创建一个没有元素的序列，只会发送失败 (<code>.Error</code>) 事件。<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> error = <span class=\"type\">NSError</span>(domain: <span class=\"string\">\"Test\"</span>, code: -<span class=\"number\">1</span>, userInfo: <span class=\"literal\">nil</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> erroredSequence: <span class=\"type\">Observable</span>&lt;<span class=\"type\">Int</span>&gt; = failWith(error)</span><br><span class=\"line\"><span class=\"keyword\">let</span> subscription = erroredSequence.subscribe &#123; event <span class=\"keyword\">in</span> <span class=\"built_in\">print</span>(event)&#125;</span><br><span class=\"line\">--- failWith example ---</span><br><span class=\"line\"><span class=\"type\">Error</span>(<span class=\"type\">Error</span> <span class=\"type\">Domain</span>=<span class=\"type\">Test</span> <span class=\"type\">Code</span>=-<span class=\"number\">1</span> <span class=\"string\">\"The operation couldn’t be completed. (Test error -1.)\"</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"create自定义订阅源\"><a href=\"#create自定义订阅源\" class=\"headerlink\" title=\"create自定义订阅源\"></a>create自定义订阅源</h3><p><code>create</code> 可以通过闭包创建序列，通过 <code>.on(e: Event)</code> 添加可观察者事件。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"create\"</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> myJust = &#123; (singleElement: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Observable</span>&lt;<span class=\"type\">Int</span>&gt; <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> create &#123; observer <span class=\"keyword\">in</span></span><br><span class=\"line\">                observer.on(.<span class=\"type\">Next</span>(singleElement))</span><br><span class=\"line\">                observer.on(.<span class=\"type\">Completed</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"type\">NopDisposable</span>.instance</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> subscription = myJust(<span class=\"number\">5</span>).subscribe &#123; event <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(event)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- create example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"deferred订阅源的懒加载\"><a href=\"#deferred订阅源的懒加载\" class=\"headerlink\" title=\"deferred订阅源的懒加载\"></a>deferred订阅源的懒加载</h3><p><code>deferred</code>表示当有有新增订阅者第一次订阅了该订阅源时，订阅源才会被创建，且每个订阅者订阅的对象都是内容相同而完全独立的序列。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"TestDeferred\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value: <span class=\"type\">String</span>? = <span class=\"literal\">nil</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> subscription: <span class=\"type\">Observable</span>&lt;<span class=\"type\">String</span>?&gt; = deferred &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> just(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// got value</span></span><br><span class=\"line\">    value = <span class=\"string\">\"Hello!\"</span></span><br><span class=\"line\">    subscription.subscribe &#123; event <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(event)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- <span class=\"type\">TestDeferred</span> example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">Optional</span>(<span class=\"string\">\"Hello!\"</span>))</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"几种特殊类型的订阅源\"><a href=\"#几种特殊类型的订阅源\" class=\"headerlink\" title=\"几种特殊类型的订阅源\"></a>几种特殊类型的订阅源</h2><p><code>Subject</code> 可以看做是一种代理和桥梁。它既是订阅者又是订阅源，这意味着它既可以订阅其他 <code>Observable 对象</code>，同时又可以对它的订阅者们发送事件。</p>\n<h3 id=\"PublishSubject-向所有订阅者发送事件队列\"><a href=\"#PublishSubject-向所有订阅者发送事件队列\" class=\"headerlink\" title=\"PublishSubject 向所有订阅者发送事件队列\"></a>PublishSubject 向所有订阅者发送事件队列</h3><p>当<code>PublishSubject</code>类型订阅源事件队列中<code>.on()</code>新增事件时，会触发所有订阅者，一起响应该事件。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"PublishSubject\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> subject = <span class=\"type\">PublishSubject</span>&lt;<span class=\"type\">String</span>&gt;()</span><br><span class=\"line\">    writeSequenceToConsole(<span class=\"string\">\"1\"</span>, sequence: subject)</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"a\"</span>))</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"b\"</span>))</span><br><span class=\"line\">    writeSequenceToConsole(<span class=\"string\">\"2\"</span>, sequence: subject)</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"c\"</span>))</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"d\"</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- <span class=\"type\">PublishSubject</span> example ---</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(a)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(b)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Next</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(d)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Next</span>(d)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"基于PublishSubject的几种补发式订阅源\"><a href=\"#基于PublishSubject的几种补发式订阅源\" class=\"headerlink\" title=\"基于PublishSubject的几种补发式订阅源\"></a>基于PublishSubject的几种补发式订阅源</h3><p>以下几种类型的订阅源，相较第一种仅多了补发历史事件，姑且称为<code>补发式订阅源</code>。</p>\n<h4 id=\"ReplaySubject先向最新订阅者补发所有已发生的事件\"><a href=\"#ReplaySubject先向最新订阅者补发所有已发生的事件\" class=\"headerlink\" title=\"ReplaySubject先向最新订阅者补发所有已发生的事件\"></a>ReplaySubject先向最新订阅者补发所有已发生的事件</h4><p>当<code>ReplaySubject</code>类型的订阅源，新增订阅者时，该类型的订阅源会把之前已发送过的所有事件队列重新补发给这个最新订阅者。这样就迫使订阅者会对从历史的事件队列逐一响应。<br><code>bufferSize</code> 是缓冲区的大小，决定了补发队列的最大值。如果 <code>bufferSize</code> 是1，那么新的订阅者出现的时候就会补发上一个事件，如果是2，则补两个，以此类推。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"ReplaySubject\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> subject = <span class=\"type\">ReplaySubject</span>&lt;<span class=\"type\">String</span>&gt;.create(bufferSize: <span class=\"number\">1</span>)</span><br><span class=\"line\">    writeSequenceToConsole(<span class=\"string\">\"1\"</span>, sequence: subject)</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"a\"</span>))</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"b\"</span>))</span><br><span class=\"line\">    writeSequenceToConsole(<span class=\"string\">\"2\"</span>, sequence: subject)</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"c\"</span>))</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"d\"</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- <span class=\"type\">ReplaySubject</span> example ---</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(a)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(b)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Next</span>(b) <span class=\"comment\">// 补了一个 b</span></span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Next</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(d)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Next</span>(d)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"BehaviorSubject-先向最新订阅者补发最近一次历史事件\"><a href=\"#BehaviorSubject-先向最新订阅者补发最近一次历史事件\" class=\"headerlink\" title=\"BehaviorSubject 先向最新订阅者补发最近一次历史事件\"></a>BehaviorSubject 先向最新订阅者补发最近一次历史事件</h4><p><code>BehaviorSubject</code>类型的订阅源会向最新订阅者发送最近一次的历史事件队列，如果没有则发送一个默认值。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"BehaviorSubject\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> subject = <span class=\"type\">BehaviorSubject</span>(value: <span class=\"string\">\"z\"</span>)</span><br><span class=\"line\">    writeSequenceToConsole(<span class=\"string\">\"1\"</span>, sequence: subject)</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"a\"</span>))</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"b\"</span>))</span><br><span class=\"line\">    writeSequenceToConsole(<span class=\"string\">\"2\"</span>, sequence: subject)</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"c\"</span>))</span><br><span class=\"line\">    subject.on(.<span class=\"type\">Completed</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- <span class=\"type\">BehaviorSubject</span> example ---</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(z)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(a)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(b)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Next</span>(b)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Next</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Completed</span></span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Completed</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Variable\"><a href=\"#Variable\" class=\"headerlink\" title=\"Variable\"></a>Variable</h4><p><code>Variable</code> 是基于 <code>BehaviorSubject</code> 的一层封装，它的优势是：不会被显式终结。<br>即：不会收到 <code>.Completed</code> 和 <code>.Error</code> 这类的终结事件，它会主动在析构的时候发送 <code>.Complete</code><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"Variable\"</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> variable = <span class=\"type\">Variable</span>(<span class=\"string\">\"z\"</span>)</span><br><span class=\"line\">    writeSequenceToConsole(<span class=\"string\">\"1\"</span>, sequence: variable)</span><br><span class=\"line\">    variable.value = <span class=\"string\">\"a\"</span></span><br><span class=\"line\">    variable.value = <span class=\"string\">\"b\"</span></span><br><span class=\"line\">    writeSequenceToConsole(<span class=\"string\">\"2\"</span>, sequence: variable)</span><br><span class=\"line\">    variable.value = <span class=\"string\">\"c\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- <span class=\"type\">Variable</span> example ---</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(z)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(a)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(b)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Next</span>(b)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Next</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Next</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">1</span>, event: <span class=\"type\">Completed</span></span><br><span class=\"line\"><span class=\"type\">Subscription</span>: <span class=\"number\">2</span>, event: <span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"支持订阅的嵌套函数\"><a href=\"#支持订阅的嵌套函数\" class=\"headerlink\" title=\"支持订阅的嵌套函数\"></a>支持订阅的嵌套函数</h2><h3 id=\"map-规则-遍历映射\"><a href=\"#map-规则-遍历映射\" class=\"headerlink\" title=\"map{规则} 遍历映射\"></a>map{规则} 遍历映射</h3><p>通过闭包中定义的规则将队列中的数据映射到新的队列中，支持订阅遍历事件。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">map</span>&lt;U&gt;<span class=\"params\">(transform: <span class=\"params\">(T)</span></span></span> -&gt; <span class=\"type\">U</span>) -&gt; <span class=\"type\">U</span>[]</span><br><span class=\"line\"><span class=\"comment\">//效果</span></span><br><span class=\"line\">[ x1, x2, ... , xn].<span class=\"built_in\">map</span>(f) -&gt; [f(x1), f(x2), ... , f(xn)]</span><br></pre></td></tr></table></figure><br><code>map</code>接受一个把 <code>T</code> 类型的转换成 <code>U</code> 类型的<code>transform</code>函数，最终返回的是 <code>U 类型的集合</code>。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"map\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> originalSequence = sequenceOf(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">    originalSequence.<span class=\"built_in\">map</span>&#123; $<span class=\"number\">0</span> * <span class=\"number\">2</span> &#125;.subscribe&#123; <span class=\"built_in\">print</span>($<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- <span class=\"built_in\">map</span> example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"flatMap-嵌套式遍历映射\"><a href=\"#flatMap-嵌套式遍历映射\" class=\"headerlink\" title=\"flatMap 嵌套式遍历映射\"></a>flatMap 嵌套式遍历映射</h3><p>嵌套式遍历描述：在遍历当前队列的过程中，每次执行闭包时都会遍历另一个嵌套队列中的所有事件。<br>可以想象嵌套for 循环来理解。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"flatMap\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sequenceInt = sequenceOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sequenceString = sequenceOf(<span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"--\"</span>)</span><br><span class=\"line\">    sequenceInt.flatMap&#123; int <span class=\"keyword\">in</span> sequenceString &#125;.subscribe&#123; <span class=\"built_in\">print</span>($<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- flatMap example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">A</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">B</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(--)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">A</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">B</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(--)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">A</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">B</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(--)</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"scan-initial-U-combine-U-T-gt-U-迭代映射\"><a href=\"#scan-initial-U-combine-U-T-gt-U-迭代映射\" class=\"headerlink\" title=\"scan(initial:U,combine:(U, T) -&gt; U)迭代映射\"></a>scan(initial:U,combine:(U, T) -&gt; U)迭代映射</h3><p>scan 有点像 reduce ，把<code>U</code>类型集合中的所有元素，以<code>initial</code>为初始值，按照<code>combine</code>规则，逐个迭代并返回一个U类型的对象。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"scan\"</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sequenceToSum = sequenceOf(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">    sequenceToSum.scan(<span class=\"number\">0</span>) &#123; acum, elem <span class=\"keyword\">in</span> acum + elem &#125;</span><br><span class=\"line\">    .subscribe &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>($<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- scan example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">15</span>)</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Filtering-支持订阅的过滤器\"><a href=\"#Filtering-支持订阅的过滤器\" class=\"headerlink\" title=\"Filtering 支持订阅的过滤器\"></a>Filtering 支持订阅的过滤器</h2><h3 id=\"filter-布尔语句-条件过滤法\"><a href=\"#filter-布尔语句-条件过滤法\" class=\"headerlink\" title=\"filter{布尔语句} 条件过滤法\"></a>filter{布尔语句} 条件过滤法</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"filter\"</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">let</span> subscription = sequenceOf(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\">.<span class=\"built_in\">filter</span> &#123; $<span class=\"number\">0</span> % <span class=\"number\">2</span> == <span class=\"number\">0</span> &#125;.subscribe &#123; <span class=\"built_in\">print</span>($<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- <span class=\"built_in\">filter</span> example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">8</span>)</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"distinctUntilChanged-去重过滤法（相邻且不重复）\"><a href=\"#distinctUntilChanged-去重过滤法（相邻且不重复）\" class=\"headerlink\" title=\"distinctUntilChanged() 去重过滤法（相邻且不重复）\"></a>distinctUntilChanged() 去重过滤法（相邻且不重复）</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"distinctUntilChanged\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> subscription = sequenceOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">    .distinctUntilChanged().subscribe&#123; <span class=\"built_in\">print</span>($<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- distinctUntilChanged example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"take-int-掐尖过滤法\"><a href=\"#take-int-掐尖过滤法\" class=\"headerlink\" title=\"take(int) 掐尖过滤法\"></a>take(int) 掐尖过滤法</h3><p><code>take</code>只获取队列中前 n 个事件，在满足数量之后会自动 <code>.Completed</code><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"take\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">let</span> subscription = sequenceOf(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\">.take(<span class=\"number\">3</span>).subscribe &#123; <span class=\"built_in\">print</span>($<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- take example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Combining-订阅源聚合器\"><a href=\"#Combining-订阅源聚合器\" class=\"headerlink\" title=\"Combining 订阅源聚合器\"></a>Combining 订阅源聚合器</h2><p>订阅源聚合器将多个可观察者（订阅源）合并成一个可观察者（聚合订阅源），这样更便于订阅者同时监听多个订阅源。</p>\n<h3 id=\"startWith-向可观察者队列中添加排头兵（新增的可观察者）\"><a href=\"#startWith-向可观察者队列中添加排头兵（新增的可观察者）\" class=\"headerlink\" title=\"startWith 向可观察者队列中添加排头兵（新增的可观察者）\"></a>startWith 向可观察者队列中添加排头兵（新增的可观察者）</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> subscription = sequenceOf(<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>).startWith(<span class=\"number\">3</span>).subscribe &#123; <span class=\"built_in\">print</span>($<span class=\"number\">0</span>)&#125;</span><br><span class=\"line\">--- startWith example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"combineLatest-合并聚合订阅源最后一次事件数据，生成一个聚合事件\"><a href=\"#combineLatest-合并聚合订阅源最后一次事件数据，生成一个聚合事件\" class=\"headerlink\" title=\"combineLatest 合并聚合订阅源最后一次事件数据，生成一个聚合事件\"></a>combineLatest 合并聚合订阅源最后一次事件数据，生成一个聚合事件</h3><p>便于订阅者监听聚合订阅源中每个订阅源的最后一次事件数据<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"combineLatest 1\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> intOb1 = <span class=\"type\">PublishSubject</span>&lt;<span class=\"type\">String</span>&gt;()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> intOb2 = <span class=\"type\">PublishSubject</span>&lt;<span class=\"type\">Int</span>&gt;()</span><br><span class=\"line\">    combineLatest(intOb1, intOb2) &#123;<span class=\"string\">\"\\($0) \\($1)\"</span>&#125;.subscribe &#123;  <span class=\"built_in\">print</span>($<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\">    intOb1.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"A\"</span>))</span><br><span class=\"line\">    intOb2.on(.<span class=\"type\">Next</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">    intOb1.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"B\"</span>))</span><br><span class=\"line\">    intOb2.on(.<span class=\"type\">Next</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- combineLatest <span class=\"number\">1</span> example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">A</span> <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">B</span> <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">B</span> <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"zip-intOb1-intOb2-拉链式合并\"><a href=\"#zip-intOb1-intOb2-拉链式合并\" class=\"headerlink\" title=\"zip(intOb1, intOb2) 拉链式合并\"></a>zip(intOb1, intOb2) 拉链式合并</h3><p>仅在凑齐聚合源中所有订阅源的事件时，才会聚合一次，触发订阅者的响应。可以将多达8个订阅源<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"zip 1\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> intOb1 = <span class=\"type\">PublishSubject</span>&lt;<span class=\"type\">String</span>&gt;()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> intOb2 = <span class=\"type\">PublishSubject</span>&lt;<span class=\"type\">Int</span>&gt;()</span><br><span class=\"line\">    <span class=\"built_in\">zip</span>(intOb1, intOb2) &#123; <span class=\"string\">\"\\($0) \\($1)\"</span> &#125;.subscribe &#123; <span class=\"built_in\">print</span>($<span class=\"number\">0</span>)&#125;</span><br><span class=\"line\">    intOb1.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"A\"</span>))</span><br><span class=\"line\">    intOb2.on(.<span class=\"type\">Next</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">    intOb1.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"B\"</span>))</span><br><span class=\"line\">    intOb1.on(.<span class=\"type\">Next</span>(<span class=\"string\">\"C\"</span>))</span><br><span class=\"line\">    intOb2.on(.<span class=\"type\">Next</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- <span class=\"built_in\">zip</span> <span class=\"number\">1</span> example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">A</span> <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"type\">B</span> <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"merge-按可观察者的新的事件次序合并队列\"><a href=\"#merge-按可观察者的新的事件次序合并队列\" class=\"headerlink\" title=\"merge() 按可观察者的新的事件次序合并队列\"></a>merge() 按可观察者的新的事件次序合并队列</h3><p>订阅者会按次序来响应聚合订阅源的每一件事件<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"merge 1\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> subject1 = <span class=\"type\">PublishSubject</span>&lt;<span class=\"type\">Int</span>&gt;()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> subject2 = <span class=\"type\">PublishSubject</span>&lt;<span class=\"type\">Int</span>&gt;()</span><br><span class=\"line\">    sequenceOf(subject1, subject2).merge().subscribeNext &#123; int <span class=\"keyword\">in</span> <span class=\"built_in\">print</span>(int)&#125;</span><br><span class=\"line\">    subject1.on(.<span class=\"type\">Next</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">    subject1.on(.<span class=\"type\">Next</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">    subject2.on(.<span class=\"type\">Next</span>(<span class=\"number\">3</span>))</span><br><span class=\"line\">    subject1.on(.<span class=\"type\">Next</span>(<span class=\"number\">4</span>))</span><br><span class=\"line\">    subject2.on(.<span class=\"type\">Next</span>(<span class=\"number\">5</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- merge <span class=\"number\">1</span> example ---</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"switchLatest订阅源切换器：用于嵌套式订阅源\"><a href=\"#switchLatest订阅源切换器：用于嵌套式订阅源\" class=\"headerlink\" title=\"switchLatest订阅源切换器：用于嵌套式订阅源\"></a>switchLatest订阅源切换器：用于嵌套式订阅源</h3><p>通过切换（var3.value）嵌套的订阅源，来切换订阅者当前监听的订阅源，以响应当前订阅源中的可观察者的事件。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"switchLatest\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> var1 = <span class=\"type\">Variable</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> var2 = <span class=\"type\">Variable</span>(<span class=\"number\">200</span>)</span><br><span class=\"line\">    <span class=\"comment\">// var3 is like an Observable&lt;Observable&lt;Int&gt;&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> var3 = <span class=\"type\">Variable</span>(var1)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> d = var3.switchLatest().subscribe&#123; <span class=\"built_in\">print</span>($<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\">    var1.value = <span class=\"number\">1</span></span><br><span class=\"line\">    var1.value = <span class=\"number\">2</span></span><br><span class=\"line\">    var1.value = <span class=\"number\">3</span></span><br><span class=\"line\">    var1.value = <span class=\"number\">4</span></span><br><span class=\"line\">    var3.value = var2</span><br><span class=\"line\">    var2.value = <span class=\"number\">201</span></span><br><span class=\"line\">    var1.value = <span class=\"number\">5</span></span><br><span class=\"line\">    var3.value = var1</span><br><span class=\"line\">    var2.value = <span class=\"number\">202</span></span><br><span class=\"line\">    var1.value = <span class=\"number\">6</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- switchLatest example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">200</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">201</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">6</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"订阅器\"><a href=\"#订阅器\" class=\"headerlink\" title=\"订阅器\"></a>订阅器</h2><ol>\n<li>订阅器：<code>subscribe</code> 用来订阅可观察者的事件队列（即订阅源），并指定响应的相关操作</li>\n<li>Next订阅器：<code>subscribeNext</code> 只订阅 <code>.Next</code> 事件</li>\n<li>Completed订阅器：<code>subscribeCompleted</code> 只订阅<code>.Completed</code> 完成事件</li>\n<li>Error订阅器：<code>subscribeError</code> 订阅 <code>.Error</code> 失败事件</li>\n<li>订阅器观察者：<code>doOn</code> 在订阅器执行之前，获得执行代码的机会。可对比理解：<code>swift中的属性观察者</code></li>\n</ol>\n<h2 id=\"控制take掐尖过滤器\"><a href=\"#控制take掐尖过滤器\" class=\"headerlink\" title=\"控制take掐尖过滤器\"></a>控制take掐尖过滤器</h2><p>过滤器通过指定的事件和状态语句来判断是否停止take</p>\n<h3 id=\"takeUntil-得到指定事件之后触发-Completed-事件\"><a href=\"#takeUntil-得到指定事件之后触发-Completed-事件\" class=\"headerlink\" title=\"takeUntil 得到指定事件之后触发 .Completed 事件\"></a>takeUntil 得到指定事件之后触发 .Completed 事件</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"takeUntil\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> originalSequence = <span class=\"type\">PublishSubject</span>&lt;<span class=\"type\">Int</span>&gt;()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> whenThisSendsNextWorldStops = <span class=\"type\">PublishSubject</span>&lt;<span class=\"type\">Int</span>&gt;()</span><br><span class=\"line\">    originalSequence.takeUntil(whenThisSendsNextWorldStops)</span><br><span class=\"line\">    .subscribe &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>($<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    originalSequence.on(.<span class=\"type\">Next</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">    originalSequence.on(.<span class=\"type\">Next</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">    whenThisSendsNextWorldStops.on(.<span class=\"type\">Next</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">    originalSequence.on(.<span class=\"type\">Next</span>(<span class=\"number\">3</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- takeUntil example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"takeWhile-判断语句\"><a href=\"#takeWhile-判断语句\" class=\"headerlink\" title=\"takeWhile 判断语句\"></a>takeWhile 判断语句</h3><p>takeWhile 则是可以通过状态语句判断是否继续 take 。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example(<span class=\"string\">\"takeWhile\"</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sequence = <span class=\"type\">PublishSubject</span>&lt;<span class=\"type\">Int</span>&gt;()</span><br><span class=\"line\">    sequence.takeWhile &#123; int <span class=\"keyword\">in</span> int &lt; <span class=\"number\">2</span> &#125;.subscribe &#123; <span class=\"built_in\">print</span>($<span class=\"number\">0</span>) &#125;</span><br><span class=\"line\">    sequence.on(.<span class=\"type\">Next</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">    sequence.on(.<span class=\"type\">Next</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">    sequence.on(.<span class=\"type\">Next</span>(<span class=\"number\">3</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--- takeWhile example ---</span><br><span class=\"line\"><span class=\"type\">Next</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"type\">Completed</span></span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"开源库","path":"api/categories/开源库.json"},{"name":"RxSwift","path":"api/categories/RxSwift.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"SDK","path":"api/tags/SDK.json"}]},{"title":"互动性的教学工具XCPlayground","slug":"swift/互动性的教学工具XCPlayground","date":"2017-03-01T17:27:16.000Z","updated":"2017-03-01T17:27:16.000Z","comments":true,"path":"api/articles/swift/互动性的教学工具XCPlayground.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/xcplayground-sources.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>Playground 展示语法和实时执行真实数据的特性，为编写方法和库接口提供了很好的机会，通过实时编译我们能了解语法、写出例子以及获得方法如何使用的说明，所有这些就如一个活的文档展示在眼前。</p>\n<ol>\n<li>演习框架API，了解框架结构<br><a href=\"https://github.com/objcio/PersonalSwiftPlaygrounds\" target=\"_blank\" rel=\"noopener\">SceneKitMac.playground</a><br>是一个功能完备带动画的 3D 场景。你需要打开 Assistant Editor (在菜单上依次点击 View | Assistant Editor | Show Assistant Editor)，3D 效果和动画将会被自动渲染。这不需要编译循环，而且任何的改动，比如改变颜色、几何形状、亮度等，都能实时反映出来。使用它能在一个交互例子中很好的记录和介绍如何使用SceneKit框架。</li>\n<li>测试驱动开发<br>我们可以验证一个方法的执行是否正确，甚至在加载到 playground 的时候就能判断方法是否被正确解析。不难想象我们也可以在 playground 里添加断言，以及创建真正的单元测试。或者更进一步，创建出符合条件的测试，从而在你打字时就实现测试驱动开发。</li>\n</ol>\n<h2 id=\"Sources\"><a href=\"#Sources\" class=\"headerlink\" title=\"Sources\"></a>Sources</h2><p>打开 Project Navigator (⌘1) 并展开 Playground 文件，你就能看到”Sources”路径。<br>放到此目录下的源文件会被编译成模块(module)并自动导入到 Playground 中，并且这个编译只会进行一次(或者我们对该目录下的文件进行修改的时候)，而非每次你敲入一个字母的时候就编译一次。 这将会大大提高代码执行的效率。</p>\n<blockquote>\n<p>注意：由于此目录下的文件都是被编译成模块导入的，只有被设置成 public 的类型，属性或方法才能在 Playground 中使用。</p>\n</blockquote>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcplayground-sources.png?imageMogr2/2/w/800\">\n<h2 id=\"导入Frameworks\"><a href=\"#导入Frameworks\" class=\"headerlink\" title=\"导入Frameworks\"></a>导入Frameworks</h2><p>如果想要导入外部 framework，创建一个 Xcode Workspace 包含了 framework 项目和你的 Playground。在 Build 之后，就可以通过常规的import命令导入对应的包。</p>\n<h3 id=\"手动配置cocoa-touch-Framework来桥接playground\"><a href=\"#手动配置cocoa-touch-Framework来桥接playground\" class=\"headerlink\" title=\"手动配置cocoa touch Framework来桥接playground\"></a>手动配置cocoa touch Framework来桥接playground</h3><p>在Playgroud中使用个人项目中的类相关方法，需要借助于Custom Frameworks桥接<br>注：.swift的文件中的方法必须是public修饰。<br>参考文档：<code>Playground help -&gt; Importing Custom Frameworks into a Playground</code></p>\n<ol>\n<li>导入个人项目文件，需要借助<code>cocoa touch Framework</code>桥接<code>playground</code></li>\n<li>需要<code>workspace</code>来管理<code>Framework</code>项目和<code>playground</code>文件，典型例子：pod项目都是用workspace来管理多个项目。</li>\n<li>把个人项目的<code>swift文件</code>关联到<code>Cocoa touch Framework</code>项目的<code>target</code>中：<br> 详细设置：选中target -&gt; build phases -&gt; compiles sources -&gt;点击 + 加号，选中原项目中的swift</li>\n<li>在<code>build</code>选项中选中Framework的scheme进行编译 ,要保证framework的target配置：<code>build setting -&gt; build active architecture Only -&gt;debug</code>选项设置为<code>YES</code></li>\n<li>打开playground文件 import Framework名称，此时即可使用Framework中的提供的public API方法了。<br>Workspace相关设置，build生成的目录：xcode偏好设置要和项目中的workspace中设置要保持一致.</li>\n<li>xcode的偏好设置中 -&gt;Locations -&gt; Locations -&gt;点击打开 Advanced…在弹出框中设置Unique选项.</li>\n<li>在workspace中选中菜单 File -&gt; workspace settings… -&gt; 在弹出框中设置为Unique选项.</li>\n</ol>\n<h3 id=\"导入cocopads管理的依赖库\"><a href=\"#导入cocopads管理的依赖库\" class=\"headerlink\" title=\"导入cocopads管理的依赖库\"></a>导入cocopads管理的依赖库</h3><p>xcode7.3.1和cocoapods1.0版本导致playground无法import相关动态库<br>解决办法：<a href=\"http://stackoverflow.com/questions/38216238/xcode-playground-with-cocoapods#\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/38216238/xcode-playground-with-cocoapods#</a><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#在写入磁盘之前，修改一些工程的配置:</span></span><br><span class=\"line\">post_install <span class=\"keyword\">do</span> |installer|</span><br><span class=\"line\">    installer.pods_project.targets.each <span class=\"keyword\">do</span> |target|</span><br><span class=\"line\">        <span class=\"keyword\">if</span> target.name != <span class=\"string\">'CocoaAsyncSocket'</span></span><br><span class=\"line\">            <span class=\"comment\">#playground相关配置，会导致'GCDAsyncSocket.h' file not found</span></span><br><span class=\"line\">            target.build_configurations.each <span class=\"keyword\">do</span> |config|</span><br><span class=\"line\">                config.build_settings[<span class=\"string\">'CONFIGURATION_BUILD_DIR'</span>] = <span class=\"string\">'$PODS_CONFIGURATION_BUILD_DIR'</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">#Use Legacy Swift Language Version” (SWIFT_VERSION):</span></span><br><span class=\"line\">                <span class=\"comment\">#   https://github.com/CocoaPods/CocoaPods/issues/5864#issuecomment-247109685</span></span><br><span class=\"line\">                puts <span class=\"string\">\"SWIFT_VERSIION:\"</span></span><br><span class=\"line\">                config.build_settings[<span class=\"string\">'SWIFT_VERSION'</span>] = <span class=\"string\">\"3.0.1\"</span></span><br><span class=\"line\">                puts config.build_settings[<span class=\"string\">'SWIFT_VERSION'</span>]</span><br><span class=\"line\">            end</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"comment\">#输出操作</span></span><br><span class=\"line\">            puts <span class=\"string\">\"以下不能在playground中使用的库名：\"</span></span><br><span class=\"line\">            puts target.name</span><br><span class=\"line\">        end</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Playground沙盒Resources\"><a href=\"#Playground沙盒Resources\" class=\"headerlink\" title=\"Playground沙盒Resources\"></a>Playground沙盒Resources</h2><p>Playgrounds 有两个与相关的Resources关联起来：一个是每一个独立的 playground 本地的，另一个则是 playground 之间共享的。在你的实验过程中，Playgrounds 能够支持 XML，JSON 数据，XIB，和图像文件。这也增加了其使用可用性。</p>\n<h2 id=\"本地-bundle访问本地资源\"><a href=\"#本地-bundle访问本地资源\" class=\"headerlink\" title=\"本地 bundle访问本地资源\"></a>本地 bundle访问本地资源</h2><p>Resources 文件夹, 与 Sources 文件夹一样在 Playground 的包路径中, 通过 Project Navigator 就可见了——只需要简单的拖拽图像和数据文件，就可以在 Playground 中使用了。对应的内容在 main bundle 中也是可见的。比如，我们可以像这样非常快捷的加载一个包含天气数据的 JSON 文件：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> jsonPath = <span class=\"type\">NSBundle</span>.mainBundle().bundlePath.stringByAppendingPathComponent(<span class=\"string\">\"weather.json\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span></span><br><span class=\"line\">jsonData = <span class=\"type\">NSData</span>(contentsOfFile: jsonPath),</span><br><span class=\"line\">json = <span class=\"type\">NSJSONSerialization</span>.<span class=\"type\">JSONObjectWithData</span>(jsonData, options: <span class=\"literal\">nil</span>, error: <span class=\"literal\">nil</span>) <span class=\"keyword\">as</span>? [<span class=\"type\">String</span>: <span class=\"type\">AnyObject</span>] </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"共享-访问Documents共享目录\"><a href=\"#共享-访问Documents共享目录\" class=\"headerlink\" title=\"共享 访问Documents共享目录\"></a>共享 访问Documents共享目录</h2><p>“共享 Playground 数据”的内容在你的”Documents”文件夹路径下，也同样对于你创建的任何 Playground 都可见。我们通过XCPSharedDataDirectoryPath常量来访问该共享文件夹。</p>\n<p>如果你自习想尝试，需要在 “~/Documents/Shared Playground Data” 下简历一个文件夹。 这里我们尝试载入一个名字叫做 “image.png” 的图片文件:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sharedImagePath = <span class=\"type\">XCPSharedDataDirectoryPath</span>.stringByAppendingPathComponent(<span class=\"string\">\"image.png\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> image = <span class=\"type\">UIImage</span>(contentsOfFile: sharedImagePath) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"PlaygroundSupport\"><a href=\"#PlaygroundSupport\" class=\"headerlink\" title=\"PlaygroundSupport\"></a>PlaygroundSupport</h2><h3 id=\"liveView视图代理\"><a href=\"#liveView视图代理\" class=\"headerlink\" title=\"liveView视图代理\"></a>liveView视图代理</h3><p>实现在playground中实现UI显示及交互操作<br>liveView定义：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> liveView: <span class=\"type\">XCPlaygroundLiveViewable</span>?</span><br></pre></td></tr></table></figure><br>遵循了<code>XCPlaygroundLiveViewable</code>协议即可在playground中可视化显示：</p>\n<ol>\n<li>在iOS 和 tvOS中<code>UIView</code> and <code>UIViewController</code>遵循该协议</li>\n<li>在OS X中<code>NSView</code> and <code>NSViewController</code>遵循该协议</li>\n<li>用户自定类型，须遵守XCPlaygroundLiveViewable协议<br>总之，只要遵守改协议并实现代理方法，都可以在playground中可视化显示。<br>用法：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.liveView = <span class=\"type\">UIView</span>()／<span class=\"type\">NSViewController</span>()</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"捕获值（XCPCaptureValue在XCPlayground中过时）\"><a href=\"#捕获值（XCPCaptureValue在XCPlayground中过时）\" class=\"headerlink\" title=\"捕获值（XCPCaptureValue在XCPlayground中过时）\"></a>捕获值（XCPCaptureValue在XCPlayground中过时）</h3><p><a href=\"http://swifter.tips/playground-capture/\" target=\"_blank\" rel=\"noopener\">冒泡排序可视化预览</a><br><figure class=\"highlight swift\"><figcaption><span>XCPlayground Module</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// This function has been deprecated.</span></span><br><span class=\"line\"><span class=\"meta\">@available</span>(*, deprecated)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">XCPCaptureValue</span>&lt;T&gt;<span class=\"params\">(identifier: String, value: T)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>简介：可以多次调用该方法来做图，相同的 identifier 的数据将会出现在同一张图上，而 value 将根据输入的次序进行排列,将一组数据轻而易举地绘制到时间轴上，从而让我们能看到每一步的结果。这不仅对我们直观且及时地了解算法内部的变化很有帮助，也会是教学或者演示时候的神兵利器。</p>\n<ol>\n<li>使用：导入框架<code>import XCPlayground</code></li>\n<li>扩展：XCPCaptureValue 的数据输入是任意类型的，所以不论是传什么进去都是可以表示的。它们将以 QuickLook 预览的方式被表现出来，一些像 UIImage，UIColor 或者 UIBezierPath 这样的类型已经实现了 QuickLook。当然对于那些没有实现快速预览的 NSObject 子类，也可以通过重写</li>\n</ol>\n<p>一个 Playground 通常立即显示简单表达式的结果。数组，字符串，数字等等，会在结果面板把计算后的结果显示出来。那么，随着时间改变的值是如何处理的呢？</p>\n<p>通过使用 XCPCaptureValue() 函数，我们可以随着一系列的迭代建立一个变动值的图。回到我们上面提到的天气例子，让我们来看看按小时计的温度数据，使用 XCPCaptureValue 来在辅助编辑界面以时间线的方式显示 温度的值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> XCPlayground</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> forecast <span class=\"keyword\">in</span> forecasts </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> tempString = forecast[<span class=\"string\">\"temp\"</span>]?[<span class=\"string\">\"english\"</span>] <span class=\"keyword\">as</span>? <span class=\"type\">String</span>, temperature = tempString.toInt()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">XCPCaptureValue</span>(<span class=\"string\">\"Temperature\"</span>, temperature)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另一种可选的方式是, 选择 Editor → Show Result For Current Line 就会捕获当前线的数值并且直接以图表的形势显示在 Playground 流中：</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcplayground-capture.png?imageMogr2/2/w/800\">\n<h3 id=\"异步执行（Asynchronous-Execution）\"><a href=\"#异步执行（Asynchronous-Execution）\" class=\"headerlink\" title=\"异步执行（Asynchronous Execution）\"></a>异步执行（Asynchronous Execution）</h3><p>不同于大部分 Swift 代码，是作为框架或者应用的一部分，Playgrounds 被当做是 高级代码。Playground 中的高级代码是按照指令接着指令的顺序从上到下执行的。<br>这种无容器风格的代码执行提供了立即反馈，但是存在着一个问题：在执行到了 Playground 底部后，会立即停止。网络请求，计时器，以及长时间运行的后台队列都会在提供反馈成功或者失败之前被立即终止。<br><code>PlaygroundSupport</code> 模块包含一个能够延长该过程的函数：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> needsIndefiniteExecution: <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>开启异步：默认值为<code>false</code>,当使用liveView代理时，会自动设置为<code>true</code>。当为<code>true</code>时，在高级代码执行完成后，会告诉Xcode继续运行Playground页面。为<code>false</code>时，当代码执行完直接终止。</li>\n<li>手动终止：还可以使用<code>PlaygroundPage.finishExecution()</code>手动终止正在运行的Playground。</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> PlaygroundSupport</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.needsIndefiniteExecution = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> url = <span class=\"type\">NSURL</span>(string: <span class=\"string\">\"http://httpbin.org/image/png\"</span>)!</span><br><span class=\"line\"><span class=\"keyword\">let</span> task = <span class=\"type\">NSURLSession</span>.sharedSession().dataTaskWithURL(url) &#123;</span><br><span class=\"line\">    data, <span class=\"number\">_</span>, <span class=\"number\">_</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> image = <span class=\"type\">UIImage</span>(data: data)</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//手动终止</span></span><br><span class=\"line\">        <span class=\"type\">PlaygroundPage</span>.current.currentPage.finishExecution()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">task.resume()</span><br></pre></td></tr></table></figure>\n<h2 id=\"支持Markdown格式的文档\"><a href=\"#支持Markdown格式的文档\" class=\"headerlink\" title=\"支持Markdown格式的文档\"></a>支持Markdown格式的文档</h2><p><a href=\"https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>除了实验用途，Playgrounds 在展示 Swift 语言的工具和框架中也一样强大。特别文档部分可以作为丰富格式的方式展示出来，以提供对于代码的清晰解释从而展示某个技术或者正确使用某个 Library 的方式。</p>\n<p>不同于<a href=\"http://nshipster.cn/swift-documentation/\" target=\"_blank\" rel=\"noopener\">Swift代码中的注释文档语法</a>, <code>Swift Playgrounds</code> 使用 <code>Markdown</code> 来显示多格式的文档。<br>例如：<br><code>//:</code>：可以指定单行文本说明<br><code>/*: Markdown格式内容... */</code>：可以用<code>Markdown</code>格式来显示丰富的文档内容</p>\n<p><code>xcode</code>切换备注以<code>Markdown</code>格式显示：</p>\n<ol>\n<li>选择<code>Editor → Show Rendered Markup</code> 菜单</li>\n<li>在 <code>File Inspector (⌘⌥1)</code> 选中 <code>Render Documentation</code> 复选框。<blockquote>\n<p>在xcode8中打开之前版本时，菜单上的<code>Show Rendered Markup</code>会显示为<code>Upgrade playgound...</code>升级菜单项，这样就需要先点击升级菜单项之后，才能激活上述（1）（2）设置项。</p>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//: This line will have **bold** and *italic* text.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*:</span></span><br><span class=\"line\"><span class=\"comment\">## Headers of All Sizes</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">### Lists of Links</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">- [NSHipster](http://nshipster.com)</span></span><br><span class=\"line\"><span class=\"comment\">- [ASCIIwwdc](http://asciiwwdc.com)</span></span><br><span class=\"line\"><span class=\"comment\">- [SwiftDoc](http://swiftdoc.org)</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">### Images, Too</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">![Remote Image](http://nshipster.s3.amazonaws.com/alert.gif)</span></span><br><span class=\"line\"><span class=\"comment\">![Local Image](bomb.gif) </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*Images in the Resources directory can be referenced locally*</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcplayground-documentation.png?imageMogr2/2/w/800\">\n<p>Playgrounds 提供了一个我们关于分享和学习 OS X 和 iOS 相关工具的方式的重大改变。Playground 可以展示每一个特性，并且为将来的用户探索和发现你创建的库提供了空间。丢掉你的静态README.md， 换成可互动的README.playground吧，再玩起来！</p>\n","raw":null,"categories":[{"name":"swift","path":"api/categories/swift.json"},{"name":"playground","path":"api/categories/playground.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"测试","path":"api/tags/测试.json"}]},{"title":"使用Cocoapods创建私有podspec","slug":"工具/使用Cocoapods创建私有podspec","date":"2017-02-28T15:46:16.000Z","updated":"2018-06-21T21:43:37.000Z","comments":true,"path":"api/articles/工具/使用Cocoapods创建私有podspec.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/repo目录.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"创建一个版本库来托管pod索引-pod-repo-add命令\"><a href=\"#创建一个版本库来托管pod索引-pod-repo-add命令\" class=\"headerlink\" title=\"创建一个版本库来托管pod索引:pod repo add命令\"></a>创建一个版本库来托管pod索引:pod repo add命令</h2><p>第一步：在github登录个人账号，创建一个库作为pod索引托管库。也可根据具体情况可以选择：<code>github</code>、<code>CODING</code>、<code>开源中国</code>、<code>Bitbucket</code>以及<code>CSDN</code>等，代码托管平台。<br>当索引库托管在github私有的仓库时，如果有其他同事共同开发维护，则需要配置Git仓库的权限。<br>第二步：pod化版本库，使其专门用户管理个人的<code>*podspec</code>索引文件<br><figure class=\"highlight ruby\"><figcaption><span>repo add命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># pod repo add [Private Repo Name] [GitHub HTTPS clone URL]</span></span><br><span class=\"line\">$ pod repo add PodRepo <span class=\"symbol\">https:</span>/<span class=\"regexp\">/github.com/huos</span>3203/PodRepo.git</span><br><span class=\"line\"><span class=\"comment\">#输出：</span></span><br><span class=\"line\">&gt; Cloning spec repo <span class=\"string\">`PodRepo`</span> from <span class=\"string\">`https://github.com/huos3203/PodRepo.git`</span></span><br></pre></td></tr></table></figure><br>此时在本地会生成<code>~/.cocoapods/repos/PodRepo</code>目录，这个目录就可以用来存储你所有的开源包。<br>每当一个或多个<code>*.podspec</code>文件测试无误时，就可以使用<code>pod repo push</code>命令向私有索引库中提交该文件。<br><figure class=\"highlight ruby\"><figcaption><span>lib create命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod repo push PodRepo LogSwift.podspec  <span class=\"comment\">#PodRepo是本地Repo名字 后面是podspec名字</span></span><br></pre></td></tr></table></figure><br>完成之后这个组件库就添加到私有索引库中，自动生成的<code>pod 库</code>标准结构：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/repo目录.png?imageMogr2/2/w/800\"><br>同时<code>push命令</code>会将新增的索引目录推送至自己的远程仓库中，即索引托管库<code>PodRepo.git</code>中。</p>\n<p>下面详述<code>podspec文件</code>的配置，检测，使用的过程。</p>\n<h2 id=\"使用模板命令创建Pod工程项目-lib-create\"><a href=\"#使用模板命令创建Pod工程项目-lib-create\" class=\"headerlink\" title=\"使用模板命令创建Pod工程项目 lib create\"></a>使用模板命令创建Pod工程项目 lib create</h2><p>初始化Pod模板项目：<br><figure class=\"highlight ruby\"><figcaption><span>lib create命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod lib create LogSwift</span><br></pre></td></tr></table></figure><br>有以下五步命令行交互：<br><figure class=\"highlight ruby\"><figcaption><span>交互</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">What is your email?</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">What language <span class=\"keyword\">do</span> you want to use?? [ Swift / ObjC ]</span><br><span class=\"line\">&gt;Swift</span><br><span class=\"line\">Would you like to <span class=\"keyword\">include</span> a demo application with your library? [ Yes / No ]</span><br><span class=\"line\">&gt;Yes</span><br><span class=\"line\">Which testing frameworks will you use? [ Quick / None ]</span><br><span class=\"line\">&gt;Quick</span><br><span class=\"line\">Would you like to <span class=\"keyword\">do</span> view based testing? [ Yes / No ]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure><br>会自动执行<code>pod install</code>命令创建项目并生成依赖。</p>\n<h3 id=\"添加库文件和资源\"><a href=\"#添加库文件和资源\" class=\"headerlink\" title=\"添加库文件和资源\"></a>添加库文件和资源</h3><p>例如：把一个网络模块的共有组件放入<code>Pod/Classes</code>中，然后进入<code>Example</code>文件夹执行<code>pod update</code>命令，再打开项目工程可以看到，刚刚添加的组件已经在<code>Pods</code>子工程下<code>Development Pods/PodTestLibrary</code>中了，然后编辑demo工程，测试组件。<br>测试无误后需要将该项目添加并推送到远端仓库，并编辑podspec文件。</p>\n<h3 id=\"配置podspec文件及验证命令lib-lint\"><a href=\"#配置podspec文件及验证命令lib-lint\" class=\"headerlink\" title=\"配置podspec文件及验证命令lib lint\"></a>配置podspec文件及验证命令lib lint</h3><h4 id=\"打tag号作为podspec版本号\"><a href=\"#打tag号作为podspec版本号\" class=\"headerlink\" title=\"打tag号作为podspec版本号\"></a>打tag号作为podspec版本号</h4><p>因为<code>podspec文件</code>中获取<code>Git版本控制</code>的项目还需要<code>tag号</code>，所以我们要打上一个<code>tag</code><br><figure class=\"highlight ruby\"><figcaption><span>打标签</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -m <span class=\"string\">\"first release\"</span> <span class=\"number\">0</span>.<span class=\"number\">1.0</span></span><br><span class=\"line\">$ git push --tags     <span class=\"comment\">#推送tag到远端仓库</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"编辑podspec文件\"><a href=\"#编辑podspec文件\" class=\"headerlink\" title=\"编辑podspec文件\"></a>编辑podspec文件</h4><p><code>podspec文件</code>是一个Ruby格式：<br><figure class=\"highlight ruby\"><figcaption><span>podspec文件</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pod::Spec.new <span class=\"keyword\">do</span> <span class=\"params\">|s|</span></span><br><span class=\"line\">s.name             = <span class=\"string\">\"PodTestLibrary\"</span>    <span class=\"comment\">#名称</span></span><br><span class=\"line\">s.version          = <span class=\"string\">\"0.1.0\"</span>             <span class=\"comment\">#版本号</span></span><br><span class=\"line\">s.summary          = <span class=\"string\">\"Just Testing.\"</span>     <span class=\"comment\">#简短介绍，下面是详细介绍</span></span><br><span class=\"line\">s.description      = <span class=\"string\">&lt;&lt;-DESC</span></span><br><span class=\"line\"><span class=\"string\">Testing Private Podspec.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* Markdown format.</span></span><br><span class=\"line\"><span class=\"string\">* Don't worry about the indent, we strip it!</span></span><br><span class=\"line\"><span class=\"string\">DESC</span></span><br><span class=\"line\">s.homepage         = <span class=\"string\">\"https://coding.net/u/boyers/p/podTestLibrary\"</span>                           <span class=\"comment\">#主页,这里要填写可以访问到的地址，不然验证不通过</span></span><br><span class=\"line\"><span class=\"comment\"># s.screenshots     = \"www.example.com/screenshots_1\", \"www.example.com/screenshots_2\"           #截图</span></span><br><span class=\"line\">s.license          = <span class=\"string\">'MIT'</span>              <span class=\"comment\">#开源协议</span></span><br><span class=\"line\">s.author           = &#123; <span class=\"string\">\"boyers\"</span> =&gt; <span class=\"string\">\"boyers@foxmail.com\"</span> &#125;  <span class=\"comment\">#作者信息</span></span><br><span class=\"line\">s.source           = &#123; <span class=\"symbol\">:git</span> =&gt; <span class=\"string\">\"https://coding.net/boyers/podTestLibrary.git\"</span>, <span class=\"symbol\">:tag</span> =&gt; <span class=\"string\">\"0.1.0\"</span> &#125;      <span class=\"comment\">#项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS</span></span><br><span class=\"line\"><span class=\"comment\"># s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;'                       #多媒体介绍地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.platform     = <span class=\"symbol\">:ios</span>, <span class=\"string\">'7.0'</span>            <span class=\"comment\">#支持的平台及版本</span></span><br><span class=\"line\">s.requires_arc = <span class=\"literal\">true</span>                   <span class=\"comment\">#是否使用ARC，如果指定具体文件，则具体的问题使用ARC</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.source_files = <span class=\"string\">'Pod/Classes/**/*'</span>     <span class=\"comment\">#代码源文件地址，**/*表示Classes目录及其子目录下所有文件，如果有多个目录下则用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置</span></span><br><span class=\"line\">s.resource_bundles = &#123;</span><br><span class=\"line\"><span class=\"string\">'PodTestLibrary'</span> =&gt; [<span class=\"string\">'Pod/Assets/*.png'</span>]</span><br><span class=\"line\">&#125;                                       <span class=\"comment\">#资源文件地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.public_header_files = <span class=\"string\">'Pod/Classes/**/*.h'</span>   <span class=\"comment\">#公开头文件地址</span></span><br><span class=\"line\">s.frameworks = <span class=\"string\">'UIKit'</span>                  <span class=\"comment\">#所需的framework，多个用逗号隔开</span></span><br><span class=\"line\">s.dependency <span class=\"string\">'AFNetworking'</span>, <span class=\"string\">'~&gt; 2.3'</span>   <span class=\"comment\">#依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependency</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"验证podspec文件可用性\"><a href=\"#验证podspec文件可用性\" class=\"headerlink\" title=\"验证podspec文件可用性\"></a>验证podspec文件可用性</h4><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod lib lint</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">-&gt; PodTestLibrary (<span class=\"number\">0</span>.<span class=\"number\">1.0</span>)</span><br><span class=\"line\">PodTestLibrary passed validation.</span><br></pre></td></tr></table></figure>\n<p>说明验证通过了，不过这只是这个<code>podspec文件</code>是合格的，不一定说明这个Pod是可以用的，Pod需要在本地做一下验证。</p>\n<h3 id=\"将源码托管到远程仓库\"><a href=\"#将源码托管到远程仓库\" class=\"headerlink\" title=\"将源码托管到远程仓库\"></a>将源码托管到远程仓库</h3><p>通过<code>Cocoapods</code>创建出来的目录本身就在本地的<code>Git</code>管理下，我们需要做的就是给它添加远端仓库，同样去<code>GitHub</code>或其他的Git服务提供商那里创建一个<code>私有的仓库</code>，拿到<code>SSH地址</code>，然后<code>cd</code>到<code>LogSwift</code>目录<br><figure class=\"highlight ruby\"><figcaption><span>添加到远程仓库</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -s -m <span class=\"string\">\"Initial Commit of Library\"</span></span><br><span class=\"line\">$ git remote add origin <span class=\"symbol\">https:</span>/<span class=\"regexp\">/coding.net/git</span><span class=\"regexp\">/LogSwift.git   #添加远端仓库</span></span><br><span class=\"line\"><span class=\"regexp\">$ git push origin master        #提交到远端仓库</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"手动配置Pod私库项目支持：spec-create\"><a href=\"#手动配置Pod私库项目支持：spec-create\" class=\"headerlink\" title=\"手动配置Pod私库项目支持：spec create\"></a>手动配置Pod私库项目支持：spec create</h2><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod spec create LogSwift git@coding.<span class=\"symbol\">net:</span>boyers/LogSwift.git</span><br></pre></td></tr></table></figure>\n<p>执行完之后，就创建了一个<code>podspec文件</code>，他其中会包含很多内容，可以按照我之前介绍的进行编辑，没用的删掉。编辑完成之后使用验证命令<code>pod lib lint</code>验证一下。</p>\n<h2 id=\"path-gt-在新项目配置检测podspec文件\"><a href=\"#path-gt-在新项目配置检测podspec文件\" class=\"headerlink\" title=\":path =&gt; 在新项目配置检测podspec文件\"></a>:path =&gt; 在新项目配置检测podspec文件</h2><p>在这个项目的<code>Podfile</code>文件中直接指定刚才创建编辑好的<code>podspec文件</code>，看是否可用。</p>\n<ol>\n<li>指定本地依赖的两种方式:<figure class=\"highlight ruby\"><figcaption><span>Podfile</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">platform <span class=\"symbol\">:ios</span>, <span class=\"string\">'7.0'</span></span><br><span class=\"line\">pod <span class=\"string\">'LogSwift'</span>, <span class=\"symbol\">:path</span> =&gt; <span class=\"string\">'~/code/Cocoapods/podTest/LogSwift'</span>      <span class=\"comment\"># 指定路径</span></span><br><span class=\"line\">pod <span class=\"string\">'LogSwift'</span>, <span class=\"symbol\">:podspec</span> =&gt; <span class=\"string\">'~/code/Cocoapods/podTest/LogSwift/LogSwift.podspec'</span>  <span class=\"comment\"># 指定podspec文件</span></span><br></pre></td></tr></table></figure></li>\n<li>指定源码的远程仓库作为依赖<br>前提时索引文件中指定的tag版本的源码必须推送到远程仓库<figure class=\"highlight ruby\"><figcaption><span>Podfile</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">platform <span class=\"symbol\">:ios</span>, <span class=\"string\">'7.0'</span></span><br><span class=\"line\">pod <span class=\"string\">'MusicLrc'</span>, <span class=\"symbol\">:git</span> =&gt; <span class=\"string\">'https://github.com/huos3203/MusicLrcTest.git'</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>然后执行<code>pod install</code>命令安装依赖，打开项目工程，可以看到<code>库文件</code>和<code>资源</code>都被加载到<code>Pods子项目</code>中了，不过它们并没有在<code>Pods目录</code>下，而是跟测试项目一样存在于<code>Development Pods/LogSwift</code>中，这是因为我们是在本地测试，而没有把<code>podspec文件</code>添加到<code>Spec Repo</code>中的缘故。</p>\n<h2 id=\"万事具备，向私有索引库中提交podspec文件：repo-push\"><a href=\"#万事具备，向私有索引库中提交podspec文件：repo-push\" class=\"headerlink\" title=\"万事具备，向私有索引库中提交podspec文件：repo push\"></a>万事具备，向私有索引库中提交podspec文件：repo push</h2><p>每当一个或多个<code>*.podspec</code>文件测试无误时，就可以使用<code>pod repo push</code>命令向私有索引库中提交该文件。<br><figure class=\"highlight ruby\"><figcaption><span>lib create命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod repo push PodRepo LogSwift.podspec  <span class=\"comment\">#PodRepo是本地Repo名字 后面是podspec名字</span></span><br></pre></td></tr></table></figure><br>完成之后这个组件库就添加到私有索引库中，自动生成的<code>pod 库</code>标准结构：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/repo目录.png?imageMogr2/2/w/800\"><br>同时<code>push命令</code>会将新增的索引目录推送至自己的远程仓库中，即索引托管库<code>PodRepo.git</code>中。</p>\n<h2 id=\"trunk-push-添加到Cocoapods的官方索引库\"><a href=\"#trunk-push-添加到Cocoapods的官方索引库\" class=\"headerlink\" title=\"trunk push 添加到Cocoapods的官方索引库\"></a>trunk push 添加到Cocoapods的官方索引库</h2><h3 id=\"注册trunk，邮箱验证\"><a href=\"#注册trunk，邮箱验证\" class=\"headerlink\" title=\"注册trunk，邮箱验证\"></a>注册trunk，邮箱验证</h3><p>在注册trunk之前，我们需要确认当前的CocoaPods版本是否足够新:<br>sudo gem install cocoapods<br>开始注册trunk：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod trunk register boyer@163.com <span class=\"string\">'boyers1250'</span>  --verbose</span><br></pre></td></tr></table></figure><br><code>-verbose</code>参数是为了便于输出注册过程中的调试信息。<br>执行上面的语句后，你的邮箱将会受到一封带有验证链接的邮件，如果没有请去垃圾箱找找，有可能被屏蔽了。点击邮件的链接就完成了trunk注册流程。<br>使用下面的命令可以向trunk服务器查询自己的注册信息：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod trunk me</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"通过trunk推送podspec文件\"><a href=\"#通过trunk推送podspec文件\" class=\"headerlink\" title=\"通过trunk推送podspec文件\"></a>通过trunk推送podspec文件</h3><p>现在我们已经有了自己的podspec文件，但是在推送podspec文件之前你需要确认以下几点：</p>\n<ol>\n<li>确保你的源码已经push到Github上。</li>\n<li>确保你所push的代码已经打上”version tag”版本号标签：<br>只有确保了以上两点，CocoaPods才能更准确地找到你的repo。<br>现在我们开始通过trunk上传你的podspec文件。先cd到podspec文件所在目录，执行：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod trunk push WZLBadge.podspec</span><br></pre></td></tr></table></figure>\n执行上面的push操作，就相当于你把你的源代码提交给CocoaPods团队审核了，CocoaPods审核只需要几秒钟或者几分钟就可以完成。</li>\n</ol>\n<h2 id=\"使用远程的私有Pod库\"><a href=\"#使用远程的私有Pod库\" class=\"headerlink\" title=\"使用远程的私有Pod库\"></a>使用远程的私有Pod库</h2><p>我们的这个组件库就已经制作添加完成了，现在可以<code>pod search</code>命令查到这个库，当使用时配置Podfile依赖文件即可。</p>\n<ol>\n<li>pod search 查找库<figure class=\"highlight ruby\"><figcaption><span>查找库</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod search PodTestLibrary</span><br><span class=\"line\"></span><br><span class=\"line\">-&gt; PodTestLibrary (<span class=\"number\">0</span>.<span class=\"number\">1.0</span>)</span><br><span class=\"line\">Just Testing.</span><br><span class=\"line\">pod <span class=\"string\">'PodTestLibrary'</span>, <span class=\"string\">'~&gt; 0.1.0'</span></span><br><span class=\"line\">- <span class=\"symbol\">Homepage:</span> <span class=\"symbol\">https:</span>/<span class=\"regexp\">/coding.net/u</span><span class=\"regexp\">/boyers/p</span><span class=\"regexp\">/podTestLibrary</span></span><br><span class=\"line\"><span class=\"regexp\">- Source:   https:/</span><span class=\"regexp\">/coding.net/boyers</span><span class=\"regexp\">/podTestLibrary.git</span></span><br><span class=\"line\"><span class=\"regexp\">- Versions: 0.1.0 [WTSpecs repo]</span></span><br></pre></td></tr></table></figure></li>\n<li>在Podfile文件中配置库依赖<figure class=\"highlight ruby\"><figcaption><span>配置库依赖</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod <span class=\"string\">'PodTestLibrary'</span>, <span class=\"string\">'~&gt; 0.1.0'</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"更新维护podspec文件配置，升级库版本\"><a href=\"#更新维护podspec文件配置，升级库版本\" class=\"headerlink\" title=\"更新维护podspec文件配置，升级库版本\"></a>更新维护podspec文件配置，升级库版本</h2><p><code>subspec</code>特性，可以在库原有基础上，添加更多的模块，相应创建了多个子目录。现在尝试添加包括<code>工具类</code>，底层<code>Model</code>及<code>UIKit</code>扩展等。</p>\n<h3 id=\"添加模块库文件和资源\"><a href=\"#添加模块库文件和资源\" class=\"headerlink\" title=\"添加模块库文件和资源\"></a>添加模块库文件和资源</h3><p>具体做法是先将源文件添加到<code>Pod/Classes</code>中，然后按照不同的模块对文件目录进行整理，因为我有四个模块，所以在<code>Pod/Classes</code>下有创建了四个子目录</p>\n<h3 id=\"打tag号作为podspec版本号-1\"><a href=\"#打tag号作为podspec版本号-1\" class=\"headerlink\" title=\"打tag号作为podspec版本号\"></a>打tag号作为podspec版本号</h3><p>因为<code>podspec文件</code>中获取<code>Git版本控制</code>的项目还需要<code>tag号</code>，所以我们要打上一个<code>tag</code><br><figure class=\"highlight ruby\"><figcaption><span>打标签</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -m <span class=\"string\">\"first release\"</span> <span class=\"number\">0</span>.<span class=\"number\">1.0</span></span><br><span class=\"line\">$ git push --tags     <span class=\"comment\">#推送tag到远端仓库</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"更新podspec配置文件\"><a href=\"#更新podspec配置文件\" class=\"headerlink\" title=\"更新podspec配置文件\"></a>更新podspec配置文件</h3><p>当创建了<code>subspec</code>，之前项目整体的依赖<code>dependency</code>:</p>\n<ol>\n<li>源文件:<code>source_files</code></li>\n<li>头文件:<code>public_header_files</code></li>\n<li>资源文件:<code>resource</code><br>都移动到了各自的<code>subspec</code>中，每个<code>subspec</code>之间也可以有相互的依赖关系，比如<code>UIKitAdditio</code>n就依赖于<code>CommonTools</code>。<figure class=\"highlight ruby\"><figcaption><span>更新podspec配置文件</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pod::Spec.new <span class=\"keyword\">do</span> <span class=\"params\">|s|</span></span><br><span class=\"line\">s.name             = <span class=\"string\">\"PodTestLibrary\"</span></span><br><span class=\"line\">s.version          = <span class=\"string\">\"1.0.0\"</span></span><br><span class=\"line\">s.summary          = <span class=\"string\">\"Just Testing.\"</span></span><br><span class=\"line\">s.description      = <span class=\"string\">&lt;&lt;-DESC</span></span><br><span class=\"line\"><span class=\"string\">                         Testing Private Podspec.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">                        * Markdown format.</span></span><br><span class=\"line\"><span class=\"string\">                        * Don't worry about the indent, we strip it!</span></span><br><span class=\"line\"><span class=\"string\">                    DESC</span></span><br><span class=\"line\">s.homepage         = <span class=\"string\">\"https://coding.net/u/boyers/p/podTestLibrary\"</span></span><br><span class=\"line\"><span class=\"comment\"># s.screenshots     = \"www.example.com/screenshots_1\", \"www.example.com/screenshots_2\"</span></span><br><span class=\"line\">s.license          = <span class=\"string\">'MIT'</span></span><br><span class=\"line\">s.author           = &#123; <span class=\"string\">\"boyers\"</span> =&gt; <span class=\"string\">\"boyers@foxmail.com\"</span> &#125;</span><br><span class=\"line\">s.source           = &#123; <span class=\"symbol\">:git</span> =&gt; <span class=\"string\">\"https://coding.net/boyers/podTestLibrary.git\"</span>, <span class=\"symbol\">:tag</span> =&gt; <span class=\"string\">\"1.0.0\"</span> &#125;</span><br><span class=\"line\"><span class=\"comment\"># s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;'</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.platform     = <span class=\"symbol\">:ios</span>, <span class=\"string\">'7.0'</span></span><br><span class=\"line\">s.requires_arc = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#s.source_files = 'Pod/Classes/**/*'</span></span><br><span class=\"line\"><span class=\"comment\">#s.resource_bundles = &#123; 'PodTestLibrary' =&gt; ['Pod/Assets/*.png'] &#125;</span></span><br><span class=\"line\"><span class=\"comment\">#s.public_header_files = 'Pod/Classes/**/*.h'</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.subspec <span class=\"string\">'NetWorkEngine'</span> <span class=\"keyword\">do</span> <span class=\"params\">|networkEngine|</span></span><br><span class=\"line\">    networkEngine.source_files = <span class=\"string\">'Pod/Classes/NetworkEngine/**/*'</span></span><br><span class=\"line\">    networkEngine.public_header_files = <span class=\"string\">'Pod/Classes/NetworkEngine/**/*.h'</span></span><br><span class=\"line\">    networkEngine.dependency <span class=\"string\">'AFNetworking'</span>, <span class=\"string\">'~&gt; 2.3'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.subspec <span class=\"string\">'DataModel'</span> <span class=\"keyword\">do</span> <span class=\"params\">|dataModel|</span></span><br><span class=\"line\">    dataModel.source_files = <span class=\"string\">'Pod/Classes/DataModel/**/*'</span></span><br><span class=\"line\">    dataModel.public_header_files = <span class=\"string\">'Pod/Classes/DataModel/**/*.h'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.subspec <span class=\"string\">'CommonTools'</span> <span class=\"keyword\">do</span> <span class=\"params\">|commonTools|</span></span><br><span class=\"line\">    commonTools.source_files = <span class=\"string\">'Pod/Classes/CommonTools/**/*'</span></span><br><span class=\"line\">    commonTools.public_header_files = <span class=\"string\">'Pod/Classes/CommonTools/**/*.h'</span></span><br><span class=\"line\">    commonTools.dependency <span class=\"string\">'OpenUDID'</span>, <span class=\"string\">'~&gt; 1.0.0'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.subspec <span class=\"string\">'UIKitAddition'</span> <span class=\"keyword\">do</span> <span class=\"params\">|ui|</span></span><br><span class=\"line\">    ui.source_files = <span class=\"string\">'Pod/Classes/UIKitAddition/**/*'</span></span><br><span class=\"line\">    ui.public_header_files = <span class=\"string\">'Pod/Classes/UIKitAddition/**/*.h'</span></span><br><span class=\"line\">    ui.resource = <span class=\"string\">\"Pod/Assets/MLSUIKitResource.bundle\"</span></span><br><span class=\"line\">    ui.dependency <span class=\"string\">'PodTestLibrary/CommonTools'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.frameworks = <span class=\"string\">'UIKit'</span></span><br><span class=\"line\">    <span class=\"comment\">#s.dependency 'AFNetworking', '~&gt; 2.3'</span></span><br><span class=\"line\">    <span class=\"comment\">#s.dependency 'OpenUDID', '~&gt; 1.0.0'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n编辑完成之后，在测试项目里<code>pod update</code>一下，几个子项目都被加进项目工程了，写代码验证无误之后，就可以将这个工程push到远端仓库，并打上新的<code>tag-&gt;1.0.0</code>。<blockquote>\n<p>但是如果你的代码版本号没变(podspec里的version自然也没变)就会提示push失败，即使你更改了podspec的其他地方，pod也会认为这两个文件是同一个。 我目前为止找不到trunk的相关update接口，所以只能顺水推舟，更新源代码版本号（如：1.1.1-&gt;1.1.2），重新push version tag，然后再执行pod trunk push操作。</p>\n</blockquote>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"工具","path":"api/categories/工具.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"pod","path":"api/tags/pod.json"},{"name":"私库","path":"api/tags/私库.json"}]},{"title":"UIStackView教程：了解Stack View","slug":"iOS/UIStackView教程了解StackView","date":"2017-02-24T18:12:14.000Z","updated":"2017-02-25T14:33:14.000Z","comments":true,"path":"api/articles/iOS/UIStackView教程了解StackView.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><a href=\"http://blog.csdn.net/kmyhy/article/details/50456444\" target=\"_blank\" rel=\"noopener\">原地址</a></p>\n<h2 id=\"UIStackView简单介绍\"><a href=\"#UIStackView简单介绍\" class=\"headerlink\" title=\"UIStackView简单介绍\"></a>UIStackView简单介绍</h2><p>一个Stack View能够将它所含的View以各种方式沿其轴向进行分布，同时也可以将View沿某个方向等距分布，要隐藏<code>Stack View</code>中的视图，你只需要设置该View的<code>Hidden</code>属性为<code>true</code>，剩下的工作Stack View会自己完成。。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0.png?imageMogr2/2/w/800\"><br>坐标（Axis）、间隔（Spacing）、对齐（Alignment）以及分布（Distribution ）等。<br>distribution属性：决定Stack View如何沿它轴向的水平方向摆放它的subview，当属性值是Fill，这表示subview会沿轴向完全占据Stack View。因此，Stack View会拉伸其中一个subview使其填充剩余空间，尤其是水平内容优先级最低的那个，如果所有subview优先级相同，则拉伸第一个subview。<br>Alignment属性：决定了Stack View如何沿它轴向的垂直方向摆放它的subview，对于一个垂直的Stack View，这个属性可以设置为Fill、Leading、Center和Trailing。<br>对于水平的Stack View，这个属性则稍有不同：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack006.png?imageMogr2/2/w/800\"><br>.Top取代了.Leading，.Bottom取代了.Trailing。此外，水平Stack View还多出了两个属性值：.FirstBaseLine和.LastBaseLine。<br>对于水平的Stack View，这个属性则稍有不同：<br>Fill:<br><img title=\"Fill\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack007.png?imageMogr2/2/w/800\"><br>Leading:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack008.png?imageMogr2/2/w/800\"><br>Center:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack009.png?imageMogr2/2/w/800\"><br>Trailing:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack000.png?imageMogr2/2/w/800\"></p>\n<p>布局方式对比<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack01.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"添加一个新的Stack-View\"><a href=\"#添加一个新的Stack-View\" class=\"headerlink\" title=\"添加一个新的Stack View\"></a>添加一个新的Stack View</h3><p>点击故事板画布左下角<code>Auto Layout工具栏</code>中的<code>Stack按钮</code>：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack3.png?imageMogr2/2/w/800\"><br>另一种解散的方法是选中Stack View，然后点击<code>Editor\\Emebed in\\stack view</code>菜单。</p>\n<h3 id=\"解散一个废弃的Stack-View\"><a href=\"#解散一个废弃的Stack-View\" class=\"headerlink\" title=\"解散一个废弃的Stack View\"></a>解散一个废弃的Stack View</h3><p>首先，选定想解散的Stack View。按下<code>Option键</code>，点击<code>Stack 按钮</code>。这将弹出一个上下文菜单，然后点击Unembed：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack001.png?imageMogr2/2/w/800\"><br>另一种解散的方法是选中Stack View，然后点击<code>Editor\\Unemebed</code>菜单。</p>\n<h2 id=\"使用场景描述\"><a href=\"#使用场景描述\" class=\"headerlink\" title=\"使用场景描述\"></a>使用场景描述</h2><p>当APP运行中增加或删除一个<code>view</code>时，需要重新调整邻近<code>view</code>的位置布局。<br>预见困境：</p>\n<ol>\n<li>在故事板中新建一些布局约束连接，以便能够安装或卸载其中的一些约束</li>\n<li>使用第三方库来实现</li>\n<li>根据任务复杂程度完全用代码实现<br>也许这个在视图附近的视图树中的所有View都不需要在运行时改变，但当你将新视图添加到故事板时，仍然要想方设法为它挤出空间来。</li>\n</ol>\n<p><code>UIStackView</code>提供了一个对多个视图进行水平或垂直布局的方法。通过对几个属性进行简单设置，比如对齐、分布和间距，可以让我们让其所包含的视图适应于其有效空间。</p>\n<h2 id=\"实现需求\"><a href=\"#实现需求\" class=\"headerlink\" title=\"实现需求\"></a>实现需求</h2><p>存在着这几方面的问题:</p>\n<h3 id=\"问题一：自适应横竖屏\"><a href=\"#问题一：自适应横竖屏\" class=\"headerlink\" title=\"问题一：自适应横竖屏\"></a>问题一：自适应横竖屏</h3><p>在横屏状态下（command+左箭头旋转为横屏），发现截图中的一排按钮位置无法适应屏幕宽度的变化。这时可以使用<code>UIStackView</code>来帮助实现自动适应横竖屏的效果。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/UIStackView.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"问题二：控件间留白不紧凑\"><a href=\"#问题二：控件间留白不紧凑\" class=\"headerlink\" title=\"问题二：控件间留白不紧凑\"></a>问题二：控件间留白不紧凑</h3><p>点击WEATHER旁边的Hide按钮。隐藏了下面的文本内容后，留下了一大块的空白区域。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/WEATHERhide.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"Storyboard引入界面\"><a href=\"#Storyboard引入界面\" class=\"headerlink\" title=\"Storyboard引入界面\"></a>Storyboard引入界面</h3><p>打开<code>Main.storyboard</code>，找到<code>Spot Info View Controller</code>这个Scene。将这些标签和按钮设为不同的背景色，是为了在运行时效果更直观。就是在故事板中，这也有助于看到<code>Stack View</code>属性的改变导致其内部视图的变化。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack1.png?imageMogr2/2/w/800\"><br>如果想在运行App时看见这些颜色，在<code>SpotInfoViewController</code>的<code>viewDidLoad()</code>方法中将下列语句注释：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 清空标签和按钮的背景色</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> view <span class=\"keyword\">in</span> backgroundColoredViews </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    view.backgroundColor = <span class=\"type\">UIColor</span>.clearColor()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Size类便于使用storyboard\"><a href=\"#Size类便于使用storyboard\" class=\"headerlink\" title=\"Size类便于使用storyboard\"></a>Size类便于使用storyboard</h3><p>在本案例中，故事板中Scene大小不是默认<code>600x600</code>，在这里Simulated Metrics下的Size属性被设置成iPhone 4-inch。Simulated Metrics属性在运行时并没有任何影响——不同设备上视图的大小仍然会自动改变。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/05-simulated-metrics-iphone-4-inch_639x173.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"创建水平UIStackView\"><a href=\"#创建水平UIStackView\" class=\"headerlink\" title=\"创建水平UIStackView\"></a>创建水平<code>UIStackView</code></h2><h3 id=\"按钮模块\"><a href=\"#按钮模块\" class=\"headerlink\" title=\"按钮模块\"></a>按钮模块</h3><ol>\n<li>选中按钮<br>用<code>Command+左键</code>同时选中<code>Spot Info View Controller</code>底下一排的所有按钮：<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack2.png?imageMogr2/2/w/800\"></li>\n<li>Stack按钮添加一个新的Stack View<br>点击故事板画布左下角<code>Auto Layout工具栏</code>中新增的<code>Stack按钮</code>：    </li>\n</ol>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/Stack按钮?imageMogr2/2/w/800\">\n<p>这些按钮被嵌到一个新的Stack View中：</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack4.png?imageMogr2/2/w/800\">\n<h4 id=\"给新的Stack-View添加布局约束\"><a href=\"#给新的Stack-View添加布局约束\" class=\"headerlink\" title=\"给新的Stack View添加布局约束\"></a>给新的Stack View添加布局约束</h4><p>要在故事板选取一个充满了子视图的Stack View还是比较难的，介绍两种选择技巧。<br>3.1 在<code>Outline视图</code>中选取Stack View</p>\n<img title=\"Outline视图\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack5.png?imageMogr2/2/w/800\">\n<p>3.2 Shift+右键调出View树<br>在Stack View 的任意地方按下<code>Shift+右键</code>或者<code>Control+Shift+左键</code>（如果你正在用触控板的话）。这时将弹出一个上下文菜单，列出了位于所点击的地方的View树，你可以在这个菜单中选择Stack View。</p>\n<img title=\"Shift+右键\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack6.png?imageMogr2/2/w/800\">\n<ol>\n<li>自动布局工具栏中的Pin按钮,添加一个约束<img title=\"自动布局工具栏中的Pin按钮\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack7.png?imageMogr2/2/w/800\">\n</li>\n</ol>\n<p>首先勾选Constrain to margins。然后在Stack View四周添加下列约束：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Top</span>: <span class=\"number\">20</span>, <span class=\"type\">Leading</span>: <span class=\"number\">0</span>, <span class=\"type\">Trailing</span>: <span class=\"number\">0</span>, <span class=\"type\">Bottom</span>: <span class=\"number\">0</span></span><br></pre></td></tr></table></figure><br>仔细检查top、leading、trailing、bottom中的数字并确保它们的I型柱都被选中。然后点击Add 4 Constraints：<br><img title=\"Add4Constraints\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack8.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"按钮等间距分布\"><a href=\"#按钮等间距分布\" class=\"headerlink\" title=\"按钮等间距分布\"></a>按钮等间距分布</h4><p>添加约束后，导致第一个按钮被拉伸：<br><img title=\"第一个按钮被拉伸填充所有剩余空间\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack9.png?imageMogr2/2/w/800\"></p>\n<h5 id=\"使用等宽约束的Spacer-View实现\"><a href=\"#使用等宽约束的Spacer-View实现\" class=\"headerlink\" title=\"使用等宽约束的Spacer View实现\"></a>使用等宽约束的<code>Spacer View</code>实现</h5><p>解决这个问题只能使用空白的View来分隔这些按钮，在按钮之间摆放上一些用于分隔空间的 Spacer View。所有的Spacer View都要添加等宽约束，以及许多额外的约束，才能将这些Spacer View布局正确。<br>这看起来如下图所示。为了直观起见，这些Spacer View的背景色设置成了浅灰色：<br><img title=\"SpacerView添加等宽约束实现\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack04.png?imageMogr2/2/w/800\"><br>如果要在运行时添加一个按钮或者隐藏/删除一个按钮时，要想调整这些Spacer View和约束就要命了。</p>\n<h5 id=\"Distribution属性：沿轴向水平分布\"><a href=\"#Distribution属性：沿轴向水平分布\" class=\"headerlink\" title=\"Distribution属性：沿轴向水平分布\"></a><code>Distribution</code>属性：沿轴向水平分布</h5><p>distribution属性：决定Stack View如何将它的subview沿轴向分布，当属性值是Fill，这表示subview会沿轴向完全占据Stack View。因此，Stack View会拉伸其中一个subview使其填充剩余空间，尤其是水平内容优先级最低的那个，如果所有subview优先级相同，则拉伸第一个subview。<br>打开Stack View属性面板。将<code>Distribution</code>属性由<code>Fill</code>修改为<code>Equal Spacing</code>：<br><img title=\"`Fill`修改为`Equal\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack02.png?imageMogr2/2/w/800\"><br>编译运行，点击某个单元格，旋转模拟器（⌘→）。你将看到最下一排按钮现在按照等间距排列了！<br><img title=\"`Distribution`属性值`Equal\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack03.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"Rating版块\"><a href=\"#Rating版块\" class=\"headerlink\" title=\"Rating版块\"></a>Rating版块</h3><p>选中RATING标签，以及旁边的显示为几个星形图标的标签：<br><img title=\"选中RATING标签\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack05.png?imageMogr2/2/w/800\"><br>然后点击Stack按钮将它们嵌到一个Stack View中：<br><img title=\"Stack按钮\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack3.png?imageMogr2/2/w/800\"><br><img title=\"RATING标签嵌到一个StackView中\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack06.png?imageMogr2/2/w/800\"><br>然后点击Pin按钮。勾选Constrain to margins，并添加如下约束：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Top</span>: <span class=\"number\">20</span>, <span class=\"type\">Leading</span>: <span class=\"number\">0</span>, <span class=\"type\">Bottom</span>: <span class=\"number\">20</span></span><br></pre></td></tr></table></figure><br><img title=\"添加约束\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack07.png?imageMogr2/2/w/800\"><br>打开属性面板，将间距设置为8：<br><img title=\"间距设置为8\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack08.png?imageMogr2/2/w/800\"><br>你可能会看到一个 Misplaced Views的布局约束警告，同时星星标签会显示将会被拉伸到视图之外：<br><img title=\"MisplacedViews的布局约束警告\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack09.png?imageMogr2/2/w/800\"><br>有时候Xcode会临时提示一些警告，或者显示Stack View的位置不正确，这些警告会在你添加其他约束后消失。你完全可以忽略这些警告。<br>要解决这个警告，我们可以修改一下Stack View的Frame然后又改回，或者临时修改它的一条布局约束。<br>让我们试一下。先将Alignment 属性从Fill修改为Top，然后又改回原来的Fill。你将看到这下星星标签显示正常了：<br><img title=\"布局约束警告消失\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack00.png?imageMogr2/2/w/800\"><br>编译运行，进行测试</p>\n<h2 id=\"创建垂直的Stack-View\"><a href=\"#创建垂直的Stack-View\" class=\"headerlink\" title=\"创建垂直的Stack View\"></a>创建垂直的Stack View</h2><p>Xcode会自动根据这两者的位置推断出这将是一个垂直的Stack View，Stack View没有添加任何约束时，会自动适应了两个标签中的最宽的一个的宽度。</p>\n<h3 id=\"WHY-VISIT模块\"><a href=\"#WHY-VISIT模块\" class=\"headerlink\" title=\"WHY VISIT模块\"></a>WHY VISIT模块</h3><p>选中WHY VISIT标签及下面的标签,创建一个垂直的Stack View：<br><img title=\"选中WHY\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack002.png?imageMogr2/2/w/800\"><br>点击Stack 按钮将二者嵌到一个Stack View：<br><img title=\"嵌到一个垂直的StackView\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack003.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"添加约束\"><a href=\"#添加约束\" class=\"headerlink\" title=\"添加约束\"></a>添加约束</h4><p>默认，约束是相对于距离最近的对象，对于Bottom约束来说就是距离它15像素的Hide按钮。但我们其实是想让约束相对于WEATHER标签。<br>选中Stack View，点击Pin按钮。勾选Constrain to margins，设置Top、Leading、Trainling为0。<br>然后，点击Bottom右边的下拉按钮，从列表中选择WEATHER（curent distance =20）：<br><img title=\"Top、Leading、Trainling为0\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack004.png?imageMogr2/2/w/800\"><br>最后点击Add 4 Constraints按钮。显示结果如下图所示：<br><img title=\"Top、Leading、Trainling为0\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack005.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"alignment属性：轴向的垂直方向\"><a href=\"#alignment属性：轴向的垂直方向\" class=\"headerlink\" title=\"alignment属性：轴向的垂直方向\"></a>alignment属性：轴向的垂直方向</h4><p>Stack View问题，它的右边对齐于View的右边。但是底下的标签仍然是原来的宽度。需要使用alignment属性解决这个问题。<br>当你测试完所有Alignment值的布局效果后，将Alignment修改为Fill：<br><img title=\"Top、Leading、Trainling为0\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0001.png?imageMogr2/2/w/800\"><br>将<code>Alignment</code>设置为<code>Fill</code>，表示所有View将沿与Stack View轴向垂直的方向进行全占式分布。这会让WHY VISIT标签扩展它的宽度到100%.</p>\n<p>如果我们只想让底下的标签将宽度扩展到100%怎么办？</p>\n<p>这个问题现在看来还不是多大的问题，因为两个标签在运行时的背景色都是透明的。但对于Weather版块来说就不同了。</p>\n<p>我们将用另外一个Stack View来说明这个问题。</p>\n<h2 id=\"垂直／水平Stack-View嵌套使用\"><a href=\"#垂直／水平Stack-View嵌套使用\" class=\"headerlink\" title=\"垂直／水平Stack View嵌套使用\"></a>垂直／水平Stack View嵌套使用</h2><h3 id=\"Weather版块\"><a href=\"#Weather版块\" class=\"headerlink\" title=\"Weather版块\"></a>Weather版块</h3><p>在Weather版块相对复杂一些，因为它多了一个Hide按钮。<br>要隐藏<code>Stack View</code>中的视图，你只需要设置该View的<code>Hidden</code>属性为<code>true</code>，剩下的工作Stack View会自己完成。这也是我们解决用户隐藏WEATHER标签下文本的主要思路。<br>一种方法是使用嵌套的Stack View，先将WEATHER标签和Hide按钮嵌到一个水平StackView，再将这个Stack View和标签嵌到一个垂直Stack View。<br><img title=\"垂直/水平StackView嵌套使用\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0002.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"垂直stackView\"><a href=\"#垂直stackView\" class=\"headerlink\" title=\"垂直stackView\"></a>垂直stackView</h4><p>注意Alignment属性负责Stack View轴向垂直的方向上的布局。所以，我们需要将Alignment属性设置为 Bottom：<br><img title=\"垂直/水平StackView嵌套使用\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0003.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"水平StackView中出现按钮拉伸标签的问题\"><a href=\"#水平StackView中出现按钮拉伸标签的问题\" class=\"headerlink\" title=\"水平StackView中出现按钮拉伸标签的问题\"></a>水平StackView中出现按钮拉伸标签的问题</h4><p>注意，WEATHER标签被拉伸为和Hide按钮一样高了。这并不合适，因为这会导致WEATHER标签和下面的文本之间多出了一些空间。<br>正确的方法是让 Hide 按钮不要和 Weather 版块呆在同一个Stack View中，或者任何别的Stack View中。<br>这样，在顶层View中还会保留一个subview，你将为它添加一个相对于WEATHER标签的约束——WEATHER标签嵌在Stack View里的。也就是说，你要为位于Stack View之外的按钮加一个约束，这个约束是相对于Stack View内的一个标签！</p>\n<h4 id=\"垂直stack-View1-嵌套WEATHER标签和标签\"><a href=\"#垂直stack-View1-嵌套WEATHER标签和标签\" class=\"headerlink\" title=\"垂直stack View1:嵌套WEATHER标签和标签\"></a>垂直stack View1:嵌套WEATHER标签和标签</h4><p>选中WEATHER标签和标签：<br><img title=\"选中嵌套标签\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0004.png?imageMogr2/2/w/800\"><br>点击 Stack 按钮：<br><img title=\"Stack按钮创建stackView\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0005.png?imageMogr2/2/w/800\"><br>点击Pin 按钮，勾上Constrain to margins，然后添加如下约束：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Top</span>: <span class=\"number\">20</span>, <span class=\"type\">Leading</span>: <span class=\"number\">0</span>, <span class=\"type\">Trailing</span>: <span class=\"number\">0</span>, <span class=\"type\">Bottom</span>: <span class=\"number\">20</span></span><br></pre></td></tr></table></figure><br>将Stack View的Alignment设为Fill：<br><img title=\"Alignment设为Fill\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0006.png?imageMogr2/2/w/800\"><br>我们需要在 Hide 按钮左边和WEATHER标签右边加一条约束，这样WEATHER 标签的宽度就不会拉满整个Stack View了。</p>\n<p>当然，底下的标签宽度还是需要100%占满的。</p>\n<p>我们是通过将WEATHER标签嵌到一个垂直Stack View 来实现的。注意，垂直Stack View的Alignment 属性可以设置为 .Leading，如果将Stack View拉宽，则它里面的View 会保持左对齐。</p>\n<h4 id=\"垂直stack-View2-仅嵌套WEATHER标签\"><a href=\"#垂直stack-View2-仅嵌套WEATHER标签\" class=\"headerlink\" title=\"垂直stack View2: 仅嵌套WEATHER标签\"></a>垂直stack View2: 仅嵌套WEATHER标签</h4><p>从Outline视图中选取WEATHER 标签，或者用Control+Shift+左键的方式选取WEATHER 标签：<br><img title=\"Stack按钮创建stackView\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0006.png?imageMogr2/2/w/800\"><br>然后点击Stack 按钮：<br><img title=\"Stack按钮创建stackView\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0007.png?imageMogr2/2/w/800\"><br>确保Axis 为 Vertical 的情况下，将Alignment 设置为 Leading：<br><img title=\"Alignment设置为Leading\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0008.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"按钮和WEATHER标签两个约束\"><a href=\"#按钮和WEATHER标签两个约束\" class=\"headerlink\" title=\"按钮和WEATHER标签两个约束\"></a>按钮和WEATHER标签两个约束</h4><p>从Hide 按钮用右键拖一条新的约束到 WEATHER 标签：<br><img title=\"AddConstraints\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0009.png?imageMogr2/2/w/800\"><br>按下Shift键，同时选择Horizontal Spacing 和 Baseline。然后点击 Add Constraints：<br><img title=\"AddConstraints\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack0000.png?imageMogr2/2/w/800\"><br>编译运行。Hide 按钮的位置现在对了，而且当按下Hide 按钮，位于Stack View 中的标签被隐藏后，下面的视图也会被调整——根本不需要我们进行手动调整。<br><img title=\"编译运行\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack010.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"顶级-Stack-View\"><a href=\"#顶级-Stack-View\" class=\"headerlink\" title=\"顶级 Stack View\"></a>顶级 Stack View</h2><p>在Outline 视图中，用Command+左键选择5个最顶级的 Stack View：<br><img title=\"选中视图\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack011.png?imageMogr2/2/w/800\"><br>然后点击 Stack 按钮：<br><img title=\"Stack按钮\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack012.png?imageMogr2/2/w/800\"><br>点击Pin 按钮，勾上 Constrain to margins，将 4 个边的约束都设为0。然后将Spacing 设置为20，Alignment 设为 Fill。现在故事板会是这个样子：<br><img title=\"添加约束\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack013.png?imageMogr2/2/w/800\"><br>编译运行：<br><img title=\"编译运行\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack014.png?imageMogr2/2/w/800\"><br>噢！这个 Hide 按钮又失去了它 的约束！因为包含 WEATHER 标签的Stack View的外边又套了一层 Stack View。这不是什么大问题，就像之前你做过的那样，再重新为它添加约束就是了。</p>\n<p>右键从Hide 按钮拖一条约束到 WEATHER标签，按下 Shift 键，同时选择 Horizontal Spacing 和 Baseline。然后点击 Add Constraints：<br><img title=\"AddConstraints\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack015.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"重新调整视图位置\"><a href=\"#重新调整视图位置\" class=\"headerlink\" title=\"重新调整视图位置\"></a>重新调整视图位置</h2><p>现在，所有的版块都被嵌到一个顶级的 Stack View中了，我们想修改一下 what to see版块的位置，让它位于 weather 版块之后。</p>\n<p>从 Outline 视图中选择中间的的 Stack View，然后将它拖到第一、二个 Stack View 之间。<br>注意：让箭头稍微偏向你正在拖的Stack View左边一点，以便它能够作为外层 Stack View 的 subview 添加。蓝色的小圆圈应当位于两个 Stack View 之间的左端而不是右端：<br><img title=\"调整视图位置\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack016.png?imageMogr2/2/w/800\"></p>\n<p>现在，weather版块是从上到下的第三个版块，由于 Hide 按钮它并不是 Stack View的subview，所以它不会参与移动，它的frame当前是不正确的。</p>\n<p>点击 Hide 按钮，选中它：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack017.png?imageMogr2/2/w/800\"></p>\n<p>然后点击自动布局工具栏中的 Resolve Auto Layout Issues 按钮，选择 Update Frames：<br><img title=\"Update\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack018.png?imageMogr2/2/w/800\"><br>现在 Hide 按钮将回到正确的位置：<br><img title=\"UpdateHide按钮\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack019.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"基于配置的-Size-类\"><a href=\"#基于配置的-Size-类\" class=\"headerlink\" title=\"基于配置的 Size 类\"></a>基于配置的 Size 类</h2><p>最后还有一个任务没有完成。在横屏模式，垂直空间是比较珍贵的，你想将这些版块之间靠得更近一些。要实现这个，你需要判断当垂直Size类为compact时，将顶层 Stack View的 Spacing属性由 20 改成 10.</p>\n<p>选择顶层 Stack View，点击 Spacing 前面的+按钮：<br><img title=\"前面的+按钮Spacing\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack020.png?imageMogr2/2/w/800\"></p>\n<p>选择 Any Width &gt; Compact Height：<br><img title=\"CompactHeight\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack021.png?imageMogr2/2/w/800\"></p>\n<p>在新出现的 wAny hC 一栏中，将 Spacing 设为 10：<br><img title=\"Spacing设为10\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack022.png?imageMogr2/2/w/800\"><br>编译运行。在竖屏模式下Spacing不会改变。旋转模拟器（⌘←），你会看到各版块之间的间距减少了，现在底部按钮之间的空间也变大了：<br><img title=\"编译运行\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/stack023.png?imageMogr2/2/w/800\"><br>如果你没有添加最外层的 Stack View，你仍然可以使用 Size 类将每个版块之间的垂直间距设置为 10，但这就不是仅仅设置一个地方就能够办到的了。</p>\n<h2 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h2><p>现在，在隐藏和显示天气信息时仍然会觉得有一些突兀。你将增加一个动画使这个转换变得更平滑。</p>\n<p>Stack View完全支持 <code>UIView 动画</code>。也就是说要以动画方式显示/隐藏它所包含的subview，只需要简单地在一个动画块中切换它的 hidden 属性。</p>\n<p>让我们来看看代码怎么实现。打开 <code>SpotInfoViewController.Swift</code>，找到<br><code>updateWeatherInfoViews(hideWeatherInfo:animated:)</code>方法。</p>\n<p>将方法的最后一行：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br></pre></td></tr></table></figure><br>替换为：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> animated </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">UIView</span>.animateWithDuration(<span class=\"number\">0.3</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">else</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>编译运行，点击Hide 按钮或 Show 按钮。是不是加入动画之后看起来要好得多呢？</p>\n<p>除了对 Stack View 中的视图以动画的方式设置 hidden 属性，你也可以对 Stack View 自身的属性使用 UIView 动画，例如 Alignment 属性、 Distribution 属性、 Spacing 属性和 Axis 属性。<br><a href=\"http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Starter.zip\" target=\"_blank\" rel=\"noopener\">开始项目源码</a><br><a href=\"http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Complete.zip\" target=\"_blank\" rel=\"noopener\">完整项目源码</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2>","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"控件","path":"api/categories/控件.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"}]},{"title":"CFBundleDisplayName更改APP启动图标的名称","slug":"iOS/更改设备屏幕上显示的应用程序图标下方的名称","date":"2017-02-24T14:23:59.000Z","updated":"2017-05-26T18:13:13.000Z","comments":true,"path":"api/articles/iOS/更改设备屏幕上显示的应用程序图标下方的名称.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/qa1823_ExpandAppInProjectNavigator.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>修改APP启动图标上的名称，需配置<code>Info.plist</code>文件，增加<code>CFBundleDisplayName</code>属性键值对。<br>进入到如下界面：<br><!--长宽设置百分比大小无效果--><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/qa1823_ExpandAppInProjectNavigator.png?imageMogr2/2/w/800\"></p>\n<p>在<code>Info.plist</code>文件属性列表中搜索”Bundle display name”，如果存在就修改为新APP名称。<br>如果不存在，在任何一个属性条目下，点击”+”按钮，弹出的下拉列表中选择”Bundle display name”，再双击”Bundle display name”属性值列，输入新APP名称。<br><!--长宽设置百分比大小无效果--><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/qa1823_WatchKitAppInfoPane.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"agvtool自动增加版本号命令行工具\"><a href=\"#agvtool自动增加版本号命令行工具\" class=\"headerlink\" title=\"agvtool自动增加版本号命令行工具\"></a>agvtool自动增加版本号命令行工具</h2><p>版本号和编译号分别是代表了正式发布版本和内部版本， agvtool 是一个自动增加版本号的命令行工具。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/QA1827_AppStoreBuildNumber.png?imageMogr2/2/w/800\"><br>注意：版本号是给用户看的，用于标明当前的发行版本，并且被存储在 App 的 Info.plist 文件的 CFBundleShortVersionString (Bundle versions string, short) 中。编译号是内部使用的，用于标明未发行或者已内部发行的应用程序，并且它被存储在 Info.plist 文件的 CFBundleVersion (Bundle version) 中。</p>\n<p>注意：如果应用程序包含了多个目标（target）， agvtool 工具将会把所有目标都设置为同一个版本号和编译号。</p>\n<h3 id=\"设置-Current-Project-Version-为选定的值\"><a href=\"#设置-Current-Project-Version-为选定的值\" class=\"headerlink\" title=\"设置 Current Project Version 为选定的值\"></a>设置 Current Project Version 为选定的值</h3><p>Xcode 工程文件 project.pbxproj 包含了 CURRENT_PROJECT_VERSION (Current Project Version) 编译设定，这个编译设定指定了当前工程的版本。<br>agvtool 会搜索此编译选项。如果这个值存在就运行，否则不运行，这个值用来更新编译号。</p>\n<h3 id=\"设置-Versioning-System-为-Apple-Generic\"><a href=\"#设置-Versioning-System-为-Apple-Generic\" class=\"headerlink\" title=\"设置 Versioning System 为 Apple Generic\"></a>设置 Versioning System 为 Apple Generic</h3><p>默认情况下苹果不使用任何版本系统，设置为 Apple Generic 确保 Xcode 包含全部的 agvtool 生成的版本信息。</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/QA1827_Versioning.png?imageMogr2/2/w/800\">\n<p>注意： Current Project Version 的值必须是整数或者浮点数，新工程最好设置为1。</p>\n<h3 id=\"设置版本和编译号\"><a href=\"#设置版本和编译号\" class=\"headerlink\" title=\"设置版本和编译号\"></a>设置版本和编译号</h3><p>agvtool 从 Info.plist 文件搜索版本和编译号。如果存在就更新，不存在就不执行。<br>确保 CFBundleVersion (Bundle version) 和 CFBundleShortVersionString (Bundle versions string, short) 存在。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/QA1827_InfoPaneInXcode.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"版本号命令\"><a href=\"#版本号命令\" class=\"headerlink\" title=\"版本号命令\"></a>版本号命令</h3><p>退出 Xcode，在终端下进入到包含 .xcodeproj 工程文件的目录， .xcodeproj 文件包含了 project.pbxproj 文件。</p>\n<ol>\n<li><p>查看版本号：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">agvtool what-marketing-version</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新版本号</p>\n</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">agvtool new-marketing-version &lt;指定的版本号&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"编译号命令\"><a href=\"#编译号命令\" class=\"headerlink\" title=\"编译号命令\"></a>编译号命令</h3><ol>\n<li><p>将编译号设置为指定版本</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">agvtool new-version -all &lt;指定的版本号&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新编译号</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">agvtool next-version -all</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看当前编译号</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">agvtool what-version</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"配置","path":"api/categories/配置.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"经历","path":"api/tags/经历.json"},{"name":"配置","path":"api/tags/配置.json"}]},{"title":"高期望实现异步单元测试","slug":"测试/高期望实现异步单元测试","date":"2017-02-20T23:09:30.000Z","updated":"2017-05-26T11:03:05.000Z","comments":true,"path":"api/articles/测试/高期望实现异步单元测试.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"异步单元测试\"><a href=\"#异步单元测试\" class=\"headerlink\" title=\"异步单元测试\"></a>异步单元测试</h2><p>在Xcode 6之前的版本里面并没有内置<code>XCTest</code>，只能是在主线程的<code>RunLoop</code>里面使用一个<code>while循环</code>,然后一直等待响应或者直到<code>timeout</code>.</p>\n<p>在Xcode 6里，苹果以<code>XCTestExpection类</code>的方式向<code>XCTest框架</code>里添加了<code>测试期望</code>(test expection)。<br>XCTest框架中相关的方法：设置期望，实现期望，通知期望，谓词计算期望等，以及期望的传递。</p>\n<h3 id=\"常规实现方式\"><a href=\"#常规实现方式\" class=\"headerlink\" title=\"常规实现方式\"></a>常规实现方式</h3><p>在主线程里，使用<code>while循环</code>每隔10毫秒会执行一次，直到有响应或者5秒之后超出响应时间限制才会跳出：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testAsyncTheOldWay</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timeoutDate = <span class=\"type\">Date</span>.<span class=\"keyword\">init</span>(timeIntervalSinceNow: <span class=\"number\">5.0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> responseHasArrived = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"type\">Alamofire</span>.request(<span class=\"string\">\"https://www.baidu.com\"</span>).responseData&#123;response <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"获取到的数据长度：\\(String(data: response.data!, </span></span><br><span class=\"line\"><span class=\"string\">                                   encoding:String.Encoding.utf8)!)\"</span>)</span><br><span class=\"line\">        responseHasArrived = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"type\">XCTAssert</span>((response.data?.<span class=\"built_in\">count</span>)! &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (responseHasArrived == <span class=\"literal\">false</span> </span><br><span class=\"line\">            &amp;&amp; (timeoutDate.timeIntervalSinceNow &gt; <span class=\"number\">0</span>)) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">CFRunLoopRunInMode</span>(<span class=\"type\">CFRunLoopMode</span>.defaultMode, <span class=\"number\">0.01</span>, <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (responseHasArrived == <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">XCTFail</span>(<span class=\"string\">\"Test timed out\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"XCTest相关API\"><a href=\"#XCTest相关API\" class=\"headerlink\" title=\"XCTest相关API\"></a>XCTest相关API</h2><p>在Xcode 6里，苹果以<code>XCTestExpection类</code>的方式向<code>XCTest框架</code>里添加了<code>测试期望</code>(test expection)。</p>\n<h3 id=\"XCTestExpection-高期望-High-Expectations-的实现和使用\"><a href=\"#XCTestExpection-高期望-High-Expectations-的实现和使用\" class=\"headerlink\" title=\"XCTestExpection:高期望(High Expectations)的实现和使用\"></a>XCTestExpection:高期望(High Expectations)的实现和使用</h3><p>设置期望，实现期望，通知期望，谓词计算期望等，以及期望的传递。</p>\n<h4 id=\"expectation-description-为XCTest测试单元设置期望\"><a href=\"#expectation-description-为XCTest测试单元设置期望\" class=\"headerlink\" title=\"expectation(description:):为XCTest测试单元设置期望\"></a><code>expectation(description:)</code>:为XCTest测试单元设置期望</h4><p>为XCTest单元测试，设置一个测试期望以及错误信息描述，并在某一时刻<code>fulfill</code>实现该期望对象<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//expectation(description: String) -&gt; XCTestExpectation</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> expection = expectation(description: <span class=\"string\">\"失败时显示原因\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"fulfill-调用它表示测试达到期望值\"><a href=\"#fulfill-调用它表示测试达到期望值\" class=\"headerlink\" title=\"fulfill():调用它表示测试达到期望值\"></a><code>fulfill()</code>:调用它表示测试达到期望值</h5><p>一般在单元测试通过时调用，告知测试已达期望，这一方法替代了<code>responseHasArrived</code>作为Flag的方式<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//- (void)fulfill;</span></span><br><span class=\"line\">expection.fulfill()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"waitForExpectations-timeout-handler-在方法底部设置测试期望的时效\"><a href=\"#waitForExpectations-timeout-handler-在方法底部设置测试期望的时效\" class=\"headerlink\" title=\"waitForExpectations(timeout:handler:):在方法底部设置测试期望的时效\"></a><code>waitForExpectations(timeout:handler:)</code>:在方法底部设置测试期望的时效</h4><p>在方法底部指定一个超时，如果测试条件不适合时间范围便会结束执行<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// open func waitForExpectations(timeout: TimeInterval, handler: XCTest.XCWaitCompletionHandler? = nil)</span></span><br><span class=\"line\">waitForExpectations(timeout: <span class=\"number\">5</span>) &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"错误信息:\\(error?.localizedDescription)\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如果完成处理的代码在指定时限里执行并调用了<code>fulfill()</code>方法，那么就说明所有的测试期望在此期间都已经被实现。否则就测试就被打断不再执行</p>\n<h4 id=\"expectation-forNotification-object-handler-通知期望\"><a href=\"#expectation-forNotification-object-handler-通知期望\" class=\"headerlink\" title=\"expectation(forNotification:object:handler:):通知期望\"></a>expectation(forNotification:object:handler:):通知期望</h4><p>该方法监听一个通知,如果在规定时间内正确收到通知则测试通过<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//expectation(forNotification notificationName: String, object objectToObserve: Any?, handler: XCTest.XCNotificationExpectationHandler? = nil) -&gt; XCTestExpectation</span></span><br><span class=\"line\"><span class=\"comment\">//设置一个测试通知期望</span></span><br><span class=\"line\">expectation(forNotification: <span class=\"string\">\"BLDownloadImageNotification\"</span>, </span><br><span class=\"line\">                     object: <span class=\"literal\">nil</span>) </span><br><span class=\"line\">&#123;(notification) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> userInfo = notification.userInfo <span class=\"keyword\">as</span>! [<span class=\"type\">String</span>:<span class=\"type\">String</span>]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name = userInfo[<span class=\"string\">\"name\"</span>]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"name:\\(name)\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">来定义一个通知并发送通知，来测试：</span><br><span class=\"line\"><span class=\"keyword\">let</span> notif =  <span class=\"type\">Notification</span>.<span class=\"type\">Name</span>(rawValue: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\"><span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.post(name: notif, object: <span class=\"keyword\">self</span>, userInfo: [<span class=\"string\">\"name\"</span>:<span class=\"string\">\"huosan\"</span>,<span class=\"string\">\"sex\"</span>:<span class=\"string\">\"man\"</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置延迟多少秒后，如果没有满足测试条件就报错</span></span><br><span class=\"line\">waitForExpectations(timeout: <span class=\"number\">3</span>, handler: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"使用expectation-description-实现\"><a href=\"#使用expectation-description-实现\" class=\"headerlink\" title=\"使用expectation(description:)实现\"></a>使用<code>expectation(description:)</code>实现</h5><p>帮助理解 <code>expectation(forNotification:object:handler:)</code> 方法和 <code>expectation(description:)</code> 的区别<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testAsynForNotificationWithExpectation</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> expectation = <span class=\"keyword\">self</span>.expectation(description: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> notif = <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>(rawValue: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sub = <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(forName: notif, object: <span class=\"literal\">nil</span>, queue: <span class=\"literal\">nil</span>) &#123; (notification) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        expectation.fulfill()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//发送一个通知</span></span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.post(name: notif, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//waitForExpectations</span></span><br><span class=\"line\">    waitForExpectations(timeout: <span class=\"number\">1</span>, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//移除通知</span></span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.removeObserver(sub)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"expectation-for-evaluatedWith-handler-谓词计算测试法\"><a href=\"#expectation-for-evaluatedWith-handler-谓词计算测试法\" class=\"headerlink\" title=\"expectation(for:evaluatedWith:handler:):谓词计算测试法\"></a>expectation(for:evaluatedWith:handler:):谓词计算测试法</h4><p>利用谓词计算，判断<code>button</code>的<code>backgroundImageForState</code>方法，是否正确的获得了<code>backgroundImage</code>，如果<code>20秒</code>内正确获得则通过测试，否则失败<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//open func expectation(for predicate: NSPredicate, evaluatedWith object: Any, handler: XCTest.XCPredicateExpectationHandler? = nil) -&gt; XCTestExpectation</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testThatBackgroundImageChanges</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> viewController = <span class=\"type\">OnclickLikeViewController</span>()</span><br><span class=\"line\">    <span class=\"comment\">//viewController.loadView()  //不执行viewDidload方法</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"number\">_</span> = viewController.view</span><br><span class=\"line\">    <span class=\"keyword\">let</span> button = viewController.button</span><br><span class=\"line\">    <span class=\"keyword\">let</span> img = button.backgroundImage(<span class=\"keyword\">for</span>: .normal)</span><br><span class=\"line\">    <span class=\"type\">XCTAssertNil</span>(img,<span class=\"string\">\"此时img不为nil,中止执行\"</span>)  <span class=\"comment\">//当img不是nil时，执行断言</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> predicate = <span class=\"type\">NSPredicate</span>.<span class=\"keyword\">init</span> &#123; (anyobject, bindings) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> button = anyobject <span class=\"keyword\">as</span>! <span class=\"type\">UIButton</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> button.backgroundImage(<span class=\"keyword\">for</span>: <span class=\"type\">UIControlState</span>()) != <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    expectation(<span class=\"keyword\">for</span>: predicate, evaluatedWith: button, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    waitForExpectations(timeout: <span class=\"number\">20</span>, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"使用expectation-description-实现-1\"><a href=\"#使用expectation-description-实现-1\" class=\"headerlink\" title=\"使用expectation(description:)实现\"></a>使用<code>expectation(description:)</code>实现</h5><p>帮助理解 <code>expectation(for:evaluatedWith:handler:)</code> 方法和 <code>expectation(description:)</code> 的区别<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testThatBackgroundImageChanges</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//设置期望</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> expectation = <span class=\"keyword\">self</span>.expectation(description: <span class=\"string\">\"backgroundImageForState\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> viewController = <span class=\"type\">OnclickLikeViewController</span>()</span><br><span class=\"line\">    <span class=\"comment\">//viewController.loadView()  //不执行viewDidload方法</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"number\">_</span> = viewController.view</span><br><span class=\"line\">    <span class=\"keyword\">let</span> button = viewController.button</span><br><span class=\"line\">    <span class=\"keyword\">let</span> img = button.backgroundImage(<span class=\"keyword\">for</span>: .normal)</span><br><span class=\"line\">    <span class=\"type\">XCTAssertNil</span>(img,<span class=\"string\">\"此时img不为nil,中止执行\"</span>)  <span class=\"comment\">//当img不是nil时，执行断言</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> predicate = <span class=\"type\">NSPredicate</span>.<span class=\"keyword\">init</span> &#123; (anyobject, bindings) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> button = anyobject <span class=\"keyword\">as</span>! <span class=\"type\">UIButton</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> button.backgroundImage(<span class=\"keyword\">for</span>: <span class=\"type\">UIControlState</span>()) != <span class=\"literal\">nil</span></span><br><span class=\"line\">        <span class=\"comment\">//实现测试期望</span></span><br><span class=\"line\">        expectation.fulfill()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//等待期望实现</span></span><br><span class=\"line\">    waitForExpectations(timeout: <span class=\"number\">20</span>, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传递expectation在目的方法中再fulfill-实现期望\"><a href=\"#传递expectation在目的方法中再fulfill-实现期望\" class=\"headerlink\" title=\"传递expectation在目的方法中再fulfill()实现期望\"></a>传递expectation在目的方法中再fulfill()实现期望</h3><p>例如将期望封装在字典中，通过通知来传递给异步下载的方法中调用该期望的<code>fulfill()</code>方法，实现单元测试的期望<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*/</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testAsynForNotificationWithExpectation2</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> expectation = <span class=\"keyword\">self</span>.expectation(description: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> notif = <span class=\"type\">Notification</span>.<span class=\"type\">Name</span>(rawValue: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(<span class=\"keyword\">self</span>, selector: #selector(<span class=\"type\">AsyncTheOldWayTest</span>.downLoadImage(<span class=\"number\">_</span>:)), name: notif, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//将期望封装在字典中传递</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> userInf = [<span class=\"string\">\"name\"</span>:<span class=\"string\">\"huosan\"</span>,<span class=\"string\">\"sex\"</span>:<span class=\"string\">\"man\"</span>,<span class=\"string\">\"expectation\"</span>:expectation]</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.post(name: notif, object: <span class=\"keyword\">self</span>, userInfo: userInf)</span><br><span class=\"line\">        <span class=\"comment\">//等待期望实现</span></span><br><span class=\"line\">        waitForExpectations(timeout: <span class=\"number\">1</span>, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.removeObserver(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">downLoadImage</span><span class=\"params\">(<span class=\"number\">_</span> notification:Notification)</span></span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> userInfo = notification.userInfo <span class=\"keyword\">as</span>! [<span class=\"type\">String</span>:<span class=\"type\">AnyObject</span>]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> name = userInfo[<span class=\"string\">\"name\"</span>]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> sex = userInfo[<span class=\"string\">\"sex\"</span>]</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"name:\\(name), sex = \\(sex)\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> expectation = userInfo[<span class=\"string\">\"expectation\"</span>] <span class=\"keyword\">as</span>! <span class=\"type\">XCTestExpectation</span></span><br><span class=\"line\">        expectation.fulfill()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"测试","path":"api/categories/测试.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"单元测试","path":"api/tags/单元测试.json"}]},{"title":"UI自动测试开发相关API","slug":"测试/UI自动测试学习","date":"2017-02-20T17:16:49.000Z","updated":"2017-05-26T11:03:05.000Z","comments":true,"path":"api/articles/测试/UI自动测试学习.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/XCUIElementAttributes.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"UI-Testing-和-Accessibility\"><a href=\"#UI-Testing-和-Accessibility\" class=\"headerlink\" title=\"UI Testing 和 Accessibility\"></a>UI Testing 和 Accessibility</h2><p>UI Accessibility 早在 iOS 3.0 就被引入了，用来辅助身体不便的人士使用 app。VoiceOver 是 Apple 的屏幕阅读技术，而 UI Accessibility 的基本原则就是对屏幕上的 UI 元素进行分类和标记。两者配合，通过阅读或者聆听这些元素，用户就可以在不接触屏幕的情况下通过声音来使用 app。</p>\n<p>Accessibility 的核心思想是对 UI 元素进行分类和标记 – 将屏幕上的 UI 分类为像是按钮，文本框，cell 或者是静态文本 (也就是 label) 这样的类型，然后使用 identifier 来区分不同的 UI 元素。用户可以通过语音控制 app 的按钮点击，或是询问某个 label 的内容等等，十分方便。iOS SDK 中的控件都实现了默认的 Accessibility 支持，而我们如果使用自定义的控件的话，则需要自行使用 Accessibility 的 API 来进行添加。</p>\n<h2 id=\"UI-Testing-API\"><a href=\"#UI-Testing-API\" class=\"headerlink\" title=\"UI Testing API\"></a>UI Testing API</h2><h3 id=\"XCUIApplication-获取APP实例\"><a href=\"#XCUIApplication-获取APP实例\" class=\"headerlink\" title=\"XCUIApplication()获取APP实例\"></a>XCUIApplication()获取APP实例</h3><p><code>XCUIApplication()</code>继承<code>XCUIElement</code>，这个类掌管应用程序的生命周期，里面包含两个主要方法<br><code>launch():</code>启动程序<br><code>terminate():</code>终止程序</p>\n<h3 id=\"获取XCUIElementQuery对象的四种方式\"><a href=\"#获取XCUIElementQuery对象的四种方式\" class=\"headerlink\" title=\"获取XCUIElementQuery对象的四种方式\"></a>获取<code>XCUIElementQuery</code>对象的四种方式</h3><h4 id=\"第一种简写形式：buttons-gt-XCUIElementQuery\"><a href=\"#第一种简写形式：buttons-gt-XCUIElementQuery\" class=\"headerlink\" title=\"第一种简写形式：buttons-&gt;XCUIElementQuery\"></a>第一种简写形式：<code>buttons-&gt;XCUIElementQuery</code></h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttons:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().buttons</span><br><span class=\"line\"><span class=\"keyword\">let</span> textFields:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().textFields</span><br></pre></td></tr></table></figure>\n<h4 id=\"三种通过XCUIElementType的枚举值\"><a href=\"#三种通过XCUIElementType的枚举值\" class=\"headerlink\" title=\"三种通过XCUIElementType的枚举值\"></a>三种通过<code>XCUIElementType</code>的枚举值</h4><p>通过<code>XCUIElementType</code>的枚举值来获取<code>XCUIElementQuery</code>对象，其中第二种是简写方式。<br><code>XCUIElementType</code>枚举声明如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">XCUIElementType</span> : <span class=\"title\">UInt</span> </span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">case</span> button</span><br><span class=\"line\">    <span class=\"keyword\">case</span> radioButton</span><br><span class=\"line\">    <span class=\"keyword\">case</span> textField</span><br><span class=\"line\">    <span class=\"keyword\">case</span> comboBox</span><br><span class=\"line\">    <span class=\"keyword\">case</span> menuButton</span><br><span class=\"line\">    <span class=\"keyword\">case</span> toolbarButton</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"第一种获取所有的元素：descendantsMatchingType-gt-XCUIElementQuery\"><a href=\"#第一种获取所有的元素：descendantsMatchingType-gt-XCUIElementQuery\" class=\"headerlink\" title=\"第一种获取所有的元素：descendantsMatchingType-&gt;XCUIElementQuery\"></a>第一种获取所有的元素：<code>descendantsMatchingType-&gt;XCUIElementQuery</code></h5><p>取某种类型的元素以及它的子类集合，能获取到系统级控件如<code>UIButton</code>，和用户自定义的UI控件<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttons:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().descendantsMatchingType(.<span class=\"type\">Button</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> textFields:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().descendantsMatchingType(.textField)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"第三种仅获取当前层级子元素：childrenMatchingType\"><a href=\"#第三种仅获取当前层级子元素：childrenMatchingType\" class=\"headerlink\" title=\"第三种仅获取当前层级子元素：childrenMatchingType\"></a>第三种仅获取当前层级子元素：<code>childrenMatchingType</code></h5><p>取某种类型的元素集合，不包含它的子类，即仅获取系统级控件如<code>UIButton</code>，不获取用户自定义的UI控件<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttons:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().childrenMatchingType(.<span class=\"type\">Button</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> textFields:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().childrenMatchingType(.textField)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"第四种所有包含的元素：containingType\"><a href=\"#第四种所有包含的元素：containingType\" class=\"headerlink\" title=\"第四种所有包含的元素：containingType\"></a>第四种所有包含的元素：<code>containingType</code></h5><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttons:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().containingType(.<span class=\"type\">Button</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> textFields:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().containingType(.textField)</span><br></pre></td></tr></table></figure>\n<h3 id=\"XCUIElement表示系统的各种UI控件\"><a href=\"#XCUIElement表示系统的各种UI控件\" class=\"headerlink\" title=\"XCUIElement表示系统的各种UI控件\"></a>XCUIElement表示系统的各种UI控件</h3><p><code>XCUIElement</code>UI控件在测试框架中的代理，继承<code>NSObject</code>，实现<code>XCUIElementAttributes</code>协议, <code>XCUIElementTypeQueryProvider</code>协议，可以表示系统的各种UI控件。</p>\n<ol>\n<li>XCUIElementAttributes协议：里面包含了UIAccessibility中的部分属性<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/XCUIElementAttributes.png?imageMogr2/2/w/800\">\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/UIAccessibility.jpg?imageMogr2/2/w/800\"></li>\n<li>XCUIElementTypeQueryProvider协议：包含了系统中大部分UI控件的类型，可通过读属性的方式取得某种类型的UI集合<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/XCUIElementTypeQueryProvider.png?imageMogr2/2/w/800\">\n</li>\n</ol>\n<h4 id=\"访问UI控件\"><a href=\"#访问UI控件\" class=\"headerlink\" title=\"访问UI控件\"></a>访问UI控件</h4><ol>\n<li><code>exist:</code>判断当前的UI元素是否存在，如果对一个不存在的元素进行操作，会导致测试组件抛出异常并中断测试.</li>\n<li><code>element()</code>／<code>下标方法</code>：<code>XCUIElementQuery</code>实例的方法获取UI控件，不能直接通过<code>XCUIElement</code> 来访问 app 中的元素，只能通过 <code>Accessibility</code> 中的像是 <code>identifier</code> 或者 <code>frame</code> 这样的属性来获取 UI 的信息。<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> userNameTextField:<span class=\"type\">XCUIElement</span> = app.textFields.element(boundBy: <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> userNameTextField:<span class=\"type\">XCUIElement</span> = app.textFields[<span class=\"string\">\"username\"</span>]</span><br></pre></td></tr></table></figure>\n对于 <code>XCUIElementQuery</code>，<code>Query</code>的执行是有延迟的，它和最后我们得到的 <code>XCUIElement</code> 并不是一一对应的。和 <code>NSURL</code> 与请求到的内容的关系类似，随着时间的变化，同一个 <code>URL</code> 有可能请求到不同的内容。<br>在拿到<code>Query</code>实例后，只有在通过<code>下标</code>或<code>访问方法</code>访问时，才会真正寻找对应的 <code>UI 控件</code>。这就是说，随着我们的 UI 的变化，同样的 <code>query</code> 也可能获取到不用的<code>UI控件</code>。为了获取UI元素准确：我们可以通过在 <code>Interface Builder</code> 或者<code>代码</code>中，对UI控件的 <code>identifier</code>属性进行设置，这样就可以使用下标的方式进行访问了。</li>\n</ol>\n<h4 id=\"设置UI控件触发事件和属性值\"><a href=\"#设置UI控件触发事件和属性值\" class=\"headerlink\" title=\"设置UI控件触发事件和属性值\"></a>设置UI控件<code>触发事件</code>和<code>属性值</code></h4><p>使用<code>typeText(text:String)</code>,<code>tap()</code>,<code>doubleTap()</code>等方法。<br>以获取userNameTextField控件为例：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> userNameTextField:<span class=\"type\">XCUIElement</span> = app.textFields.element(boundBy: <span class=\"number\">0</span>)</span><br><span class=\"line\">userNameTextField.tap()</span><br><span class=\"line\">userNameTextField.typeText(<span class=\"string\">\"文本内容\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"XCUIElementAttributes协议\"><a href=\"#XCUIElementAttributes协议\" class=\"headerlink\" title=\"XCUIElementAttributes协议\"></a>XCUIElementAttributes协议</h4><p>UI元素中包含的各个属性，<code>identifier</code>，<code>frame</code>,<code>title</code>,<code>label</code>等…</p>\n<ol>\n<li>使用: 可使用这些属性来获取UI元素对象。<figure class=\"highlight swift\"><figcaption><span>title获取</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> username = <span class=\"string\">\"hsg\"</span></span><br><span class=\"line\">userNameTextField.typeText(username)</span><br><span class=\"line\">app.textFields[username].tap()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><figcaption><span>identifier获取</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> identifier = <span class=\"string\">\"hsg\"</span></span><br><span class=\"line\">userNameTextField.typeText(username)</span><br><span class=\"line\">app.textFields[username].tap()</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"测试","path":"api/categories/测试.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"单元测试","path":"api/tags/单元测试.json"}]},{"title":"JavaScript自动化组件OC桥接","slug":"macOS/JavaScript自动化组件OC桥接","date":"2017-02-15T17:19:30.000Z","updated":"2017-02-16T13:43:01.000Z","comments":true,"path":"api/articles/macOS/JavaScript自动化组件OC桥接.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><a href=\"https://developer.apple.com/library/content/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/OSX10-10.html#//apple_ref/doc/uid/TP40014508-CH109-SW8\" target=\"_blank\" rel=\"noopener\">文档</a><br><code>JavaScript自动化</code>有一个内置的<code>Objective-C Bridge</code>，使您能够访问文件系统，创建Cocoa应用程序。<br><code>Objective-C Bridge</code>的主要接入点是全局属性<code>objc</code>和<code>$</code>。</p>\n<h2 id=\"Frameworks\"><a href=\"#Frameworks\" class=\"headerlink\" title=\"Frameworks\"></a>Frameworks</h2><p><code>Foundation framework</code>中的语法默认支持<code>JavaScript自动化</code>。也可以通过使用<code>ObjC.import()</code>方法导入其他Frameworks 和 libraries。<br>例如，使用<code>Cocoa框架</code>中的<code>NSBeep()</code>函数，需要导入<code>Cocoa框架</code><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjC.import(<span class=\"string\">'Cocoa'</span>)</span><br><span class=\"line\">$.NSBeep()</span><br></pre></td></tr></table></figure><br>除了系统框架之外，一些系统库的功能也被暴露出来。这个功能可以通过<code>头文件</code>的名称来暴漏出来（不带.h）<br>例如：<br>arpa/inet, asl, copyfile, dispatch, dyld, errno, getopt, glob, grp, ifaddrs, launch, membership, netdb, netinet/in, notify, objc, paths, pwd, readline, removefile, signal, spawn, sqlite3, stdio, stdlib, string, sys/fcntl, sys/file, sys/ioctl, sys/mount, sys/param, sys/resource, sys/socket, sys/stat, sys/sysctl, sys/time, sys/times, sys/types, sys/wait, sys/xattr, syslog, time, unistd, uuid/uuid, vImage, vecLib, vmnet, xpc, 和 zlib.<br>导入框架时，系统将参考桥接支持文件。除了内置的框架和库，您可以导入任何具有桥接支持的框架，只需要将完整路径传递给框架，如下示例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjC.import(<span class=\"string\">'/Library/Frameworks/Awesome.framework'</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>原始的<code>JavaScript数据类型</code>映射到<code>C数据类型</code>。例如，一个<code>JavaScript字符串</code>映射为<code>char *</code>，而<code>JavaScript整数</code>映射到<code>int</code>。使用<code>objc API</code>返回一个<code>char *</code>时，会得到一个<code>JS 字符串</code></p>\n<p>原始的<code>JavaScript数据类型</code>将被自动转换为<code>ObjC对象类型</code>，并能作为一个预期的对象类型的参数传递给ObjC方法。<br>例如，一个<code>JS字符串</code>将被转换为一个<code>NSString对象</code>如果是什么方法签名说应该是输入。</p>\n<blockquote>\n<p>注意，然而，ObjC方法返回的ObjC对象类型是不会自动转换为原始的JavaScript的数据类型。</p>\n</blockquote>\n<h2 id=\"实例化的类和调用方法\"><a href=\"#实例化的类和调用方法\" class=\"headerlink\" title=\"实例化的类和调用方法\"></a>实例化的类和调用方法</h2><p>所有类都定义为<code>$对象</code>的属性。ObjC对象的方法有两种方式调用，根据是否需要参数的方法。<br>如果ObjC方法不带参数，然后调用<code>JavaScript属性名</code>访问<code>属性值</code>。这个例子中实例化一个空的字符串。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = $.NSMutableString.alloc.init</span><br></pre></td></tr></table></figure><br>如果ObjC方法不带参数，根据<code>JSExport</code>规范来命名，通过JavaScript的方法调用（function-typed property）；<br>对于多参数的方法，Objective-C的方法每个部分都合并在一起，冒号后的字母变为大写并移除冒号。比如下边协议中的方法，在JavaScript调用就是：doFooWithBar(foo, bar);<br>这个例子说明<code>JavaScript字符串</code>转为<code>NSString</code>然后写入到一个文件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = $.NSString.alloc.initWithUTF8String(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\">str.writeToFileAtomically(<span class=\"string\">'/tmp/foo'</span>, <span class=\"literal\">true</span>)</span><br></pre></td></tr></table></figure></p>\n<p>如果你调用一个方法，如<code>-intValue</code>，返回<code>C数据类型</code>而不是一个对象，然后你会回到原始的<code>JavaScript数据类型</code>。<br>此示例返回原始的JavaScript的整数，99。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.NSNumber.numberWithInt(<span class=\"number\">99</span>).intValue</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"访问-ObjC-Properties\"><a href=\"#访问-ObjC-Properties\" class=\"headerlink\" title=\"访问 ObjC Properties\"></a>访问 ObjC Properties</h3><p><code>ObjC属性</code>也可以通过<code>JavaScript属性</code>来访问，很像调用无参数方法。<br>当一个<code>桥接对象属性</code>的被访问时，ObjC属性列表是第一参考，如果列表中存在该名称对应的属性，那么就调用相应属性的<code>getter</code>或<code>setter</code>选择器。如果该名称的ObjC属性不在类中属性的列表中，那么该属性名称就作为<code>方法选择器</code>来调用。<br>使用自定义<code>getter</code>名定义一个属性，你可以使用<code>属性</code>名 或 <code>getter</code>名，并得到相同的结果。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task = $.NSTask.alloc.init</span><br><span class=\"line\">task.running == task.isRunning</span><br></pre></td></tr></table></figure><br>另外，不同的参数方法，<code>桥接对象属性</code>映射到<code>ObjC属性</code>也可以设置为（read/write属性）。下面的两行定义了一个ObjC属性：<code>launchPath</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task.launchPath = <span class=\"string\">'/bin/sleep'</span></span><br><span class=\"line\">task.setLaunchPath(<span class=\"string\">'/bin/sleep'</span>)</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"JS","path":"api/categories/JS.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"混编","path":"api/tags/混编.json"}]},{"title":"macOS支持JavaScript自动化组件基础","slug":"macOS/macOS支持JavaScript自动化组件基础","date":"2017-02-15T17:19:30.000Z","updated":"2017-02-16T13:43:01.000Z","comments":true,"path":"api/articles/macOS/macOS支持JavaScript自动化组件基础.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>苹果 <code>OS X Yosemite系统</code>把 <code>JavaScript</code>作为<code>AppleScript</code>的另一选择。<code>Automation</code> 是 <code>OS X 10.10版本</code>中的新特性，苹果在官网发布<a href=\"https://developer.apple.com/library/prerelease/mac/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/index.html#//apple_ref/doc/uid/TP40014508\" target=\"_blank\" rel=\"noopener\">JavaScript for Automation Release Notes</a>有篇文章介绍了用<code>JavaScript</code>写自动化<code>Automation</code>脚本。<br><code>JavaScript</code>凭借其简单的语法，良好的性能，超轻量的框架，极小耦合的模块系统等等优势已经吸引了很多大厂的关注。<br>再加上<code>JavaScript</code>先天开放且无版权专利纠纷的问题，拥有非常广泛的开发者（开源）群体，苹果将其引入<code>OS X平台</code>代替私有的<code>AppleScript</code>，可能也有着一部分开放性平台的考虑，从而吸引广泛的第三方开发者。<br>资源<br><a href=\"https://github.com/tylergaw/js-osx-app-examples\" target=\"_blank\" rel=\"noopener\">JavaScript OS X App Examples</a><br><a href=\"https://github.com/dtinth/JXA-Cookbook\" target=\"_blank\" rel=\"noopener\">JavaScript for Automation Cookbook</a></p>\n<h2 id=\"OSA框架-Open-Scripting-Architecture\"><a href=\"#OSA框架-Open-Scripting-Architecture\" class=\"headerlink\" title=\"OSA框架:Open Scripting Architecture\"></a>OSA框架:<code>Open Scripting Architecture</code></h2><p><code>OSA</code>组件用于实现MacAPP自动化操作。这些框架组件使用场景包括：<code>Script Editor</code>编辑器，全系统的<code>Script菜单</code>，<code>Run JavaScript Automator</code>命令的操作，<code>applets</code>小程序，命令行<code>osascript</code>工具，<code>NSUserScriptTask API</code>中，还可以运用在其他的<code>OSA</code>组件中例如：<code>AppleScript</code>。这也就包括了<code>Mail</code>规则、<code>Folder</code>操作、<code>Address Book</code>插件、日历闹钟和消息触发器。</p>\n<h2 id=\"脚本字典\"><a href=\"#脚本字典\" class=\"headerlink\" title=\"脚本字典\"></a>脚本字典</h2><p>脚本字典详细介绍APP的对象模型。在脚本字典映射到有效的JavaScript标识符遵循一套规范的术语。在<code>Script Editor</code>脚本字典浏览器已经更新到显示术语<code>AppleScript</code>，<code>JavaScript</code>和O<code>bjective-C</code>（Scripting Bridge framework）格式。</p>\n<h3 id=\"打开脚本字典\"><a href=\"#打开脚本字典\" class=\"headerlink\" title=\"打开脚本字典\"></a>打开脚本字典</h3><p>启动<code>Script Editor</code> (/Applications/Utilities/) –&gt;<code>File &gt; Open Dictionary or Window &gt; Library</code>。</p>\n<h2 id=\"object-specifier\"><a href=\"#object-specifier\" class=\"headerlink\" title=\"object specifier\"></a>object specifier</h2><p>在<code>JavaScript自动化主机</code>环境中的大部分对象指的是外部实例，如：其他APP，window或在这些APP的相关数据。当访问一个APP对象或APP中的某个元素的<code>JavaScript属性</code>时，会返回一个新的<code>object specifier</code>，也就是这个对象的<code>specifier 属性</code>。</p>\n<blockquote>\n<p>object specifier不是外部实例属性的实际值，是这个对象的引用指针。如果要获取这个属性的实际值，使用get／set方法。</p>\n</blockquote>\n<h2 id=\"访问APP\"><a href=\"#访问APP\" class=\"headerlink\" title=\"访问APP\"></a>访问APP</h2><p>六种方式:<br><figure class=\"highlight js\"><figcaption><span>By name</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application(<span class=\"string\">'Mail'</span>)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><figcaption><span>By bundle ID</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application(<span class=\"string\">'com.apple.mail'</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>By path</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application(<span class=\"string\">'/Applications/Mail.app'</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>By process ID</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application(<span class=\"number\">763</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>On a remote machine</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application(<span class=\"string\">'eppc://127.0.0.1/Mail'</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>currentApplication</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application.currentApplication()</span><br></pre></td></tr></table></figure>\n<h2 id=\"语法示例\"><a href=\"#语法示例\" class=\"headerlink\" title=\"语法示例\"></a>语法示例</h2><figure class=\"highlight js\"><figcaption><span>Access properties</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.name</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>Access elements</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.outgoingMessages[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>Call commands</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.open(...)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>Create new objects</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.OutgoingMessage(...)</span><br></pre></td></tr></table></figure>\n<h3 id=\"属性的get-set方法\"><a href=\"#属性的get-set方法\" class=\"headerlink\" title=\"属性的get/set方法\"></a>属性的get/set方法</h3><p>点运算符访问脚本对象，是JavaScript语法特性之一。<br>如上所述，返回的对象是一个<code>object specifier</code>是一个对象的引用，而不是属性实际值。<br>当访问属性时，会作为一个get函数，返回实际值：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subject = Mail.inbox.messages[<span class=\"number\">0</span>].subject()</span><br></pre></td></tr></table></figure><br>当赋值属性时，会作为一个set函数，把参数赋值该属性：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.outgoingMessages[<span class=\"number\">0</span>].subject = <span class=\"string\">'Hello world'</span></span><br></pre></td></tr></table></figure><br>获取数组中的每个元素属性（在这种情况下，得到邮件收件箱中的每份邮件的标题）<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subjects = Mail.inbox.messages.subject()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"元素数组\"><a href=\"#元素数组\" class=\"headerlink\" title=\"元素数组\"></a>元素数组</h3><p>通过在数组中调用特定元素检索方法，或使用方括号并指定要检索的元素的名称或索引来访问数组中的元素。返回值是对象相关，与自己的属性和元素，引用数组元素。他们可以访问<br><figure class=\"highlight js\"><figcaption><span>索引</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span> = Mail.windows.at(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">window</span> = Mail.windows[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure><br><figure class=\"highlight js\"><figcaption><span>name</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span> = Mail.windows.byName(<span class=\"string\">'New Message'</span>)</span><br><span class=\"line\"><span class=\"built_in\">window</span> = Mail.windows[<span class=\"string\">'New Message'</span>]</span><br></pre></td></tr></table></figure><br><figure class=\"highlight js\"><figcaption><span>ID</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span> = Mail.windows.byId(<span class=\"number\">412</span>)</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Note: 使用ID来访问不是方括号[]而是().</p>\n</blockquote>\n<h3 id=\"调用命令\"><a href=\"#调用命令\" class=\"headerlink\" title=\"调用命令\"></a>调用命令</h3><p>命令被称为函数。</p>\n<ol>\n<li>直接参数的函数，该参数作为命令的第一个参数传递。</li>\n<li>如果函数需要带参数名的参数，那么这个参数可以接受一个键值对对象。</li>\n<li>如果函数需要一个直接参数，就需要传递一个带参数名的参数作为第二个参数。</li>\n<li>如果函数不存在直接参数，那么带参数名的参数作为第一个参数传递，并且唯一参数。</li>\n<li>直接参数是可选的，可以不用传递任何值，当第一个参数存在参数名时，则传递NULL作为第一个参数。<figure class=\"highlight js\"><figcaption><span>无参数命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message.open()</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>无参数名的命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.open(message)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>带参数名的命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response = message.reply(&#123;</span><br><span class=\"line\">replayAll: <span class=\"literal\">true</span>,</span><br><span class=\"line\">openingWindow: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>Command with direct parameter and named parameters</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Safari.doJavaScript(<span class=\"string\">'alert(\"Hello world\")'</span>, &#123;</span><br><span class=\"line\"><span class=\"keyword\">in</span>: Safari.windows[<span class=\"number\">0</span>].tabs[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Creating-Objects\"><a href=\"#Creating-Objects\" class=\"headerlink\" title=\"Creating Objects\"></a>Creating Objects</h2><p>通过调用<code>类构造函数</code>初始化<code>属性</code>和<code>数据</code>来创建新对象。<br>在创建对象时,需要执行的其中步骤：</p>\n<ol>\n<li><code>make()</code>方法：调用对象上的<code>make()</code>方法来实例化对象。</li>\n<li><code>push()</code>方法：调用对象数组上的<code>push</code>方法来实例化对象。<br>在调用这些方法中的一个之前，对象实际上并不存在于应用程序中。</li>\n</ol>\n<h3 id=\"Create-a-new-object\"><a href=\"#Create-a-new-object\" class=\"headerlink\" title=\"Create a new object.\"></a>Create a new object.</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message = Mail.OutgoingMessage().make()</span><br></pre></td></tr></table></figure>\n<h3 id=\"Create-a-new-object-with-properties\"><a href=\"#Create-a-new-object-with-properties\" class=\"headerlink\" title=\"Create a new object with properties.\"></a>Create a new object with properties.</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message = Mail.OutgoingMessage(&#123;</span><br><span class=\"line\">subject: <span class=\"string\">'Hello world'</span>,</span><br><span class=\"line\">visible: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Mail.outgoingMessages.push(message)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Create-a-new-object-with-data\"><a href=\"#Create-a-new-object-with-data\" class=\"headerlink\" title=\"Create a new object with data.\"></a>Create a new object with data.</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">para = TextEdit.Paragraph(&#123;&#125;, <span class=\"string\">'Some text'</span>)</span><br><span class=\"line\">TextEdit.documents[<span class=\"number\">0</span>].paragraphs.push(para)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用对象\"><a href=\"#使用对象\" class=\"headerlink\" title=\"使用对象\"></a>使用对象</h3><p>一旦你在应用程序中创建一个新的对象（通过调用<code>make</code>或<code>push</code>），可以像任何现有的应用程序对象一样进行交互。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message = Mail.OutgoingMessage().make()</span><br><span class=\"line\">message.subject = <span class=\"string\">'Hello world'</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Scripting-Additions\"><a href=\"#Scripting-Additions\" class=\"headerlink\" title=\"Scripting Additions\"></a>Scripting Additions</h3><p>使用脚本添加（脚本插件）来增强应用程序的功能。操作系统有一套标准的脚本添加提供speak text,展示用户交互对话，等。<br>使用这些，必须明确设置<code>includeStandardAdditions</code>的<code>flag</code>为 <code>true</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app = Application.currentApplication()</span><br><span class=\"line\">app.includeStandardAdditions = <span class=\"literal\">true</span></span><br><span class=\"line\">app.say(<span class=\"string\">'Hello world'</span>)</span><br><span class=\"line\">app.displayDialog(<span class=\"string\">'Please enter your email address'</span>, &#123;</span><br><span class=\"line\">withTitle: <span class=\"string\">'Email'</span>,</span><br><span class=\"line\">defaultAnswer: <span class=\"string\">'your_email@site.com'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Applets\"><a href=\"#Applets\" class=\"headerlink\" title=\"Applets\"></a>Applets</h2><p>在<code>Script Editor</code>编写脚本并保存为一个应用程序，且可以被双击独立运行的程序称为<code>Applet</code>。<br>程序支持以下事件处理：<br>当Applet运行时，<code>run</code>处理事件被调用：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<p>用于拖放操作的<code>openDocuments</code>处理事件程序包配置小程序，当文档被拖放到该小程序上时，这个处理操作将被执行：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">openDocuments</span>(<span class=\"params\">docs</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><br>传递的参数是一个文件路径字符串数组。<br><a href=\"https://developer.apple.com/library/content/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/OSX10-10.html#//apple_ref/doc/uid/TP40014508-CH109-SW8\" target=\"_blank\" rel=\"noopener\">更多样例</a></p>\n<h2 id=\"UI-Automation\"><a href=\"#UI-Automation\" class=\"headerlink\" title=\"UI Automation\"></a>UI Automation</h2><p>通过编写系统事件应用程序，可以自动化应用程序的用户界面。在脚本编辑器<code>Script Editor</code>中浏览<code>System Events</code>的脚本字典，特别是进程套件<code>Processes Suite</code>，以查看支持此类型自动化的应用程序接口元素的列表。<br>下面的示例使用UI脚本创建Notes中的新注释。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Notes = Application(<span class=\"string\">'Notes'</span>)</span><br><span class=\"line\">Notes.activate()</span><br><span class=\"line\"></span><br><span class=\"line\">delay(<span class=\"number\">1</span>)</span><br><span class=\"line\">SystemEvents = Application(<span class=\"string\">'System Events'</span>)</span><br><span class=\"line\">Notes = SystemEvents.processes[<span class=\"string\">'Notes'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">Notes.windows[<span class=\"number\">0</span>].splitterGroups[<span class=\"number\">0</span>].groups[<span class=\"number\">1</span>].groups[<span class=\"number\">0</span>].buttons[<span class=\"number\">0</span>].click()</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"JS","path":"api/categories/JS.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"混编","path":"api/tags/混编.json"},{"name":"JavaScript","path":"api/tags/JavaScript.json"}]},{"title":"通过沙盒中JS脚本访问其他APP","slug":"macOS/通过沙盒中JS脚本访问其他APP","date":"2017-02-14T18:25:29.000Z","updated":"2017-02-16T13:43:01.000Z","comments":true,"path":"api/articles/macOS/通过沙盒中JS脚本访问其他APP.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>如何使用脚本字典里的命令和对象来与其他的应用进行通讯?<br>这个教程将向您展示现在使用 <code>AppleScript</code> 来控制别的应用的最佳方式。我也会告诉您一些小技巧以帮助您和您的用户用最小的努力就架设起 <code>AppleScript</code>。</p>\n<h2 id=\"在自己的APP中编写\"><a href=\"#在自己的APP中编写\" class=\"headerlink\" title=\"在自己的APP中编写\"></a>在自己的APP中编写</h2><h3 id=\"编写AppleScript代码\"><a href=\"#编写AppleScript代码\" class=\"headerlink\" title=\"编写AppleScript代码\"></a>编写AppleScript代码</h3><p><a href=\"https://developer.apple.com/library/mac/documentation/applescript/conceptual/applescriptlangguide/introduction/ASLR_intro.html#//apple_ref/doc/uid/TP40000983-CH208-SW1\" target=\"_blank\" rel=\"noopener\">AppleScript 脚本指南</a><br>与其他应用进行通讯的脚本一般来说都很短，也容易理解。<code>AppleScript</code> 可以被想做一种传送的机制，而不是一种处理环境。<br>典型脚本:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on chockify(inputString)</span><br><span class=\"line\">    set resultString to <span class=\"string\">\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        repeat <span class=\"keyword\">with</span> inputStringCharacter <span class=\"keyword\">in</span> inputString</span><br><span class=\"line\">            set asciiValue to (ASCII number inputStringCharacter)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (asciiValue &gt; <span class=\"number\">96</span> and asciiValue &lt; <span class=\"number\">123</span>) then</span><br><span class=\"line\">                set resultString to resultString &amp; (ASCII character (asciiValue - <span class=\"number\">32</span>))</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((asciiValue &gt; <span class=\"number\">64</span> and asciiValue &lt; <span class=\"number\">91</span>) or (asciiValue = <span class=\"number\">32</span>)) then</span><br><span class=\"line\">                    set resultString to resultString &amp; inputStringCharacter</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (asciiValue &gt; <span class=\"number\">47</span> and asciiValue &lt; <span class=\"number\">58</span>) then</span><br><span class=\"line\">                        set numberStrings to &#123;<span class=\"string\">\"ZERO\"</span>, <span class=\"string\">\"ONE\"</span>, <span class=\"string\">\"TWO\"</span>, <span class=\"string\">\"THREE\"</span>, <span class=\"string\">\"FOR\"</span>, <span class=\"string\">\"FIVE\"</span>, <span class=\"string\">\"SIX\"</span>, <span class=\"string\">\"SEVEN\"</span>, <span class=\"string\">\"EIGHT\"</span>, <span class=\"string\">\"NINE\"</span>&#125;</span><br><span class=\"line\">                        set itemIndex to asciiValue - <span class=\"number\">47</span></span><br><span class=\"line\">                        set numberString to item itemIndex <span class=\"keyword\">of</span> numberStrings</span><br><span class=\"line\">                        set resultString to resultString &amp; numberString &amp; <span class=\"string\">\" \"</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (asciiValue = <span class=\"number\">33</span>) then</span><br><span class=\"line\">                            set resultString to resultString &amp; <span class=\"string\">\" DUH\"</span></span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (asciiValue = <span class=\"number\">63</span>) then</span><br><span class=\"line\">                                set resultString to resultString &amp; <span class=\"string\">\" IF YOU KNOW WHAT I MEAN\"</span></span><br><span class=\"line\">                            end <span class=\"keyword\">if</span></span><br><span class=\"line\">                        end <span class=\"keyword\">if</span></span><br><span class=\"line\">                    end <span class=\"keyword\">if</span></span><br><span class=\"line\">                end <span class=\"keyword\">if</span></span><br><span class=\"line\">            end <span class=\"keyword\">if</span></span><br><span class=\"line\">        end repeat</span><br><span class=\"line\">        resultString</span><br><span class=\"line\">end chockify</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"创建事件描述符-event-descriptor\"><a href=\"#创建事件描述符-event-descriptor\" class=\"headerlink\" title=\"创建事件描述符 (event descriptor)\"></a>创建事件描述符 (event descriptor)</h3><ol>\n<li>导入Carbon.h<br>它有关于所有的 AppleEvent 的定义。<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Carbon/Carbon.h&gt;</span> // for AppleScript definitions</span></span><br></pre></td></tr></table></figure></li>\n<li>OC中创建<code>chockify</code>事件描述符<br>这是可以在你的脚本和应用之间互相传递的一个数据块。可以把它理解成一个封装好的会去执行某个事件的目标，一个将被调用的函数，以及这个函数的参数。使用一个 <code>NSString</code> 作为参数，创建<code>chockify</code>事件描述符：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSAppleEventDescriptor</span> *)chockifyEventDescriptorWithString:(<span class=\"built_in\">NSString</span> *)inputString</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// parameter</span></span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *parameter = [<span class=\"built_in\">NSAppleEventDescriptor</span> descriptorWithString:inputString];</span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *parameters = [<span class=\"built_in\">NSAppleEventDescriptor</span> listDescriptor];</span><br><span class=\"line\">    [parameters insertDescriptor:parameter atIndex:<span class=\"number\">1</span>]; <span class=\"comment\">// you have to love a language with indices that start at 1 instead of 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// target</span></span><br><span class=\"line\">    ProcessSerialNumber psn = &#123;<span class=\"number\">0</span>, kCurrentProcess&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *target = [<span class=\"built_in\">NSAppleEventDescriptor</span> descriptorWithDescriptorType:typeProcessSerialNumber bytes:&amp;psn length:<span class=\"keyword\">sizeof</span>(ProcessSerialNumber)];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// function</span></span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *function = [<span class=\"built_in\">NSAppleEventDescriptor</span> descriptorWithString:<span class=\"string\">@\"chockify\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// event</span></span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *event = [<span class=\"built_in\">NSAppleEventDescriptor</span> appleEventWithEventClass:kASAppleScriptSuite eventID:kASSubroutineEvent targetDescriptor:target returnID:kAutoGenerateReturnID transactionID:kAnyTransactionID];</span><br><span class=\"line\">    [event setParamDescriptor:function forKeyword:keyASSubroutineName];</span><br><span class=\"line\">    [event setParamDescriptor:parameters forKeyword:keyDirectObject];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> event;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"OC中加载-AppleScript\"><a href=\"#OC中加载-AppleScript\" class=\"headerlink\" title=\"OC中加载 AppleScript\"></a>OC中加载 AppleScript</h3><p>通过应用包(Application bundle)的一个 <code>URL</code> 可以创建 <code>NSAppleScript</code>的实例。而反过来，脚本也要和上面创建的 <code>chockify 事件描述符</code>一起使用。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURL</span> *URL = [[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"Automation\"</span> withExtension:<span class=\"string\">@\"scpt\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (URL) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAppleScript</span> *appleScript = [[<span class=\"built_in\">NSAppleScript</span> alloc] initWithContentsOfURL:URL error:<span class=\"literal\">NULL</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *event = [<span class=\"keyword\">self</span> chockifyEventDescriptorWithString:[<span class=\"keyword\">self</span>.chockifyInputTextField stringValue]];</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *error = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *resultEventDescriptor = [appleScript executeAppleEvent:event error:&amp;error];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! resultEventDescriptor) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s AppleScript run error = %@\"</span>, __PRETTY_FUNCTION__, error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> *string = [<span class=\"keyword\">self</span> stringForResultEventDescriptor:resultEventDescriptor];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> updateChockifyTextFieldWithString:string];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如果一切正常的话，你会得到另一个事件描述符。如果出错了，你会得到一个包含了描述错误信息的字典。虽说这个模式和很多其他 <code>Foundation 类</code>很相似，但是返回的错误并不是一个 <code>NSError</code> 的实例。</p>\n<h3 id=\"调用事件描述符\"><a href=\"#调用事件描述符\" class=\"headerlink\" title=\"调用事件描述符\"></a>调用事件描述符</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)stringForResultEventDescriptor:(<span class=\"built_in\">NSAppleEventDescriptor</span> *)resultEventDescriptor</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *result = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resultEventDescriptor)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([resultEventDescriptor descriptorType] != kAENullEvent)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ([resultEventDescriptor descriptorType] == kTXNUnicodeTextData) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result = [resultEventDescriptor stringValue];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>InputString 输入可以被正确整形输出，并且你现在也看到想在你的应用里运行 AppleScripts 的方法</p>\n<h2 id=\"调用沙盒中脚本代码与访问其他应用\"><a href=\"#调用沙盒中脚本代码与访问其他应用\" class=\"headerlink\" title=\"调用沙盒中脚本代码与访问其他应用\"></a>调用沙盒中脚本代码与访问其他应用</h2><h3 id=\"了解APP沙盒限制\"><a href=\"#了解APP沙盒限制\" class=\"headerlink\" title=\"了解APP沙盒限制\"></a>了解APP沙盒限制</h3><p>如果一段脚本可以轻易地拿到浏览器当前页面上的内容，甚至是在任意标签和窗口运行<code>JavaScript</code>。想象一下如果这些页面里有你的银行账号，或者包含你的信用卡信息什么的。</p>\n<p>对于沙盒应用，Apple 所提倡的是通过用户的需要来驱动安全策略。这意味着是否运行你的脚本完全取决于用户。这些脚本可能是来自互联网，也可能是你应用的一部分。一旦得到了权限，脚本就可以以一种受限的方式与系统其他部分进行交互了。<code>NSUserScriptTask</code>使这一切变得可能。<br>由此：Apple 引入了一个新的抽象类 <code>NSUserScriptTask</code>,有三个具体的子类实现:</p>\n<ol>\n<li><code>NSUserUnixTask</code>: 执行 Unix shell 命令</li>\n<li><code>NSUserAutomatorTask</code>: Automator 工作流</li>\n<li><code>NSUserAppleScriptTask</code>:执行<code>AppleScript脚本</code>,脚本是异步执行的,所以脚本不能对用户界面做更新操作。</li>\n</ol>\n<h3 id=\"开始安装运行脚本\"><a href=\"#开始安装运行脚本\" class=\"headerlink\" title=\"开始安装运行脚本\"></a>开始安装运行脚本</h3><p>怎么向用户请求运行脚本的许可，让你的应用与用户的其他应用更好地工作在一起？<br>两种策略:</p>\n<ol>\n<li>帮助用户来存放运行脚本的位置</li>\n<li>获取行脚本目录可读写</li>\n</ol>\n<h4 id=\"帮用户存放运行脚本的位置\"><a href=\"#帮用户存放运行脚本的位置\" class=\"headerlink\" title=\"帮用户存放运行脚本的位置\"></a>帮用户存放运行脚本的位置</h4><p>只能把把这些脚本放到用户的脚本文件夹(<code>User &gt; Library &gt; Application Scripts/bundle identifier/</code>)中，以只读的方式来运行你的脚本。<br>脚本想要进入这个特定的文件夹的唯一方式就是用用户把它们复制到那里。再者<code>Library 文件夹</code>在 OS X 里默认还是隐藏的。这样对用户都很不友好。<br>让代码来帮助用户打开这个隐藏文件夹：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\"><span class=\"built_in\">NSURL</span> *directoryURL = [[<span class=\"built_in\">NSFileManager</span> defaultManager] URLForDirectory:<span class=\"built_in\">NSApplicationScriptsDirectory</span> inDomain:<span class=\"built_in\">NSUserDomainMask</span> appropriateForURL:<span class=\"literal\">nil</span> create:<span class=\"literal\">YES</span> error:&amp;error];</span><br><span class=\"line\">[[<span class=\"built_in\">NSWorkspace</span> sharedWorkspace] openURL:directoryURL];</span><br></pre></td></tr></table></figure><br>通过你的应用的某个控件打开这个文件夹，然后进行编辑。这对于用户自己写的脚本来说是个很好的解决方案。</p>\n<h4 id=\"设置运行脚本目录的读写权限\"><a href=\"#设置运行脚本目录的读写权限\" class=\"headerlink\" title=\"设置运行脚本目录的读写权限\"></a>设置运行脚本目录的读写权限</h4><ol>\n<li>在 Xcode 里，你需要更新 <code>Capabilities</code>，让其包括 <code>User Selected File to Read/Write</code>。在 <code>App Sandbox &gt; File Access</code>里找到相关选项。</li>\n<li>用户的意愿是关键，因为你需要获取权限以将脚本添加到文件夹：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\"><span class=\"built_in\">NSURL</span> *directoryURL = [[<span class=\"built_in\">NSFileManager</span> defaultManager] URLForDirectory:<span class=\"built_in\">NSApplicationScriptsDirectory</span> inDomain:<span class=\"built_in\">NSUserDomainMask</span> appropriateForURL:<span class=\"literal\">nil</span> create:<span class=\"literal\">YES</span> error:&amp;error];</span><br><span class=\"line\"><span class=\"built_in\">NSOpenPanel</span> *openPanel = [<span class=\"built_in\">NSOpenPanel</span> openPanel];</span><br><span class=\"line\">[openPanel setDirectoryURL:directoryURL];</span><br><span class=\"line\">[openPanel setCanChooseDirectories:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">[openPanel setCanChooseFiles:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">[openPanel setPrompt:<span class=\"string\">@\"Select Script Folder\"</span>];</span><br><span class=\"line\">[openPanel setMessage:<span class=\"string\">@\"Please select the User &gt; Library &gt; Application Scripts &gt; com.iconfactory.Scriptinator folder\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">[openPanel beginWithCompletionHandler:^(<span class=\"built_in\">NSInteger</span> result) &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (result == <span class=\"built_in\">NSFileHandlingPanelOKButton</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *selectedURL = [openPanel URL];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([selectedURL isEqual:directoryURL])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSURL</span> *destinationURL = [selectedURL URLByAppendingPathComponent:<span class=\"string\">@\"Automation.scpt\"</span>];</span><br><span class=\"line\">        <span class=\"built_in\">NSFileManager</span> *fileManager = [<span class=\"built_in\">NSFileManager</span> defaultManager];</span><br><span class=\"line\">        <span class=\"built_in\">NSURL</span> *sourceURL = [[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"Automation\"</span> withExtension:<span class=\"string\">@\"scpt\"</span>];</span><br><span class=\"line\">        <span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\">        <span class=\"built_in\">BOOL</span> success = [fileManager copyItemAtURL:sourceURL toURL:destinationURL error:&amp;error];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (success)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSAlert</span> *alert = [<span class=\"built_in\">NSAlert</span> alertWithMessageText:<span class=\"string\">@\"Script Installed\"</span> defaultButton:<span class=\"string\">@\"OK\"</span> alternateButton:<span class=\"literal\">nil</span> otherButton:<span class=\"literal\">nil</span> informativeTextWithFormat:<span class=\"string\">@\"The Automation script was installed succcessfully.\"</span>];</span><br><span class=\"line\">            [alert runModal];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s error = %@\"</span>, __PRETTY_FUNCTION__, error);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ([error code] == <span class=\"built_in\">NSFileWriteFileExistsError</span>) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// this is where you could update the script, by removing the old one and copying in a new one</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// the item couldn't be copied, try again</span></span><br><span class=\"line\">                [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(installAutomationScript:) withObject:<span class=\"keyword\">self</span> afterDelay:<span class=\"number\">0.0</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// try again because the user changed the folder path</span></span><br><span class=\"line\">        [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(installAutomationScript:) withObject:<span class=\"keyword\">self</span> afterDelay:<span class=\"number\">0.0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n这么一来，应用包中的 <code>Automation.scpt</code> 文件现在暴露在常规的文件系统中了。</li>\n</ol>\n<h3 id=\"执行脚本任务\"><a href=\"#执行脚本任务\" class=\"headerlink\" title=\"执行脚本任务\"></a>执行脚本任务</h3><p>使用 <code>NSUserAppleScriptTask</code> 来替代 <code>NSAppleScript</code>，来运行上面创建的<code>事件描述符</code>。<br>你大概会经常用到这些脚本任务。文档警告说对于给定的类的某个实例， <code>NSUserAppleScriptTask</code> 不应该被执行多次。所以写一个<code>工厂函数</code>来在需要的时候创建任务：<br><figure class=\"highlight objc\"><figcaption><span>工厂函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSUserAppleScriptTask</span> *)automationScriptTask</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSUserAppleScriptTask</span> *result = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *directoryURL = [[<span class=\"built_in\">NSFileManager</span> defaultManager] URLForDirectory:<span class=\"built_in\">NSApplicationScriptsDirectory</span> inDomain:<span class=\"built_in\">NSUserDomainMask</span> appropriateForURL:<span class=\"literal\">nil</span> create:<span class=\"literal\">YES</span> error:&amp;error];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (directoryURL) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSURL</span> *scriptURL = [directoryURL URLByAppendingPathComponent:<span class=\"string\">@\"Automation.scpt\"</span>];</span><br><span class=\"line\">        result = [[<span class=\"built_in\">NSUserAppleScriptTask</span> alloc] initWithURL:scriptURL error:&amp;error];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! result) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s no AppleScript task error = %@\"</span>, __PRETTY_FUNCTION__, error);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> if you're not running in a sandbox, the directory URL will always be nil</span></span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s no Application Scripts folder error = %@\"</span>, __PRETTY_FUNCTION__, error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>如果你正在写一个同时适用于沙盒和非沙盒的 Mac 应用的话，在获取 <code>directoryURL</code> 时你需要特别小心。<code>NSApplicationScriptsDirectory</code>只在沙盒中有效。</p>\n</blockquote>\n<p>在创建脚本任务后，你需要使用 <code>AppleEvent</code> 并提供一个结束处理来执行它：<br><figure class=\"highlight objc\"><figcaption><span>AppleEvent</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSUserAppleScriptTask</span> *automationScriptTask = [<span class=\"keyword\">self</span> automationScriptTask];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (automationScriptTask) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *event = [<span class=\"keyword\">self</span> safariURLEventDescriptor];</span><br><span class=\"line\">    [automationScriptTask executeWithAppleEvent:event completionHandler:^(<span class=\"built_in\">NSAppleEventDescriptor</span> *resultEventDescriptor, <span class=\"built_in\">NSError</span> *error) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! resultEventDescriptor) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s AppleScript task error = %@\"</span>, __PRETTY_FUNCTION__, error);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSURL</span> *URL = [<span class=\"keyword\">self</span> URLForResultEventDescriptor:resultEventDescriptor];</span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> The completion handler for the script is not run on the main thread. Before you update any UI, you'll need to get</span></span><br><span class=\"line\">            <span class=\"comment\">// on that thread by using libdispatch or performing a selector.</span></span><br><span class=\"line\">            [<span class=\"keyword\">self</span> performSelectorOnMainThread:<span class=\"keyword\">@selector</span>(updateURLTextFieldWithURL:) withObject:URL waitUntilDone:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>对于用户写的脚本，用户可能期望你的应用只是简单地’运行’脚本 (而不去调用事件描述符中指定的函数)。在这种情况下，你可以为 <code>event</code> 传递一个 <code>nil</code>，脚本就会像用户在 <code>Finder</code> 中双击那样的行为进行执行。<br><code>NSUserAppleScriptTask</code>脚本是异步执行的，所以你的用户界面并不会被一个 (比较长) 的脚本锁住，在结束后会执行回调处理。</p>\n<h2 id=\"同步操作\"><a href=\"#同步操作\" class=\"headerlink\" title=\"同步操作\"></a>同步操作</h2><p><code>NSAppleScript</code> 和 <code>NSUserAppleScriptTask</code> 有一个微妙的区别：新的机制是异步执行的。对于大部分情况，使用一个结束回调来处理会是一个好得多的方式，因为这样就不会因为执行脚本而阻碍你的应用。<br>然而有时候如果你想带有依赖地来执行任务的时候，事情就变得有些取巧了。比方说一个任务需要在另一个任务开始之前必须完成。这种情况下你就会想念 <code>NSAppleScript</code> 的同步特性了。<br>要获得传统方式的行为，一种简单的方法是使用一个<code>信号量(semaphore)</code> 来确保同时只有一个任务运行、在你的类或者应用的初始化方法中，使用 <code>libdispatch</code> 创建一个信号量：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.appleScriptTaskSemaphore = dispatch_semaphore_create(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure><br>接下来在初始化脚本任务之前，简单地等待信号量。当任务完成时，标记相同的这个信号量：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// wait for any previous tasks to complete before starting a new one — remember that you're blocking the main thread here!</span></span><br><span class=\"line\">dispatch_semaphore_wait(<span class=\"keyword\">self</span>.appleScriptTaskSemaphore, DISPATCH_TIME_FOREVER);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// run the script task</span></span><br><span class=\"line\"><span class=\"built_in\">NSAppleEventDescriptor</span> *event = [<span class=\"keyword\">self</span> openNetworkPreferencesEventDescriptor];</span><br><span class=\"line\">[automationScriptTask executeWithAppleEvent:event completionHandler:^(<span class=\"built_in\">NSAppleEventDescriptor</span> *resultEventDescriptor, <span class=\"built_in\">NSError</span> *error) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! resultEventDescriptor)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s AppleScript task error = %@\"</span>, __PRETTY_FUNCTION__, error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> performSelectorOnMainThread:<span class=\"keyword\">@selector</span>(showNetworkAlert) withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// the task has completed, so let any pending tasks proceed</span></span><br><span class=\"line\">    dispatch_semaphore_signal(<span class=\"keyword\">self</span>.appleScriptTaskSemaphore);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure><br>再强调一下，除非确实有所需要，否则最好别这么做。</p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"JS","path":"api/categories/JS.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"沙盒","path":"api/tags/沙盒.json"},{"name":"脚本","path":"api/tags/脚本.json"},{"name":"AppleScript","path":"api/tags/AppleScript.json"}]},{"title":"macOS之PDFKit基础","slug":"macOS/macOS之PDFKit基础","date":"2017-02-14T14:29:18.000Z","updated":"2018-01-08T14:10:41.000Z","comments":true,"path":"api/articles/macOS/macOS之PDFKit基础.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/view_vspage_space.gif?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>一个PDF的基本构建块是Documents本身。Documents通常作为文件存储在磁盘上。<br>作为文件版本，可以支持元数据标记如作者，创建日期，等等。<br>一个文件可以加密，需要密码才能查看它。两级加密存在：</p>\n<ul>\n<li>用户级加密：如果用户成功地获得用户级权限，他或她可以查看文档，但可以限制打印或复制文档。</li>\n<li>所有者级别加密：获得所有者级别权限的用户可以查看文档并具有完全使用权限。<br>许多加密的PDF文件有一个“dummy”的用户密码为<code>空字符串</code>。大多数PDF文档解析器（包括PDF套件）自动尝试空字符串密码加密后的文件，如果成功，只显示文档。因此，在技术上加密的文档不一定提示用户口令。</li>\n</ul>\n<h2 id=\"PDF页面\"><a href=\"#PDF页面\" class=\"headerlink\" title=\"PDF页面\"></a>PDF页面</h2><p>一个PDF文档由若干页面组成。这个页面看起来就像一本物理书页面显示在屏幕上。同时PDF页面可以包含<code>超链接</code>和<code>注释</code>。页面可以支持<code>裁剪</code>，还有其他使用功能：例如隐藏多余的部分（如注册标记）。</p>\n<h3 id=\"view-VS-page空间坐标\"><a href=\"#view-VS-page空间坐标\" class=\"headerlink\" title=\"view VS page空间坐标\"></a>view VS page空间坐标</h3><p>页面上的大多数对象都是在<code>page</code>空间中指定的，而不是在<code>view</code>空间中。<br>也就是说，坐标系统是在点（每英寸72点），<code>坐标原点</code>在page左侧底部，而不是<code>view</code>。<code>page</code>空间不关心缩放，显示模式等等。一个有<code>bounds</code>的item，比如说32points，保留这些界限，无论显示大小。<br>图view和page坐标系比较<br><img title=\"view和page坐标系比较\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/view_vspage_space.gif?imageMogr2/2/w/800\"><br><code>PDFView class</code>包含几个转换方法，将坐标系统从<code>view space</code>的<code>page space</code>，反之亦然。</p>\n<h2 id=\"PDF-Kit-Classes\"><a href=\"#PDF-Kit-Classes\" class=\"headerlink\" title=\"PDF Kit Classes\"></a>PDF Kit Classes</h2><p><code>PDF Kit</code>套件提供了几个不同功能的<code>类</code>。<br><code>PDFView</code>和<code>PDFSelection</code>除外，这些<code>类</code>大致对应着各个<code>对象</code>在PDF格式的规范需求。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/pdfkit_inheritancehierarchy.gif?imageMogr2/2/w/800\"></p>\n<h3 id=\"PDFView-Class\"><a href=\"#PDFView-Class\" class=\"headerlink\" title=\"PDFView Class\"></a>PDFView Class</h3><p><code>PDFView类</code>，就好比Web工具包的<code>WebView类</code>，源于<code>Application Kit</code>中的<code>NSView类</code>。在项目开发中，你可以使用<code>Interface Builder</code>轻松拖动一个<code>PDFView对象</code>放在一个window中。<del>从/Developer/Extras/Palettes/PDFKit.palette得到调色板。</del><br><code>PDFView</code>可能是<code>PDF Kit</code>中唯一个需要你自定义的的类。在APP中显示PDF数据，允许用户选择文档内容和导航浏览PDF文档，设置缩放级别，复制文本内容到剪贴板。用户可以拖放PDF文档到<code>PDFView</code>。<br><code>PDFView</code>能通过调用其他<code>PDF实用类</code>来实现其大部分功能。如果要添加特殊功能，则需要用户自定义<code>实用类</code>的子类来扩展其特殊功能。<br>Utility classes as used by PDFView<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/pdfkit_uses_hierarchy.gif?imageMogr2/2/w/800\"></p>\n<h3 id=\"PDF-Kit-Utility-Classes\"><a href=\"#PDF-Kit-Utility-Classes\" class=\"headerlink\" title=\"PDF Kit Utility Classes\"></a>PDF Kit Utility Classes</h3><p>PDF套件工具类提供一种混合的<code>Foundation-like</code>和<code>Application Kit-like</code>的行为。他们有类似的<code>NSString类</code>和<code>NSString Additions</code>方法。这些类都系橙自<code>NSObject</code><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/pdfkit_inheritancehierarchy.gif?imageMogr2/2/w/800\"></p>\n<h4 id=\"PDF-Document\"><a href=\"#PDF-Document\" class=\"headerlink\" title=\"PDF Document\"></a>PDF Document</h4><p><code>PDFDocument</code>是<code>PDF kit工具类</code>中重要类，代表着PDF data或PDF文件。其他实用工具类一般都在<code>PDFDocument</code>方法中的实例化。是<code>PDFPage</code>和<code>PDFOutline</code>；或相关支持操作：<code>PDFSelection</code>和<code>PDFDestination</code>。<br>你<code>PDFDocument对象</code>初始化，需要一个<code>PDF数据</code>或一个指向PDF文件的<code>URL</code>。实例化之后就可以访问<code>页数</code>，<code>添加</code>或<code>删除</code>页面，对所选内容为<code>NSString对象</code>进行<code>查找</code>或<code>分析</code>。</p>\n<h4 id=\"PDFPage\"><a href=\"#PDFPage\" class=\"headerlink\" title=\"PDFPage\"></a>PDFPage</h4><p><code>PDFPage</code>代表一个PDF文档的页面。你的应用程序获取一个<code>PDFPage</code>对象必须通过从<code>PDFDocument</code>对象来实例化。<code>PDFPage</code>对象是用户所看到的屏幕，和一个<code>view</code>可以同时显示多个<code>page</code>。你可以使用<code>PDFPage</code>把PDF文档内容渲染到屏幕上，添加<code>注释</code>，<code>计数字符串</code>，定义<code>选择</code>，获取一个<code>page</code>中的文本内容作为<code>NSString对象</code>或<code>NSAttributedString对象</code>。</p>\n<h4 id=\"PDFOutline\"><a href=\"#PDFOutline\" class=\"headerlink\" title=\"PDFOutline\"></a>PDFOutline</h4><p>除了显示实际的文件内容，<code>PDF Kit</code>也能呈现<code>PDFOutline</code>信息，前提是PDF文档中存在目录结构。在目录结构中，一个<code>PDFOutline对象</code>代表一个<code>父目录</code>或<code>子目录</code>。<br>目录是由一个层次的<code>PDFOutline对象</code>组层。顶层是<code>根目录对象</code>，它仅作为其他目录对象的容器。用户的<code>根目录</code>是不可见的。</p>\n<h4 id=\"PDFSelection\"><a href=\"#PDFSelection\" class=\"headerlink\" title=\"PDFSelection\"></a>PDFSelection</h4><p>一个<code>PDFSelection</code>对象包含一个跨PDF文档中文本。你不要直接创建<code>PDFSelection</code>。<code>PDFSelection</code>对象是作为返回值来实例化的。例如：通过调用<code>PDFPage</code>或<code>PDFDocument</code>对象中的selection方法，并从成功搜索的返回值来实例化<code>PDFSelection</code>对象。<br>在同时显示多个<code>PDFPage</code>的<code>PDFView</code>中，<code>PDFSelection</code>可以是不连续的，或两者兼具的。例如，可以选择在一个单柱连续两列页面的文本。可以在任何方向从一个选择区, 合并选择区, 或扩展选择区中得到文本和网页覆盖。</p>\n<h4 id=\"PDFAnnotation\"><a href=\"#PDFAnnotation\" class=\"headerlink\" title=\"PDFAnnotation\"></a>PDFAnnotation</h4><p>一个<code>PDFAnnotation</code>对象可以表示多种内容以外，在一个PDF文件的主要文本内容：链接、表单元素，突出圈子，等等。每个注释与页面上的特定位置相关，并且可以与用户提供交互性。<br><code>PDFAnnotation</code>是如图所示的具体类的抽象类。各种具体类代表<code>PDF Kit</code>支持的注释类型。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/annotations.gif?imageMogr2/2/w/800\"></p>\n<h4 id=\"PDFBorder\"><a href=\"#PDFBorder\" class=\"headerlink\" title=\"PDFBorder\"></a>PDFBorder</h4><p><code>PDFBorder</code>对象封装的拉伸<code>PDFAnnotation</code>对象边框的行为。可以定义一个PDF的bord线的风格属性（例如，固体，破灭，或斜面），bord线的宽度，和圆角半径。</p>\n<p>过期:<del>从/Developer/Extras/Palettes/PDFKit.palette得到调色板。</del><br>Here’s what Apple says about it:<br><blockquote><p>“To add the PDFKit palette in Interface Builder, select the Palettes tab in the Preferences panel. Click the Add<br>button, navigate to the /Developer/Extras/Palettes folder, and select the PDFKit palette. Next, select the Customize Toolbar menu item in the Tools/Palettes menu and drag the PDFKit palette to the toolbar to make it visible.”</p>\n<footer><strong>老文档</strong><cite><a href=\"http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Conceptual/PDFKitGuide/PDFKit_Prog_Tasks/PDFKit_Prog_Tasks.html\" target=\"_blank\" rel=\"noopener\">PDFKit_Prog_Tasks</a></cite></footer></blockquote><br>So:<br>there’s no Palettes tab anywhere in the Preferences panel and the Xcode Help return a blank when searching for it.<br>There’s no PDFKit.palette file anywhere on my HD (says Spotlight).<br>I guess these instructions are for an older version of XCode but it’s all Apple seemed to have on it…</p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"PDF","path":"api/categories/PDF.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"PDF","path":"api/tags/PDF.json"},{"name":"阅读器","path":"api/tags/阅读器.json"}]},{"title":"Fabric对macOS系统的支持","slug":"macOS/Fabric对macOS系统的支持调研","date":"2017-02-14T11:14:35.000Z","updated":"2017-02-14T14:33:17.000Z","comments":true,"path":"api/articles/macOS/Fabric对macOS系统的支持调研.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"Fabric\"><a href=\"#Fabric\" class=\"headerlink\" title=\"Fabric\"></a>Fabric</h2><p><code>Fabric</code> 是Twitter的移动应用开发平台，一个模块化、跨平台的移动开发套件，该博文主要研究<code>crashlytics</code>在app中的运用。<br><a href=\"https://try.crashlytics.com/\" target=\"_blank\" rel=\"noopener\">注册新的账户</a>登录，审核通过时间为几个小时或者1到2天不等。然后注册时候输入的邮箱就会收到如下的邀请涵<br><a href=\"https://docs.fabric.io/apple/crashlytics/os-x.html#macos-support\" target=\"_blank\" rel=\"noopener\">浏览官方文档</a></p>\n<h3 id=\"crashlytics支持macOS\"><a href=\"#crashlytics支持macOS\" class=\"headerlink\" title=\"crashlytics支持macOS\"></a>crashlytics支持macOS</h3><p>对<code>macOS</code>的支持中出现的问题<br>问题：<code>NSApplicationCrashOnExceptions</code> is not set. This will result in poor <code>top-level</code> uncaught exception reporting<br>官方解释：<br><blockquote><p>Uncaught Exceptions<br>Intercepting and reporting uncaught exceptions on macOS is more complex than it is on iOS. On macOS, AppKit will catch exceptions thrown on the main thread, preventing the application from crashing, but also preventing Crashlytics from reporting them. To make matters worse, Apple’s frameworks are not exception safe. This means that while AppKit will prevent your app from crashing, it will also likely corrupt your process’s state, often including AppKit itself. Typically, once an exception involving UI interaction is thrown, it will prevent your app from working correctly from that moment on.<br>Thankfully, AppKit has a little-known feature you can turn on to make the behavior much more predictable. We strongly recommend that you do the following in your application, right before you initialize Crashlytics.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] registerDefaults:@&#123; <span class=\"string\">@”NSApplicationCrashOnExceptions”</span>: @YES &#125;];</span><br></pre></td></tr></table></figure>\n\n<p>This will make your application’s behavior much closer to iOS. It will mean that your app will crash on uncaught exceptions, and will also allow Crashlytics to report them with useful stack traces. It will also give you the ability to override this behavior with the user defaults system, even on per-user basis.<br>Of course, this is all optional. Crashlytics will warn about NSApplicationCrashOnExceptions not being set, but will otherwise preserve normal AppKit behavior by default.</p>\n<footer><strong>官方文档</strong><cite><a href=\"https://docs.fabric.io/apple/crashlytics/os-x.html#macos-support\" target=\"_blank\" rel=\"noopener\">macOS Support</a></cite></footer></blockquote><br>拦截和报告未捕获的异常在MacOS比iOS更复杂。在MacOS，AppKit会抓住扔在主线程异常，防止应用程序崩溃，也防止crashlytics报告他们。更糟糕的是，Apple’s frameworks也不例外。这意味着AppKit可以防止你的应用程序崩溃，也可能破坏你的进程的状态，包括AppKit本身。通常情况下，一旦涉及到用户界面交互的异常被抛出，它将阻止您的应用程序从正确的工作从那一刻起。<br>以上情况，可以通过设置：<code>NSApplicationCrashOnExceptions</code> 改变系统默认的值，达到像iOS端一样抓去异常。如果没有设置会提示：NSApplicationCrashOnExceptions not set</p>\n<h3 id=\"Cause-a-Test-Crash教程\"><a href=\"#Cause-a-Test-Crash教程\" class=\"headerlink\" title=\"Cause a Test Crash教程\"></a><a href=\"https://docs.fabric.io/apple/crashlytics/test-crash.html\" target=\"_blank\" rel=\"noopener\">Cause a Test Crash教程</a></h3><p>崩溃日志是在重启APP程序的同时进行的，要确保程序在前台全屏显示。<br>Xcode调试器会阻止我们捕捉崩溃报告，所以在抓取崩溃报告时，要保证在非调试状态下进行。如果你的移动设备连接到Mac机上，Xcode仍然可以进入调试状态。</p>\n<ol>\n<li><code>run</code>在模拟器上安装运行APP</li>\n<li>点击<code>Stop</code>断开Xcode和模拟器，确保在非调试状态</li>\n<li>在模拟器上启动APP，并执行崩溃操作</li>\n<li>在Xcode上点击<code>run</code><br>在Xcode的控制台console中输出显示奔溃报告，以及上传日志的相关提示。<br>macOS系统中的日志目录：<br>运行日志目录：/private/var/log/system.log<br>奔溃日志目录：/Users/pyc/Library/Logs/DiagnosticReports/APPNAME_2016-11-10-165115.crash</li>\n</ol>\n<blockquote><p>It’s possible, but rare, that we are missing a dSYM to symbolicate any crash reports. There will be an alert on your dashboard if this is the case. Click through to upload the missing dSYM. Keep in mind that exceptions are not guaranteed to crash. The full code path, including code in system libraries, matters here. If you aren’t seeing the dSYM alert, you can go to your app’s settings page, and append “/mappings” to the URL to reach it, e.g. <a href=\"https://fabric.io/settings/apps/some_app_id/mappings\" target=\"_blank\" rel=\"noopener\">https://fabric.io/settings/apps/some_app_id/mappings</a></p>\n<footer><strong>官方文档</strong><cite><a href=\"https://docs.fabric.io/apple/crashlytics/test-crash.html\" target=\"_blank\" rel=\"noopener\">Cause a Test Crash教程</a></cite></footer></blockquote>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"调试","path":"api/categories/调试.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"SDK","path":"api/tags/SDK.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"发布","path":"api/tags/发布.json"},{"name":"macOS","path":"api/tags/macOS.json"}]},{"title":"思维导图之开发实践篇","slug":"导图/思维导图之开发实践篇","date":"2017-02-13T17:11:26.000Z","updated":"2017-06-24T15:32:42.000Z","comments":true,"path":"api/articles/导图/思维导图之开发实践篇.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/需求速记.jpg?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"阅读书籍\"><a href=\"#阅读书籍\" class=\"headerlink\" title=\"阅读书籍\"></a>阅读书籍</h2><ul>\n<li>5种图表解决工作中的12大难题</li>\n<li>你的第一本思维导图操作书</li>\n<li>5分钟手绘彩色圆珠笔涂鸦集</li>\n<li>如果阅读一本书</li>\n</ul>\n<p>使用思维导图的场景无处不在，无论是做产品还是做设计，我们都需要清晰的思路，明确自己需要做些什么，最后需要达到什么效果，这时候，如果有一张清晰的思维导图，就能很快的理清自己的思路。作为互联网公司自称是产品型设计师（也就是既需要帮助老板整理需求梳理产品，也要设计漂亮的界面）的我更是如此。 </p>\n<p>目的：通过学习在该文章中讲到的开发设计案例，站在项目开发角度，了解从速记到思维导图再到实际开发的过程。<br>从产品、设计等方面谈谈我是如何运用思维导图的。</p>\n<h2 id=\"需求分析——完善最初的想法\"><a href=\"#需求分析——完善最初的想法\" class=\"headerlink\" title=\"需求分析——完善最初的想法\"></a>需求分析——完善最初的想法</h2><p>一般老板只会告诉我们大概需要一个什么东西，具体的细节还需要我们去整理。这时候，我会把大概涉及到的基本点写在纸上，想到一条写一条，特别是一些需要注意的地方。</p>\n<h3 id=\"需求速记法\"><a href=\"#需求速记法\" class=\"headerlink\" title=\"需求速记法\"></a>需求速记法</h3><p>先用纸笔速记的方式，把临时能想到的点记录下来<br><img title=\"需求速记\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/需求速记.jpg?imageMogr2/2/w/800\"><br>在纸上列得差不多了，再新建一个 <code>XMind</code> 文档，把之前列的一些点一一转到电脑上，然后整理分类。</p>\n<h3 id=\"功能结构图案例\"><a href=\"#功能结构图案例\" class=\"headerlink\" title=\"功能结构图案例\"></a>功能结构图案例</h3><ol>\n<li>码市逻辑图<br>通过思维导图能够一目了然的看到码市的功能<img src=\"https://dn-coding-net-production-pp.qbox.me/fa34c949-b36d-4c86-a1be-a6f6c5459f3e.png\"></li>\n<li>网站功能逻辑图<br>通过功能主干图直观显示了一个网站或者 APP 整体大功能组成部分，一般在写产品需求文档时需要的功能逻辑图。<img src=\"https://dn-coding-net-production-pp.qbox.me/535567ad-e51f-43b9-aa66-8b98fc719dc6.png\">\n<h2 id=\"产品设计——通过画原型来完善功能结构\"><a href=\"#产品设计——通过画原型来完善功能结构\" class=\"headerlink\" title=\"产品设计——通过画原型来完善功能结构\"></a>产品设计——通过画原型来完善功能结构</h2><code>梳理功能结构和画原型是产品设计中相互迭代的过程</code>，在画原型时会具体到每个元素的交互过程，一旦发现功能结构导图的不合理，就要及时调整思路，做到一边画原型一边更新功能结构。<h3 id=\"悬赏功能结构图\"><a href=\"#悬赏功能结构图\" class=\"headerlink\" title=\"悬赏功能结构图\"></a>悬赏功能结构图</h3>为产品原型图考虑，在梳理整理产品功能结构图时，尽可能包括页面上所有需要展示的内容以及基本的交互流程等。<br>下面这个图是码市功能结构中的发布悬赏功能部分：<img src=\"https://dn-coding-net-production-pp.qbox.me/4b1d61b9-c558-4afc-9aed-54dd47b440be.png\" class=\"码市悬赏功能结构\" title=\"悬赏功能结构\">\n有了功能结构图，就可以一一对照来做原型了。<h3 id=\"原型图\"><a href=\"#原型图\" class=\"headerlink\" title=\"原型图\"></a>原型图</h3>正如前面所说：<code>梳理功能结构和画原型是产品设计中相互迭代的过程</code>，在画原型时会具体到每个元素的交互过程，一旦发现功能导图的不合理，就要及时调整思路，做到一边画原型一边更新功能结构。<br>然后得到下面的原型：<img src=\"https://dn-coding-net-production-pp.qbox.me/eb4feccf-3514-41ac-b4de-222db74ef1d9.png\">\n</li>\n</ol>\n<h2 id=\"写文章时用到的思维导图\"><a href=\"#写文章时用到的思维导图\" class=\"headerlink\" title=\"写文章时用到的思维导图\"></a>写文章时用到的思维导图</h2><p><a href=\"https://blog.coding.net/blog/coding-mindmap\" target=\"_blank\" rel=\"noopener\">原文</a><br>把想到的先列出来，慢慢整理调整，梳理出写作思路。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/QbMJNrM.png!web.png?imageMogr2/2/w/800\"><br>演变过程：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/vIfAjiY.png!web.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"微信推出应用号的处境：\"><a href=\"#微信推出应用号的处境：\" class=\"headerlink\" title=\"微信推出应用号的处境：\"></a>微信推出应用号的处境：</h3><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/QQ20160114-1.png?imageMogr2/2/w/800\">\n","raw":null,"categories":[{"name":"导图","path":"api/categories/导图.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"思维导图","path":"api/tags/思维导图.json"}]},{"title":"用Git将代码恢复到一个历史的版本","slug":"git/用Git将代码恢复到一个历史的版本","date":"2017-02-10T18:19:48.000Z","updated":"2017-02-10T18:29:19.000Z","comments":true,"path":"api/articles/git/用Git将代码恢复到一个历史的版本.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>经历：将代码全提交到默认的head分支中，切换分支后，无法找到分支的严重后果：<br>目的：在当前分支上，将代码恢复到一个历史的提交版本上。</p>\n<h2 id=\"暴力的方式\"><a href=\"#暴力的方式\" class=\"headerlink\" title=\"暴力的方式\"></a>暴力的方式</h2><p>如果仓库是自己在用（不影响别人），那么可以使用<code>git reset --hard &lt;target_commit_id&gt;</code> 来恢复到指定的提交，再用 git push -f 来强制更新远程的分支指针。为了保证万一需要找回历史提交，我们可以先打一个 tag 来备份。</p>\n<ol>\n<li>第一步：查看本地的索引的提交日志：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git reflog \t\t</span></span><br><span class=\"line\">a1d09fd HEAD@&#123;0&#125;: checkout: moving from all to master</span><br><span class=\"line\">a1d09fd HEAD@&#123;1&#125;: checkout: moving from master to all</span><br><span class=\"line\">a1d09fd HEAD@&#123;2&#125;: checkout: moving from HEAD to master</span><br><span class=\"line\">a1d09fd HEAD@&#123;3&#125;: checkout: moving from all to HEAD</span><br></pre></td></tr></table></figure></li>\n<li>第二步：根据上面的sh2值，回滚：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset  —hard  a1d09fd</span><br></pre></td></tr></table></figure>\n这样就可以找回代码.</li>\n</ol>\n<h2 id=\"温柔的方式\"><a href=\"#温柔的方式\" class=\"headerlink\" title=\"温柔的方式\"></a>温柔的方式</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">回滚</span></span><br><span class=\"line\">git reset  —hard  a1d09fd</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">将当前代码切换回最新的提交</span></span><br><span class=\"line\">git reset --soft origin/source</span><br></pre></td></tr></table></figure>\n<p>此时工作区变成了历史的提交内容，这个时候用 <code>git add</code> 和 <code>git commit</code> 即可.</p>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"恢复","path":"api/categories/恢复.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"git","path":"api/tags/git.json"}]},{"title":"Crash文件分析方法","slug":"调试/Crash文件分析方法","date":"2017-02-07T12:38:58.000Z","updated":"2017-05-26T11:03:05.000Z","comments":true,"path":"api/articles/调试/Crash文件分析方法.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>第一步：在任意目录创建调试crash的目录</p>\n<p>第二步：将之前Archive的文件copy到crash目录里面,其中包括两个文件.app和.app.dSYM</p>\n<p>第三步：将symbolicatecrash工具copy到crash目录<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /Applications/Xcode.app -name symbolicatecrash -type f</span><br></pre></td></tr></table></figure></p>\n<p>2.用命令将symbolicatecrash拷贝到桌面的crash文件夹里面，与.app和.app.dSYM放一起<br>拷贝到crash目录：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /Applications/Xcode.app/.../symbolicatecrash /Users/Desktop/crash</span><br></pre></td></tr></table></figure></p>\n<p>第四步：执行symbolicatecrash<br>1.打开终端用命令切换到桌面的crash目录下：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /Users/你的电脑名称/Desktop/crash</span><br></pre></td></tr></table></figure></p>\n<p>2.执行命令<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./symbolicatecrash /Users/Desktop/crash/PBB.crash /Users/Desktop/crash/Control.app.dSYM &gt; Control_symbol.crash</span><br></pre></td></tr></table></figure></p>\n<p>这时候终端有可能会出现：<code>Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 60.</code></p>\n<p>3.输入命令：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> DEVELOPER_DIR=<span class=\"string\">\"/Applications/XCode.app/Contents/Developer\"</span></span><br></pre></td></tr></table></figure></p>\n<p>4.再执行 2.的命令行</p>\n<p>5.将终端完成以后，在crash文件夹里面会多出一个文件Control_symbol.crash。<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Unsupported crash <span class=\"built_in\">log</span> version: 12 at ./symbolicatecrash line 614.</span><br></pre></td></tr></table></figure></p>\n<p>第五步：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dwarfdump --lookup 0x000cf358 --arch armv7 appname.app.dSYM/</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"调试","path":"api/categories/调试.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"测试","path":"api/tags/测试.json"}]},{"title":"Docker安装使用","slug":"Docker使用","date":"2016-12-21T21:25:29.000Z","updated":"2017-02-07T13:47:53.000Z","comments":true,"path":"api/articles/Docker使用.json","excerpt":null,"keywords":null,"cover":"http://docs.daocloud.io/user/pages/03.faq/08.install-docker-daocloud/DashboardDaoCloudInstall.png","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"安装Docker-for-Mac\"><a href=\"#安装Docker-for-Mac\" class=\"headerlink\" title=\"安装Docker for Mac\"></a>安装<a href=\"https://www.docker.com/products/docker#/mac\" target=\"_blank\" rel=\"noopener\">Docker for Mac</a></h2><p>在Mac上运行Docker。系统要求，OS X 10.10.3 或者更高版本，至少4G内存，4.3.30版本以前的VirtualBox会与Docker for Mac产生冲突，所以请卸载旧版本的VitrualBox。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo <span class=\"string\">'下载dmg...'</span></span><br><span class=\"line\">curl -o Docker.dmg <span class=\"symbol\">https:</span>/<span class=\"regexp\">/dn-dao-github-mirror.qbox.me/docker</span><span class=\"regexp\">/install/mac</span><span class=\"regexp\">/Docker.dmg</span></span><br><span class=\"line\"><span class=\"regexp\">#安装Docker.dmg</span></span><br><span class=\"line\"><span class=\"regexp\">MOUNTDIR=$(echo `hdiutil mount Docker.dmg | tail -1 \\</span></span><br><span class=\"line\"><span class=\"regexp\">| awk '&#123;$1=$2=\"\"; print $0&#125;'` | xargs -0 echo) \\</span></span><br><span class=\"line\"><span class=\"regexp\">&amp;&amp; cd $&#123;MOUNTDIR&#125; &amp;&amp; cp -R Docker.app /</span>Applications/ \\</span><br><span class=\"line\">&amp;&amp; open /Applications/Docker.app</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"配置-Docker-加速器镜像源\"><a href=\"#配置-Docker-加速器镜像源\" class=\"headerlink\" title=\"配置 Docker 加速器镜像源\"></a>配置 Docker 加速器镜像源</h3><p>右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Advanced 标签下的 Registry mirrors 列表中加入下面的镜像地址:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://142*****.m.daocloud.io</span><br></pre></td></tr></table></figure></p>\n<p>点击 Apply &amp; Restart 按钮使设置生效。</p>\n<h3 id=\"安装主机监控程序加速器\"><a href=\"#安装主机监控程序加速器\" class=\"headerlink\" title=\"安装主机监控程序加速器\"></a>安装主机监控程序加速器</h3><hr>\n<ol>\n<li>登录到 <code>DaoCloud 控制台</code>，点击「我的集群」按钮，在「接入自有主机」界面，点击 Mac 按钮。</li>\n<li>安装<a href=\"https://github.com/docker/toolbox/releases/download/v1.12.5/DockerToolbox-1.12.5.pkg\" target=\"_blank\" rel=\"noopener\">DockerToolbox</a>，是一个完整的开发组件，通过安装和配置<code>DaoCloud加速器 v2</code>，提升下载 <code>Docker Hub 镜像</code>的速度。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//下载pkg</span><br><span class=\"line\">curl -o DockerToolbox.pkg https://github.com/docker/toolbox/releases/download/v1.12.5/DockerToolbox-1.12.5.pkg</span><br><span class=\"line\">//安装pkg</span><br><span class=\"line\">sudo installer -pkg DockerToolbox.pkg -target /</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<a id=\"more\"></a>\n<ol>\n<li>安装Toolbox好了，下一步：<br><img src=\"http://docs.daocloud.io/user/pages/03.faq/08.install-docker-daocloud/DashboardDaoCloudInstall.png\" alt=\"\"></li>\n<li><code>$ docker-machine start default</code>启动 Docker.<br>当执行后提示：<code>Host does not exist: &quot;default&quot;</code><figure class=\"highlight plain\"><figcaption><span>docker-machine create</span><a href=\"http://stackoverflow.com/a/38602630\" target=\"_blank\" rel=\"noopener\">stackoverflow</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-machine create -d virtualbox default</span><br></pre></td></tr></table></figure></li>\n<li><p>在 <code>Docker 主机</code> DaoCloud 加速器的组件包：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -sSL <span class=\"symbol\">https:</span>/<span class=\"regexp\">/get.daocloud.io/daomonit</span><span class=\"regexp\">/install.sh | sh -s d0312f829e9807ee0bf157******</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动组件包,会在「安装主机监控程序」的 DaoCloud 控制台页面下方显示一台已经接入的主机。</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/daoshell.png?imageMogr2/2/w/800\"></li>\n<li>执行<code>Dao Pull</code>命令,高速下载<code>Docker Hub</code>镜像文件<br>这台 Docker 主机已经被接入 DaoCloud 平台，用户可以在 DaoCloud 控制台的「我的集群」页面发现这台主机，可以执行管理和部署应用的操作。</li>\n</ol>\n<h3 id=\"从Docker-Hub-仓库中获取一个镜像\"><a href=\"#从Docker-Hub-仓库中获取一个镜像\" class=\"headerlink\" title=\"从Docker Hub 仓库中获取一个镜像\"></a>从Docker Hub 仓库中获取一个镜像</h3><hr>\n<p>Docker 使用类似 git 的方式管理镜像。通过基本的镜像可以定制创建出来不同种应用的 Docker 镜像。Docker Hub 是 Docker 官方提供的镜像中心。在这里可以很方便地找到各类应用、环境的镜像。由于 Docker 使用联合文件系统，所以镜像就像是夹心饼干一样一层层构成，相同底层的镜像可以共享。所以 Docker 还是相当节约磁盘空间的。要使用一 个镜像，需要先从远程的镜像注册中心拉取，这点非常类似 git。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull ubuntu</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Docker-命令创建管理容器\"><a href=\"#Docker-命令创建管理容器\" class=\"headerlink\" title=\"Docker 命令创建管理容器\"></a>Docker 命令创建管理容器</h2><hr>\n<h3 id=\"获取镜像的两种方式\"><a href=\"#获取镜像的两种方式\" class=\"headerlink\" title=\"获取镜像的两种方式\"></a>获取镜像的两种方式</h3><hr>\n<h4 id=\"1-docker-pull命令\"><a href=\"#1-docker-pull命令\" class=\"headerlink\" title=\"1. docker pull命令\"></a>1. <code>docker pull</code>命令</h4><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker search perfectlysoft/ubuntu</span><br><span class=\"line\">docker pull perfectlysoft/ubuntu</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-docker-import命令\"><a href=\"#2-docker-import命令\" class=\"headerlink\" title=\"2. docker import命令\"></a>2. <code>docker import</code>命令</h4><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker import myubuntu.tar.gz</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过镜像创建容器\"><a href=\"#通过镜像创建容器\" class=\"headerlink\" title=\"通过镜像创建容器\"></a>通过镜像创建容器</h3><hr>\n<p>创建一个容器有两种方式：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker create 镜像名</span><br><span class=\"line\">docker run   镜像名   /<span class=\"regexp\">/立即启动容器 等价于：create + start 命令组合</span></span><br></pre></td></tr></table></figure></p>\n<p>进入容器终端控制台如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@ec72dc76502e:/# ls</span><br><span class=\"line\">app  boot  etc   lib    media  opt   root  sbin  sys  usr</span><br><span class=\"line\">bin  dev   home  lib64  mnt    proc  run   srv   tmp  var</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"docker-run-images命令\"><a href=\"#docker-run-images命令\" class=\"headerlink\" title=\"docker run images命令\"></a><code>docker run images</code>命令</h4><ol>\n<li><p>样例1<br>执行<code>run images</code>，并将 Ubuntu 的 Shell 作为入口，进入Docker容器环境操作</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it <span class=\"symbol\">ubuntu:</span>latest sh -c <span class=\"string\">'/bin/bash'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>样例2<br>执行<code>docker start -i 容器</code>命令进入容器环境</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker start -i 容器ID/容器名</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"从KitematicGUI进入容器环境\"><a href=\"#从KitematicGUI进入容器环境\" class=\"headerlink\" title=\"从KitematicGUI进入容器环境\"></a>从<code>Kitematic</code>GUI进入容器环境</h4><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash -c <span class=\"string\">\"clear &amp;&amp; docker exec -it perfectswift sh\"</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>参数<br>-i 表示这是一个交互容器，会把当前标准输入重定向到容器的标准输入中，而不是终止程序运行<br>-t 指为这个容器分配一个终端</p>\n</blockquote>\n<p>这时候我们成功创建了一个 Ubuntu 的容器，并将当前终端连接为这个 Ubuntu 的 bash shell。这时候就可以愉快地使用 Ubuntu 的相关命令了。</p>\n<h3 id=\"ps-查看容器状态\"><a href=\"#ps-查看容器状态\" class=\"headerlink\" title=\"ps 查看容器状态\"></a>ps 查看容器状态</h3><hr>\n<p>在容器运行期间，我们可以通过 <code>docker ps</code> 命令看到所有当前正在运行的容器。<br>添加-a参数可以看到所有创建的容器：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps -a</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"容器ID标识\"><a href=\"#容器ID标识\" class=\"headerlink\" title=\"容器ID标识\"></a>容器ID标识</h3><hr>\n<p>每个容器都有一个唯一的 ID 标识，通过 ID 可以对这个容器进行管理和操作。在创建容器时，我们可以通过 –name 参数指定一个容器名称，如果没有指定系统将会分配一个，就像这里的「trusting_morse」。</p>\n<h3 id=\"启动-退出-移除容器\"><a href=\"#启动-退出-移除容器\" class=\"headerlink\" title=\"启动/退出/移除容器\"></a>启动/退出/移除容器</h3><hr>\n<p>启动：<code>start</code><br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker start -i trusting_morse</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意：每次执行 docker run 命令都会创建新的容器，建议一次创建后，使用 docker start/stop 来启动和停用容器。</p>\n</blockquote>\n<p>退出：<br>按 <code>Ctrl+D</code> 退出</p>\n<p>移除：<code>rm</code>ID/name<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm [CONTAINER ID/NAMES]</span><br></pre></td></tr></table></figure></p>\n<p>重命名：<code>rename</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rename 容器ID newName</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"创建管理镜像\"><a href=\"#创建管理镜像\" class=\"headerlink\" title=\"创建管理镜像\"></a>创建管理镜像</h2><hr>\n<p>Docker 强大的威力在于可以把自己开发的应用随同各种依赖环境一起打包、分发、运行。要创建一个新的 Docker 镜像，通常基于一个已有的 Docker 镜像来创建。<br>Docker 提供了两种方式来创建镜像：</p>\n<ol>\n<li>把容器创建为一个新的镜像</li>\n<li>使用 Dockerfile 创建镜像。</li>\n</ol>\n<h3 id=\"将容器创建为镜像\"><a href=\"#将容器创建为镜像\" class=\"headerlink\" title=\"将容器创建为镜像\"></a>将容器创建为镜像</h3><hr>\n<ol>\n<li><p>为了创建一个新的镜像，我们先创建一个新的容器作为基底：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it <span class=\"symbol\">ubuntu:</span>latest sh -c <span class=\"string\">'/bin/bash'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>定制这个容器，例如我们可以配置 PHP 环境、将我们的项目代码部署在里面等：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install php</span><br><span class=\"line\"><span class=\"comment\"># some other opreations ...</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>当执行完操作之后，我们按 Ctrl+D 退出容器.</p>\n<ol>\n<li><p>获取定制后的容器ID</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps -a</span><br><span class=\"line\">[root@localhost ~]# docker ps -a</span><br><span class=\"line\"></span><br><span class=\"line\">CONTAINER ID        IMAGE                        COMMAND                    CREATED             STATUS                      PORTS               NAMES</span><br><span class=\"line\">cb2b06c83a50        ubuntu:latest                &quot;sh -c /bin/bash&quot;          7 minutes ago       Exited (0) 7 seconds ago                       trusting_morse</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行<code>docker commit</code> 把这个容器变为一个镜像：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit cb2b06c83a50 ubuntu:myubuntu</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这时候 docker 容器会被创建为一个新的 Ubuntu 镜像，版本名称为 myubuntu。以后我们可以随时使用这个镜像来创建容器了，新的容器将自动包含上面对容器的操作。    </p>\n<ol>\n<li><p>打包/发布镜像</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker save -o myubuntu.tar.gz <span class=\"symbol\">ubuntu:</span>myubuntu</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>导入打包镜像</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker import myubuntu.tar.gz</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h3><hr>\n<h4 id=\"通过Dockerfile创建镜像\"><a href=\"#通过Dockerfile创建镜像\" class=\"headerlink\" title=\"通过Dockerfile创建镜像\"></a>通过<code>Dockerfile</code>创建镜像</h4><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build yourDir/Dockerfile</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>确保Dockerfile文件在一个目录中，否则会提示错误</p>\n</blockquote>\n<p>Docker Hub 提供了类似 GitHub 的镜像存管服务。一个镜像发布到 Docker Hub 不仅可以供更多人使用，而且便于镜像的版本管理。在一个企业内部可以通过自建 Docker Registry 的方式来统一管理和发布镜像。将 Docker Registry 集成到版本管理和上线发布的工作流之中，还有许多工作要做，在我整理出最佳实践后会第一时间分享。<br>使用命令行的方式创建 Docker 镜像通常难以自动化操作。在更多的时候，我们使用 Dockerfile 来创建 Docker 镜像。Dockerfile 是一个纯文本文件，它记载了从一个镜像创建另一个新镜像的步骤。撰写好 Dockerfile 文件之后，我们就可以轻而易举的使用 docker build 命令来创建镜像了。<br>Dockerfile 非常简单，仅有以下命令在 Dockerfile 中常被使用：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:right\">命令</th>\n<th style=\"text-align:right\">参数</th>\n<th style=\"text-align:right\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:right\">#</td>\n<td style=\"text-align:right\">-</td>\n<td style=\"text-align:right\">注释说明</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">FROM</td>\n<td style=\"text-align:right\"><image>[:<tag>]</tag></image></td>\n<td style=\"text-align:right\">从一个已有镜像创建，例如ubuntu:latest</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">MAINTAINER</td>\n<td style=\"text-align:right\">Author <a href=\"&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#115;&#111;&#109;&#101;&#x2d;&#x6f;&#x6e;&#x65;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#x65;&#x2e;&#x63;&#x6f;&#109;\">&#115;&#111;&#109;&#101;&#x2d;&#x6f;&#x6e;&#x65;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#x65;&#x2e;&#x63;&#x6f;&#109;</a></td>\n<td style=\"text-align:right\">镜像作者名字，如Max Liu <a href=\"&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#115;&#111;&#x6d;&#x65;&#45;&#111;&#110;&#101;&#x40;&#101;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#46;&#x63;&#111;&#109;\">&#115;&#111;&#x6d;&#x65;&#45;&#111;&#110;&#101;&#x40;&#101;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#46;&#x63;&#111;&#109;</a></td>\n</tr>\n<tr>\n<td style=\"text-align:right\">RUN</td>\n<td style=\"text-align:right\"><cmd>或者[‘cmd1’, ‘cmd2’…]</cmd></td>\n<td style=\"text-align:right\">在镜像创建用的临时容器里执行单行命令</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">ADD</td>\n<td style=\"text-align:right\"><src> <dest></dest></src></td>\n<td style=\"text-align:right\">将本地的<src>添加到镜像容器中的<dest>位置</dest></src></td>\n</tr>\n<tr>\n<td style=\"text-align:right\">VOLUME</td>\n<td style=\"text-align:right\"><path></path>或者[‘/var’, ‘home’]</td>\n<td style=\"text-align:right\">将指定的路径挂载为数据卷</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">EXPOSE</td>\n<td style=\"text-align:right\"><port> [<port>…]</port></port></td>\n<td style=\"text-align:right\">将指定的端口暴露给主机</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">ENV</td>\n<td style=\"text-align:right\"><key> <value> 或者 <key> = <value></value></key></value></key></td>\n<td style=\"text-align:right\">指定环境变量值</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">CMD</td>\n<td style=\"text-align:right\">[“executable”,”param1”,”param2”]</td>\n<td style=\"text-align:right\">容器启动时默认执行的命令。注意一个Dockerfile中只有最后一个CMD生效。</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">ENTRYPOINT</td>\n<td style=\"text-align:right\">[“executable”, “param1”, “param2”]</td>\n<td style=\"text-align:right\">容器的进入点</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"配置Dockerfile\"><a href=\"#配置Dockerfile\" class=\"headerlink\" title=\"配置Dockerfile\"></a>配置Dockerfile</h4><hr>\n<p>下面是一个 Dockerfile 的例子：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># This is a comment</span></span><br><span class=\"line\">FROM <span class=\"symbol\">ubuntu:</span><span class=\"number\">14.04</span></span><br><span class=\"line\">MAINTAINER Kate Smith &lt;ksmith@example.com&gt;</span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y ruby ruby-dev</span><br><span class=\"line\">RUN gem install sinatra</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"CMD命令\"><a href=\"#CMD命令\" class=\"headerlink\" title=\"CMD命令\"></a><code>CMD</code>命令</h5><hr>\n<p><code>CMD</code>: 命令可用指定 Docker 容器启动时默认的命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it ubuntu:latest sh -c &apos;/bin/bash&apos;</span><br></pre></td></tr></table></figure></p>\n<p>其中 <code>sh -c &#39;/bin/bash&#39;</code> 就是手工指定的<code>CMD</code>,否则容器将会使用默认 <code>CMD</code> 指定的命令启动。</p>\n<h5 id=\"ENTRYPOINT命令\"><a href=\"#ENTRYPOINT命令\" class=\"headerlink\" title=\"ENTRYPOINT命令\"></a><code>ENTRYPOINT</code>命令</h5><hr>\n<p>用来指定可执行文件、Shell 脚本，同时会并把启动参数或 CMD 指定的默认值，当作附加参数传递给 执行文件、Shell 脚本。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRYPOINT [<span class=\"string\">'/usr/bin/mysql'</span>]</span><br><span class=\"line\">CMD [<span class=\"string\">'-h 192.168.100.128'</span>, <span class=\"string\">'-p'</span>]</span><br></pre></td></tr></table></figure></p>\n<p>执行mysql启动程序，连接<code>192.168.100.128</code> 主机,也可以通过指定参数，来连接别的主机。</p>\n<p>因此，我们在使用 Dockerfile 创建文件的时候，可以创建一个 entrypoint.sh 脚本，作为系统入口。在这个文件里面，我们可以进行一些基础性的自举操作，比如检查环境变量，根据需要初始化数据库等等。下面两个文件是我在日常工作的项目中添加的 Dockerfile 和 entrypoint.sh，仅供参考：<br><a href=\"https://github.com/starlight36/SimpleOA/blob/master/Dockerfile\" target=\"_blank\" rel=\"noopener\">https://github.com/starlight36/SimpleOA/blob/master/Dockerfile</a><br><a href=\"https://github.com/starlight36/SimpleOA/blob/master/docker-entrypoint.sh\" target=\"_blank\" rel=\"noopener\">https://github.com/starlight36/SimpleOA/blob/master/docker-entrypoint.sh</a><br>在准备好 Dockerfile 之后，我们就可以创建镜像了：</p>\n<h4 id=\"创建镜像\"><a href=\"#创建镜像\" class=\"headerlink\" title=\"创建镜像\"></a>创建镜像</h4><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t starlight36/simpleoa .</span><br></pre></td></tr></table></figure>\n","raw":null,"categories":[{"name":"docker","path":"api/categories/docker.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"}]},{"title":"GTD任务清单整理技巧","slug":"导图/GTD任务清单整理技巧","date":"2016-01-07T16:00:53.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/导图/GTD任务清单整理技巧.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/6w1h.jpg?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>什么是GTD？<br>GTD 的基本理论是把一个人所要要完成的任务和事件全部从大脑中移出来，记录到纸上。这样，大脑便会不被多余的事情打搅而集中于现在所需完成的事情上面。</p>\n<h2 id=\"GTD守则：\"><a href=\"#GTD守则：\" class=\"headerlink\" title=\"GTD守则：\"></a>GTD守则：</h2><pre><code>收集任务  设置每天最重要的任务  \n（把所有你需要做的和需要完成的事情全部记录下来，放在一个“收集箱”里）  \n↓  \n过程  \n（每次按照顺序，一次只做一件事）  \n↓  \n管理任务  \n（列出有详细内容的to-do列表）  \n↓  \n复习任务   \n（复习你所有完成的任务，计划方案和等待完成的事情。确保每一件新进入的任务都有很好的安排）  \n↓  \n开始行动！  \n</code></pre><h3 id=\"建立有强行动性的任务清单\"><a href=\"#建立有强行动性的任务清单\" class=\"headerlink\" title=\"建立有强行动性的任务清单\"></a>建立有强行动性的任务清单</h3><p>任务清单（To-do List）的重要性毋庸置疑，建立有强行动性的任务清单可以让你更清楚地明白自己需要完成的任务，同时还保持了你去完成任务的激情和动力。</p>\n<ol>\n<li>分解任务：就像走远路时，以每一段路程为目标，让人更有动力去追求一样。如果你要阅读一本书，便可以将任务分成“读完第一章”，“读完第二章”等等。</li>\n<li>使用有力的动词：比如说联系某个人，就要写上“给某某打电话”或者“发邮件给某某”而不是写“联系某某”。</li>\n<li>有限的清单：谁都不希望有一张写满几大页的任务清单，你需要找出那些有强动力的行动。</li>\n<li>清理已完成的任务：已完成的任务要及时清理，否者会阻碍你的下一步行动任务。<!--nore-->\n</li>\n</ol>\n<h2 id=\"7W3H\"><a href=\"#7W3H\" class=\"headerlink\" title=\"7W3H\"></a>7W3H</h2><p>7W3H是一个用于项目规划和管理的专业术语。公司管理者邀请相关员工一起进行分析讨论，按照7W3H进行各述己见，收集、归纳、再收集、再归纳，这样一种互动、发散性思维的工作方法极大调动下属员工的积极性、责任感。否则，公司管理者单方面出台项目计划，对下属员工解释耗费时力不说，项目计划的有效性、完善性、可行性也都可能存在质疑。</p>\n<h3 id=\"7W\"><a href=\"#7W\" class=\"headerlink\" title=\"7W\"></a>7W</h3><pre><code>what 指目标与内容，包括主体，目标，机能，性能等\nwhy 指原因，包括任务，期望，背景，技术等\nwho 指人员，包括制造，行销，流通，负责的主体等\nwhere 指地点类，包括 环境，市场，区域，渠道等\nwhen 指时间，包括期限，时机，预期等\nwhom 买家，消费者，接收者\nwhich 附属品\n</code></pre><h3 id=\"3H\"><a href=\"#3H\" class=\"headerlink\" title=\"3H\"></a>3H</h3><pre><code>how to 如何做，指方式和手段，包括集体方案，详实计划，战略方针\nhow much 价格成本，投入产出，综效成果\nhow many 负面效益，各种量（问题，业务，工作）\n</code></pre><h3 id=\"案例6W1H\"><a href=\"#案例6W1H\" class=\"headerlink\" title=\"案例6W1H\"></a>案例6W1H</h3><p>截自《5个图表解决12大难题》<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/6w1h.jpg?imageMogr2/2/w/800\"></p>\n<h2 id=\"十二个赛博学习问题\"><a href=\"#十二个赛博学习问题\" class=\"headerlink\" title=\"十二个赛博学习问题\"></a><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NjA3OTM0MA==&amp;mid=403475231&amp;idx=1&amp;sn=bbf21f2e37e91fc10d1a48285e8abefd&amp;scene=23&amp;srcid=0115194ziliaGGBscdYC3N0d#rd\" target=\"_blank\" rel=\"noopener\">十二个赛博学习问题</a></h2><p>赛博学习法是一种动态的学习过程，在这个过程中你（不是你的老师，也不是某些教科书的作者）会掌握控制权，成为你自己教育的“引航员”。<br>这种方法的第一步是对话：你会针对正在学习的材料，提出一系列具体的问题。慢慢地，通过信息的整理和再整理，以及在新材料与你学过的知识之间建立新的联系，你将真正理解材料。<br>用这种方法改进你的笔记，只要回答12个问题就能掌握科教书的要点：<br><img title=\"用更短的时间达到更佳效果和更好成绩用更短的时间达到更佳效果和更好成绩\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/IMG_0028.JPG?imageMogr2/2/w/800\"></p>\n<h2 id=\"个人常用的工具类\"><a href=\"#个人常用的工具类\" class=\"headerlink\" title=\"个人常用的工具类\"></a>个人常用的工具类</h2><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/IFTTT.jpg?imageMogr2/2/w/800\">\n","raw":null,"categories":[{"name":"导图","path":"api/categories/导图.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"逻辑思维","path":"api/tags/逻辑思维.json"}]},{"title":"清除git历史记录大文件bfg","slug":"git/清除git历史记录大文件bfg","date":"2015-10-20T11:17:27.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/清除git历史记录大文件bfg.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><ol>\n<li><a href=\"https://search.maven.org/remote_content?g=com.madgag&amp;a=bfg&amp;v=LATEST\" target=\"_blank\" rel=\"noopener\">下载bfg</a> 到本地soft/bfg目录下。</li>\n<li>sudo vi ~/.bash_profile  添加如下：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias bfg=&quot;java -jar ~/Downloads/soft/bfg/bfg.jar&quot;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>cd 到库目录，执行bfg命令： <a href=\"https://rtyley.github.io/bfg-repo-cleaner/\" target=\"_blank\" rel=\"noopener\">bfg官网</a> </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd PBB_SSH所属目录下</span><br><span class=\"line\">$ bfg --delete-folders universal --no-blob-protection  PBB_SSH</span><br><span class=\"line\">$ cd PBB_SSH</span><br><span class=\"line\">$ git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</span><br><span class=\"line\">$ git push</span><br></pre></td></tr></table></figure>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"工具","path":"api/categories/工具.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"git","path":"api/tags/git.json"},{"name":"坑","path":"api/tags/坑.json"}]},{"title":"calabash一款跨平台UI测试工具初探","slug":"测试/calabash一款跨平台UI测试工具初探","date":"2015-10-06T08:32:41.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/测试/calabash一款跨平台UI测试工具初探.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>参考：<a href=\"http://blog.csdn.net/zangcw/article/details/25299243\" target=\"_blank\" rel=\"noopener\">使用jenkins+calabash+cocoapods搭建ios持续集成环境</a></p>\n<ol>\n<li>calabash  是一款开源的跨平台UI测试工具，目前支持iOS和Android。它使用Cucumber作为测试核心，Cucumber是一个在敏捷团队十分流行的自动化的功能测试工具，它使用接近于自然语言的特性文档进行用例的书写和测试，支持多语言和多平台。</li>\n<li><p>安装Calabash  </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem install calabash-cucumber</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装Calabash中文支持包  </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem install calabash-cucumber-cn</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"For-automatic-setup\"><a href=\"#For-automatic-setup\" class=\"headerlink\" title=\"For automatic setup:\"></a>For automatic setup:</h4><ol>\n<li><p>In a terminal, go to your iOS project  </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\tcd path-to-my-ios-project (i.e. directory containing .xcodeproj file)</span><br><span class=\"line\">\t```  </span><br><span class=\"line\">2. Install calabash-cucumber gem (this make take some time because of dependencies)</span><br></pre></td></tr></table></figure>\n<p> gem install calabash-cucumber</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3. Setup your project for Calabash-iOS.</span><br></pre></td></tr></table></figure>\n<p> calabash-ios setup  //Answer the questions and read the output :)</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4. Generate a skeleton features folder for your tests</span><br></pre></td></tr></table></figure>\n<p> calabash-ios gen</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5. In Xcode, build your project using the -cal scheme</span><br><span class=\"line\"></span><br><span class=\"line\">6. Run the generated test!</span><br></pre></td></tr></table></figure>\n<p> cucumber</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">If all goes well, you are now ready to write your first test. Start by editing the file features/my_first.feature.</span><br><span class=\"line\">&lt;!--more--&gt;</span><br><span class=\"line\">#### [cucumber官网](https://cukes.info/)   </span><br><span class=\"line\"></span><br><span class=\"line\">\t\t* Feature（功能）  </span><br><span class=\"line\">\t\t* Scenario（情景）  </span><br><span class=\"line\">\t\t*  Given（给定）  </span><br><span class=\"line\">\t\t*  When（当）  </span><br><span class=\"line\">\t\t*  Then（则） </span><br><span class=\"line\">#####[运行原理](http://www.educity.cn/se/619226.html)  </span><br><span class=\"line\">![image](http://img.educity.cn/img_7/262/2013122000/125005907.jpg)  </span><br><span class=\"line\">cucumber是一种BDD测试框架，核心为cucumber的calabash的脚本在运行测试的时候会在虚拟机/真机上预装一个web服务器，这个web服务器就是解释calabash的脚本，将其解释为robotium的脚本，然后这个web服务器会想测试app发送robotium的脚本，测试app拿到robotium脚本后，将其解释为instumentation命令向被测试的app发送这些命令，被测试的app执行这些命令，然后将结果返回给测试app，然后一级一级返得到最后的测试结果。    </span><br><span class=\"line\">#####结构框架</span><br><span class=\"line\">calabash完全采用了cucumber的结构模式，calabash是脚本与TC分离设计，在业务变化的情况下，只要功能存在基本只需要修改TC逻辑，在业务不变，功能变化的情况下，基本只需要修改脚本。   </span><br><span class=\"line\">![image](http://img.educity.cn/img_7/262/2013122000/126005907.jpg)  </span><br><span class=\"line\">feature为主件夹，step_definitions目录内是你封装的脚本，my_first.feature文件就是你的TC逻辑。  </span><br><span class=\"line\">再看一下其中的内容：</span><br><span class=\"line\"></span><br><span class=\"line\">\t　　my_first.feature</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　Feature： 登陆</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　Scenario： 输入正确的用户名密码能够正常登陆</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　When 打开登陆页面</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　And    输入用户名XXX输入密码XXX</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　And   点击登陆</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　Then  验证登陆成功</span><br><span class=\"line\"></span><br><span class=\"line\">　　看起来很简单吧，想要验证其他功能也是类似的语言描述即可。  </span><br><span class=\"line\">如果你没有用过cucumber或者calabash那么你肯定现在有一个疑问，计算机怎么能识别汉字来进行测试的呢，  </span><br><span class=\"line\">那么看一下step_definition，以 输入用户名XXX输入密码XXX为例：</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tWhen /^ 输入用户名\\&quot;([^\\\\\\&quot;]*)\\&quot; 输入密码\\&quot;([^\\\\\\&quot;]*)\\&quot;  $/ do |username，password|</span><br><span class=\"line\">\t\tperformAction(&apos;enter_text_into_numbered_field&apos;，username，1)</span><br><span class=\"line\">\t\tperformAction(&apos;enter_text_into_numbered_field&apos;，password，2)</span><br><span class=\"line\">\t\tend</span><br><span class=\"line\">现在应该能明白为什么你需要写汉字的脚本就可以了吧。  </span><br><span class=\"line\">在这里解释一下为什么如果业务存在功能修改这种情况，自动化脚本的修改量会小。  </span><br><span class=\"line\">还是以这个登录脚本为例：</span><br><span class=\"line\"></span><br><span class=\"line\">\t假如现在输入用户名和密码的输入框顺序变了，在你的页面显示上，可能是从左下角移到中间了，这种变化，那么feature文件你不用改，只需要改step_definition脚本就好了</span><br><span class=\"line\">#####运行报告</span><br><span class=\"line\">alabash-android支持很多报告生成模式，支持html，json，junit等等报告模式，只需要你在run的时候添加-f参数-o参数就可以了。</span><br><span class=\"line\"></span><br><span class=\"line\">　　例如 calabash-android run xxxx.apk -f html -o l，上图展示一下强大html报告  </span><br><span class=\"line\">　　![image](http://img.educity.cn/img_7/262/2013122000/127005907.jpg)</span><br><span class=\"line\"></span><br><span class=\"line\">[【cucumber解析features文件】](http://blog.csdn.net/qs_csu/article/details/9000262) \t\t</span><br><span class=\"line\">1. my_first.feature: 描述在这个条件下需要做什么事情；</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFeature: Running a test  </span><br><span class=\"line\">\t\t  As an iOS developer  </span><br><span class=\"line\">\t\t  I want to have a sample feature file  </span><br><span class=\"line\">\t\t  So I can begin testing quickly  </span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\tScenario: Example steps1  </span><br><span class=\"line\">\t\t  Given I am on the Welcome Screen  </span><br><span class=\"line\">\t\t  Then I swipe left  </span><br><span class=\"line\">\t\t  And I wait until I don&apos;t see &quot;Please swipe left&quot;  </span><br><span class=\"line\">\t\t  And take picture  </span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\tScenario: Example steps2  </span><br><span class=\"line\">\t\t  Given I am on the Welcome Screen  </span><br><span class=\"line\">\t\t #ASSERTION  </span><br><span class=\"line\">\t\t  Then I should see a &quot;login&quot; button  </span><br><span class=\"line\">\t\t #INPUT TEXT  </span><br><span class=\"line\">\t\t  Then I enter &quot;my_username&quot; into text field number 1  </span><br><span class=\"line\">\t\t#  Then I touch &quot;Return&quot;  </span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\t #TOGGLE SWITCH  </span><br><span class=\"line\">\t\t  Then I toggle the switch  </span><br><span class=\"line\">\t\t  Then I touch &quot;Login&quot;  </span><br><span class=\"line\">\t\t  And I touch &quot;Second&quot;  </span><br><span class=\"line\">\t\t  And take picture  </span><br><span class=\"line\">\t该文件描述了在“on the Welcome Screen”这个Step中需要做的事情，两个场景:steps1 和 steps2. </span><br><span class=\"line\"></span><br><span class=\"line\">2. my_first_step.rb: 解释了Given的具体条件</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tGiven /^I am on the Welcome Screen$/ do  </span><br><span class=\"line\">\t\t  element_exists(&quot;view&quot;)  </span><br><span class=\"line\">\t\t  check_element_exists(&quot;label text:&apos;First View&apos;&quot;)  </span><br><span class=\"line\">\t\t  sleep(STEP_PSEAU)  </span><br><span class=\"line\">\t\tend</span><br><span class=\"line\">\t这个语句，判定了当前条件&quot;on the Welcome Screen&quot;是否满足，如果element存在，则就在&quot;Welcome Screen&quot;</span><br><span class=\"line\">\t</span><br><span class=\"line\">[更多的测试框架](http://www.infoq.com/cn/articles/build-ios-continuous-integration-platform-part2)</span><br><span class=\"line\"></span><br><span class=\"line\">UIAutomation</span><br><span class=\"line\"></span><br><span class=\"line\">UIAutomation是随着iOS SDK 4.0引入，帮助开发者在真实设备和模拟器上执行自动化的UI测试。其本质上是一个Javascript的类库，通过 界面上的标签和值的访问性来获得UI元素，完成相应的交互操作，从而达到测试的目的，类似于Web世界的Selenium。</span><br><span class=\"line\"></span><br><span class=\"line\">通过上面的描述，可以得知，使用UIAutomation做测试时，开发者必须掌握两件事：</span><br><span class=\"line\"></span><br><span class=\"line\">- 如何找到界面上的一个UI元素</span><br><span class=\"line\">- 如何指定针对一个UI元素的操作</span><br><span class=\"line\"></span><br><span class=\"line\">在UIAutomation中，界面就是由一堆UI元素构建的层级结构，所有UI元素都继承对象UIAElement ，该对象提供了每个UI元素必须具备的一些属性：</span><br><span class=\"line\"></span><br><span class=\"line\">- name</span><br><span class=\"line\">- value</span><br><span class=\"line\">- elements</span><br><span class=\"line\">- parent</span><br><span class=\"line\">- …</span><br><span class=\"line\"></span><br><span class=\"line\">而整个界面的层级结构如下：</span><br><span class=\"line\"></span><br><span class=\"line\">\target（设备级别的UI，用于支持晃动，屏幕方向变动等操作）</span><br><span class=\"line\">\t    Application（设备上的应用，比方说Status Bar，keyboard等）</span><br><span class=\"line\">\t      Main window（应用的界面，比方说导航条）</span><br><span class=\"line\">\t        View（界面下的View，比方说UITableView）</span><br><span class=\"line\">\t           Element（View下的一个元素）</span><br><span class=\"line\">\t              Child element(元素下的一个子元素)</span><br><span class=\"line\">下面是一个访问到Child element的例子：</span><br><span class=\"line\"></span><br><span class=\"line\">\tUIATarget.localTarget().HamcrestDemo().tableViews()[0].cells()[0].elements()</span><br><span class=\"line\">开发者还可以通过“UIATarget.localTarget().logElementTree()”在控制台打印出该target下所有的的elements。</span><br><span class=\"line\"></span><br><span class=\"line\">找到UI元素之后，开发者可以基于该UI元素做期望的操作，UIAutomation作为原生的UI测试框架，基本上支持iOS上的所有UI元素和操作，比方说：</span><br><span class=\"line\"></span><br><span class=\"line\">- 点击按钮，例: ***.buttons[“add”].tap()</span><br><span class=\"line\">- 输入文本, 例:***.textfields[0].setValue(“new”)</span><br><span class=\"line\">- 滚动屏幕，例:***.scrollToElementWithPredicate(“name begin with ’test’”)</span><br><span class=\"line\">- ……</span><br><span class=\"line\">关于使用UIAutomation做UI测试，推荐大家一定要看一下2010的WWDC的Session 306：[Automating User Interface Testing with Instruments](https://developer.apple.com/videos/wwdc/2010/?id=306)。 另外，这儿还有一篇很好的博客，详细的讲解了[如何使用UIAutomation做UI自动化测试](http://blog.manbolo.com/2012/04/08/ios-automated-tests-with-uiautomation)  </span><br><span class=\"line\">Apple通过Instruments为UIAutomation测试用例的命令行运行提供了支持，这样就为UIAutomation和CI服务器的集成提供了便利。开发者可以通过如下的步骤在命令行中运行UIAutomation测试脚本:</span><br><span class=\"line\">1. 指定目标设备，构建被测应用，该应用会被安装到指定的DSTROOT目录下</span><br><span class=\"line\">```ruby</span><br><span class=\"line\">xcodebuild</span><br><span class=\"line\">-project &quot;/Users/twer/Documents/xcodeworkspace/AudioDemo/AudioDemo.xcodeproj&quot; </span><br><span class=\"line\">-schemeAudioDemo</span><br><span class=\"line\">-sdk iphonesimulator6.1 </span><br><span class=\"line\">-configuration Release SYMROOT=&quot;/Users/twer/Documents/xcodeworkspace/</span><br><span class=\"line\">AudioDemo/build&quot; DSTROOT=&quot;/Users/twer/Documents/xcodeworkspace/AudioDemo/</span><br><span class=\"line\">build&quot; TARGETED_DEVICE_FAMILY=&quot;1&quot; </span><br><span class=\"line\">install</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动Instruments，基于第一步生成的应用运行UIAutomation测试</p>\n<pre><code class=\"ruby\">instruments\n-t  <span class=\"string\">\"/Applications/Xcode.app/Contents/Applications/Instruments.app/</span>\n<span class=\"string\">Contents/PlugIns/AutomationInstrument.bundle/Contents/Resources/</span>\n<span class=\"string\">Automation.tracetemplate\"</span> <span class=\"string\">\"/Users/twer/Documents/xcodeworkspace/AudioDemo</span>\n<span class=\"string\">/build/Applications/TestExample.app\"</span>\n-e UIASCRIPT &lt;absolute_path_to_the_test_file&gt;\n</code></pre>\n<p>为了更好的展示测试效果以及与CI服务器集成，活跃的社区开发者们还尝试把UIAutomation和Jasmine集成: <a href=\"https://github.com/shaune/jasmine-ios-acceptance-tests\" target=\"_blank\" rel=\"noopener\">https://github.com/shaune/jasmine-ios-acceptance-tests</a></p>\n</li>\n</ol>\n<p>UIAutomation因其原生支持，并且通过和Instruments的绝佳配合，开发者可以非常方便的使用录制操作自动生成测试脚本，赢得了很多开发者的支持，但是因苹果公司的基因，其系统非常封闭，导致开发者难以扩展，于是活跃的社区开发者们开始制造自己的轮子，<a href=\"https://gorillalogic.com/fonemonkey-0-7-1-released/\" target=\"_blank\" rel=\"noopener\">Fone Monkey,最新版本更新于2010年，估计过时</a>就是其中的一个优秀成果。</p>\n","raw":null,"categories":[{"name":"工具","path":"api/categories/工具.json"},{"name":"集成","path":"api/categories/集成.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"测试","path":"api/tags/测试.json"}]},{"title":"使用SmartSVN创建版本库","slug":"git/使用SmartSVN创建版本库","date":"2015-10-05T19:16:47.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/使用SmartSVN创建版本库.json","excerpt":null,"keywords":null,"cover":"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/adeb039a-b429-481a-ac25-2044b871e45e/screenshot.png?resizeSmall&amp;width=832","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>SmartSVN有以下版本：</p>\n<ol>\n<li>SmartSVN enterprise 9 企业版</li>\n<li>SmartSVN foundation 8 基础版</li>\n</ol>\n<p>由于企业版只能建立本地的版本库，无法创建&amp;使用svn://localhost方式。</p>\n<h4 id=\"用基础版来说明创建版本库。\"><a href=\"#用基础版来说明创建版本库。\" class=\"headerlink\" title=\"用基础版来说明创建版本库。\"></a>用基础版来说明创建版本库。</h4><p>参考：<a href=\"http://hammadk.com/how-to-create-repository-in-smartsvn-tutorial/\" target=\"_blank\" rel=\"noopener\">Create Repository in SmartSVN – Tutorial</a>  </p>\n<ol>\n<li>启动SmartSVN SmartSVN foundation 8 基础版  </li>\n<li>菜单栏Project-&gt; set up Local Repository…<br>需要设置如下两个参数：  <ol>\n<li>svnadmin 在终端执行： whereis svnadmin  </li>\n<li>svnserve 在终端执行： whereis svnserve<br>￼<img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/adeb039a-b429-481a-ac25-2044b871e45e/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\">  </li>\n</ol>\n</li>\n<li>指定版本库的目录位置：<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/a3f00903-101c-4848-a10a-3479643baea7/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\">  </li>\n<li>初始化账户密码：<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/140f257e-e452-47ea-8317-34a5ed8d6c7f/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\">  </li>\n<li>完成。<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/ed975623-72bb-4132-8d04-ac9a7b1d2fc9/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\"><br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/53306789-9d97-485c-a54d-a143e7b078f1/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\"><a id=\"more\"></a>    \n<h5 id=\"开始导入项目源码，来跟踪版本变化，实现版本控制。\"><a href=\"#开始导入项目源码，来跟踪版本变化，实现版本控制。\" class=\"headerlink\" title=\"开始导入项目源码，来跟踪版本变化，实现版本控制。\"></a>开始导入项目源码，来跟踪版本变化，实现版本控制。</h5></li>\n<li>新建SmartSVNRepos目录，存放APP源码，用于导入版本库的原始目录。导入后，该目录源码就被版本跟踪了，在开发时，不用再从版本库导出，可以用该目录的代码直接在版本上开发了。<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/ee02bf65-27e3-435a-8300-8189bc087eb8/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\"></li>\n<li>菜单栏Project -&gt; Import Into Repository…<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/eccc10f0-4c5a-435c-8397-062028d0d4f4.png?resizeSmall&amp;width=832\" alt=\"image\"></li>\n<li>选择以上新建的SmartSVN版本库：svn://localhost<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/ecfe16b4-17ac-4fc1-a64f-1ce259d77b3b/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\"> </li>\n</ol>\n<p>查看是否安装SVN服务：</p>\n<pre><code>svnserve —version\n</code></pre><p>SVN随系统一起启动：</p>\n<pre><code>vi /etc/rc.local   //(此文件Mac系统中默认是不存在的，需手动创建)\n\n添加启动SVN服务： \nsvnserve -d -r /data/svn/repos  \n</code></pre><p>关闭svn服务:</p>\n<pre><code>直接ps aux | grep svn，然后kill -9 进程号\n</code></pre><ol>\n<li><p>创建库:<br> 打印应用目录命令：</p>\n<pre><code>whereis svn\n</code></pre><p> 新建版本库目录：</p>\n<pre><code>sudo mkdir -p /data/svn/repos/local    \nchmod u+w 文件名\n</code></pre><p> 创建：</p>\n<pre><code>sudo svnadmin create /data/svn/repos/local\n查看文件权限： ls -l\n</code></pre></li>\n<li><p>配置版本库的访问权限</p>\n<pre><code>cd conf/ \n</code></pre><ol>\n<li><p>开启密码权限，普通用户/匿名用户</p>\n<pre><code>sudo vi svnserve.conf\n</code></pre></li>\n<li><p>设置用户：密码</p>\n<pre><code>sudo vi passwd\n</code></pre></li>\n<li><p>分组设置，组权限</p>\n<pre><code>sudo vi authz\n</code></pre></li>\n</ol>\n</li>\n<li><p>启动svnserve服务  </p>\n<pre><code>sudo svnserve -d -r /data/svn/repos —log-file=/var/log/svn.log\n</code></pre></li>\n<li><p>测试端口：</p>\n<pre><code>telnet localhost 3690\n</code></pre></li>\n<li><p>重启必先kill ：</p>\n<pre><code>sudo kill PID\n</code></pre></li>\n<li><p>版本库路径：</p>\n<pre><code>svn://localhost/local\n</code></pre><p>其他：</p>\n<pre><code>svn ls svn://svnpath 可以查询snv仓库内容  \nlsof -i :3690 查看svn是否启动  \nps aux | grep ‘svn’ 查找所有svn启动的进程id  \nkill -9 pid 将pid替换为上面查到的进程id可以杀掉svn进程  \n</code></pre></li>\n</ol>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"svn","path":"api/categories/svn.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"svn","path":"api/tags/svn.json"}]},{"title":"Mac安装gitLab服务器","slug":"git/Mac安装gitLab服务器","date":"2015-09-27T19:25:38.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/Mac安装gitLab服务器.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"必要配置\"><a href=\"#必要配置\" class=\"headerlink\" title=\"必要配置\"></a>必要配置</h4><pre><code>*创建一个名称为&quot;gitlab&quot;管理员用户，然后再创建一个名称为&quot;gitlab&quot;的群组\n*开启gitlab用户的远程登录\n</code></pre><p>在系统启动界面:<br>隐藏gitlab用户 </p>\n<pre><code>sudo defaults write /Library/Preferences/com.apple.loginwindow HiddenUsersList -array-add gitlab\n</code></pre><p>显示git用户</p>\n<pre><code>sudo defaults delete /Library/Preferences/com.apple.loginwindow HiddenUsersList\n</code></pre><h4 id=\"添加系统账户gitlab\"><a href=\"#添加系统账户gitlab\" class=\"headerlink\" title=\"添加系统账户gitlab\"></a>添加系统账户gitlab</h4><h6 id=\"生成gitlab服务器目录，即用户根目录\"><a href=\"#生成gitlab服务器目录，即用户根目录\" class=\"headerlink\" title=\"生成gitlab服务器目录，即用户根目录\"></a>生成gitlab服务器目录，即用户根目录</h6><p>进入<strong>系统偏好设置…</strong>,在管理<strong>用户与群组</strong>中，添加其他用户，暂时定为：gitlab ，登录密码假设为：gitlab，添加完成后，会自动在/Users目录下，生成用户根目录gitlab.</p>\n<h6 id=\"安装-Gitlab-Shell\"><a href=\"#安装-Gitlab-Shell\" class=\"headerlink\" title=\"安装 Gitlab Shell\"></a>安装 Gitlab Shell</h6><pre><code>cd /Users/gitlab\nsudo -u gitlab git clone https://github.com/gitlabhq/gitlab-shell.git\ncd gitlab-shell\nsudo -u gitlab git checkout v1.9.1\nsudo -u gitlab cp config.yml.example config.yml\n</code></pre><p>打开 config.yml,然后进行编辑<br>设置  gitlab_url. 把 gitlab.example.com 替换成你自己的域名 （如果本地就不用了）<br>把所有的/home 替换成 /Users</p>\n<pre><code>sudo -u gitlab sed -i &quot;&quot; &quot;s/\\/home\\//\\/Users\\//g&quot; config.yml\nsudo -u gitlab sed -i &quot;&quot; &quot;s/\\/usr\\/bin\\/redis-cli/\\/usr\\/local\\/bin\\/redis-cli/&quot; config.yml\n</code></pre><p>然后执行安装脚本：<code>sudo -u gitlab -H ./bin/install</code>  <strong>//需在gitlab-shell目录下载执行</strong></p>\n<h6 id=\"安装gitlab\"><a href=\"#安装gitlab\" class=\"headerlink\" title=\"安装gitlab\"></a>安装gitlab</h6><p>先下载gitlab</p>\n<pre><code>cd /Users/gitlab\nsudo -u gitlab git clone https://github.com/gitlabhq/gitlabhq.git\ncd gitlab\nsudo -u gitlab git checkout 6-7-stable\n</code></pre><p>配置gitlab</p>\n<pre><code>sudo -u gitlab cp config/gitlab.yml.example config/gitlab.yml\nsudo -u gitlab sed -i &quot;&quot; &quot;s/\\/usr\\/bin\\/git/\\/usr\\/local\\/bin\\/git/g&quot; config/gitlab.yml\nsudo -u gitlab sed -i &quot;&quot; &quot;s/\\/home/\\/Users/g&quot; config/gitlab.yml\nsudo -u gitlab sed -i &quot;&quot; &quot;s/localhost/domain.com/g&quot; config/gitlab.yml\n</code></pre><p>配置MySQL数据库，创建gitlab用户，数据库，和gitlab用户的管理权限</p>\n<pre><code># Login to MySQL\n$ mysql -u root -p\n\n# Create the GitLab production database\nmysql&gt; CREATE DATABASE IF NOT EXISTS `gitlabhq_production` DEFAULT CHARACTER SET `utf8` COLLATE `utf8_unicode_ci`;\n\n# Create the MySQL User change $password to a real password\nmysql&gt; CREATE USER &apos;gitlab&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;$password&apos;;\n\n# Grant proper permissions to the MySQL User\nmysql&gt; GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER ON `gitlabhq_production`.* TO &apos;gitlab&apos;@&apos;localhost&apos;;\n</code></pre><h6 id=\"安装-Gitolite帮助管理git内部用户\"><a href=\"#安装-Gitolite帮助管理git内部用户\" class=\"headerlink\" title=\"安装 Gitolite帮助管理git内部用户\"></a>安装 Gitolite帮助管理git内部用户</h6><p>克隆gitlab的gitolite分支源代码：</p>\n<pre><code>sudo -H -u gitlab git clone -b gl-v304 https://github.com/gitlabhq/gitolite.git /Users/gitlab/gitolite\n</code></pre><p>安装：</p>\n<pre><code>cd /Users/gitlab\nsudo -u gitlab -H mkdir bin\nsudo -u gitlab sh -c &apos;echo -e &quot;PATH=\\$PATH:/Users/gitlab/bin\\nexport PATH&quot; &gt;&gt; /Users/gitlab/.profile&apos;\nsudo -u gitlab sh -c &apos;gitolite/install -ln /Users/gitlab/bin&apos;\n\nsudo cp ~/.ssh/id_rsa.pub /Users/gitlab/gitlab.pub\nsudo chmod 0444 /Users/gitlab/gitlab.pub\n\nsudo -u gitlab -H sh -c &quot;PATH=/Users/gitlab/bin:$PATH; gitolite setup -pk /Users/gitlab/gitlab.pub&quot;\n</code></pre><p>为 Git 创建用户：    </p>\n<pre><code>sudo adduser \\\n  --system \\\n  --shell /bin/sh \\\n  --gecos &apos;git version control&apos; \\\n  --group \\\n  --disabled-password \\\n  --home /home/git \\\n  git\n</code></pre><p>若干问题解决办法：<a href=\"http://www.cnblogs.com/whj198579/archive/2013/04/09/3009350.html\" target=\"_blank\" rel=\"noopener\">Mac搭建Git服务器—开启SSH</a></p>\n<pre><code>Cloning into &apos;/tmp/gitolite-admin&apos;...\nssh: connect to host localhost port 22: Connection refused\nfatal: Could not read from remote repository.\n</code></pre><p>SSH无密码登陆设置：</p>\n<pre><code>$ cd /etc\n$ chmod 666 sshd_config\n$ vim sshd_config\n\n#PermitRootLogin yes  改为：PermitRootLogin no\n#UsePAM yes             改为: UsePAM no\n</code></pre><p>Remove the # from the following</p>\n<pre><code>#RSAAuthentication yes\n#PubkeyAuthentication yes\n#AuthorizedKeysFile     .ssh/authorized_keys    \n#PasswordAuthentication no\n#PermitEmptyPasswords no\n</code></pre>","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"gitLab","path":"api/categories/gitLab.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"git","path":"api/tags/git.json"},{"name":"gitLab","path":"api/tags/gitLab.json"}]},{"title":"如何使用gitBook协作Octopress同时完成博客和书籍","slug":"git/如何使用gitBook协作Octopress同时完成博客和书籍","date":"2015-08-11T14:41:40.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/如何使用gitBook协作Octopress同时完成博客和书籍.json","excerpt":null,"keywords":null,"cover":"https://raw.githubusercontent.com/huos3203/IOSDev/master/EAC7C104-FCE1-40CF-9766-F14C4F271FCF.png","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"将gitbook添加到github库中\"><a href=\"#将gitbook添加到github库中\" class=\"headerlink\" title=\"将gitbook添加到github库中\"></a>将gitbook添加到github库中</h4><ul>\n<li>使用gitbook新建New book，即在~/GitBook/Library/Import/yourbookName/下，创建了git库</li>\n<li>菜单：Book -&gt; Repository setting… -&gt; <img src=\"https://raw.githubusercontent.com/huos3203/IOSDev/master/EAC7C104-FCE1-40CF-9766-F14C4F271FCF.png\" alt=\"设置库路径\"></li>\n<li>使用SourceTree版本工具，添加本地的yourbookName版本库，来协助gitbook管理版本。</li>\n</ul>\n<h4 id=\"协助Octopress\"><a href=\"#协助Octopress\" class=\"headerlink\" title=\"协助Octopress\"></a>协助Octopress</h4><ul>\n<li>必须在yourBlog目录下，执行rake newe_post[‘’]创建.MarkDown文件。</li>\n<li>将第一步新建的文件，通过Gitbook的Files tree 树形栏，导入yourbookname版本库中。</li>\n<li>在gitbook的Table of Contents中新建章节，命名为第一步创建时的文件名。</li>\n<li>编辑yourbookName 版本库中的SUMMARY.md，将文件与目录关联起来，并保存SUMMARY.md。</li>\n<li>点击目录节点名，即可在编辑框内，对该md文件编辑。</li>\n</ul>\n<h4 id=\"如何将gitbook编辑的md文件内容同步到Octopress中\"><a href=\"#如何将gitbook编辑的md文件内容同步到Octopress中\" class=\"headerlink\" title=\"如何将gitbook编辑的md文件内容同步到Octopress中\"></a>如何将gitbook编辑的md文件内容同步到Octopress中</h4><ul>\n<li>方法一：拷贝gitbook编辑的md文件，覆盖到octpress的_post目录下。</li>\n<li>方法二：通过github，公用一个版本库，来管理同步。</li>\n</ul>\n<p><font color=\"red\">更新：</font>gitbook 4.2.2之后，默认将rake new_post生成的文件目录导入到~/gitbook目录中，至此，以上方法作废了。</p>\n<p>使用GitBook（<strong>版本限于4.0之前的版本</strong>） 来编写Octopress博客的步骤：  </p>\n<ol>\n<li><code>cd ~/MyBlog</code>  </li>\n<li><strong><code>rake new_post[&#39;文章名&#39;]</code></strong>或 <strong><code>rake new_page[&#39;404&#39;]</code></strong>新建md文档.  </li>\n<li><strong><code>mv *.markdown *.md</code></strong> mv命令修改后缀为md，便于gitbook在Preview website识别该文档。  </li>\n<li>配置SUMMARY.md 关联 gitbook，通过目录访问Octopress文档。  </li>\n<li>打开gitbook客户端，对新建的文档进行编写即可。</li>\n</ol>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"IDE","path":"api/categories/IDE.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"gitBook","path":"api/tags/gitBook.json"}]},{"title":"快速正确的安装Ruby,Rails运行环境","slug":"工具/快速正确的安装Ruby,Rails运行环境","date":"2015-01-21T23:00:39.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/工具/快速正确的安装Ruby,Rails运行环境.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>安装ruby环境：<br>方法一：下载源码，编译安装：<a href=\"http://fsjoy.blog.51cto.com/318484/115045/\" target=\"_blank\" rel=\"noopener\">配置中制定安装目录</a><br>方法二：使用rvm安装：<a href=\"https://ruby-china.org/wiki/rvm-guide\" target=\"_blank\" rel=\"noopener\">可以提供一个便捷的多版本 Ruby 环境的管理和切换</a><br>方法三：使用macport安装 <code>port install ruby</code></p>\n<p><a href=\"https://ruby-china.org/wiki/install_ruby_guide\" target=\"_blank\" rel=\"noopener\">详细教程</a></p>\n<p>问题：<br><code>ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/rake</code><br><a href=\"http://stackoverflow.com/questions/30812777/cannot-install-cocoa-pods-after-uninstalling-results-in-error/30851030#30851030\" target=\"_blank\" rel=\"noopener\">stackoverflow方法</a>测试结果没走通。<br>最终通过<a href=\"http://tadaland.com/os-x-rootless.html\" target=\"_blank\" rel=\"noopener\">OS X 10.11中Rootless的实现与解释以及关闭方法</a>解决.</p>\n<h4 id=\"Gem介绍\"><a href=\"#Gem介绍\" class=\"headerlink\" title=\"Gem介绍\"></a>Gem介绍</h4><p>Gem是一个ruby库和程序的标准包，它通过RubyGem来定位、安装、升级和卸载，非常的便捷。</p>\n<p>Ruby 1.9.2版本默认安装RubyGem，如果你使用其它版本，请参考如何安装RubyGem。<br><a id=\"more\"></a></p>\n<h4 id=\"升级RubyGem\"><a href=\"#升级RubyGem\" class=\"headerlink\" title=\"升级RubyGem\"></a>升级RubyGem</h4><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gem update --system</span><br></pre></td></tr></table></figure>\n<h4 id=\"安装新的Gem\"><a href=\"#安装新的Gem\" class=\"headerlink\" title=\"安装新的Gem\"></a>安装新的Gem</h4><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gem install rai</span><br><span class=\"line\"></span><br><span class=\"line\">/<span class=\"regexp\">/指定安装某一版本的Gem包</span></span><br><span class=\"line\"><span class=\"regexp\">gem install [gemname] --version=1.3.2</span></span><br></pre></td></tr></table></figure>\n<p>在安装过程中可以看到如下提示，说明它是从rubygems.org内去寻找并安装gem package的。<br>Fetching source index for <a href=\"http://rubygems.org/\" target=\"_blank\" rel=\"noopener\">http://rubygems.org/</a></p>\n<h4 id=\"gem-的安装方式\"><a href=\"#gem-的安装方式\" class=\"headerlink\" title=\"gem 的安装方式\"></a>gem 的安装方式</h4><h4 id=\"MacPorts安装和使用\"><a href=\"#MacPorts安装和使用\" class=\"headerlink\" title=\"MacPorts安装和使用\"></a>MacPorts安装和使用</h4><p><a href=\"http://ccvita.com/434.html\" target=\"_blank\" rel=\"noopener\">http://ccvita.com/434.html</a><br><a href=\"http://guide.macports.org\" target=\"_blank\" rel=\"noopener\">http://guide.macports.org</a><br><a href=\"http://www.fantageek.com/318/install-pkg-config-for-mac-osx/\" target=\"_blank\" rel=\"noopener\">http://www.fantageek.com/318/install-pkg-config-for-mac-osx/</a>  </p>\n<p>Mac下面除了用dmg、pkg来安装软件外，比较方便的还有用MacPorts来帮助你安装其他应用程序，跟BSD中的ports道理一样。MacPorts就像apt-get、yum一样，可以快速安装些软件。</p>\n<p>安装后，配置：</p>\n<pre><code>sudo vi /etc/profile\nexport PATH=/opt/local/bin:$PATH\nexport PATH=/opt/local/sbin:$PATH\n</code></pre><p>MacPorts使用 <a href=\"http://witcheryne.iteye.com/blog/991821\" target=\"_blank\" rel=\"noopener\">http://witcheryne.iteye.com/blog/991821</a></p>\n<ol>\n<li><p>更新ports tree和MacPorts版本，强烈推荐第一次运行的时候使用-v参数，显示详细的更新过程。<br>sudo port -v selfupdate</p>\n</li>\n<li><p>搜索索引中的软件</p>\n<p> port search name</p>\n</li>\n<li><p>安装新软件<br>sudo port install name</p>\n</li>\n<li><p>卸载软件<br>sudo port uninstall name</p>\n</li>\n<li><p>查看有更新的软件以及版本<br>port outdated</p>\n</li>\n<li><p>升级可以更新的软件<br>sudo port upgrade outdated</p>\n</li>\n</ol>\n<p>实例：<br>Eclipse的插件需要subclipse需要JavaHL，下面通过MacPorts来安装</p>\n<pre><code>sudo port install subversion-javahlbindings\n\ninstalled \n</code></pre><p>列出全部或者指定的已经安装的软件：</p>\n<pre><code>port installed\nport -v installed atlas\n</code></pre><p>dependents 查看哪些软件时依赖与这个软件的</p>\n<pre><code>删除一个软件时候，最好先执行一下这个命令.\n    port dependents openssl\n</code></pre>","raw":null,"categories":[{"name":"工具","path":"api/categories/工具.json"},{"name":"ruby","path":"api/categories/ruby.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"脚本","path":"api/tags/脚本.json"},{"name":"安装","path":"api/tags/安装.json"}]},{"title":"Git中的储藏工具stash","slug":"git/Git中的储藏工具stash","date":"2015-01-19T19:57:04.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/Git中的储藏工具stash.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><ol>\n<li><a href=\"#Stashing\">Stashing</a></li>\n<li><a href=\"#work\">储藏工作</a></li>\n<li><a href=\"#apply\">应用储藏</a></li>\n<li><a href=\"#applyIndex\">被暂存的文件重新暂存</a></li>\n<li><a href=\"#drop\">应用后，移除储藏的内容</a></li>\n<li><a href=\"#unapply\">取消储藏(Un-applying a Stash)</a></li>\n<li><a href=\"#stash-unapply\">新建stash-unapply别名</a></li>\n<li><a href=\"#stashBranch\">从储藏中创建分支</a></li>\n</ol>\n<h3 id=\"Git工具-储藏（Stashing）git\"><a href=\"#Git工具-储藏（Stashing）git\" class=\"headerlink\" title=\"Git工具 - 储藏（Stashing）git\"></a><a name=\"Stashing\">Git工具 - 储藏（Stashing）</a>git</h3><hr>\n<p><a href=\"https://git-scm.com/book/zh/v2/Git-工具-储藏与清理\" target=\"_blank\" rel=\"noopener\">原文</a><br>场景：当项目中某一部分正在编码中，突然接到新任务，又必须换至其他分支去完成。</p>\n<p>问题：你不想提交进行了一半的工作，否则以后你无法回到这个工作点。</p>\n<p>解决：<strong><font color=\"red\">git stash </font></strong>命令。</p>\n<p>“Stashing”可以获取工作目录的中间状态，即：将修改过的被追踪的文件和暂存的变更，保存到一个未完结变更的堆栈中，随时可以重新应用。</p>\n<h3 id=\"储藏工作\"><a href=\"#储藏工作\" class=\"headerlink\" title=\"储藏工作\"></a><a name=\"work\">储藏工作</a></h3><hr>\n<ol>\n<li>进入项目目录，修改某个文件，有可能还暂存其中的一个变更。</li>\n<li><strong><font color=\"red\">git status </font></strong>命令,查看中间状态：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\"># Changes to be committed:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   index.html</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   lib/simplegit.rb</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure></li>\n<li>切换分支，但不提交step 1 中的变更，所以储藏这些变更。<br>执行<strong><font color=\"red\">git stash </font></strong>命令，往堆栈中推送一个新的储藏：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash</span><br><span class=\"line\">Saved working directory and index state \\</span><br><span class=\"line\">  <span class=\"string\">\"WIP on master: 049d078 added the index file\"</span></span><br><span class=\"line\">HEAD is now at 049d078 added the index file</span><br><span class=\"line\">(To restore them <span class=\"built_in\">type</span> <span class=\"string\">\"git stash apply\"</span>)</span><br></pre></td></tr></table></figure></li>\n<li>执行step 2查看目录库，中间状态就不见了：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\"><span class=\"comment\">#######On branch master</span></span><br><span class=\"line\">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>\n这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。</li>\n<li>使用<strong><font color=\"red\">git stash list</font></strong>要查看现有的储藏：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash list</span><br><span class=\"line\">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class=\"line\">stash@&#123;1&#125;: WIP on master: c264051 Revert <span class=\"string\">\"added file_size\"</span></span><br><span class=\"line\">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to <span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n在这个案例中，之前已经进行了两次储藏，所以你可以访问到三个不同的储藏。<h3 id=\"应用储藏\"><a href=\"#应用储藏\" class=\"headerlink\" title=\"应用储藏\"></a><a name=\"apply\">应用储藏</a></h3></li>\n</ol>\n<hr>\n<p>执行<strong><font color=\"red\">git stash apply</font></strong>命令, 可以重新应用最近的一次储藏；<br>执行<strong><font color=\"red\">git stash apply stash@{2}</font></strong>命令，即通过指定储藏的名字，来应用更早的储藏。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash apply</span><br><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   index.html</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   lib/simplegit.rb</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure><br><a id=\"more\"></a><br>可以看到 Git 重新修改了你所储藏的那些当时尚未提交的文件。在这个案例里，你尝试应用储藏的工作目录是干净的，并且属于同一分支；但是一个干净的工作目录和应用到相同的分支上并不是应用储藏的必要条件。你可以在其中一个分支上保留一份储藏，随后切换到另外一个分支，再重新应用这些变更。在工作目录里包含已修改和未提交的文件时，你也可以应用储藏——Git 会给出归并冲突如果有任何变更无法干净地被应用。</p>\n<h3 id=\"被暂存的文件重新暂存\"><a href=\"#被暂存的文件重新暂存\" class=\"headerlink\" title=\"被暂存的文件重新暂存\"></a><a name=\"applyIndex\">被暂存的文件重新暂存</a></h3><hr>\n<p>执行<strong><font color=\"red\">git stash apply</font></strong>命令,虽然对文件的变更被重新应用，但是被暂存的文件没有重新被暂存。<br>执行<strong><font color=\"red\">git stash apply –index</font></strong>命令,即可让被暂存的文件重新暂存。<br><strong>–index</strong>选项告诉命令重新应用被暂存的变更：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash apply --index</span><br><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\"># Changes to be committed:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   index.html</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   lib/simplegit.rb</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"应用后，移除储藏的内容\"><a href=\"#应用后，移除储藏的内容\" class=\"headerlink\" title=\"应用后，移除储藏的内容\"></a><a name=\"drop\">应用后，移除储藏的内容</a></h3><hr>\n<p><strong>apply </strong>选项只尝试应用储藏的工作——储藏的内容仍然在栈上。<br>执行<strong><font color=\"red\">git stash drop 储藏的名字</font></strong>命令，，即可从栈中彻底移除储藏内容：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash list</span><br><span class=\"line\">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class=\"line\">stash@&#123;1&#125;: WIP on master: c264051 Revert <span class=\"string\">\"added file_size\"</span></span><br><span class=\"line\">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to <span class=\"built_in\">log</span></span><br><span class=\"line\">$ git stash drop stash@&#123;0&#125;</span><br><span class=\"line\">Dropped stash@&#123;0&#125; (364e91f3f268f0900bc3ee613f9f733e82aaed43)</span><br></pre></td></tr></table></figure><br>你也可以运行 <strong><font color=\"red\">git stash pop</font></strong>命令，来重新应用储藏，同时立刻将其从堆栈中移走。</p>\n<h3 id=\"取消储藏-Un-applying-a-Stash\"><a href=\"#取消储藏-Un-applying-a-Stash\" class=\"headerlink\" title=\"取消储藏(Un-applying a Stash)\"></a><a name=\"unapply\">取消储藏(Un-applying a Stash)</a></h3><hr>\n<p>在某些情况下，重新应用了之前的储藏的变更，进行了一些其他的修改后，又想要取消之前所应用储藏的修改。<br>Git没有提供类似于 <strong><font color=\"red\">stash unapply</font></strong>的命令，但是可以通过取消该储藏的补丁达到同样的效果：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash show -p stash@&#123;0&#125; | git apply -R</span><br></pre></td></tr></table></figure><br>同样的，如果你沒有指定具体的某个储藏，Git 会选择最近的储藏：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash show -p | git apply -R</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"新建stash-unapply别名\"><a href=\"#新建stash-unapply别名\" class=\"headerlink\" title=\"新建stash-unapply别名\"></a><a name=\"stash-unapply\">新建stash-unapply别名</a></h4><hr>\n<p>你可能会想要新建一个別名，在你的 Git 里增加一个<strong><font color=\"red\">stash-unapply</font></strong> 命，这样更有效率。例如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global alias.stash-unapply <span class=\"string\">'!git stash show -p | git apply -R'</span></span><br><span class=\"line\">$ git stash apply</span><br><span class=\"line\">$ <span class=\"comment\">#... work work work</span></span><br><span class=\"line\">$ git stash-unapply</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"从储藏中创建分支\"><a href=\"#从储藏中创建分支\" class=\"headerlink\" title=\"从储藏中创建分支\"></a><a name=\"stashBranch\">从储藏中创建分支</a></h3><hr>\n<p>如果你储藏了一些工作，暂时不去理会，然后继续在你储藏工作的分支上工作，你在重新应用工作时可能会碰到一些问题。如果尝试应用的变更是针对一个你那之后修改过的文件，你会碰到一个归并冲突并且必须去化解它。如果你想用更方便的方法来重新检验你储藏的变更，你可以运行 git stash branch，这会创建一个新的分支，检出你储藏工作时的所处的提交，重新应用你的工作，如果成功，将会丢弃储藏。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash branch testchanges</span><br><span class=\"line\">Switched to a new branch <span class=\"string\">\"testchanges\"</span></span><br><span class=\"line\"><span class=\"comment\"># On branch testchanges</span></span><br><span class=\"line\"><span class=\"comment\"># Changes to be committed:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   index.html</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   lib/simplegit.rb</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">Dropped refs/stash@&#123;0&#125; (f0dfc4d5dc332d1cee34a634182e168c4efc3359)</span><br></pre></td></tr></table></figure><br>这是一个很棒的捷径来恢复储藏的工作然后在新的分支上继续当时的工作。</p>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"工具","path":"api/categories/工具.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"git","path":"api/tags/git.json"},{"name":"坑","path":"api/tags/坑.json"}]},{"title":"Xcode HeaderDoc 教程","slug":"xcode/XcodeHeaderDoc教程","date":"2014-08-28T15:18:41.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/xcode/XcodeHeaderDoc教程.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/car.jpg?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>HeaderDoc 是在Xcode 5 和 iOS7 发布时，新增的一个命令行工具，功能：可以从代码中自动生成格式良好的HTML文档——当然，必须依赖于特定格式的注释来完成的。</p>\n<p>另外，Xcode 还会在 quick look 面板中以<strong>HeaderDoc</strong>风格显示你的注释。</p>\n<p>通过本教程，将学习如下几点：</p>\n<ul>\n<li>如何书写 HeaderDoc 风格的注释</li>\n<li>分如何在 Xcode 中预览文档</li>\n<li>如何生成 HTML 文档</li>\n<li>如何使用 VVDocumenter-Xcode(一个易于使用的第3方文档制作工具)</li>\n</ul>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>下载本教程中用到的 <a href=\"http://cdn2.raywenderlich.com/wp-content/uploads/2014/03/DocumentationExamples_Starter.zip\" target=\"_blank\" rel=\"noopener\">示例项目</a></p>\n<p>这个简单的示例程序只包含了两个类：</p>\n<ul>\n<li>Car: 包含几个属性及一个 “drive” 方法以及一个 completion 块。</li>\n<li>MathAPI: 包含了1个方法，用于累加两个数。<br>现在，这两个类还没有任何注释。以便演示如何通过 <strong>HeaderDoc</strong> 为这两个类创建文档。<a id=\"more\"></a>\n<h4 id=\"HeaderDoc-注释\"><a href=\"#HeaderDoc-注释\" class=\"headerlink\" title=\"HeaderDoc 注释\"></a>HeaderDoc 注释</h4></li>\n</ul>\n<p><strong>HeaderDoc</strong> 可以从命令行中运行，也可以通过 Xcode 运行。它扫描文件中以某种格式书写的注释,包括这3种形式：<br>这3中语法在 Xcode 中产生同样效果的文档</p>\n<pre><code>注释 1. 一般用于单行注释\n    /// Your documentation comment will go here\n注释 2.\n    /**  * Your documentation comment will go here  */\n注释 3: 一般用于较长的注释块\n    /*!  * Your documentation comment will go here  */\n\n注意：在注释2和注释3中，在每一行开头都会有一个额外的*，直至结尾的 */。这仅仅是为了美观，而不是必须的。\n</code></pre><h4 id=\"HeaderDoc-标签\"><a href=\"#HeaderDoc-标签\" class=\"headerlink\" title=\"HeaderDoc 标签\"></a>HeaderDoc 标签</h4><p>当 <strong>HeaderDoc</strong> 发现上述3种注释，它就开始寻找其中的<strong>HeaderDoc 标签</strong>。<strong>HeaderDoc 标签</strong> 用来修饰<strong>HeaderDoc 注释</strong>。</p>\n<p><strong>HeaderDoc 标签</strong>以 <strong>@</strong> 符号开头，然后是关键字，然后是一个空格，最后才是相应的文本（例如 @param foo）。<br>HeaderDoc 标签可以分为两种：</p>\n<ol>\n<li><p>顶级标签: 这些标签声明所要注释的对象的类型（例如头部声明、类、方法等等）。</p>\n<ul>\n<li>顶级标签，例如 @typedef，用于表示 <strong>typedef</strong> 定义的类型，比如枚举、结构体和函数指针。</li>\n<li><strong>HeaderDoc</strong> 能够根据上下文自动产生顶级标签，因此通常不是必须的。</li>\n</ul>\n</li>\n<li><p>二级标签:这些标签才是具体的注释内容。</p>\n<ul>\n<li>@brief: 简单描述你准备文档化的数据的类型，方法等等。</li>\n<li>@abstract: 等于 @brief。<ul>\n<li>@discussion: 类似 @abstract 和 @brief，但允许多行。它不是必须的，仅仅是为了使描述更清晰。</li>\n<li>@param: 描述方法、回调或函数的参数名称。</li>\n<li>@return: 描述方法或函数的返回值。（等同于 @result）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<!-- More -->\n<h4 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h4><ul>\n<li><h6 id=\"属性的文档化\"><a href=\"#属性的文档化\" class=\"headerlink\" title=\"属性的文档化\"></a>属性的文档化</h6><p>用 Xcode 打开<strong>DocumentationExamples</strong> 项目, 打开<strong>ViewController.h</strong>,<br>在<strong> car </strong>属性的前面，加入一行注释:</p>\n<pre><code>/*!  * @brief The ViewController class&apos; car object.  */\n\n@property (nonatomic) Car *car;\n</code></pre></li>\n</ul>\n<p>编译项目。编译结束，按住 alt/option 键，点击<strong>car</strong> 变量名。你将看到<strong>pop菜单</strong>中显示了刚才的注释内容。<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/car.jpg?imageMogr2/2/w/800\"><br>另一种方法:切换到Utitlities 面板的<strong>Quick Help</strong> 检查器窗口。点击 <strong>car</strong> 变量名，通过<strong>Quick Help</strong>,你将看到如下效果：<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/carquickhelp.jpg?imageMogr2/2/w/800\"></p>\n<ul>\n<li><h6 id=\"方法的文档化\"><a href=\"#方法的文档化\" class=\"headerlink\" title=\"方法的文档化\"></a>方法的文档化</h6><p><strong>MathAPI</strong>包含一个方法需要文档化。打开<strong>MathAPI.h</strong>,找到<code>addNumber:toNumber:</code>。</p>\n</li>\n</ul>\n<p>这个方法有两个参数及一个返回值。因此需要一个 @description 标签、两个@param标签，以及一个@return 标签，如下面所示：</p>\n<pre><code>/*!  * @discussion A really simple way to calculate the sum of two numbers.\n\n      * @param firstNumber An NSInteger to be used in the summation of two numbers\n\n      * @param secondNumber The second half of the equation.\n\n       * @return The sum of the two numbers passed in.\n\n*/\n\n+ (NSInteger)addNumber:(NSInteger)firstNumber toNumber:(NSInteger)secondNumber;\n</code></pre><p>编译，再 <strong>alt + 左键</strong>：<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/method.jpg?imageMogr2/2/w/800\"></p>\n<p> 问题: 在 Xcode 文本编辑窗口，很多地方都支持 <strong>alt+左键</strong>。请确保你点击在正确的地方。在上面的例子里，你应当在addNumber: 和 toNumber: 两处使用 alt+左键。</p>\n<p>你也许不知道，这个方法的实现真的很恶心。它只能使用非负数作为参数。为了让用户明白这一点，你应当在注释中添加更多的说明。因此，我们可以在 @return 前面加入一个 @warning 标签。</p>\n<pre><code>* @warning Please make note that this method is only good for adding non-negative numbers.\n</code></pre><p>编译项目，然后使用 alt+左键。我们添加的 @warning 标签效果如下：<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/warning.jpg?imageMogr2/2/w/800\"></p>\n<h4 id=\"Code-Snippets，让一切变得更简单\"><a href=\"#Code-Snippets，让一切变得更简单\" class=\"headerlink\" title=\"Code Snippets，让一切变得更简单:\"></a>Code Snippets，让一切变得更简单:</h4><p>一个<strong>snippet</strong> 是一个可以重用的代码块（存储在 snippet 库中）。<strong>Snippets</strong> 甚至可以包含一些需要你去填充的占位符。<br>这意味着, 可以用 <strong>snipppet</strong>来进行文档化。</p>\n<p>在 <strong>MathAPI.h</strong> 中，在原有的注释上面加入以下内容：</p>\n<pre><code>/*!  * @discussion &lt;#description#&gt;\n\n     * @param &lt;#param description#&gt;\n\n     * @return &lt;#return description#&gt;\n*/\n</code></pre><p> 注意，当粘贴上述代码时，“&lt;# #&gt;”之间的内容会变成一个<strong>token</strong>,意味着可以通过 <strong>tab 键</strong>在 <strong>token</strong> 之间来回切换。就像编写代码时的自动完成功能。<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/token.png?imageMogr2/2/w/800\"></p>\n<h6 id=\"学习使用Code-Snippets工具\"><a href=\"#学习使用Code-Snippets工具\" class=\"headerlink\" title=\"学习使用Code Snippets工具\"></a>学习使用Code Snippets工具</h6><p> 打开 <strong>Utilities 面板</strong>中的 <strong>CodeSnippets Library 检查器</strong>窗口，选中上述注释块，将它拖到该检查器窗口中（从某个 token 例如&lt;#description#&gt;开始拖）:<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/codesnippet.jpg?imageMogr2/2/w/800\"><br> 将会弹出一个编辑窗口让输入 snippet 的某些信息，并以此来创建一个<strong>自动完成快捷方式</strong>。要修改某个<strong>snippet</strong>时,直接点击 <strong>Code Snippet Library</strong> 中的 snippet，然后点 Edit 按钮。按照如下形式填写：<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/snippetwindow.jpg?imageMogr2/2/w/800\"></p>\n<p>要想让 <strong>snippet</strong> 生效，首先删除原有注释，然后将鼠标放到addNumber:toNumber: 方法的 + 号前面,输入<strong>doccomment</strong>，然后回车，该<strong>snippet</strong> 将自动生成。然后，通过 Tab 键在3个 token 间移动，并填充它们。最终完成的文档化结果如下:</p>\n<pre><code>/*!  * @discussion A really simple way to calculate the sum of two numbers.\n\n     * @param firstNumber An NSInteger to be used in the summation of two numbers.\n\n     * @param secondNumber The second half of the equation.\n\n     * @warning Please make note that this method is only good for adding non-negative numbers.\n\n     * @return The sum of the two numbers passed in.\n*/\n</code></pre><p><strong>@param 标签</strong>和 <strong>@warning 标签</strong>需要手动书写。</p>\n<h4 id=\"Typedefs的文档化\"><a href=\"#Typedefs的文档化\" class=\"headerlink\" title=\"Typedefs的文档化\"></a>Typedefs的文档化</h4><p> 打开 Car.h，在 class 之,有一个NS_ENUM，即 typedef enum，一个块，几个属性，一个空方法等，需要文档化。</p>\n<p>还记得 @typedef 标签吗？<br>这个顶级标签稍微特殊一点。它可以对<strong>typedef enum</strong> 或者 <strong>typedef struct</strong> 的类型进行注释。<br>根据注释的对象的不同，它会包含与定义的类型相关的二级标签。</p>\n<p>以 enum 为例，它会包含 @constant 标签，用于每个常量（对于struct，则会是 @field 标签）。</p>\n<p>找到 <strong>enum OldCarType</strong>。它包含两个常量，是用于古典汽车的。在<strong>typedef</strong> 声明之上，将原来的注释替换为：</p>\n<pre><code>/*!  * @typedef OldCarType\n\n     * @brief A list of older car types.\n\n     * @constant OldCarTypeModelT A cool old car.\n\n     * @constant OldCarTypeModelA A sophisticated old car.\n*/\n\ntypedef enum {\n        /// A cool, old car.\n\n         OldCarTypeModelT,\n\n        /// A sophisticated older car.\n\n        OldCarTypeModelA\n\n} OldCarType;\n</code></pre><p> 编译，然后在 <strong>OldCarType</strong> 或上<strong>OldCarTypeModelT</strong>使用<strong>alt + 左键</strong>。</p>\n<p>在这个类中只有一个 <strong>NS_ENUM</strong>，因此接下来进行进行文档化。常量已经注释了，只要对整个<strong>NS_ENUM</strong> 进行一个总体的注释就可以了。</p>\n<pre><code>/*!  * @typedefCarType\n\n     * @brief Alist of newer car types.\n\n     * @constantCarTypeHatchback Hatchbacks are fun, but small.\n\n     * @constantCarTypeSedan Sedans should have enough room to put your kids, and your golfclubs\n\n     * @constantCarTypeEstate Estate cars should hold your kids, groceries, sport equipment,etc.\n\n     * @constantCarTypeSport Sport cars should be fast, fun, and hard on the back.\n*/\n</code></pre><p>注意:这个enum 是通过宏来声明的，悲催的 Xcode 不能完全支持和 <strong>typedef enum</strong> 一样的文档特性，虽然<strong>NS_ENUM</strong> 实际上是声明 enums 的推荐的方法。</p>\n<h4 id=\"typedef-block-文档化\"><a href=\"#typedef-block-文档化\" class=\"headerlink\" title=\"typedef block 文档化\"></a>typedef block 文档化</h4><pre><code>/*!  * @brief A block that makes the car drive.\n     * @param distance The distance is equal to a distance driven when the block is ready to execute. It could be miles, or kilometers, but not both. Just pick one and stick with it. ;]\n*/\n\ntypedef void(^driveCompletion)(CGFloat distance);\n</code></pre><p><strong>typedef block</strong> 的文档化和之前的并无多少不同，它包含了：</p>\n<ul>\n<li>一个 @brief 标签，简单说明了一下这个块的作用。</li>\n<li>一个 @param 标签，说明调用块时需要传递的参数。</li>\n</ul>\n<h4 id=\"添加格式化代码到文档中\"><a href=\"#添加格式化代码到文档中\" class=\"headerlink\" title=\"添加格式化代码到文档中\"></a>添加格式化代码到文档中</h4><p>例如，Car 类的 <strong>driveCarWithComplete:</strong> 方法。</p>\n<p>这个方法以块作为参数，因为块对于新手来说一般比较困难，因此最好是告诉程序员如何使用这个方法。</p>\n<p>这需要使用 <strong>@code 标签</strong>。在 <strong>driveCarWithCompletion</strong>方法声明之前添加如下内容：</p>\n<pre><code>/*!  * @brief The car will drive, and then execute the drive block\n\n     * @param completion A driveCompletion block\n\n     * @code [car driveCarWithCompletion:^(CGFloat distance){\n\n                            NSLog(@&quot;Distance driven %f&quot;, distance);\n\n                         }];\n*/\n</code></pre><p>编译，在方法名上使用<strong>alt+左键</strong>。如下图所示：<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/driveCar.jpg?imageMogr2/2/w/800\"></p>\n<h4 id=\"检查文档\"><a href=\"#检查文档\" class=\"headerlink\" title=\"检查文档\"></a>检查文档</h4><p>学会了如何添加注释，如果 <strong>Xcode</strong> 能帮你检查你的工作，就像Xcode会自动检查代码中的语法错误，那岂不是更好？有一个好消息，Clang 有一个标志，叫做“<strong>CLANG_WARN_DOCUMENTATION_COMMENTS</strong>”,可以用于检查 <strong>HeaderDoc</strong> 格式的注释。</p>\n<p>打开 <strong>DocumentationExamples</strong>的项目设置，点击 <strong>Build Settings</strong>，找到 <strong>DocumentationComments</strong>, 将值设置为 <strong>YES</strong>。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/buildsetting.jpg?imageMogr2/2/w/800\"><br>如下，打开 <strong>MathAPI.h</strong>，将第一个 @param 标签的参数名由<strong>firstNumber</strong> 修改为 <strong>thirdNumber</strong>,然后编译。<br>有一个警告发生，甚至提出了修改建议。它不会影响任何事情，但有助于检查文档中的错误。<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/RW_Documentation_WarningEx.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"特殊注释\"><a href=\"#特殊注释\" class=\"headerlink\" title=\"特殊注释\"></a>特殊注释</h4><p><strong>Xcode</strong> 还支持几种特殊注释，对于你或者使用你代码的人非常有用。</p>\n<p>打开 Car.m，在 <strong>driveCarWithCompletion:</strong> 方法中，在调用<strong>completion</strong> 块之前添加下列注释：</p>\n<pre><code>// FIXME: This is broken\n\n// !!!: Holy cow, it should be checked!\n\n// ???: Perhaps check if the block is not nil first?\n</code></pre><p>这里出现了3中注释：</p>\n<ul>\n<li>FIXME: 某个地方需要修正</li>\n<li>!!!: 某个地方需要注意。</li>\n<li>???: 代码中有问题，或者代码是可疑的。</li>\n</ul>\n<p>这些注释不但有助于浏览代码，而且 Xcode 绘制 <strong>Jump Bar</strong> 中显示它们。点击<strong>Jump Bar</strong>，如下图所示：</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/RW_Documentation_JumpBar-700x151.png?imageMogr2/2/w/800\">\n<p> 你将看到这3个注释以粗体显示：</p>\n <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/RW_Documentation_JumpBarSelect-700x287.png?imageMogr2/2/w/800\">\n<p> 到此，你已经完全掌握了如何对项目进行文档化。花一些时间对项目的其他属性和方法操作一番，并加入一些自己的东西。看看在注释块中改变一些东西或者删除某个标签会发生什么。这将让你明白注释格式如何对文档造成影响的。</p>\n<p>#用headerdoc2html 创建 HTML文档<br>文档化是由一个 <strong>HeaderDoc 工具</strong>完成的。当 Xcode 安装时，它就已经安装好了。<br>它除了解释已添加的注释，显示一个弹出菜单以及将注释在<strong>Quick Help</strong> 中显示之外，还可以在文档化之后创建 HTML、XML 以及联机帮助手册。</p>\n<p>本节介绍 HTML 文件的制作。如果你对用 HeaderDoc 如何创建在线文档感兴趣，请参考<a href=\"https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/HeaderDoc/usage/usage.html\" target=\"_blank\" rel=\"noopener\">HeaderDoc 用户指南</a>.</p>\n<p>打开终端，转到 DocumentationExamples 项目目录：</p>\n<pre><code>cd /path/to/your/folder\n\n确保该路径下包含了 Xcodeproject  文件(“DocumentationExamples.xcodeproj”)。\n</code></pre><p>然后用下列命令创建 HTML 文档：</p>\n<pre><code>headerdoc2html -o ~/Desktop/documentation DocumentationExamples/\n</code></pre><p>此时终端会有许多输出。当创建完毕，返回桌面，出现一个名为documentation 的目录。双击打开，找到 Car_h 目录，打开 index.html：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/Screen-Shot-2014-04-05-at-5.58.18-PM.png?imageMogr2/2/w/800\"></p>\n<p><strong>headerdoc2html 脚本</strong>有两个参数：</p>\n<p>So what justhappened? Well, you ran the headerdoc2htmlscript with 2 options:</p>\n<ul>\n<li>-o ~/Desktop/documentation – 这个参数指定输出的 Html 文件路径——即桌面的 documentation 目录。</li>\n<li>DocumentationExamples/ – 该参数指定要解析的源文件位于 DocumentationExamples 目录（不包含项目目录下的其他目录，因为它们并不包含源代码）</li>\n</ul>\n<p>问题:</p>\n<ol>\n<li>最新版本<strong>headerdoc2html</strong>有个问题，用 google chrome打开 index.html后，左边的目录显示不正常，但 Safari打开正常。</li>\n<li>最新版本的<strong>headerdoc2html</strong> 不能正确解析 /// 类的注释，可以使用 /*! 类型的注释代替。</li>\n</ol>\n<p>这很酷，但还可以更进一步。除了手动进入到输出目录中进行导航，<strong>HeaderDoc</strong>还会创建一个主目录索引。<br>返回终端，导航至新建的 <strong>documentation</strong> 目录，输入：</p>\n<pre><code>cd ~/Desktop/documentation\n</code></pre><p>然后输入命令，创建内容索引:</p>\n<pre><code>gatherheaderdoc .\n</code></pre><p><strong>gatherheaderdoc</strong>自动查找目录，为 <strong>.</strong> 目录（表示当前目录）创建索引。<br>用 Finder 打开 documentation  目录。你会发现多出一个 <strong>masterTOC.html</strong> 文件。打开它，它将列出所有已文档化的属性、方法、枚举和块的链接。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/Screen-Shot-2014-04-05-at-6.01.35-PM.png?imageMogr2/2/w/800\"><br>你可以将所有 HTML 文件放到 web 服务器上，然后所有人都可以访问你的文档！</p>\n<p>#VVDocumenter-Xcode</p>\n<p>最后的内容是 <strong>VVDocumenter-Xcode</strong>，一个第三方 Xcode插件，它能让你的文档化工作简单至比使用早先介绍的 <strong>Code Snippet</strong> 更容易。</p>\n<p>首先，从 <a href=\"https://github.com/onevcat/VVDocumenter-Xcode\" target=\"_blank\" rel=\"noopener\">Github</a> 下载插件。</p>\n<p>你所需要做的全部工作就是打开项目，然后 <strong>Build</strong>。它会将插件自动安装到~/Library/ApplicationSupport/Developer/Shared/Xcode/Plug-ins 目录。</p>\n<p>然后重启 Xcode。再次打开 DocumentationExamples项目。在 MathAPI.h，删除 <strong><code>addNumber:toNumber</code></strong> 方法的注释块，然后在方法声明上面输入：</p>\n<pre><code>///\n</code></pre><p><strong>VVDocumenter-Xcode</strong> 将自动创建注释块，包括所有必要的 <strong>@param</strong> 标签以及自动完成 <strong>token</strong>。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/RW_Documentation_VVDocumentor-700x184.png?imageMogr2/2/w/800\"></p>\n<p>打开 Car.h，删除 <strong>NS_ENUM CarType</strong> 的注释，以及每个常量的注释。在<strong>NS_ENUM</strong> 声明之上，输入：</p>\n<pre><code>///\n</code></pre><p>这回，它会在 enum 之上创建 <strong>discussion</strong> 标签，甚至还每个常量上面放入了必要的注释！</p>\n<p><strong>VVDocumenter-Xcode</strong> 使你的生活更加轻松。如果你想定制<strong>VVDocumenter-Xcode</strong>，在Xcode中，使用 <strong>Window&gt;VVDocumenter菜单</strong>。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/VW_Documentation_VVDocPrefs-700x410.png?imageMogr2/2/w/800\"></p>\n<p>这里，你可以改变自动完成关键字、注释风格以及其他。你想怎样定制 VVDocumenter-Xcode都行。VVDocumenter-Xcode 为我省下了大量的时间！<br>接下来做什么？</p>\n<p>最终完成的示例项目在 这里<a href=\"http://cdn2.raywenderlich.com/wp-content/uploads/2014/03/DocumentationExamples_Final.zip\" target=\"_blank\" rel=\"noopener\">下载</a>。</p>\n<p>在你自己的代码中进行文档化。尝试自己编写 <strong>code snippet</strong> 并使用<strong>VVDocumentor</strong>。</p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"文档","path":"api/categories/文档.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"}]},{"title":"instrument之Zombie工具","slug":"调试/instrument之Zombie工具","date":"2014-07-01T19:54:02.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/调试/instrument之Zombie工具.json","excerpt":null,"keywords":null,"cover":"/images/templateOfTraceDcument.jpg","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>Zombie:针对<strong>僵尸对象</strong>导致应用程序崩溃，即已经<code>deallocated</code>的对象，它们的<code>retainCount</code>计数器已经为0，通过正常的手段是无法在<code>debug</code>中跟踪和观察到的。</p>\n<p>如果你开启了 <code>Zombie Enabled</code> ，则当 Zombie 问题出现时，控制台会输出 Zombie 对象的地址，且程序会在此处产生断点：</p>\n<pre><code>-[CALayer retainCount]: message sent to deallocated instance &lt;memoryaddress&gt;\n</code></pre><a id=\"more\"></a>\n<p>虽然可以看到内存地址，知道是某个指针导致了 <code>Zombie</code> 引用，但对于解决问题却毫无帮助，因为仍不知道该地址到底是哪个对象？原因很显然，既然该对象已经<code>deallocated</code>，就无法再从内存中找回它来。虽然可以以对象的形式打印这个指针：</p>\n<pre><code>（GDB）po &lt;内存地址&gt;\n</code></pre><p>仍然会得到一个 <strong><code>message sent to deallocated instance</code></strong> 的错误消息。</p>\n<p>可以在 <code>Instrument</code> 用 <code>Zombie</code> 模板，来观察到这些 <code>Zombie</code> 对象。</p>\n<blockquote>\n<p>提示：只能在模拟器中使用 Zombie 模板，对于在设备中运行的程序， 你只能手动找出<code>Zombie</code>对象，<code>Zombie</code>模板对物理设备无效。</p>\n</blockquote>\n<p>使用操作如下：<br>点击 Xcode 的 Project –&gt; Profile 菜单。在 Instrument 的“模板选择窗口”中，选择“iOSSimulator”下面的 Zombie 模板。<br><img src=\"/images/templateOfTraceDcument.jpg\" alt=\"image\"><br>在模拟器中调试程序，如果 Zombie 问题出现，程序将崩溃，同时 Instrument 会弹出一个“Zombie 消息报告”，同时程序将在此处中断，如下图所示。<br><img src=\"/images/ZombieMsgAlert.jpg\" alt=\"image\"></p>\n<p>点击地址 (0x158b3c00) 右边的箭头，将列出该 Zombie 对象曾经发生过的 retain/release 动作。</p>\n<p>从列表中找到 retain count 在变为 -1 之前的那行,打开 View -&gt; Extended detail，将显示导致了过渡释放的代码调用：<br><img src=\"/images/ErrCodeline.jpg\" alt=\"image\"></p>\n<p>双击这句代码，将在源文件中高亮显示该语句：</p>\n<p><img src=\"/images/Errorcode.png\" alt=\"image\"><br>现在，知道问题出在哪里了吧？</p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"instrument","path":"api/categories/instrument.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"Storyboard","path":"api/tags/Storyboard.json"}]}]}