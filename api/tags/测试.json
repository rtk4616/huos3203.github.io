{"name":"测试","postlist":[{"title":"互动性的教学工具XCPlayground","slug":"swift/互动性的教学工具XCPlayground","date":"2017-03-01T17:27:16.000Z","updated":"2017-03-01T17:27:16.000Z","comments":true,"path":"api/articles/swift/互动性的教学工具XCPlayground.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/xcplayground-sources.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>Playground 展示语法和实时执行真实数据的特性，为编写方法和库接口提供了很好的机会，通过实时编译我们能了解语法、写出例子以及获得方法如何使用的说明，所有这些就如一个活的文档展示在眼前。</p>\n<ol>\n<li>演习框架API，了解框架结构<br><a href=\"https://github.com/objcio/PersonalSwiftPlaygrounds\" target=\"_blank\" rel=\"noopener\">SceneKitMac.playground</a><br>是一个功能完备带动画的 3D 场景。你需要打开 Assistant Editor (在菜单上依次点击 View | Assistant Editor | Show Assistant Editor)，3D 效果和动画将会被自动渲染。这不需要编译循环，而且任何的改动，比如改变颜色、几何形状、亮度等，都能实时反映出来。使用它能在一个交互例子中很好的记录和介绍如何使用SceneKit框架。</li>\n<li>测试驱动开发<br>我们可以验证一个方法的执行是否正确，甚至在加载到 playground 的时候就能判断方法是否被正确解析。不难想象我们也可以在 playground 里添加断言，以及创建真正的单元测试。或者更进一步，创建出符合条件的测试，从而在你打字时就实现测试驱动开发。</li>\n</ol>\n<h2 id=\"Sources\"><a href=\"#Sources\" class=\"headerlink\" title=\"Sources\"></a>Sources</h2><p>打开 Project Navigator (⌘1) 并展开 Playground 文件，你就能看到”Sources”路径。<br>放到此目录下的源文件会被编译成模块(module)并自动导入到 Playground 中，并且这个编译只会进行一次(或者我们对该目录下的文件进行修改的时候)，而非每次你敲入一个字母的时候就编译一次。 这将会大大提高代码执行的效率。</p>\n<blockquote>\n<p>注意：由于此目录下的文件都是被编译成模块导入的，只有被设置成 public 的类型，属性或方法才能在 Playground 中使用。</p>\n</blockquote>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcplayground-sources.png?imageMogr2/2/w/800\">\n<h2 id=\"导入Frameworks\"><a href=\"#导入Frameworks\" class=\"headerlink\" title=\"导入Frameworks\"></a>导入Frameworks</h2><p>如果想要导入外部 framework，创建一个 Xcode Workspace 包含了 framework 项目和你的 Playground。在 Build 之后，就可以通过常规的import命令导入对应的包。</p>\n<h3 id=\"手动配置cocoa-touch-Framework来桥接playground\"><a href=\"#手动配置cocoa-touch-Framework来桥接playground\" class=\"headerlink\" title=\"手动配置cocoa touch Framework来桥接playground\"></a>手动配置cocoa touch Framework来桥接playground</h3><p>在Playgroud中使用个人项目中的类相关方法，需要借助于Custom Frameworks桥接<br>注：.swift的文件中的方法必须是public修饰。<br>参考文档：<code>Playground help -&gt; Importing Custom Frameworks into a Playground</code></p>\n<ol>\n<li>导入个人项目文件，需要借助<code>cocoa touch Framework</code>桥接<code>playground</code></li>\n<li>需要<code>workspace</code>来管理<code>Framework</code>项目和<code>playground</code>文件，典型例子：pod项目都是用workspace来管理多个项目。</li>\n<li>把个人项目的<code>swift文件</code>关联到<code>Cocoa touch Framework</code>项目的<code>target</code>中：<br> 详细设置：选中target -&gt; build phases -&gt; compiles sources -&gt;点击 + 加号，选中原项目中的swift</li>\n<li>在<code>build</code>选项中选中Framework的scheme进行编译 ,要保证framework的target配置：<code>build setting -&gt; build active architecture Only -&gt;debug</code>选项设置为<code>YES</code></li>\n<li>打开playground文件 import Framework名称，此时即可使用Framework中的提供的public API方法了。<br>Workspace相关设置，build生成的目录：xcode偏好设置要和项目中的workspace中设置要保持一致.</li>\n<li>xcode的偏好设置中 -&gt;Locations -&gt; Locations -&gt;点击打开 Advanced…在弹出框中设置Unique选项.</li>\n<li>在workspace中选中菜单 File -&gt; workspace settings… -&gt; 在弹出框中设置为Unique选项.</li>\n</ol>\n<h3 id=\"导入cocopads管理的依赖库\"><a href=\"#导入cocopads管理的依赖库\" class=\"headerlink\" title=\"导入cocopads管理的依赖库\"></a>导入cocopads管理的依赖库</h3><p>xcode7.3.1和cocoapods1.0版本导致playground无法import相关动态库<br>解决办法：<a href=\"http://stackoverflow.com/questions/38216238/xcode-playground-with-cocoapods#\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/38216238/xcode-playground-with-cocoapods#</a><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#在写入磁盘之前，修改一些工程的配置:</span></span><br><span class=\"line\">post_install <span class=\"keyword\">do</span> |installer|</span><br><span class=\"line\">    installer.pods_project.targets.each <span class=\"keyword\">do</span> |target|</span><br><span class=\"line\">        <span class=\"keyword\">if</span> target.name != <span class=\"string\">'CocoaAsyncSocket'</span></span><br><span class=\"line\">            <span class=\"comment\">#playground相关配置，会导致'GCDAsyncSocket.h' file not found</span></span><br><span class=\"line\">            target.build_configurations.each <span class=\"keyword\">do</span> |config|</span><br><span class=\"line\">                config.build_settings[<span class=\"string\">'CONFIGURATION_BUILD_DIR'</span>] = <span class=\"string\">'$PODS_CONFIGURATION_BUILD_DIR'</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">#Use Legacy Swift Language Version” (SWIFT_VERSION):</span></span><br><span class=\"line\">                <span class=\"comment\">#   https://github.com/CocoaPods/CocoaPods/issues/5864#issuecomment-247109685</span></span><br><span class=\"line\">                puts <span class=\"string\">\"SWIFT_VERSIION:\"</span></span><br><span class=\"line\">                config.build_settings[<span class=\"string\">'SWIFT_VERSION'</span>] = <span class=\"string\">\"3.0.1\"</span></span><br><span class=\"line\">                puts config.build_settings[<span class=\"string\">'SWIFT_VERSION'</span>]</span><br><span class=\"line\">            end</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"comment\">#输出操作</span></span><br><span class=\"line\">            puts <span class=\"string\">\"以下不能在playground中使用的库名：\"</span></span><br><span class=\"line\">            puts target.name</span><br><span class=\"line\">        end</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Playground沙盒Resources\"><a href=\"#Playground沙盒Resources\" class=\"headerlink\" title=\"Playground沙盒Resources\"></a>Playground沙盒Resources</h2><p>Playgrounds 有两个与相关的Resources关联起来：一个是每一个独立的 playground 本地的，另一个则是 playground 之间共享的。在你的实验过程中，Playgrounds 能够支持 XML，JSON 数据，XIB，和图像文件。这也增加了其使用可用性。</p>\n<h2 id=\"本地-bundle访问本地资源\"><a href=\"#本地-bundle访问本地资源\" class=\"headerlink\" title=\"本地 bundle访问本地资源\"></a>本地 bundle访问本地资源</h2><p>Resources 文件夹, 与 Sources 文件夹一样在 Playground 的包路径中, 通过 Project Navigator 就可见了——只需要简单的拖拽图像和数据文件，就可以在 Playground 中使用了。对应的内容在 main bundle 中也是可见的。比如，我们可以像这样非常快捷的加载一个包含天气数据的 JSON 文件：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> jsonPath = <span class=\"type\">NSBundle</span>.mainBundle().bundlePath.stringByAppendingPathComponent(<span class=\"string\">\"weather.json\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span></span><br><span class=\"line\">jsonData = <span class=\"type\">NSData</span>(contentsOfFile: jsonPath),</span><br><span class=\"line\">json = <span class=\"type\">NSJSONSerialization</span>.<span class=\"type\">JSONObjectWithData</span>(jsonData, options: <span class=\"literal\">nil</span>, error: <span class=\"literal\">nil</span>) <span class=\"keyword\">as</span>? [<span class=\"type\">String</span>: <span class=\"type\">AnyObject</span>] </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"共享-访问Documents共享目录\"><a href=\"#共享-访问Documents共享目录\" class=\"headerlink\" title=\"共享 访问Documents共享目录\"></a>共享 访问Documents共享目录</h2><p>“共享 Playground 数据”的内容在你的”Documents”文件夹路径下，也同样对于你创建的任何 Playground 都可见。我们通过XCPSharedDataDirectoryPath常量来访问该共享文件夹。</p>\n<p>如果你自习想尝试，需要在 “~/Documents/Shared Playground Data” 下简历一个文件夹。 这里我们尝试载入一个名字叫做 “image.png” 的图片文件:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sharedImagePath = <span class=\"type\">XCPSharedDataDirectoryPath</span>.stringByAppendingPathComponent(<span class=\"string\">\"image.png\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> image = <span class=\"type\">UIImage</span>(contentsOfFile: sharedImagePath) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"PlaygroundSupport\"><a href=\"#PlaygroundSupport\" class=\"headerlink\" title=\"PlaygroundSupport\"></a>PlaygroundSupport</h2><h3 id=\"liveView视图代理\"><a href=\"#liveView视图代理\" class=\"headerlink\" title=\"liveView视图代理\"></a>liveView视图代理</h3><p>实现在playground中实现UI显示及交互操作<br>liveView定义：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> liveView: <span class=\"type\">XCPlaygroundLiveViewable</span>?</span><br></pre></td></tr></table></figure><br>遵循了<code>XCPlaygroundLiveViewable</code>协议即可在playground中可视化显示：</p>\n<ol>\n<li>在iOS 和 tvOS中<code>UIView</code> and <code>UIViewController</code>遵循该协议</li>\n<li>在OS X中<code>NSView</code> and <code>NSViewController</code>遵循该协议</li>\n<li>用户自定类型，须遵守XCPlaygroundLiveViewable协议<br>总之，只要遵守改协议并实现代理方法，都可以在playground中可视化显示。<br>用法：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.liveView = <span class=\"type\">UIView</span>()／<span class=\"type\">NSViewController</span>()</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"捕获值（XCPCaptureValue在XCPlayground中过时）\"><a href=\"#捕获值（XCPCaptureValue在XCPlayground中过时）\" class=\"headerlink\" title=\"捕获值（XCPCaptureValue在XCPlayground中过时）\"></a>捕获值（XCPCaptureValue在XCPlayground中过时）</h3><p><a href=\"http://swifter.tips/playground-capture/\" target=\"_blank\" rel=\"noopener\">冒泡排序可视化预览</a><br><figure class=\"highlight swift\"><figcaption><span>XCPlayground Module</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// This function has been deprecated.</span></span><br><span class=\"line\"><span class=\"meta\">@available</span>(*, deprecated)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">XCPCaptureValue</span>&lt;T&gt;<span class=\"params\">(identifier: String, value: T)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>简介：可以多次调用该方法来做图，相同的 identifier 的数据将会出现在同一张图上，而 value 将根据输入的次序进行排列,将一组数据轻而易举地绘制到时间轴上，从而让我们能看到每一步的结果。这不仅对我们直观且及时地了解算法内部的变化很有帮助，也会是教学或者演示时候的神兵利器。</p>\n<ol>\n<li>使用：导入框架<code>import XCPlayground</code></li>\n<li>扩展：XCPCaptureValue 的数据输入是任意类型的，所以不论是传什么进去都是可以表示的。它们将以 QuickLook 预览的方式被表现出来，一些像 UIImage，UIColor 或者 UIBezierPath 这样的类型已经实现了 QuickLook。当然对于那些没有实现快速预览的 NSObject 子类，也可以通过重写</li>\n</ol>\n<p>一个 Playground 通常立即显示简单表达式的结果。数组，字符串，数字等等，会在结果面板把计算后的结果显示出来。那么，随着时间改变的值是如何处理的呢？</p>\n<p>通过使用 XCPCaptureValue() 函数，我们可以随着一系列的迭代建立一个变动值的图。回到我们上面提到的天气例子，让我们来看看按小时计的温度数据，使用 XCPCaptureValue 来在辅助编辑界面以时间线的方式显示 温度的值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> XCPlayground</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> forecast <span class=\"keyword\">in</span> forecasts </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> tempString = forecast[<span class=\"string\">\"temp\"</span>]?[<span class=\"string\">\"english\"</span>] <span class=\"keyword\">as</span>? <span class=\"type\">String</span>, temperature = tempString.toInt()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">XCPCaptureValue</span>(<span class=\"string\">\"Temperature\"</span>, temperature)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另一种可选的方式是, 选择 Editor → Show Result For Current Line 就会捕获当前线的数值并且直接以图表的形势显示在 Playground 流中：</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcplayground-capture.png?imageMogr2/2/w/800\">\n<h3 id=\"异步执行（Asynchronous-Execution）\"><a href=\"#异步执行（Asynchronous-Execution）\" class=\"headerlink\" title=\"异步执行（Asynchronous Execution）\"></a>异步执行（Asynchronous Execution）</h3><p>不同于大部分 Swift 代码，是作为框架或者应用的一部分，Playgrounds 被当做是 高级代码。Playground 中的高级代码是按照指令接着指令的顺序从上到下执行的。<br>这种无容器风格的代码执行提供了立即反馈，但是存在着一个问题：在执行到了 Playground 底部后，会立即停止。网络请求，计时器，以及长时间运行的后台队列都会在提供反馈成功或者失败之前被立即终止。<br><code>PlaygroundSupport</code> 模块包含一个能够延长该过程的函数：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> needsIndefiniteExecution: <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>开启异步：默认值为<code>false</code>,当使用liveView代理时，会自动设置为<code>true</code>。当为<code>true</code>时，在高级代码执行完成后，会告诉Xcode继续运行Playground页面。为<code>false</code>时，当代码执行完直接终止。</li>\n<li>手动终止：还可以使用<code>PlaygroundPage.finishExecution()</code>手动终止正在运行的Playground。</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> PlaygroundSupport</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.needsIndefiniteExecution = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> url = <span class=\"type\">NSURL</span>(string: <span class=\"string\">\"http://httpbin.org/image/png\"</span>)!</span><br><span class=\"line\"><span class=\"keyword\">let</span> task = <span class=\"type\">NSURLSession</span>.sharedSession().dataTaskWithURL(url) &#123;</span><br><span class=\"line\">    data, <span class=\"number\">_</span>, <span class=\"number\">_</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> image = <span class=\"type\">UIImage</span>(data: data)</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//手动终止</span></span><br><span class=\"line\">        <span class=\"type\">PlaygroundPage</span>.current.currentPage.finishExecution()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">task.resume()</span><br></pre></td></tr></table></figure>\n<h2 id=\"支持Markdown格式的文档\"><a href=\"#支持Markdown格式的文档\" class=\"headerlink\" title=\"支持Markdown格式的文档\"></a>支持Markdown格式的文档</h2><p><a href=\"https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>除了实验用途，Playgrounds 在展示 Swift 语言的工具和框架中也一样强大。特别文档部分可以作为丰富格式的方式展示出来，以提供对于代码的清晰解释从而展示某个技术或者正确使用某个 Library 的方式。</p>\n<p>不同于<a href=\"http://nshipster.cn/swift-documentation/\" target=\"_blank\" rel=\"noopener\">Swift代码中的注释文档语法</a>, <code>Swift Playgrounds</code> 使用 <code>Markdown</code> 来显示多格式的文档。<br>例如：<br><code>//:</code>：可以指定单行文本说明<br><code>/*: Markdown格式内容... */</code>：可以用<code>Markdown</code>格式来显示丰富的文档内容</p>\n<p><code>xcode</code>切换备注以<code>Markdown</code>格式显示：</p>\n<ol>\n<li>选择<code>Editor → Show Rendered Markup</code> 菜单</li>\n<li>在 <code>File Inspector (⌘⌥1)</code> 选中 <code>Render Documentation</code> 复选框。<blockquote>\n<p>在xcode8中打开之前版本时，菜单上的<code>Show Rendered Markup</code>会显示为<code>Upgrade playgound...</code>升级菜单项，这样就需要先点击升级菜单项之后，才能激活上述（1）（2）设置项。</p>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//: This line will have **bold** and *italic* text.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*:</span></span><br><span class=\"line\"><span class=\"comment\">## Headers of All Sizes</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">### Lists of Links</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">- [NSHipster](http://nshipster.com)</span></span><br><span class=\"line\"><span class=\"comment\">- [ASCIIwwdc](http://asciiwwdc.com)</span></span><br><span class=\"line\"><span class=\"comment\">- [SwiftDoc](http://swiftdoc.org)</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">### Images, Too</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">![Remote Image](http://nshipster.s3.amazonaws.com/alert.gif)</span></span><br><span class=\"line\"><span class=\"comment\">![Local Image](bomb.gif) </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*Images in the Resources directory can be referenced locally*</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcplayground-documentation.png?imageMogr2/2/w/800\">\n<p>Playgrounds 提供了一个我们关于分享和学习 OS X 和 iOS 相关工具的方式的重大改变。Playground 可以展示每一个特性，并且为将来的用户探索和发现你创建的库提供了空间。丢掉你的静态README.md， 换成可互动的README.playground吧，再玩起来！</p>\n","raw":null,"categories":[{"name":"swift","path":"api/categories/swift.json"},{"name":"playground","path":"api/categories/playground.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"测试","path":"api/tags/测试.json"}]},{"title":"高期望实现异步单元测试","slug":"测试/高期望实现异步单元测试","date":"2017-02-20T23:09:30.000Z","updated":"2017-05-26T11:03:05.000Z","comments":true,"path":"api/articles/测试/高期望实现异步单元测试.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"异步单元测试\"><a href=\"#异步单元测试\" class=\"headerlink\" title=\"异步单元测试\"></a>异步单元测试</h2><p>在Xcode 6之前的版本里面并没有内置<code>XCTest</code>，只能是在主线程的<code>RunLoop</code>里面使用一个<code>while循环</code>,然后一直等待响应或者直到<code>timeout</code>.</p>\n<p>在Xcode 6里，苹果以<code>XCTestExpection类</code>的方式向<code>XCTest框架</code>里添加了<code>测试期望</code>(test expection)。<br>XCTest框架中相关的方法：设置期望，实现期望，通知期望，谓词计算期望等，以及期望的传递。</p>\n<h3 id=\"常规实现方式\"><a href=\"#常规实现方式\" class=\"headerlink\" title=\"常规实现方式\"></a>常规实现方式</h3><p>在主线程里，使用<code>while循环</code>每隔10毫秒会执行一次，直到有响应或者5秒之后超出响应时间限制才会跳出：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testAsyncTheOldWay</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timeoutDate = <span class=\"type\">Date</span>.<span class=\"keyword\">init</span>(timeIntervalSinceNow: <span class=\"number\">5.0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> responseHasArrived = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"type\">Alamofire</span>.request(<span class=\"string\">\"https://www.baidu.com\"</span>).responseData&#123;response <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"获取到的数据长度：\\(String(data: response.data!, </span></span><br><span class=\"line\"><span class=\"string\">                                   encoding:String.Encoding.utf8)!)\"</span>)</span><br><span class=\"line\">        responseHasArrived = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"type\">XCTAssert</span>((response.data?.<span class=\"built_in\">count</span>)! &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (responseHasArrived == <span class=\"literal\">false</span> </span><br><span class=\"line\">            &amp;&amp; (timeoutDate.timeIntervalSinceNow &gt; <span class=\"number\">0</span>)) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">CFRunLoopRunInMode</span>(<span class=\"type\">CFRunLoopMode</span>.defaultMode, <span class=\"number\">0.01</span>, <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (responseHasArrived == <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">XCTFail</span>(<span class=\"string\">\"Test timed out\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"XCTest相关API\"><a href=\"#XCTest相关API\" class=\"headerlink\" title=\"XCTest相关API\"></a>XCTest相关API</h2><p>在Xcode 6里，苹果以<code>XCTestExpection类</code>的方式向<code>XCTest框架</code>里添加了<code>测试期望</code>(test expection)。</p>\n<h3 id=\"XCTestExpection-高期望-High-Expectations-的实现和使用\"><a href=\"#XCTestExpection-高期望-High-Expectations-的实现和使用\" class=\"headerlink\" title=\"XCTestExpection:高期望(High Expectations)的实现和使用\"></a>XCTestExpection:高期望(High Expectations)的实现和使用</h3><p>设置期望，实现期望，通知期望，谓词计算期望等，以及期望的传递。</p>\n<h4 id=\"expectation-description-为XCTest测试单元设置期望\"><a href=\"#expectation-description-为XCTest测试单元设置期望\" class=\"headerlink\" title=\"expectation(description:):为XCTest测试单元设置期望\"></a><code>expectation(description:)</code>:为XCTest测试单元设置期望</h4><p>为XCTest单元测试，设置一个测试期望以及错误信息描述，并在某一时刻<code>fulfill</code>实现该期望对象<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//expectation(description: String) -&gt; XCTestExpectation</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> expection = expectation(description: <span class=\"string\">\"失败时显示原因\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"fulfill-调用它表示测试达到期望值\"><a href=\"#fulfill-调用它表示测试达到期望值\" class=\"headerlink\" title=\"fulfill():调用它表示测试达到期望值\"></a><code>fulfill()</code>:调用它表示测试达到期望值</h5><p>一般在单元测试通过时调用，告知测试已达期望，这一方法替代了<code>responseHasArrived</code>作为Flag的方式<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//- (void)fulfill;</span></span><br><span class=\"line\">expection.fulfill()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"waitForExpectations-timeout-handler-在方法底部设置测试期望的时效\"><a href=\"#waitForExpectations-timeout-handler-在方法底部设置测试期望的时效\" class=\"headerlink\" title=\"waitForExpectations(timeout:handler:):在方法底部设置测试期望的时效\"></a><code>waitForExpectations(timeout:handler:)</code>:在方法底部设置测试期望的时效</h4><p>在方法底部指定一个超时，如果测试条件不适合时间范围便会结束执行<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// open func waitForExpectations(timeout: TimeInterval, handler: XCTest.XCWaitCompletionHandler? = nil)</span></span><br><span class=\"line\">waitForExpectations(timeout: <span class=\"number\">5</span>) &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"错误信息:\\(error?.localizedDescription)\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如果完成处理的代码在指定时限里执行并调用了<code>fulfill()</code>方法，那么就说明所有的测试期望在此期间都已经被实现。否则就测试就被打断不再执行</p>\n<h4 id=\"expectation-forNotification-object-handler-通知期望\"><a href=\"#expectation-forNotification-object-handler-通知期望\" class=\"headerlink\" title=\"expectation(forNotification:object:handler:):通知期望\"></a>expectation(forNotification:object:handler:):通知期望</h4><p>该方法监听一个通知,如果在规定时间内正确收到通知则测试通过<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//expectation(forNotification notificationName: String, object objectToObserve: Any?, handler: XCTest.XCNotificationExpectationHandler? = nil) -&gt; XCTestExpectation</span></span><br><span class=\"line\"><span class=\"comment\">//设置一个测试通知期望</span></span><br><span class=\"line\">expectation(forNotification: <span class=\"string\">\"BLDownloadImageNotification\"</span>, </span><br><span class=\"line\">                     object: <span class=\"literal\">nil</span>) </span><br><span class=\"line\">&#123;(notification) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> userInfo = notification.userInfo <span class=\"keyword\">as</span>! [<span class=\"type\">String</span>:<span class=\"type\">String</span>]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name = userInfo[<span class=\"string\">\"name\"</span>]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"name:\\(name)\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">来定义一个通知并发送通知，来测试：</span><br><span class=\"line\"><span class=\"keyword\">let</span> notif =  <span class=\"type\">Notification</span>.<span class=\"type\">Name</span>(rawValue: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\"><span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.post(name: notif, object: <span class=\"keyword\">self</span>, userInfo: [<span class=\"string\">\"name\"</span>:<span class=\"string\">\"huosan\"</span>,<span class=\"string\">\"sex\"</span>:<span class=\"string\">\"man\"</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置延迟多少秒后，如果没有满足测试条件就报错</span></span><br><span class=\"line\">waitForExpectations(timeout: <span class=\"number\">3</span>, handler: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"使用expectation-description-实现\"><a href=\"#使用expectation-description-实现\" class=\"headerlink\" title=\"使用expectation(description:)实现\"></a>使用<code>expectation(description:)</code>实现</h5><p>帮助理解 <code>expectation(forNotification:object:handler:)</code> 方法和 <code>expectation(description:)</code> 的区别<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testAsynForNotificationWithExpectation</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> expectation = <span class=\"keyword\">self</span>.expectation(description: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> notif = <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>(rawValue: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sub = <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(forName: notif, object: <span class=\"literal\">nil</span>, queue: <span class=\"literal\">nil</span>) &#123; (notification) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        expectation.fulfill()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//发送一个通知</span></span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.post(name: notif, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//waitForExpectations</span></span><br><span class=\"line\">    waitForExpectations(timeout: <span class=\"number\">1</span>, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//移除通知</span></span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.removeObserver(sub)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"expectation-for-evaluatedWith-handler-谓词计算测试法\"><a href=\"#expectation-for-evaluatedWith-handler-谓词计算测试法\" class=\"headerlink\" title=\"expectation(for:evaluatedWith:handler:):谓词计算测试法\"></a>expectation(for:evaluatedWith:handler:):谓词计算测试法</h4><p>利用谓词计算，判断<code>button</code>的<code>backgroundImageForState</code>方法，是否正确的获得了<code>backgroundImage</code>，如果<code>20秒</code>内正确获得则通过测试，否则失败<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//open func expectation(for predicate: NSPredicate, evaluatedWith object: Any, handler: XCTest.XCPredicateExpectationHandler? = nil) -&gt; XCTestExpectation</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testThatBackgroundImageChanges</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> viewController = <span class=\"type\">OnclickLikeViewController</span>()</span><br><span class=\"line\">    <span class=\"comment\">//viewController.loadView()  //不执行viewDidload方法</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"number\">_</span> = viewController.view</span><br><span class=\"line\">    <span class=\"keyword\">let</span> button = viewController.button</span><br><span class=\"line\">    <span class=\"keyword\">let</span> img = button.backgroundImage(<span class=\"keyword\">for</span>: .normal)</span><br><span class=\"line\">    <span class=\"type\">XCTAssertNil</span>(img,<span class=\"string\">\"此时img不为nil,中止执行\"</span>)  <span class=\"comment\">//当img不是nil时，执行断言</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> predicate = <span class=\"type\">NSPredicate</span>.<span class=\"keyword\">init</span> &#123; (anyobject, bindings) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> button = anyobject <span class=\"keyword\">as</span>! <span class=\"type\">UIButton</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> button.backgroundImage(<span class=\"keyword\">for</span>: <span class=\"type\">UIControlState</span>()) != <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    expectation(<span class=\"keyword\">for</span>: predicate, evaluatedWith: button, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    waitForExpectations(timeout: <span class=\"number\">20</span>, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"使用expectation-description-实现-1\"><a href=\"#使用expectation-description-实现-1\" class=\"headerlink\" title=\"使用expectation(description:)实现\"></a>使用<code>expectation(description:)</code>实现</h5><p>帮助理解 <code>expectation(for:evaluatedWith:handler:)</code> 方法和 <code>expectation(description:)</code> 的区别<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testThatBackgroundImageChanges</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//设置期望</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> expectation = <span class=\"keyword\">self</span>.expectation(description: <span class=\"string\">\"backgroundImageForState\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> viewController = <span class=\"type\">OnclickLikeViewController</span>()</span><br><span class=\"line\">    <span class=\"comment\">//viewController.loadView()  //不执行viewDidload方法</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"number\">_</span> = viewController.view</span><br><span class=\"line\">    <span class=\"keyword\">let</span> button = viewController.button</span><br><span class=\"line\">    <span class=\"keyword\">let</span> img = button.backgroundImage(<span class=\"keyword\">for</span>: .normal)</span><br><span class=\"line\">    <span class=\"type\">XCTAssertNil</span>(img,<span class=\"string\">\"此时img不为nil,中止执行\"</span>)  <span class=\"comment\">//当img不是nil时，执行断言</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> predicate = <span class=\"type\">NSPredicate</span>.<span class=\"keyword\">init</span> &#123; (anyobject, bindings) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> button = anyobject <span class=\"keyword\">as</span>! <span class=\"type\">UIButton</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> button.backgroundImage(<span class=\"keyword\">for</span>: <span class=\"type\">UIControlState</span>()) != <span class=\"literal\">nil</span></span><br><span class=\"line\">        <span class=\"comment\">//实现测试期望</span></span><br><span class=\"line\">        expectation.fulfill()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//等待期望实现</span></span><br><span class=\"line\">    waitForExpectations(timeout: <span class=\"number\">20</span>, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传递expectation在目的方法中再fulfill-实现期望\"><a href=\"#传递expectation在目的方法中再fulfill-实现期望\" class=\"headerlink\" title=\"传递expectation在目的方法中再fulfill()实现期望\"></a>传递expectation在目的方法中再fulfill()实现期望</h3><p>例如将期望封装在字典中，通过通知来传递给异步下载的方法中调用该期望的<code>fulfill()</code>方法，实现单元测试的期望<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*/</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testAsynForNotificationWithExpectation2</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> expectation = <span class=\"keyword\">self</span>.expectation(description: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> notif = <span class=\"type\">Notification</span>.<span class=\"type\">Name</span>(rawValue: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(<span class=\"keyword\">self</span>, selector: #selector(<span class=\"type\">AsyncTheOldWayTest</span>.downLoadImage(<span class=\"number\">_</span>:)), name: notif, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//将期望封装在字典中传递</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> userInf = [<span class=\"string\">\"name\"</span>:<span class=\"string\">\"huosan\"</span>,<span class=\"string\">\"sex\"</span>:<span class=\"string\">\"man\"</span>,<span class=\"string\">\"expectation\"</span>:expectation]</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.post(name: notif, object: <span class=\"keyword\">self</span>, userInfo: userInf)</span><br><span class=\"line\">        <span class=\"comment\">//等待期望实现</span></span><br><span class=\"line\">        waitForExpectations(timeout: <span class=\"number\">1</span>, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.removeObserver(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">downLoadImage</span><span class=\"params\">(<span class=\"number\">_</span> notification:Notification)</span></span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> userInfo = notification.userInfo <span class=\"keyword\">as</span>! [<span class=\"type\">String</span>:<span class=\"type\">AnyObject</span>]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> name = userInfo[<span class=\"string\">\"name\"</span>]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> sex = userInfo[<span class=\"string\">\"sex\"</span>]</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"name:\\(name), sex = \\(sex)\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> expectation = userInfo[<span class=\"string\">\"expectation\"</span>] <span class=\"keyword\">as</span>! <span class=\"type\">XCTestExpectation</span></span><br><span class=\"line\">        expectation.fulfill()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"测试","path":"api/categories/测试.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"单元测试","path":"api/tags/单元测试.json"}]},{"title":"UI自动测试开发相关API","slug":"测试/UI自动测试学习","date":"2017-02-20T17:16:49.000Z","updated":"2017-05-26T11:03:05.000Z","comments":true,"path":"api/articles/测试/UI自动测试学习.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/XCUIElementAttributes.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"UI-Testing-和-Accessibility\"><a href=\"#UI-Testing-和-Accessibility\" class=\"headerlink\" title=\"UI Testing 和 Accessibility\"></a>UI Testing 和 Accessibility</h2><p>UI Accessibility 早在 iOS 3.0 就被引入了，用来辅助身体不便的人士使用 app。VoiceOver 是 Apple 的屏幕阅读技术，而 UI Accessibility 的基本原则就是对屏幕上的 UI 元素进行分类和标记。两者配合，通过阅读或者聆听这些元素，用户就可以在不接触屏幕的情况下通过声音来使用 app。</p>\n<p>Accessibility 的核心思想是对 UI 元素进行分类和标记 – 将屏幕上的 UI 分类为像是按钮，文本框，cell 或者是静态文本 (也就是 label) 这样的类型，然后使用 identifier 来区分不同的 UI 元素。用户可以通过语音控制 app 的按钮点击，或是询问某个 label 的内容等等，十分方便。iOS SDK 中的控件都实现了默认的 Accessibility 支持，而我们如果使用自定义的控件的话，则需要自行使用 Accessibility 的 API 来进行添加。</p>\n<h2 id=\"UI-Testing-API\"><a href=\"#UI-Testing-API\" class=\"headerlink\" title=\"UI Testing API\"></a>UI Testing API</h2><h3 id=\"XCUIApplication-获取APP实例\"><a href=\"#XCUIApplication-获取APP实例\" class=\"headerlink\" title=\"XCUIApplication()获取APP实例\"></a>XCUIApplication()获取APP实例</h3><p><code>XCUIApplication()</code>继承<code>XCUIElement</code>，这个类掌管应用程序的生命周期，里面包含两个主要方法<br><code>launch():</code>启动程序<br><code>terminate():</code>终止程序</p>\n<h3 id=\"获取XCUIElementQuery对象的四种方式\"><a href=\"#获取XCUIElementQuery对象的四种方式\" class=\"headerlink\" title=\"获取XCUIElementQuery对象的四种方式\"></a>获取<code>XCUIElementQuery</code>对象的四种方式</h3><h4 id=\"第一种简写形式：buttons-gt-XCUIElementQuery\"><a href=\"#第一种简写形式：buttons-gt-XCUIElementQuery\" class=\"headerlink\" title=\"第一种简写形式：buttons-&gt;XCUIElementQuery\"></a>第一种简写形式：<code>buttons-&gt;XCUIElementQuery</code></h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttons:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().buttons</span><br><span class=\"line\"><span class=\"keyword\">let</span> textFields:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().textFields</span><br></pre></td></tr></table></figure>\n<h4 id=\"三种通过XCUIElementType的枚举值\"><a href=\"#三种通过XCUIElementType的枚举值\" class=\"headerlink\" title=\"三种通过XCUIElementType的枚举值\"></a>三种通过<code>XCUIElementType</code>的枚举值</h4><p>通过<code>XCUIElementType</code>的枚举值来获取<code>XCUIElementQuery</code>对象，其中第二种是简写方式。<br><code>XCUIElementType</code>枚举声明如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">XCUIElementType</span> : <span class=\"title\">UInt</span> </span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">case</span> button</span><br><span class=\"line\">    <span class=\"keyword\">case</span> radioButton</span><br><span class=\"line\">    <span class=\"keyword\">case</span> textField</span><br><span class=\"line\">    <span class=\"keyword\">case</span> comboBox</span><br><span class=\"line\">    <span class=\"keyword\">case</span> menuButton</span><br><span class=\"line\">    <span class=\"keyword\">case</span> toolbarButton</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"第一种获取所有的元素：descendantsMatchingType-gt-XCUIElementQuery\"><a href=\"#第一种获取所有的元素：descendantsMatchingType-gt-XCUIElementQuery\" class=\"headerlink\" title=\"第一种获取所有的元素：descendantsMatchingType-&gt;XCUIElementQuery\"></a>第一种获取所有的元素：<code>descendantsMatchingType-&gt;XCUIElementQuery</code></h5><p>取某种类型的元素以及它的子类集合，能获取到系统级控件如<code>UIButton</code>，和用户自定义的UI控件<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttons:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().descendantsMatchingType(.<span class=\"type\">Button</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> textFields:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().descendantsMatchingType(.textField)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"第三种仅获取当前层级子元素：childrenMatchingType\"><a href=\"#第三种仅获取当前层级子元素：childrenMatchingType\" class=\"headerlink\" title=\"第三种仅获取当前层级子元素：childrenMatchingType\"></a>第三种仅获取当前层级子元素：<code>childrenMatchingType</code></h5><p>取某种类型的元素集合，不包含它的子类，即仅获取系统级控件如<code>UIButton</code>，不获取用户自定义的UI控件<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttons:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().childrenMatchingType(.<span class=\"type\">Button</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> textFields:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().childrenMatchingType(.textField)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"第四种所有包含的元素：containingType\"><a href=\"#第四种所有包含的元素：containingType\" class=\"headerlink\" title=\"第四种所有包含的元素：containingType\"></a>第四种所有包含的元素：<code>containingType</code></h5><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttons:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().containingType(.<span class=\"type\">Button</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> textFields:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().containingType(.textField)</span><br></pre></td></tr></table></figure>\n<h3 id=\"XCUIElement表示系统的各种UI控件\"><a href=\"#XCUIElement表示系统的各种UI控件\" class=\"headerlink\" title=\"XCUIElement表示系统的各种UI控件\"></a>XCUIElement表示系统的各种UI控件</h3><p><code>XCUIElement</code>UI控件在测试框架中的代理，继承<code>NSObject</code>，实现<code>XCUIElementAttributes</code>协议, <code>XCUIElementTypeQueryProvider</code>协议，可以表示系统的各种UI控件。</p>\n<ol>\n<li>XCUIElementAttributes协议：里面包含了UIAccessibility中的部分属性<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/XCUIElementAttributes.png?imageMogr2/2/w/800\">\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/UIAccessibility.jpg?imageMogr2/2/w/800\"></li>\n<li>XCUIElementTypeQueryProvider协议：包含了系统中大部分UI控件的类型，可通过读属性的方式取得某种类型的UI集合<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/XCUIElementTypeQueryProvider.png?imageMogr2/2/w/800\">\n</li>\n</ol>\n<h4 id=\"访问UI控件\"><a href=\"#访问UI控件\" class=\"headerlink\" title=\"访问UI控件\"></a>访问UI控件</h4><ol>\n<li><code>exist:</code>判断当前的UI元素是否存在，如果对一个不存在的元素进行操作，会导致测试组件抛出异常并中断测试.</li>\n<li><code>element()</code>／<code>下标方法</code>：<code>XCUIElementQuery</code>实例的方法获取UI控件，不能直接通过<code>XCUIElement</code> 来访问 app 中的元素，只能通过 <code>Accessibility</code> 中的像是 <code>identifier</code> 或者 <code>frame</code> 这样的属性来获取 UI 的信息。<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> userNameTextField:<span class=\"type\">XCUIElement</span> = app.textFields.element(boundBy: <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> userNameTextField:<span class=\"type\">XCUIElement</span> = app.textFields[<span class=\"string\">\"username\"</span>]</span><br></pre></td></tr></table></figure>\n对于 <code>XCUIElementQuery</code>，<code>Query</code>的执行是有延迟的，它和最后我们得到的 <code>XCUIElement</code> 并不是一一对应的。和 <code>NSURL</code> 与请求到的内容的关系类似，随着时间的变化，同一个 <code>URL</code> 有可能请求到不同的内容。<br>在拿到<code>Query</code>实例后，只有在通过<code>下标</code>或<code>访问方法</code>访问时，才会真正寻找对应的 <code>UI 控件</code>。这就是说，随着我们的 UI 的变化，同样的 <code>query</code> 也可能获取到不用的<code>UI控件</code>。为了获取UI元素准确：我们可以通过在 <code>Interface Builder</code> 或者<code>代码</code>中，对UI控件的 <code>identifier</code>属性进行设置，这样就可以使用下标的方式进行访问了。</li>\n</ol>\n<h4 id=\"设置UI控件触发事件和属性值\"><a href=\"#设置UI控件触发事件和属性值\" class=\"headerlink\" title=\"设置UI控件触发事件和属性值\"></a>设置UI控件<code>触发事件</code>和<code>属性值</code></h4><p>使用<code>typeText(text:String)</code>,<code>tap()</code>,<code>doubleTap()</code>等方法。<br>以获取userNameTextField控件为例：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> userNameTextField:<span class=\"type\">XCUIElement</span> = app.textFields.element(boundBy: <span class=\"number\">0</span>)</span><br><span class=\"line\">userNameTextField.tap()</span><br><span class=\"line\">userNameTextField.typeText(<span class=\"string\">\"文本内容\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"XCUIElementAttributes协议\"><a href=\"#XCUIElementAttributes协议\" class=\"headerlink\" title=\"XCUIElementAttributes协议\"></a>XCUIElementAttributes协议</h4><p>UI元素中包含的各个属性，<code>identifier</code>，<code>frame</code>,<code>title</code>,<code>label</code>等…</p>\n<ol>\n<li>使用: 可使用这些属性来获取UI元素对象。<figure class=\"highlight swift\"><figcaption><span>title获取</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> username = <span class=\"string\">\"hsg\"</span></span><br><span class=\"line\">userNameTextField.typeText(username)</span><br><span class=\"line\">app.textFields[username].tap()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><figcaption><span>identifier获取</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> identifier = <span class=\"string\">\"hsg\"</span></span><br><span class=\"line\">userNameTextField.typeText(username)</span><br><span class=\"line\">app.textFields[username].tap()</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"测试","path":"api/categories/测试.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"单元测试","path":"api/tags/单元测试.json"}]},{"title":"JavaScript自动化组件OC桥接","slug":"macOS/JavaScript自动化组件OC桥接","date":"2017-02-15T17:19:30.000Z","updated":"2017-02-16T13:43:01.000Z","comments":true,"path":"api/articles/macOS/JavaScript自动化组件OC桥接.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><a href=\"https://developer.apple.com/library/content/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/OSX10-10.html#//apple_ref/doc/uid/TP40014508-CH109-SW8\" target=\"_blank\" rel=\"noopener\">文档</a><br><code>JavaScript自动化</code>有一个内置的<code>Objective-C Bridge</code>，使您能够访问文件系统，创建Cocoa应用程序。<br><code>Objective-C Bridge</code>的主要接入点是全局属性<code>objc</code>和<code>$</code>。</p>\n<h2 id=\"Frameworks\"><a href=\"#Frameworks\" class=\"headerlink\" title=\"Frameworks\"></a>Frameworks</h2><p><code>Foundation framework</code>中的语法默认支持<code>JavaScript自动化</code>。也可以通过使用<code>ObjC.import()</code>方法导入其他Frameworks 和 libraries。<br>例如，使用<code>Cocoa框架</code>中的<code>NSBeep()</code>函数，需要导入<code>Cocoa框架</code><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjC.import(<span class=\"string\">'Cocoa'</span>)</span><br><span class=\"line\">$.NSBeep()</span><br></pre></td></tr></table></figure><br>除了系统框架之外，一些系统库的功能也被暴露出来。这个功能可以通过<code>头文件</code>的名称来暴漏出来（不带.h）<br>例如：<br>arpa/inet, asl, copyfile, dispatch, dyld, errno, getopt, glob, grp, ifaddrs, launch, membership, netdb, netinet/in, notify, objc, paths, pwd, readline, removefile, signal, spawn, sqlite3, stdio, stdlib, string, sys/fcntl, sys/file, sys/ioctl, sys/mount, sys/param, sys/resource, sys/socket, sys/stat, sys/sysctl, sys/time, sys/times, sys/types, sys/wait, sys/xattr, syslog, time, unistd, uuid/uuid, vImage, vecLib, vmnet, xpc, 和 zlib.<br>导入框架时，系统将参考桥接支持文件。除了内置的框架和库，您可以导入任何具有桥接支持的框架，只需要将完整路径传递给框架，如下示例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjC.import(<span class=\"string\">'/Library/Frameworks/Awesome.framework'</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>原始的<code>JavaScript数据类型</code>映射到<code>C数据类型</code>。例如，一个<code>JavaScript字符串</code>映射为<code>char *</code>，而<code>JavaScript整数</code>映射到<code>int</code>。使用<code>objc API</code>返回一个<code>char *</code>时，会得到一个<code>JS 字符串</code></p>\n<p>原始的<code>JavaScript数据类型</code>将被自动转换为<code>ObjC对象类型</code>，并能作为一个预期的对象类型的参数传递给ObjC方法。<br>例如，一个<code>JS字符串</code>将被转换为一个<code>NSString对象</code>如果是什么方法签名说应该是输入。</p>\n<blockquote>\n<p>注意，然而，ObjC方法返回的ObjC对象类型是不会自动转换为原始的JavaScript的数据类型。</p>\n</blockquote>\n<h2 id=\"实例化的类和调用方法\"><a href=\"#实例化的类和调用方法\" class=\"headerlink\" title=\"实例化的类和调用方法\"></a>实例化的类和调用方法</h2><p>所有类都定义为<code>$对象</code>的属性。ObjC对象的方法有两种方式调用，根据是否需要参数的方法。<br>如果ObjC方法不带参数，然后调用<code>JavaScript属性名</code>访问<code>属性值</code>。这个例子中实例化一个空的字符串。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = $.NSMutableString.alloc.init</span><br></pre></td></tr></table></figure><br>如果ObjC方法不带参数，根据<code>JSExport</code>规范来命名，通过JavaScript的方法调用（function-typed property）；<br>对于多参数的方法，Objective-C的方法每个部分都合并在一起，冒号后的字母变为大写并移除冒号。比如下边协议中的方法，在JavaScript调用就是：doFooWithBar(foo, bar);<br>这个例子说明<code>JavaScript字符串</code>转为<code>NSString</code>然后写入到一个文件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = $.NSString.alloc.initWithUTF8String(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\">str.writeToFileAtomically(<span class=\"string\">'/tmp/foo'</span>, <span class=\"literal\">true</span>)</span><br></pre></td></tr></table></figure></p>\n<p>如果你调用一个方法，如<code>-intValue</code>，返回<code>C数据类型</code>而不是一个对象，然后你会回到原始的<code>JavaScript数据类型</code>。<br>此示例返回原始的JavaScript的整数，99。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.NSNumber.numberWithInt(<span class=\"number\">99</span>).intValue</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"访问-ObjC-Properties\"><a href=\"#访问-ObjC-Properties\" class=\"headerlink\" title=\"访问 ObjC Properties\"></a>访问 ObjC Properties</h3><p><code>ObjC属性</code>也可以通过<code>JavaScript属性</code>来访问，很像调用无参数方法。<br>当一个<code>桥接对象属性</code>的被访问时，ObjC属性列表是第一参考，如果列表中存在该名称对应的属性，那么就调用相应属性的<code>getter</code>或<code>setter</code>选择器。如果该名称的ObjC属性不在类中属性的列表中，那么该属性名称就作为<code>方法选择器</code>来调用。<br>使用自定义<code>getter</code>名定义一个属性，你可以使用<code>属性</code>名 或 <code>getter</code>名，并得到相同的结果。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task = $.NSTask.alloc.init</span><br><span class=\"line\">task.running == task.isRunning</span><br></pre></td></tr></table></figure><br>另外，不同的参数方法，<code>桥接对象属性</code>映射到<code>ObjC属性</code>也可以设置为（read/write属性）。下面的两行定义了一个ObjC属性：<code>launchPath</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task.launchPath = <span class=\"string\">'/bin/sleep'</span></span><br><span class=\"line\">task.setLaunchPath(<span class=\"string\">'/bin/sleep'</span>)</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"JS","path":"api/categories/JS.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"混编","path":"api/tags/混编.json"}]},{"title":"Fabric对macOS系统的支持","slug":"macOS/Fabric对macOS系统的支持调研","date":"2017-02-14T11:14:35.000Z","updated":"2017-02-14T14:33:17.000Z","comments":true,"path":"api/articles/macOS/Fabric对macOS系统的支持调研.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"Fabric\"><a href=\"#Fabric\" class=\"headerlink\" title=\"Fabric\"></a>Fabric</h2><p><code>Fabric</code> 是Twitter的移动应用开发平台，一个模块化、跨平台的移动开发套件，该博文主要研究<code>crashlytics</code>在app中的运用。<br><a href=\"https://try.crashlytics.com/\" target=\"_blank\" rel=\"noopener\">注册新的账户</a>登录，审核通过时间为几个小时或者1到2天不等。然后注册时候输入的邮箱就会收到如下的邀请涵<br><a href=\"https://docs.fabric.io/apple/crashlytics/os-x.html#macos-support\" target=\"_blank\" rel=\"noopener\">浏览官方文档</a></p>\n<h3 id=\"crashlytics支持macOS\"><a href=\"#crashlytics支持macOS\" class=\"headerlink\" title=\"crashlytics支持macOS\"></a>crashlytics支持macOS</h3><p>对<code>macOS</code>的支持中出现的问题<br>问题：<code>NSApplicationCrashOnExceptions</code> is not set. This will result in poor <code>top-level</code> uncaught exception reporting<br>官方解释：<br><blockquote><p>Uncaught Exceptions<br>Intercepting and reporting uncaught exceptions on macOS is more complex than it is on iOS. On macOS, AppKit will catch exceptions thrown on the main thread, preventing the application from crashing, but also preventing Crashlytics from reporting them. To make matters worse, Apple’s frameworks are not exception safe. This means that while AppKit will prevent your app from crashing, it will also likely corrupt your process’s state, often including AppKit itself. Typically, once an exception involving UI interaction is thrown, it will prevent your app from working correctly from that moment on.<br>Thankfully, AppKit has a little-known feature you can turn on to make the behavior much more predictable. We strongly recommend that you do the following in your application, right before you initialize Crashlytics.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] registerDefaults:@&#123; <span class=\"string\">@”NSApplicationCrashOnExceptions”</span>: @YES &#125;];</span><br></pre></td></tr></table></figure>\n\n<p>This will make your application’s behavior much closer to iOS. It will mean that your app will crash on uncaught exceptions, and will also allow Crashlytics to report them with useful stack traces. It will also give you the ability to override this behavior with the user defaults system, even on per-user basis.<br>Of course, this is all optional. Crashlytics will warn about NSApplicationCrashOnExceptions not being set, but will otherwise preserve normal AppKit behavior by default.</p>\n<footer><strong>官方文档</strong><cite><a href=\"https://docs.fabric.io/apple/crashlytics/os-x.html#macos-support\" target=\"_blank\" rel=\"noopener\">macOS Support</a></cite></footer></blockquote><br>拦截和报告未捕获的异常在MacOS比iOS更复杂。在MacOS，AppKit会抓住扔在主线程异常，防止应用程序崩溃，也防止crashlytics报告他们。更糟糕的是，Apple’s frameworks也不例外。这意味着AppKit可以防止你的应用程序崩溃，也可能破坏你的进程的状态，包括AppKit本身。通常情况下，一旦涉及到用户界面交互的异常被抛出，它将阻止您的应用程序从正确的工作从那一刻起。<br>以上情况，可以通过设置：<code>NSApplicationCrashOnExceptions</code> 改变系统默认的值，达到像iOS端一样抓去异常。如果没有设置会提示：NSApplicationCrashOnExceptions not set</p>\n<h3 id=\"Cause-a-Test-Crash教程\"><a href=\"#Cause-a-Test-Crash教程\" class=\"headerlink\" title=\"Cause a Test Crash教程\"></a><a href=\"https://docs.fabric.io/apple/crashlytics/test-crash.html\" target=\"_blank\" rel=\"noopener\">Cause a Test Crash教程</a></h3><p>崩溃日志是在重启APP程序的同时进行的，要确保程序在前台全屏显示。<br>Xcode调试器会阻止我们捕捉崩溃报告，所以在抓取崩溃报告时，要保证在非调试状态下进行。如果你的移动设备连接到Mac机上，Xcode仍然可以进入调试状态。</p>\n<ol>\n<li><code>run</code>在模拟器上安装运行APP</li>\n<li>点击<code>Stop</code>断开Xcode和模拟器，确保在非调试状态</li>\n<li>在模拟器上启动APP，并执行崩溃操作</li>\n<li>在Xcode上点击<code>run</code><br>在Xcode的控制台console中输出显示奔溃报告，以及上传日志的相关提示。<br>macOS系统中的日志目录：<br>运行日志目录：/private/var/log/system.log<br>奔溃日志目录：/Users/pyc/Library/Logs/DiagnosticReports/APPNAME_2016-11-10-165115.crash</li>\n</ol>\n<blockquote><p>It’s possible, but rare, that we are missing a dSYM to symbolicate any crash reports. There will be an alert on your dashboard if this is the case. Click through to upload the missing dSYM. Keep in mind that exceptions are not guaranteed to crash. The full code path, including code in system libraries, matters here. If you aren’t seeing the dSYM alert, you can go to your app’s settings page, and append “/mappings” to the URL to reach it, e.g. <a href=\"https://fabric.io/settings/apps/some_app_id/mappings\" target=\"_blank\" rel=\"noopener\">https://fabric.io/settings/apps/some_app_id/mappings</a></p>\n<footer><strong>官方文档</strong><cite><a href=\"https://docs.fabric.io/apple/crashlytics/test-crash.html\" target=\"_blank\" rel=\"noopener\">Cause a Test Crash教程</a></cite></footer></blockquote>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"调试","path":"api/categories/调试.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"SDK","path":"api/tags/SDK.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"发布","path":"api/tags/发布.json"},{"name":"macOS","path":"api/tags/macOS.json"}]},{"title":"Crash文件分析方法","slug":"调试/Crash文件分析方法","date":"2017-02-07T12:38:58.000Z","updated":"2017-05-26T11:03:05.000Z","comments":true,"path":"api/articles/调试/Crash文件分析方法.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>第一步：在任意目录创建调试crash的目录</p>\n<p>第二步：将之前Archive的文件copy到crash目录里面,其中包括两个文件.app和.app.dSYM</p>\n<p>第三步：将symbolicatecrash工具copy到crash目录<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /Applications/Xcode.app -name symbolicatecrash -type f</span><br></pre></td></tr></table></figure></p>\n<p>2.用命令将symbolicatecrash拷贝到桌面的crash文件夹里面，与.app和.app.dSYM放一起<br>拷贝到crash目录：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /Applications/Xcode.app/.../symbolicatecrash /Users/Desktop/crash</span><br></pre></td></tr></table></figure></p>\n<p>第四步：执行symbolicatecrash<br>1.打开终端用命令切换到桌面的crash目录下：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /Users/你的电脑名称/Desktop/crash</span><br></pre></td></tr></table></figure></p>\n<p>2.执行命令<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./symbolicatecrash /Users/Desktop/crash/PBB.crash /Users/Desktop/crash/Control.app.dSYM &gt; Control_symbol.crash</span><br></pre></td></tr></table></figure></p>\n<p>这时候终端有可能会出现：<code>Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 60.</code></p>\n<p>3.输入命令：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> DEVELOPER_DIR=<span class=\"string\">\"/Applications/XCode.app/Contents/Developer\"</span></span><br></pre></td></tr></table></figure></p>\n<p>4.再执行 2.的命令行</p>\n<p>5.将终端完成以后，在crash文件夹里面会多出一个文件Control_symbol.crash。<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Unsupported crash <span class=\"built_in\">log</span> version: 12 at ./symbolicatecrash line 614.</span><br></pre></td></tr></table></figure></p>\n<p>第五步：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dwarfdump --lookup 0x000cf358 --arch armv7 appname.app.dSYM/</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"调试","path":"api/categories/调试.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"测试","path":"api/tags/测试.json"}]},{"title":"calabash一款跨平台UI测试工具初探","slug":"测试/calabash一款跨平台UI测试工具初探","date":"2015-10-06T08:32:41.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/测试/calabash一款跨平台UI测试工具初探.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>参考：<a href=\"http://blog.csdn.net/zangcw/article/details/25299243\" target=\"_blank\" rel=\"noopener\">使用jenkins+calabash+cocoapods搭建ios持续集成环境</a></p>\n<ol>\n<li>calabash  是一款开源的跨平台UI测试工具，目前支持iOS和Android。它使用Cucumber作为测试核心，Cucumber是一个在敏捷团队十分流行的自动化的功能测试工具，它使用接近于自然语言的特性文档进行用例的书写和测试，支持多语言和多平台。</li>\n<li><p>安装Calabash  </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem install calabash-cucumber</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装Calabash中文支持包  </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem install calabash-cucumber-cn</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"For-automatic-setup\"><a href=\"#For-automatic-setup\" class=\"headerlink\" title=\"For automatic setup:\"></a>For automatic setup:</h4><ol>\n<li><p>In a terminal, go to your iOS project  </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\tcd path-to-my-ios-project (i.e. directory containing .xcodeproj file)</span><br><span class=\"line\">\t```  </span><br><span class=\"line\">2. Install calabash-cucumber gem (this make take some time because of dependencies)</span><br></pre></td></tr></table></figure>\n<p> gem install calabash-cucumber</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3. Setup your project for Calabash-iOS.</span><br></pre></td></tr></table></figure>\n<p> calabash-ios setup  //Answer the questions and read the output :)</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4. Generate a skeleton features folder for your tests</span><br></pre></td></tr></table></figure>\n<p> calabash-ios gen</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5. In Xcode, build your project using the -cal scheme</span><br><span class=\"line\"></span><br><span class=\"line\">6. Run the generated test!</span><br></pre></td></tr></table></figure>\n<p> cucumber</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">If all goes well, you are now ready to write your first test. Start by editing the file features/my_first.feature.</span><br><span class=\"line\">&lt;!--more--&gt;</span><br><span class=\"line\">#### [cucumber官网](https://cukes.info/)   </span><br><span class=\"line\"></span><br><span class=\"line\">\t\t* Feature（功能）  </span><br><span class=\"line\">\t\t* Scenario（情景）  </span><br><span class=\"line\">\t\t*  Given（给定）  </span><br><span class=\"line\">\t\t*  When（当）  </span><br><span class=\"line\">\t\t*  Then（则） </span><br><span class=\"line\">#####[运行原理](http://www.educity.cn/se/619226.html)  </span><br><span class=\"line\">![image](http://img.educity.cn/img_7/262/2013122000/125005907.jpg)  </span><br><span class=\"line\">cucumber是一种BDD测试框架，核心为cucumber的calabash的脚本在运行测试的时候会在虚拟机/真机上预装一个web服务器，这个web服务器就是解释calabash的脚本，将其解释为robotium的脚本，然后这个web服务器会想测试app发送robotium的脚本，测试app拿到robotium脚本后，将其解释为instumentation命令向被测试的app发送这些命令，被测试的app执行这些命令，然后将结果返回给测试app，然后一级一级返得到最后的测试结果。    </span><br><span class=\"line\">#####结构框架</span><br><span class=\"line\">calabash完全采用了cucumber的结构模式，calabash是脚本与TC分离设计，在业务变化的情况下，只要功能存在基本只需要修改TC逻辑，在业务不变，功能变化的情况下，基本只需要修改脚本。   </span><br><span class=\"line\">![image](http://img.educity.cn/img_7/262/2013122000/126005907.jpg)  </span><br><span class=\"line\">feature为主件夹，step_definitions目录内是你封装的脚本，my_first.feature文件就是你的TC逻辑。  </span><br><span class=\"line\">再看一下其中的内容：</span><br><span class=\"line\"></span><br><span class=\"line\">\t　　my_first.feature</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　Feature： 登陆</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　Scenario： 输入正确的用户名密码能够正常登陆</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　When 打开登陆页面</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　And    输入用户名XXX输入密码XXX</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　And   点击登陆</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　Then  验证登陆成功</span><br><span class=\"line\"></span><br><span class=\"line\">　　看起来很简单吧，想要验证其他功能也是类似的语言描述即可。  </span><br><span class=\"line\">如果你没有用过cucumber或者calabash那么你肯定现在有一个疑问，计算机怎么能识别汉字来进行测试的呢，  </span><br><span class=\"line\">那么看一下step_definition，以 输入用户名XXX输入密码XXX为例：</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tWhen /^ 输入用户名\\&quot;([^\\\\\\&quot;]*)\\&quot; 输入密码\\&quot;([^\\\\\\&quot;]*)\\&quot;  $/ do |username，password|</span><br><span class=\"line\">\t\tperformAction(&apos;enter_text_into_numbered_field&apos;，username，1)</span><br><span class=\"line\">\t\tperformAction(&apos;enter_text_into_numbered_field&apos;，password，2)</span><br><span class=\"line\">\t\tend</span><br><span class=\"line\">现在应该能明白为什么你需要写汉字的脚本就可以了吧。  </span><br><span class=\"line\">在这里解释一下为什么如果业务存在功能修改这种情况，自动化脚本的修改量会小。  </span><br><span class=\"line\">还是以这个登录脚本为例：</span><br><span class=\"line\"></span><br><span class=\"line\">\t假如现在输入用户名和密码的输入框顺序变了，在你的页面显示上，可能是从左下角移到中间了，这种变化，那么feature文件你不用改，只需要改step_definition脚本就好了</span><br><span class=\"line\">#####运行报告</span><br><span class=\"line\">alabash-android支持很多报告生成模式，支持html，json，junit等等报告模式，只需要你在run的时候添加-f参数-o参数就可以了。</span><br><span class=\"line\"></span><br><span class=\"line\">　　例如 calabash-android run xxxx.apk -f html -o l，上图展示一下强大html报告  </span><br><span class=\"line\">　　![image](http://img.educity.cn/img_7/262/2013122000/127005907.jpg)</span><br><span class=\"line\"></span><br><span class=\"line\">[【cucumber解析features文件】](http://blog.csdn.net/qs_csu/article/details/9000262) \t\t</span><br><span class=\"line\">1. my_first.feature: 描述在这个条件下需要做什么事情；</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFeature: Running a test  </span><br><span class=\"line\">\t\t  As an iOS developer  </span><br><span class=\"line\">\t\t  I want to have a sample feature file  </span><br><span class=\"line\">\t\t  So I can begin testing quickly  </span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\tScenario: Example steps1  </span><br><span class=\"line\">\t\t  Given I am on the Welcome Screen  </span><br><span class=\"line\">\t\t  Then I swipe left  </span><br><span class=\"line\">\t\t  And I wait until I don&apos;t see &quot;Please swipe left&quot;  </span><br><span class=\"line\">\t\t  And take picture  </span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\tScenario: Example steps2  </span><br><span class=\"line\">\t\t  Given I am on the Welcome Screen  </span><br><span class=\"line\">\t\t #ASSERTION  </span><br><span class=\"line\">\t\t  Then I should see a &quot;login&quot; button  </span><br><span class=\"line\">\t\t #INPUT TEXT  </span><br><span class=\"line\">\t\t  Then I enter &quot;my_username&quot; into text field number 1  </span><br><span class=\"line\">\t\t#  Then I touch &quot;Return&quot;  </span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\t #TOGGLE SWITCH  </span><br><span class=\"line\">\t\t  Then I toggle the switch  </span><br><span class=\"line\">\t\t  Then I touch &quot;Login&quot;  </span><br><span class=\"line\">\t\t  And I touch &quot;Second&quot;  </span><br><span class=\"line\">\t\t  And take picture  </span><br><span class=\"line\">\t该文件描述了在“on the Welcome Screen”这个Step中需要做的事情，两个场景:steps1 和 steps2. </span><br><span class=\"line\"></span><br><span class=\"line\">2. my_first_step.rb: 解释了Given的具体条件</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tGiven /^I am on the Welcome Screen$/ do  </span><br><span class=\"line\">\t\t  element_exists(&quot;view&quot;)  </span><br><span class=\"line\">\t\t  check_element_exists(&quot;label text:&apos;First View&apos;&quot;)  </span><br><span class=\"line\">\t\t  sleep(STEP_PSEAU)  </span><br><span class=\"line\">\t\tend</span><br><span class=\"line\">\t这个语句，判定了当前条件&quot;on the Welcome Screen&quot;是否满足，如果element存在，则就在&quot;Welcome Screen&quot;</span><br><span class=\"line\">\t</span><br><span class=\"line\">[更多的测试框架](http://www.infoq.com/cn/articles/build-ios-continuous-integration-platform-part2)</span><br><span class=\"line\"></span><br><span class=\"line\">UIAutomation</span><br><span class=\"line\"></span><br><span class=\"line\">UIAutomation是随着iOS SDK 4.0引入，帮助开发者在真实设备和模拟器上执行自动化的UI测试。其本质上是一个Javascript的类库，通过 界面上的标签和值的访问性来获得UI元素，完成相应的交互操作，从而达到测试的目的，类似于Web世界的Selenium。</span><br><span class=\"line\"></span><br><span class=\"line\">通过上面的描述，可以得知，使用UIAutomation做测试时，开发者必须掌握两件事：</span><br><span class=\"line\"></span><br><span class=\"line\">- 如何找到界面上的一个UI元素</span><br><span class=\"line\">- 如何指定针对一个UI元素的操作</span><br><span class=\"line\"></span><br><span class=\"line\">在UIAutomation中，界面就是由一堆UI元素构建的层级结构，所有UI元素都继承对象UIAElement ，该对象提供了每个UI元素必须具备的一些属性：</span><br><span class=\"line\"></span><br><span class=\"line\">- name</span><br><span class=\"line\">- value</span><br><span class=\"line\">- elements</span><br><span class=\"line\">- parent</span><br><span class=\"line\">- …</span><br><span class=\"line\"></span><br><span class=\"line\">而整个界面的层级结构如下：</span><br><span class=\"line\"></span><br><span class=\"line\">\target（设备级别的UI，用于支持晃动，屏幕方向变动等操作）</span><br><span class=\"line\">\t    Application（设备上的应用，比方说Status Bar，keyboard等）</span><br><span class=\"line\">\t      Main window（应用的界面，比方说导航条）</span><br><span class=\"line\">\t        View（界面下的View，比方说UITableView）</span><br><span class=\"line\">\t           Element（View下的一个元素）</span><br><span class=\"line\">\t              Child element(元素下的一个子元素)</span><br><span class=\"line\">下面是一个访问到Child element的例子：</span><br><span class=\"line\"></span><br><span class=\"line\">\tUIATarget.localTarget().HamcrestDemo().tableViews()[0].cells()[0].elements()</span><br><span class=\"line\">开发者还可以通过“UIATarget.localTarget().logElementTree()”在控制台打印出该target下所有的的elements。</span><br><span class=\"line\"></span><br><span class=\"line\">找到UI元素之后，开发者可以基于该UI元素做期望的操作，UIAutomation作为原生的UI测试框架，基本上支持iOS上的所有UI元素和操作，比方说：</span><br><span class=\"line\"></span><br><span class=\"line\">- 点击按钮，例: ***.buttons[“add”].tap()</span><br><span class=\"line\">- 输入文本, 例:***.textfields[0].setValue(“new”)</span><br><span class=\"line\">- 滚动屏幕，例:***.scrollToElementWithPredicate(“name begin with ’test’”)</span><br><span class=\"line\">- ……</span><br><span class=\"line\">关于使用UIAutomation做UI测试，推荐大家一定要看一下2010的WWDC的Session 306：[Automating User Interface Testing with Instruments](https://developer.apple.com/videos/wwdc/2010/?id=306)。 另外，这儿还有一篇很好的博客，详细的讲解了[如何使用UIAutomation做UI自动化测试](http://blog.manbolo.com/2012/04/08/ios-automated-tests-with-uiautomation)  </span><br><span class=\"line\">Apple通过Instruments为UIAutomation测试用例的命令行运行提供了支持，这样就为UIAutomation和CI服务器的集成提供了便利。开发者可以通过如下的步骤在命令行中运行UIAutomation测试脚本:</span><br><span class=\"line\">1. 指定目标设备，构建被测应用，该应用会被安装到指定的DSTROOT目录下</span><br><span class=\"line\">```ruby</span><br><span class=\"line\">xcodebuild</span><br><span class=\"line\">-project &quot;/Users/twer/Documents/xcodeworkspace/AudioDemo/AudioDemo.xcodeproj&quot; </span><br><span class=\"line\">-schemeAudioDemo</span><br><span class=\"line\">-sdk iphonesimulator6.1 </span><br><span class=\"line\">-configuration Release SYMROOT=&quot;/Users/twer/Documents/xcodeworkspace/</span><br><span class=\"line\">AudioDemo/build&quot; DSTROOT=&quot;/Users/twer/Documents/xcodeworkspace/AudioDemo/</span><br><span class=\"line\">build&quot; TARGETED_DEVICE_FAMILY=&quot;1&quot; </span><br><span class=\"line\">install</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动Instruments，基于第一步生成的应用运行UIAutomation测试</p>\n<pre><code class=\"ruby\">instruments\n-t  <span class=\"string\">\"/Applications/Xcode.app/Contents/Applications/Instruments.app/</span>\n<span class=\"string\">Contents/PlugIns/AutomationInstrument.bundle/Contents/Resources/</span>\n<span class=\"string\">Automation.tracetemplate\"</span> <span class=\"string\">\"/Users/twer/Documents/xcodeworkspace/AudioDemo</span>\n<span class=\"string\">/build/Applications/TestExample.app\"</span>\n-e UIASCRIPT &lt;absolute_path_to_the_test_file&gt;\n</code></pre>\n<p>为了更好的展示测试效果以及与CI服务器集成，活跃的社区开发者们还尝试把UIAutomation和Jasmine集成: <a href=\"https://github.com/shaune/jasmine-ios-acceptance-tests\" target=\"_blank\" rel=\"noopener\">https://github.com/shaune/jasmine-ios-acceptance-tests</a></p>\n</li>\n</ol>\n<p>UIAutomation因其原生支持，并且通过和Instruments的绝佳配合，开发者可以非常方便的使用录制操作自动生成测试脚本，赢得了很多开发者的支持，但是因苹果公司的基因，其系统非常封闭，导致开发者难以扩展，于是活跃的社区开发者们开始制造自己的轮子，<a href=\"https://gorillalogic.com/fonemonkey-0-7-1-released/\" target=\"_blank\" rel=\"noopener\">Fone Monkey,最新版本更新于2010年，估计过时</a>就是其中的一个优秀成果。</p>\n","raw":null,"categories":[{"name":"工具","path":"api/categories/工具.json"},{"name":"集成","path":"api/categories/集成.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"测试","path":"api/tags/测试.json"}]}]}