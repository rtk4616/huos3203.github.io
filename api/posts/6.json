{"total":157,"pageSize":10,"pageCount":16,"data":[{"title":"vim编辑器的基本用法","slug":"shell/vim编辑器的基本用法","date":"2017-07-04T10:09:29.000Z","updated":"2018-04-12T19:41:46.000Z","comments":true,"path":"api/articles/shell/vim编辑器的基本用法.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><a href=\"https://github.com/huos3203/vim-galore-zh_cn\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h3 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h3><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>动作：是指移动光标的操作，你肯定很熟悉 h、j、k 和 l，以及 w 和 b。但其实，/ 也是一个动作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:h navigation</span><br></pre></td></tr></table></figure></p>\n<p>操作符：<br>对某个区域文本执行的操作。比如，d、~、gU 和 &gt; 都是操作符。这些操作符既可以在普通模式下使用，也可以在可视模式下使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:h operator</span><br></pre></td></tr></table></figure></p>\n<p>文本对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:h text-objects</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"缓冲区列表\"><a href=\"#缓冲区列表\" class=\"headerlink\" title=\"缓冲区列表\"></a>缓冲区列表</h3><p>缓冲区的几种状态：已激活，已载入，已列出，已命名<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:ls  #列出所有可以列出的缓冲区</span><br><span class=\"line\">:ls! #命令可以显示被放入缓冲区列表的和未被放入列表的缓冲区</span><br></pre></td></tr></table></figure></p>\n<p>创建一个无名临时缓冲区<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:enew</span><br></pre></td></tr></table></figure></p>\n<p>激活一个缓冲区<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:e file2</span><br></pre></td></tr></table></figure></p>\n<p>命名一个缓冲区<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:w /path/file #存储位置</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"参数列表\"><a href=\"#参数列表\" class=\"headerlink\" title=\"参数列表\"></a>参数列表</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:h argument-list</span><br></pre></td></tr></table></figure>\n<p>操作命令范围概念<br>关键字符：,|;|数字|\\$|%</p>\n<h3 id=\"跳转历史和变更历史\"><a href=\"#跳转历史和变更历史\" class=\"headerlink\" title=\"跳转历史和变更历史\"></a>跳转历史和变更历史</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:jumps</span><br><span class=\"line\">:changes</span><br><span class=\"line\">:h changelist</span><br><span class=\"line\">:h jumplist</span><br></pre></td></tr></table></figure>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><p><a href=\"http://vim.liuchengxu.org/docs/org/tutorial_cn.html#orgheadline26\" target=\"_blank\" rel=\"noopener\">space-Vim使用文档</a><br><code>空格 f t</code>  打开/关闭树型栏<br><code>SPC f R</code> 刷新文件结构目录<br><code>, f c</code> unite命令集合快速查找命令集<br><code>SPC b h</code> 返回vim主页<br><code>SPC f r</code> 最近打开过的文件清单</p>\n<h3 id=\"markdown插件命令\"><a href=\"#markdown插件命令\" class=\"headerlink\" title=\"markdown插件命令\"></a>markdown插件命令</h3><p><code>,1..3</code> 快速标题格式<code>###</code>生成章节<br><code>,ct</code> 在当前位置插入所有章节的清单<br><code>,cs</code> 新建窗口显示博客章节目录清单,支持编辑时跳转到指定的章节位置<br><code>,cp</code> 预览博客发布的效果（无效）</p>\n<h3 id=\"git插件命令\"><a href=\"#git插件命令\" class=\"headerlink\" title=\"git插件命令\"></a>git插件命令</h3><p><code>SPC g s</code> git status<br><code>SPC g d</code> git diff<br><code>AsyncRun git add file</code> git add file<br><code>SPC g c</code> git commit<br><code>SPC g p</code> git push</p>\n<h3 id=\"unite\"><a href=\"#unite\" class=\"headerlink\" title=\"unite\"></a>unite</h3><p><a href=\"http://www.cnblogs.com/pigzhu/p/3159161.html\" target=\"_blank\" rel=\"noopener\">Vim插件：Unite新手指导(译)</a><br>Unite可以在一个项目中快速浏览文件。但是它不仅限于文件，其他任何可以列出的东西都可以很好的被显示和搜索。这个开放式的特性很可能是人们找到它的原因</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p>Unite命令采用的格式为:Unite source，其中”source”是buffer，file和file_rec其中之一。</p>\n<p><code>buffer</code>: 浏览当前打开的buffer列表<br><code>file</code>: 浏览当前目录的文件列表<br><code>file_rec</code>: 递归的列出当前目录的文件<br>当一个命令被使用，一个新的水平分割窗口会被打开。<br>比如，命令:<code>Unite file</code>将会显示当前目录的文件列表。在这个窗口中，标准的Vim命令模式下的命令可以使用。可以使用“<code>j</code>”和“<code>k</code>”浏览该列表，可以使用“<code>/</code>”来查询。如果你在一个文件上按下<code>enter</code>键，Unite将会打开它。如果光标是在一个目录上，Unite将会进入该目录，并且更新该文件列表。<br>使用NERO Tree命令<br>查看帮助命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?</span><br></pre></td></tr></table></figure></p>\n<p>将选中的目录变为根目录：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C  # change tree root to the selected dir</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"模式\"><a href=\"#模式\" class=\"headerlink\" title=\"模式\"></a>模式</h3><h4 id=\"插入搜索模式\"><a href=\"#插入搜索模式\" class=\"headerlink\" title=\"插入搜索模式\"></a>插入搜索模式</h4><p>如果你在Unite窗口进入插入模式，光标将会移到该窗口的最上方，并显示“&gt;”提示符。输入字符会搜索该列表–这里和FuzzyFinder相似。和常规vim一样，按<esc>键可以退出插入模式回到命令模式。</esc></p>\n<h4 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h4><p>在命令模式下，当光标在一个文件上，按下a，Unite会显示一个可以操作该文件命令的列表。这个命令列表被称为actions，这个列表可以像Unite其他部分一样被搜索和调用。</p>\n<h4 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h4><p>actions可以组合通配符。如果输入:Unite file, 然后按下*将会标记所有文件，再输入a将会列出所有actions，最后选择above，Unite将会打开所有被标记的文件。</p>\n<h3 id=\"单行操作\"><a href=\"#单行操作\" class=\"headerlink\" title=\"单行操作\"></a>单行操作</h3><h4 id=\"光标移动\"><a href=\"#光标移动\" class=\"headerlink\" title=\"光标移动\"></a>光标移动</h4><p>hjkl (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。</p>\n<ol>\n<li><p>单词移动：<br>1.一个单词由字母，数字和下划线组成，那么就用小写的e和w。即：程序变量移动。<br>2.单词是由blank字符分隔符，那么就用大写的E和W。 即：程序语句移动。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">w → 到下一个单词的开头。</span><br><span class=\"line\">e → 到下一个单词的结尾。</span><br><span class=\"line\">b → 到前一个单词的开头。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本行移动：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 → 数字零，到行头</span><br><span class=\"line\">^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）</span><br><span class=\"line\">$ → 到本行行尾</span><br><span class=\"line\">g_ → 到本行最后一个不是blank字符的位置。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>行间移动：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NG → 到第 N 行 （陈皓注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）</span><br><span class=\"line\">gg → 到第一行。（陈皓注：相当于1G，或 :1）</span><br><span class=\"line\">G 到最后一行</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"多行范围\"><a href=\"#多行范围\" class=\"headerlink\" title=\"多行范围\"></a>多行范围</h3><p>范围 (Ranges) 其实很好理解，但很多 Vim 用户的理解不到位。</p>\n<ul>\n<li>很多命令都可以加一个数字，用于指明操作范围</li>\n<li>范围可以是一个行号，用于指定某一行</li>\n<li>范围也可以是一对通过 <code>,</code> 或 <code>;</code> 分割的行号</li>\n<li>大部分命令，默认只作用于当前行</li>\n<li>只有 <code>:write</code> 和 <code>:global</code> 是默认作用于所有行的</li>\n</ul>\n<p>范围的使用是十分直观的。以下为一些例子（其中，<code>:d</code> 为 <code>:delete</code> 的缩写）：</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>操作的行</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>:d</code></td>\n<td>当前行</td>\n</tr>\n<tr>\n<td><code>:.d</code></td>\n<td>当前行</td>\n</tr>\n<tr>\n<td><code>:1d</code></td>\n<td>第一行</td>\n</tr>\n<tr>\n<td><code>:$d</code></td>\n<td>最后一行</td>\n</tr>\n<tr>\n<td><code>:1,$d</code></td>\n<td>所有行</td>\n</tr>\n<tr>\n<td><code>:%d</code></td>\n<td>所有行（这是 <code>1,$</code> 的语法糖）</td>\n</tr>\n<tr>\n<td><code>:.,5d</code></td>\n<td>当前行至第 5 行</td>\n</tr>\n<tr>\n<td><code>:,5d</code></td>\n<td>同样是当前行至第 5 行</td>\n</tr>\n<tr>\n<td><code>:,+3d</code></td>\n<td>当前行及接下来的 3 行</td>\n</tr>\n<tr>\n<td><code>:1,+3d</code></td>\n<td>第一行至当前行再加 3 行</td>\n</tr>\n<tr>\n<td><code>:,-3d</code></td>\n<td>当前行及向上的 3 行（Vim 会弹出提示信息，因为这是一个保留的范围）</td>\n</tr>\n<tr>\n<td><code>:3,&#39;xdelete</code></td>\n<td>第三行至<a href=\"#标注\">标注</a> 为 x 的那一行</td>\n</tr>\n<tr>\n<td><code>:/^foo/,$delete</code></td>\n<td>当前行以下，以字符 “foo” 开头的那一行至结尾</td>\n</tr>\n<tr>\n<td><code>:/^foo/+1,$delete</code></td>\n<td>当前行以下，以字符 “foo” 开头的那一行的下一行至结尾</td>\n</tr>\n</tbody>\n</table>\n<p>需要注意的是，<code>;</code> 也可以用于表示范围。区别在于，<code>a,b</code> 的 <code>b</code> 是以当前行作为参考的。而 <code>a;b</code> 的 <code>b</code> 是以 <code>a</code> 行作为参考的。举个例子，现在你的光标在第 5 行。这时 <code>:1,+1d</code> 会删除第 1 行至第 6 行，而 <code>:1;+1d</code> 会删除第 1 行和第 2 行。</p>\n<h3 id=\"可视化区域选择并编辑文本\"><a href=\"#可视化区域选择并编辑文本\" class=\"headerlink\" title=\"可视化区域选择并编辑文本\"></a>可视化区域选择并编辑文本</h3><p>1.区域选择其命令格式：</p>\n<pre><code>&lt;action&gt;a&lt;object&gt; 或 &lt;action&gt;i&lt;object&gt;\n</code></pre><p>在visual 模式下，这些命令很强大。</p>\n<p><code>action</code>可以是任何的命令，如 <code>d (删除)</code>, <code>y (拷贝)</code>,<code>v (可以视模式选择)</code>。<br><code>object</code> 可能是： w 一个单词， W 一个以空格为分隔的单词， s 一个句字， p 一个段落。也可以是一个特别的字符：”、 ‘、 )、 }、 ]。</p>\n<p>示例：<br>假设你有一个字符串 (map (+) (“foo”)).而光标键在第一个 o 的位置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi&quot; → 会选择 foo.</span><br><span class=\"line\">va&quot; → 会选择 &quot;foo&quot;.</span><br><span class=\"line\">vi) → 会选择 &quot;foo&quot;.</span><br><span class=\"line\">va) → 会选择(&quot;foo&quot;).</span><br><span class=\"line\">v2i) → 会选择 map (+) (&quot;foo&quot;)</span><br><span class=\"line\">v2a) → 会选择 (map (+) (&quot;foo&quot;))</span><br></pre></td></tr></table></figure></p>\n<p>2.可视化选择： v,V,<c-v></c-v></p>\n<p>前面，我们看到了 <c-v>的示例 （在Windows下应该是<c-q>），我们可以使用 v 和 V。一但被选好了，你可以做下面的事：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">J → 把所有的行连接起来（变成一行）</span><br><span class=\"line\">&lt; 或 &gt; → 左右缩进</span><br><span class=\"line\">= → 自动给缩进 （陈皓注：这个功能相当强大，我太喜欢了）</span><br></pre></td></tr></table></figure></c-q></c-v></p>\n<p>3.在所有被选择的行后加上点东西：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">选中相关的行 (可使用 j 或 &lt;C-d&gt; 或是 /pattern 或是 % 等……)</span><br><span class=\"line\">$ 到行最后</span><br><span class=\"line\">A, 输入字符串，按 ESC。</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"文本编辑\"><a href=\"#文本编辑\" class=\"headerlink\" title=\"文本编辑\"></a>文本编辑</h3><p>插入光标位置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i → Insert 模式，按 ESC 回到 Normal 模式.</span><br><span class=\"line\">a → 在光标后插入</span><br><span class=\"line\">o → 在当前行后插入一个新行</span><br><span class=\"line\">O → 在当前行前插入一个新行</span><br></pre></td></tr></table></figure></p>\n<p>操作文本：</p>\n<p>1.删除：字符，单词，行</p>\n<pre><code>x → 删当前光标所在的一个字符。\ncw → 替换从光标所在位置后到一个单词结尾的字符【准确的说是删除从光标位置到一个单词结尾的字符并进入插入模式】\ndd → 删除当前行，并把删除的行存到剪贴板里\n</code></pre><p>通过行号确定你要删除的行；</p>\n<pre><code>set nu → 显示行号；\n:32,65d → 32-65行就被删除了\n</code></pre><p>2.拷贝：单词，行，段</p>\n<pre><code>ye → 当前位置拷贝到本单词的最后一个字符。\nyy → 拷贝当前行相当于 ddP（dd删除当前行，再粘贴）\n0y$ → 拷贝当前行，即：光标移动组合操作格式：&lt;start position&gt;&lt;command&gt;&lt;end position&gt;\ny2/foo → 拷贝2个 “foo” 之间的字符串。\n</code></pre><p>  还有很多时候并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：</p>\n<pre><code>d (删除 )\nv (可视化的选择)\ngU (变大写)\ngu (变小写)\n等等\n</code></pre><blockquote>\n<p>注：可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等</p>\n</blockquote>\n<p>3.粘帖：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p/P → p是表示在当前位置之后，P表示在当前位置之前</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"vim","path":"api/categories/vim.json"},{"name":"工具","path":"api/categories/工具.json"}],"tags":[]},{"title":"SourceKittenSwift语法自动补齐工具","slug":"shell/SourceKittenSwift语法自动补齐工具","date":"2017-06-29T10:08:50.000Z","updated":"2017-08-17T15:02:27.000Z","comments":true,"path":"api/articles/shell/SourceKittenSwift语法自动补齐工具.json","excerpt":null,"keywords":null,"cover":"http://img.blog.csdn.net/20161026000011614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>vim插件工具：Vundle</p>\n<p>主题色：<br>|组合键 |   Description|<br>空格 + T + n|  随机切换颜色主题。<br>SPC T s    |使用unite buffer方式切换一个主题</p>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><h3 id=\"Unite\"><a href=\"#Unite\" class=\"headerlink\" title=\"Unite\"></a><a href=\"https://github.com/Shougo/unite.vim\" target=\"_blank\" rel=\"noopener\">Unite</a></h3><p>预定义操作命令<br>Unite或unite.vim插件可以搜索和显示信息，例如：任意源文件、缓冲区的，最近使用的文件或记录。可以直接运行在Unite窗口中显示的几个预设操作。</p>\n<h3 id=\"neocomplete\"><a href=\"#neocomplete\" class=\"headerlink\" title=\"neocomplete\"></a>neocomplete</h3><p>一个自动补全的插件，使用TAB或ENTER键来选择。<br>同时，它又额外附带了补全代码段的特性（模版补全），要想使用这种特性，必须安装另外的插件neosnippet或者ultisnips。<br><img src=\"http://img.blog.csdn.net/20161026000011614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<h3 id=\"NERD-Commenter\"><a href=\"#NERD-Commenter\" class=\"headerlink\" title=\"NERD Commenter\"></a><a href=\"https://github.com/scrooloose/nerdcommenter\" target=\"_blank\" rel=\"noopener\">NERD Commenter</a></h3><p>快速注释/解开注释</p>\n<h3 id=\"Goyo-and-Limelight\"><a href=\"#Goyo-and-Limelight\" class=\"headerlink\" title=\"Goyo and Limelight\"></a>Goyo and Limelight</h3><p>干净模式和背景虚化。两者配合使用，效果非常好。vim 也可以很文艺</p>\n<h3 id=\"Bookmarks\"><a href=\"#Bookmarks\" class=\"headerlink\" title=\"Bookmarks\"></a><a href=\"http://blog.csdn.net/mdl13412/article/details/44081509\" target=\"_blank\" rel=\"noopener\">Bookmarks</a></h3><p>插件旨在解决 Vim 自带书签无法高亮、无法持久化、难于记忆的问题，而且解决的非常漂亮. 下面列出其主要特性:</p>\n<p>单行书签切换 ⚑<br>单行的注释(说明)书签 ☰<br>在 quickfix 窗口中访问所有书签<br>书签自动保存，下次开启自动加载<br>针对工作目录的独立书签(可选)<br>高度可定制<br>可以和 Unite 插件的 quickfix 结合<br>不依赖 Vim 自身的 marks</p>\n<h3 id=\"Gita\"><a href=\"#Gita\" class=\"headerlink\" title=\"Gita\"></a>Gita</h3><p>git插件</p>\n<h3 id=\"其他插件\"><a href=\"#其他插件\" class=\"headerlink\" title=\"其他插件\"></a>其他插件</h3><p>Key    Mode    Action</p>\n<p><leader>+gu    Normal    Open undo tree</leader></p>\n<p><leader>+i    Normal    Toggle indentation lines</leader></p>\n<p><leader>+j    Normal    Start smalls</leader></p>\n<p><leader>+r    Normal    Quickrun</leader></p>\n<p><leader>+?    Normal    Dictionary</leader></p>\n<p><leader>+W    Normal    Wiki</leader></p>\n<p><leader>+K    Normal    Thesaurus</leader></p>\n","raw":null,"categories":[{"name":"vim","path":"api/categories/vim.json"},{"name":"工具","path":"api/categories/工具.json"}],"tags":[]},{"title":"在slack上实现实时绘UML图","slug":"工具/在slack上实现实时绘UML图","date":"2017-06-28T15:57:00.000Z","updated":"2017-06-28T15:57:36.000Z","comments":true,"path":"api/articles/工具/在slack上实现实时绘UML图.json","excerpt":null,"keywords":null,"cover":"http://www.plantuml.com/plantuml/svg/NLFFRjem6B_xAImuq2An1-3Gsqxh_cXQJz031KCYWYs5H5KrJGAj3EWWeBQC5T9kRCg4fecYReCj27WPx8Itc1C3exqvNpx__dsVDLbJ45o-xJlJkyMV0cqC9QIIhCvCcrxr5xOTn-pobjMArEpdbKGowtnlqyPNEhXXxP4p-KWh8psdqEuC917Ma0ebb4WX5V3Y4T7esAAbCK0ujIg3c0zo21Dvw9y0I2f4Jy70chPEptgSEV0Qn0I6tokE82Qw_99tND70I2nuWXI571_k-VNeoj761V2gNbj6HGZpBd4n2gdnoJtjCFC7U0Esq4HRP4-8Z4BXzE3fFl0BCBBcSMSNj6H9X6ITopwhZ5bhoEg3E7xr_CdZPolM_p0RFGSlzm48iP_zPVcCzNlqkXq2c6W8gd96qY19hmJ2ACp8cgGVCRlfV2vI-oAEFL0n4_7BwVvYXYKC2n05fNsC1vd2uB4aQuYBdZVTNaqmR0qQBYQ6BzGrnhJnWLCAD_T1HG115QLuogMwCnqGNSiG6MUW5qCSUv6KxQX6iWYBhv8LtNQ-az_rp1iMNwIr-PtT04-3lgi5_BosXqYhTTPeUXtYUxl37Sou017sVPaRE35B3cOMt6z5PpwXNwxYEF12GOayWac2qxAQWoT43wa8SWYOW2hXmJmAF9Z8Xbvu5zJXi4yU3Y-cNXHnl2nqt7bPvUkUGrpsOjPrEgUhRQnLb-UyXLrR_Fqunb10-461zVj94qwg0gSxy7p_Vk_UjkZV4RlhCRCgRebdk5v8ZivQ5NPZUgzCNFu7","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><a href=\"https://github.com/huos3203/umlbot\" target=\"_blank\" rel=\"noopener\">umlbot源码库</a><br><img src=\"http://www.plantuml.com/plantuml/svg/NLFFRjem6B_xAImuq2An1-3Gsqxh_cXQJz031KCYWYs5H5KrJGAj3EWWeBQC5T9kRCg4fecYReCj27WPx8Itc1C3exqvNpx__dsVDLbJ45o-xJlJkyMV0cqC9QIIhCvCcrxr5xOTn-pobjMArEpdbKGowtnlqyPNEhXXxP4p-KWh8psdqEuC917Ma0ebb4WX5V3Y4T7esAAbCK0ujIg3c0zo21Dvw9y0I2f4Jy70chPEptgSEV0Qn0I6tokE82Qw_99tND70I2nuWXI571_k-VNeoj761V2gNbj6HGZpBd4n2gdnoJtjCFC7U0Esq4HRP4-8Z4BXzE3fFl0BCBBcSMSNj6H9X6ITopwhZ5bhoEg3E7xr_CdZPolM_p0RFGSlzm48iP_zPVcCzNlqkXq2c6W8gd96qY19hmJ2ACp8cgGVCRlfV2vI-oAEFL0n4_7BwVvYXYKC2n05fNsC1vd2uB4aQuYBdZVTNaqmR0qQBYQ6BzGrnhJnWLCAD_T1HG115QLuogMwCnqGNSiG6MUW5qCSUv6KxQX6iWYBhv8LtNQ-az_rp1iMNwIr-PtT04-3lgi5_BosXqYhTTPeUXtYUxl37Sou017sVPaRE35B3cOMt6z5PpwXNwxYEF12GOayWac2qxAQWoT43wa8SWYOW2hXmJmAF9Z8Xbvu5zJXi4yU3Y-cNXHnl2nqt7bPvUkUGrpsOjPrEgUhRQnLb-UyXLrR_Fqunb10-461zVj94qwg0gSxy7p_Vk_UjkZV4RlhCRCgRebdk5v8ZivQ5NPZUgzCNFu7\"></p>\n","raw":null,"categories":[{"name":"工具","path":"api/categories/工具.json"}],"tags":[]},{"title":"PBBReader阅读器解析","slug":"iOS/PBBReader阅读器解析","date":"2017-06-26T17:02:18.000Z","updated":"2017-06-26T17:12:47.000Z","comments":true,"path":"api/articles/iOS/PBBReader阅读器解析.json","excerpt":null,"keywords":null,"cover":"http://www.plantuml.com/plantuml/svg/ZLPRJnj757wVNp4A3zYWjPG-Rf0bBarbgG64I_iG8hIsnsRBiXlDZab95Oa4d3X02MeA936uGDh20w6G6uutc3-pisi_zI_qZ7TjVDbKzPDdvimvt_dcdEyiOYhJ2Awzo5N_jlZB8_VLCd-SgoqTkTPpfxZC2nMK93eZ5CyG9KKegXw-TeeRuoCttS89lzZyv_EQywBY_b66dTh-Xzhk0I9wohT5IKqnJNnJrSZtAhatREYC6ff6wC1ah7qZ-ZEI9CpFYixYeMijOqb2_R6XiInWOzWpndrtKsdnvmRgduoDAvaEdt3UjNS3IIPJA5FrJEV1z3JcJowSpLCHRdeQIJWK6nfCCjNGmsf26JACsJc5pffoQ38sb6NCq75Vs8JSwbxRZGLELIV_mpHE59gS6MAw759JJPi73QQ2yXfef1N4KOfe9ACm0foa5AR4ZInDYiKys4VIL9aJYmmnMPQI2P8qChfwdr2pE_r-LLTPA7m59PYtWQie0AUBmv3m4fvlkpB8Of3bJxB93BgGC1IQaaKUpiQE-_x0EThdkziY5IaqRm0b5B1w94qGCwknOKCpg1mQZSSP1JHrOiKfBEkyzVBSE_UTnSyUzQ9Wo3YYaJIBH0F9bUSCeB3wy1NVo4CUpYydJda31PPN91BjBcJPURhALoxjptkrnL-HRZ22uVMX66Pn3oKf6JihA-wb1PtXh1_o_4Ulm_nBvLNR-ZYbUvTTwsLh4uvxjMwNtY3K7HPVktuDzqctUn9QbjoHn388SmSWOGo8YikrnJr-KhGhgtQft0pgd5jyPSy3orT-hovTeFzaz7PFXYeBTu1OY1x0J7StYioR7BT34wvaR5ivzxSZkxpEyxlyS9MlRRd7ntPfqJdUzqH640Cwq-HfSmq41_IAdtmAf4cIebyePDalm8H2FVxvcstt-2-xz1P74VpgyAYQcM7OI7_11-wvDwCoeFHw10EJ_Zi_sx0hXMQUKph-AeATmdjdwzIB286Sam-rWvtgqxTU6C6cY1AGW2WYBEFMfEsIvGjjs-N0cfKnlBExVkf3symxnHtn2erQR3Gx-1zNg0dzpS__vBbpzymARkzKM7Ju3ogR4M17GL_QUZCDctfTTDfimVs8aPH3mzzu_x9pC58cI3gSCfB2T3G-IA40m466C30H6O25sQAC8B7VWiG63Gu1iocA07CqVYlBb8H6VAU6fyvVmnMLWC-kyxj47-kmQPaztmbJRm3vdfexmjTOuaUIP0Et5dmNxV16V7sEuhuhgNxGLAr2fHSrkQzNgv-dt1oppjOJP_zrTVsSFzloHgutcP5lYINem83smruX-bVgZOBQA-OgCBGV8Re_sc7AjiOHvR9NufTBNcNmjPmOy5XuwcYI1Y2lAqJjvGlSAhSYcDAzFkxuYF1SWzRnoZRFdpPr0ZM-FT86HAB8BZ-6cyBquZaOrVO_mNsV3W3bMVqB","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"支持OS-X浏览PDF简单视图\"><a href=\"#支持OS-X浏览PDF简单视图\" class=\"headerlink\" title=\"支持OS X浏览PDF简单视图\"></a>支持OS X浏览PDF简单视图</h2><p>运行scheme： <code>PDFReaderForOSX</code> 即可</p>\n<h2 id=\"支持iOS\"><a href=\"#支持iOS\" class=\"headerlink\" title=\"支持iOS\"></a>支持iOS</h2><p>pageViewController: pdf翻页效果视图控制器<br>startingViewController:DataViewController,翻页视图控制器的视图源<br>modelController:ModelController:NSObject,数据视图数据源的model模型。<br><img src=\"http://www.plantuml.com/plantuml/svg/ZLPRJnj757wVNp4A3zYWjPG-Rf0bBarbgG64I_iG8hIsnsRBiXlDZab95Oa4d3X02MeA936uGDh20w6G6uutc3-pisi_zI_qZ7TjVDbKzPDdvimvt_dcdEyiOYhJ2Awzo5N_jlZB8_VLCd-SgoqTkTPpfxZC2nMK93eZ5CyG9KKegXw-TeeRuoCttS89lzZyv_EQywBY_b66dTh-Xzhk0I9wohT5IKqnJNnJrSZtAhatREYC6ff6wC1ah7qZ-ZEI9CpFYixYeMijOqb2_R6XiInWOzWpndrtKsdnvmRgduoDAvaEdt3UjNS3IIPJA5FrJEV1z3JcJowSpLCHRdeQIJWK6nfCCjNGmsf26JACsJc5pffoQ38sb6NCq75Vs8JSwbxRZGLELIV_mpHE59gS6MAw759JJPi73QQ2yXfef1N4KOfe9ACm0foa5AR4ZInDYiKys4VIL9aJYmmnMPQI2P8qChfwdr2pE_r-LLTPA7m59PYtWQie0AUBmv3m4fvlkpB8Of3bJxB93BgGC1IQaaKUpiQE-_x0EThdkziY5IaqRm0b5B1w94qGCwknOKCpg1mQZSSP1JHrOiKfBEkyzVBSE_UTnSyUzQ9Wo3YYaJIBH0F9bUSCeB3wy1NVo4CUpYydJda31PPN91BjBcJPURhALoxjptkrnL-HRZ22uVMX66Pn3oKf6JihA-wb1PtXh1_o_4Ulm_nBvLNR-ZYbUvTTwsLh4uvxjMwNtY3K7HPVktuDzqctUn9QbjoHn388SmSWOGo8YikrnJr-KhGhgtQft0pgd5jyPSy3orT-hovTeFzaz7PFXYeBTu1OY1x0J7StYioR7BT34wvaR5ivzxSZkxpEyxlyS9MlRRd7ntPfqJdUzqH640Cwq-HfSmq41_IAdtmAf4cIebyePDalm8H2FVxvcstt-2-xz1P74VpgyAYQcM7OI7_11-wvDwCoeFHw10EJ_Zi_sx0hXMQUKph-AeATmdjdwzIB286Sam-rWvtgqxTU6C6cY1AGW2WYBEFMfEsIvGjjs-N0cfKnlBExVkf3symxnHtn2erQR3Gx-1zNg0dzpS__vBbpzymARkzKM7Ju3ogR4M17GL_QUZCDctfTTDfimVs8aPH3mzzu_x9pC58cI3gSCfB2T3G-IA40m466C30H6O25sQAC8B7VWiG63Gu1iocA07CqVYlBb8H6VAU6fyvVmnMLWC-kyxj47-kmQPaztmbJRm3vdfexmjTOuaUIP0Et5dmNxV16V7sEuhuhgNxGLAr2fHSrkQzNgv-dt1oppjOJP_zrTVsSFzloHgutcP5lYINem83smruX-bVgZOBQA-OgCBGV8Re_sc7AjiOHvR9NufTBNcNmjPmOy5XuwcYI1Y2lAqJjvGlSAhSYcDAzFkxuYF1SWzRnoZRFdpPr0ZM-FT86HAB8BZ-6cyBquZaOrVO_mNsV3W3bMVqB\"></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"}],"tags":[]},{"title":"Perfect开发天气接口API","slug":"macOS/Perfect开发天气接口API","date":"2017-06-26T17:01:24.000Z","updated":"2017-06-26T17:12:47.000Z","comments":true,"path":"api/articles/macOS/Perfect开发天气接口API.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"Perfect介绍\"><a href=\"#Perfect介绍\" class=\"headerlink\" title=\"Perfect介绍\"></a>Perfect介绍</h2><p>Perfect提供一系列代表请求和响应的对象组件，并允许在服务器上增加管理句柄用于产生页面内容。<br>所有对象都是在服务器对象创建后开始工作。服务器对象会被执行配置，随后会根据配置绑定并监听特定端口。一旦出现连接，服务器会读取请求数据，请求数据读取完成后，服务器会将request object请求对象传递给请求过滤器。</p>\n<h3 id=\"请求过滤器\"><a href=\"#请求过滤器\" class=\"headerlink\" title=\"请求过滤器\"></a>请求过滤器</h3><p>过滤器可能会根据需要修改查询请求。服务器会使用请求的URI路径检索routing请求／响应路由以获取处理该请求的具体句柄。如果找到了合适的处理句柄，服务器会传递给句柄对应的response object响应对象。当句柄反馈响应完成时，响应对象会被传递给响应过滤器。这些过滤器会根据需要修改最终输出的数据内容。最后响应结果数据会被推送给客户端浏览器，而客户端到服务器的连接或者被关闭、或者被拒绝维持HTTP持久连接、或者为后续请求和响应维持HTTP活动连接。</p>\n<h3 id=\"HTTP请求-响应路由\"><a href=\"#HTTP请求-响应路由\" class=\"headerlink\" title=\"HTTP请求/响应路由\"></a>HTTP请求/响应路由</h3><p>HTTP请求/响应路由是用于决定在当前请求下，哪一个句柄去接收和响应。</p>\n<ol>\n<li><code>句柄</code>:可以是一个函数、过程或者方法，只要能够接收特定类型的请求并做出反应即可。</li>\n<li><p><code>路由</code>:主要依据请求的方法<code>HTTP request method</code>和请求内容包括的<code>路径信息</code>来决定的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">routes.add(method: .post, uris: [<span class=\"string\">\"HostMonitor/client/log/addLog\"</span>])&#123;</span><br><span class=\"line\">    (request,response) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\">//处理请求,并响应请求</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>URI路由变量<br>URI变量是用于处理动态请求的好方法。比如，一个包含用户id的URL可以用该方法实现相关请求的用户管理。<br>每个变量组件是通过一个<code>程序块{ }</code>声明的。在程序块中是变量名称。每个变量名称都可以使用出了括号<code>}</code>之外的任何字符。变量名有点像单功能通配符一样，这样就可以匹配任何符合变量模式的路径。<br><code>变量值</code>:在匹配该模式下URL能够通过<code>HTTPRequest.urlVariables</code>字典查询变量值。该字典是[String:String]类型。</p>\n</li>\n</ol>\n<h3 id=\"请求对象HTTPRequest\"><a href=\"#请求对象HTTPRequest\" class=\"headerlink\" title=\"请求对象HTTPRequest\"></a>请求对象HTTPRequest</h3><p>当处理一个HTTP请求时，所有客户端的互动操作都是通过HTTPRequest请求对象和HTTPResponse响应对象实现的。<br>HTTPRequest对象包含了客户端浏览器发过来的全部数据，包括请求消息头、查询参数、POST表单数据以及其它所有相关信息，比如客户IP地址和URL变量。</p>\n<p>HTTPRequest对象将采用application/x-www-form-urlencoded编码格式对客户请求进行解析解码。而如果请求中采用multipart/form-data“多段”编码方式，则HTTP请求可以把各种未处理的原始格式表单传输过来。当处理“多段”表单数据时，HTTPRequest对象会为请求上传的文件自动创建临时目录并执行解码。这些文件会在请求过程中一直保持直到请求处理完毕，随后自动被删除。</p>\n<p>以上涉及到的各种属性和函数都是HTTPRequest请求协议的部分内容。</p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"终端","path":"api/categories/终端.json"}],"tags":[]},{"title":"搞定2提升工作与生活效率的52项原则","slug":"阅读/搞定2提升工作与生活效率的52项原则","date":"2017-06-26T10:41:37.000Z","updated":"2017-08-17T15:55:45.000Z","comments":true,"path":"api/articles/阅读/搞定2提升工作与生活效率的52项原则.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"《搞定II》\"><a href=\"#《搞定II》\" class=\"headerlink\" title=\"《搞定II》\"></a>《搞定II》</h2><h3 id=\"前言-轻松实现轻松做事\"><a href=\"#前言-轻松实现轻松做事\" class=\"headerlink\" title=\"前言 轻松实现轻松做事\"></a>前言 轻松实现轻松做事</h3><h3 id=\"第一部分-理清头绪，发挥创造力\"><a href=\"#第一部分-理清头绪，发挥创造力\" class=\"headerlink\" title=\"第一部分 理清头绪，发挥创造力\"></a>第一部分 理清头绪，发挥创造力</h3><pre><code>第1章 理清思路，确立新方向\n第2章 知道哪些事情自己尚未做，你才会为之心安\n第3章 理清承担的任务，可以更好地选择新任务\n第4章 要实现未来的目标，首先明确当前的位置\n第5章 以有限的可能，去利用无限的机遇\n第6章 一心二用带来压力与失败\n第7章 有意识地权衡轻重缓急\n第8章 完成未竟之事，释放自身能量\n第9章 如果你一直想着某件事，很可能是还没有搞定\n第10章 只要有空间，创造力就会展现\n第11章 渠深流畅\n第12章 担忧无益\n第13章 你不是你的工作\n</code></pre><h3 id=\"第二部分-高效关注\"><a href=\"#第二部分-高效关注\" class=\"headerlink\" title=\"第二部分 高效关注\"></a>第二部分 高效关注</h3><pre><code>第14章 想看得更清楚，请从更高处着眼\n第15章 只有身体力行，你才会知道如何去做\n第16章 工作足够努力是不可能的\n第17章 精力随心思而动\n第18章 目标越明确，实现目标的途径越多\n第19章 精益求精\n第20章 关注重心的变化等于结果的变化\n第21章 视角是地球上最贵重的商品\n第22章 多加思考\n第23章 思考有度\n第24章 效率是改善工作的唯一机会\n第25章 关注一件事才能“全神贯注”\n第26章 未来目标的价值，在于它当前培育的变化\n</code></pre><h3 id=\"第三部分-建立有效的制约机制\"><a href=\"#第三部分-建立有效的制约机制\" class=\"headerlink\" title=\"第三部分 建立有效的制约机制\"></a>第三部分 建立有效的制约机制</h3><pre><code>第27章 稳定带来创造力\n第28章 形式与功能必须符合效率最高的原则\n第29章 优化系统，放飞思想\n第30章 反应能力提升生存能力\n第31章 系统的强弱取决于最薄弱的环节\n第32章 系统的效率与你的感知度成反比\n第33章 功能取决于形式\n第34章 目标明确才能赢得胜利\n第35章 多人负责等于无人负责\n第36章 确定原则，而不是监管制度\n第37章 利用大脑来思考工作，而不是单纯关注工作\n第38章 思考的价值超乎想象\n第39章 资源越是有限，规划越有必要\n</code></pre><h3 id=\"第四部分-放松自我，开始工作\"><a href=\"#第四部分-放松自我，开始工作\" class=\"headerlink\" title=\"第四部分 放松自我，开始工作\"></a>第四部分 放松自我，开始工作</h3><pre><code>第40章 对自己做的事情承担起责任\n第41章 过度控制等于失去控制\n第42章 进展越好，状态越好\n第43章 相信自己的行动选择，需要多层面的自我管理\n第44章 你的力量取决于你的放松能力\n第45章 预料之内的意外算不上意外\n第46章 目光越长远，进展越顺畅\n第47章 放慢速度以提升速度\n第48章 你没有时间做任何项目\n第49章 坚持做好小事，就能产生重大影响\n第50章 亲力亲为才能了解事物\n第51章 动中求变更容易\n第52章 最伟大的成功源自最惨重的失败\n</code></pre><h3 id=\"第五部分-注意基本要素\"><a href=\"#第五部分-注意基本要素\" class=\"headerlink\" title=\"第五部分 注意基本要素\"></a>第五部分 注意基本要素</h3><pre><code>工作流程的5个阶段\n处理与组织整理流程图\n自然式计划模式\n每周回顾指南\n</code></pre><h3 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h3><h3 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h3>\n\n\t<div class=\"row\">\n    <embed src=\"/images/搞定2提升工作与生活效率的52项原则.pdf\" width=\"100%\" height=\"550\" type=\"application/pdf\">\n\t</div>\n\n\n\n","raw":null,"categories":[{"name":"阅读","path":"api/categories/阅读.json"}],"tags":[]},{"title":"Perfect服务器开发环境搭建","slug":"macOS/Perfect服务器开发环境搭建","date":"2017-06-25T09:21:56.000Z","updated":"2017-06-25T09:21:56.000Z","comments":true,"path":"api/articles/macOS/Perfect服务器开发环境搭建.json","excerpt":null,"keywords":null,"cover":"http://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIhEpimhI2nAp5KeoIp9INNABqf9BNBEpyalKYXAJU422oeKbsUcbRpOk_x9xcrFUrgVhrluV4BRqvahkFAJibAJInI20tpXpFpIekJKOXWt834vEp4zbOiBAgwWgmLIRVLiruJd2ngVxfhC1LK1atYoR-wBhTEUxsu1MiK5bxHIo4lCJLMmLL1wkN3dyzdhdaxeLKAI1FebFRMa62J_PDVofvCRqUHJKWjIyr9Iyv8pKo6Aa2nHua8upah1EIUn6Am4xa0bBWUWNc180G00","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>Perfect是一组完整、强大的工具箱、软件框架体系和Web应用服务器，可以在Linux、iOS和macOS (OS X)上使用。该软件体系为Swift工程师量身定制了一整套用于开发轻量、易维护、规模可扩展的Web应用及其它REST服务的解决方案，这样Swift工程师就可以实现同时在服务器和客户端上采用同一种语言开发软件项目。</p>\n<p>由于建立在一个高性能异步网络引擎基础上，Perfect还能够在FastCGI上运行，支持安全套接字加密（SSL）。该软件体系还包含很多其它互联网服务器所需要的特点，包括WebSockets和iOS消息推送，而且很快会有更多强大的功能支持。</p>\n<h2 id=\"SPM-软件包管理器编译项目\"><a href=\"#SPM-软件包管理器编译项目\" class=\"headerlink\" title=\"SPM:软件包管理器编译项目\"></a>SPM:软件包管理器编译项目</h2><p><a href=\"https://github.com/PerfectlySoft/PerfectDocs/blob/master/guide.zh_CN/buildingWithSPM.md\" target=\"_blank\" rel=\"noopener\">https://github.com/PerfectlySoft/PerfectDocs/blob/master/guide.zh_CN/buildingWithSPM.md</a><br>在Perfect Template项目模板是一个标准的SPM项目：</p>\n<ol>\n<li><code>Sources</code> 目录: 包含了所有Perfect项目的Swift源程序文件</li>\n<li><code>Package.swift</code>SPM文件管理清单: 包含了整个项目对其它库函数的依存关系<br>所有的SPM项目至少要包括一个 Sources 目录和一个 Package.swift 文件。而项目模板中目前只有一个依存关系：Perfect-HTTPServer服务器项目<br><img src=\"http://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIhEpimhI2nAp5KeoIp9INNABqf9BNBEpyalKYXAJU422oeKbsUcbRpOk_x9xcrFUrgVhrluV4BRqvahkFAJibAJInI20tpXpFpIekJKOXWt834vEp4zbOiBAgwWgmLIRVLiruJd2ngVxfhC1LK1atYoR-wBhTEUxsu1MiK5bxHIo4lCJLMmLL1wkN3dyzdhdaxeLKAI1FebFRMa62J_PDVofvCRqUHJKWjIyr9Iyv8pKo6Aa2nHua8upah1EIUn6Am4xa0bBWUWNc180G00\"><h3 id=\"swift-SPM文件管理清单\"><a href=\"#swift-SPM文件管理清单\" class=\"headerlink\" title=\"swift SPM文件管理清单\"></a>swift SPM文件管理清单</h3>参数配置的相关含义:<br><code>name</code>: 当前项目的目标名称，可执行文件的名字也会按照这个名称进行编译。<br><code>dependencies[]</code>:依存关系清单组。该内容说明了您的应用程序需要的所有子项目列表，在这个数组中其中每一个条目都包含了一个“.Package”软件包，及其来源URL和版本。<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> PackageDescription</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> package = <span class=\"type\">Package</span>(</span><br><span class=\"line\">    name: <span class=\"string\">\"PerfectTemplate\"</span>, <span class=\"comment\">// 当前项目的目标名称，可执行文件的名字也会按照这个名称进行编译。</span></span><br><span class=\"line\">    targets: [],</span><br><span class=\"line\">    dependencies: [</span><br><span class=\"line\">        .<span class=\"type\">Package</span>(url: <span class=\"string\">\"https://github.com/PerfectlySoft/Perfect-HTTPServer.git\"</span>, majorVersion: <span class=\"number\">2</span>, minor: <span class=\"number\">0</span>),</span><br><span class=\"line\">        .<span class=\"type\">Package</span>(url: <span class=\"string\">\"https://github.com/PerfectlySoft/Perfect-CURL.git\"</span>, majorVersion: <span class=\"number\">2</span>, minor: <span class=\"number\">0</span>),</span><br><span class=\"line\">        .<span class=\"type\">Package</span>(url: <span class=\"string\">\"https://github.com/iamjono/JSONConfig.git\"</span>, majorVersion: <span class=\"number\">0</span>, minor: <span class=\"number\">1</span>),</span><br><span class=\"line\">        .<span class=\"type\">Package</span>(url: <span class=\"string\">\"https://github.com/PerfectlySoft/Perfect-libcurl.git\"</span>, majorVersion: <span class=\"number\">2</span>, minor: <span class=\"number\">0</span>),</span><br><span class=\"line\">        <span class=\"comment\">//        .Package(url: \"https://github.com/dabfleming/Perfect-RequestLogger.git\", majorVersion: 0)</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"SPM项目编译命令\"><a href=\"#SPM项目编译命令\" class=\"headerlink\" title=\"SPM项目编译命令\"></a>SPM项目编译命令</h3><p>SPM提供以下命令用于编译项目，并且清理旧的编译结果</p>\n<ol>\n<li><p>初始化项目，开始编译调试版本<br>先自动下载需要的依存文件，再开始编译，默认生成是调试版本</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swift build</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动调试版本<br>默认编译生成的调试程序在<code>.build/debug/</code>目录下</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.build/debug/PerfectTemplate</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译发行版本<br>执行后可发行版本的可执行程序所在的目录<code>.build/release/</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swift build -c release</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>clean 编译命令<br>删除.build目录，然后重新开始一个全新的编译</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swift build --clean</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>clean磁盘命令<br>删除.build目录和Packages目录，重新下载所有依存关系以获得最新版本对项目的支持。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swift build --clean=dist</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>支持Xcode调试项目命令<br>在同一目录下生成xcode项目，该项目允许编译和调试</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swift package generate-xcodeproj</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>最好不要在这个Xcode项目上直接编辑或增加文件。如果需要更多的依存关系，或者需要下载更新的版本，您需要重新生成这个Xcode项目。因此，在之前您做的任何修改都会被Xcode覆盖。</p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"终端","path":"api/categories/终端.json"}],"tags":[]},{"title":"CoreML机器学习初级教程","slug":"iOS/CoreML机器学习初级教程","date":"2017-06-24T22:10:44.000Z","updated":"2017-06-24T22:24:54.000Z","comments":true,"path":"api/articles/iOS/CoreML机器学习初级教程.json","excerpt":null,"keywords":null,"cover":"http://upload-images.jianshu.io/upload_images/861914-5425960c41207b82.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h3><p><a href=\"https://developer.apple.com/documentation/coreml\" target=\"_blank\" rel=\"noopener\">Core ML开发文档</a><br><a href=\"https://developer.apple.com/machine-learning/\" target=\"_blank\" rel=\"noopener\">ML模型资源页面</a><br>在Working with Models中包含有几个常用的模型模板，例如用于在图片中检测物体——树、动物、人等等。<br><a href=\"https://developer.apple.com/documentation/coreml/integrating_a_core_ml_model_into_your_app\" target=\"_blank\" rel=\"noopener\">Integrating a Core ML Model into Your App</a></p>\n<p><a href=\"https://docs-assets.developer.apple.com/published/51ff0c1668/IntegratingaCoreMLModelintoYourApp.zip\" target=\"_blank\" rel=\"noopener\">官方Core ML文档示例 App</a><br>MarsHabitatPricePredictor 模型的输入只是数字，因此代码直接使用生成的 MarsHabitatPricer 方法和属性，而不是将模型包装在 Vision 模型中。每次都改一下参数，很容易看出模型只是一个线性回归：<br>137 <em> solarPanels + 653.50 </em> greenHouses + 5854 * acres</p>\n<h3 id=\"配置-：将-Core-ML-模型集成到你的-App\"><a href=\"#配置-：将-Core-ML-模型集成到你的-App\" class=\"headerlink\" title=\"配置 ：将 Core ML 模型集成到你的 App\"></a>配置 ：将 Core ML 模型集成到你的 App</h3><p>本教程使用 Places205-GoogLeNet 模型，可以从苹果的<a href=\"https://developer.apple.com/machine-learning/\" target=\"_blank\" rel=\"noopener\">ML</a>页面下载。往下滑找到 Working with Models，下载第一个。还在这个页面，注意一下其它三个模型，它们都用于在图片中检测物体——树、动物、人等等。</p>\n<blockquote>\n<p>注意：如果你有一个训练过的模型，并且是使用受支持的机器学习工具训练的，例如 Caffe、Keras 或 scikit-learn，Converting Trained Models to Core ML 介绍了如何将其转换为 Core ML 格式。</p>\n</blockquote>\n<ol>\n<li>添加模型<br>下载 GoogLeNetPlaces.mlmodel 后，把它从 Finder 拖到项目导航器的 Resources 组里：<br><img src=\"http://upload-images.jianshu.io/upload_images/861914-5425960c41207b82.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n<li>生成模型类<br>选择该文件，然后等一会儿。Xcode 生成了模型类后会显示一个箭头：<br><img src=\"http://upload-images.jianshu.io/upload_images/861914-e00a802f64f0ae13.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n<li>查看模型类<br>点击箭头，查看生成的类：<br><img src=\"http://upload-images.jianshu.io/upload_images/861914-1268b5b918fccf07.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>三个类：<br><code>GoogLeNetPlaces</code>: 主类，包含一个 model 属性和两个 prediction 方法<br><code>GoogLeNetPlacesInput</code>: 输入类,包含一个 CVPixelBuffer 类型的 sceneImage 属性，Vision 框架会负责把我们熟悉的图片格式转换成正确的输入类型。<br><code>GoogLeNetPlacesOutput</code>：输出属性,Vision 框架会将 <code>GoogLeNetPlacesOutput</code> 属性转换为自己的 <code>results</code> 类型.</li>\n</ol>\n<h3 id=\"实现Vision工作流程\"><a href=\"#实现Vision工作流程\" class=\"headerlink\" title=\"实现Vision工作流程\"></a>实现Vision工作流程</h3><p>标准的 Vision 工作流程是创建模型，创建一或多个请求，然后创建并运行请求处理程序。<br>并管理对 <code>prediction</code>方法的调用，所以在所有生成的代码中，我们只会使用 <code>model</code> 属性。</p>\n<ol>\n<li><p>创建模型：在 <code>Vision Model</code> 中包装 <code>Core ML Model</code><br>CoreML模型 是用于 Vision 请求的 Core ML 模型的容器<br>打开 ViewController.swift，并在 import UIKit 下面 import 两个框架：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> CoreML</span><br><span class=\"line\"><span class=\"keyword\">import</span> Vision</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建<code>VNCoreMLRequest</code>图像分析请求<br><code>VNCoreMLRequest</code> 是一个图像分析请求，它使用 Core ML 模型来完成工作。它的 completion handler 接收 request 和 error 对象。<br>Core ML 模型<code>GoogLeNetPlaces</code> 是一个分类器，因为它仅预测一个特征：图像的场景分类。这时request.results 是 <code>VNClassificationObservation</code> 对象数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建一个带有 completion handler 的 Vision 请求</span><br><span class=\"line\">let request = VNCoreMLRequest(model: model) &#123; [weak self] request, error in</span><br><span class=\"line\">    guard let results = request.results as? [VNClassificationObservation],</span><br><span class=\"line\">    let topResult = results.first else &#123;</span><br><span class=\"line\">    fatalError(&quot;unexpected result type from VNCoreMLRequest&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 在主线程上更新 UI</span><br><span class=\"line\">let article = (self?.vowels.contains(topResult.identifier.first!))! ? &quot;an&quot; : &quot;a&quot;</span><br><span class=\"line\">    DispatchQueue.main.async &#123; [weak self] in</span><br><span class=\"line\">        self?.answerLabel.text = &quot;\\(Int(topResult.confidence * 100))% it&apos;s \\(article) \\(topResult.identifier)&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>VNClassificationObservation 有两个属性：identifier - 一个 String，以及 confidence - 介于0和1之间的数字，这个数字是是分类正确的概率。使用对象检测模型时，你可能只会看到那些 confidence 大于某个阈值的对象，例如 30％ 的阈值。<br>然后取第一个结果，它会具有最高的 confidence 值，然后根据 identifier 的首字母把不定冠词设置为“a”或“an”。最后，dispatch 回到主线程来更新 label。你很快会明白分类工作为什么不在主线程，因为它会很慢。</p>\n<h3 id=\"创建并运行VNImageRequestHandler请求处理程序\"><a href=\"#创建并运行VNImageRequestHandler请求处理程序\" class=\"headerlink\" title=\"创建并运行VNImageRequestHandler请求处理程序\"></a>创建并运行VNImageRequestHandler请求处理程序</h3><p><code>VNImageRequestHandler</code> 是标准的 Vision 框架请求处理程序；不特定于 Core ML 模型。给它 image 作为 detectScene(image:) 的参数。然后调用它的 perform 方法来运行处理程序，传入请求数组。在这个例子里，我们只有一个请求。<br>把下面几行添加到 <code>detectScene(image:)</code> 的末尾：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在主线程上运行 Core ML GoogLeNetPlaces 分类器</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> handler = <span class=\"type\">VNImageRequestHandler</span>(ciImage: image)</span><br><span class=\"line\"><span class=\"type\">DispatchQueue</span>.global(qos: .userInteractive).async &#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> handler.perform([request])</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用模型来自动识别场景\"><a href=\"#使用模型来自动识别场景\" class=\"headerlink\" title=\"使用模型来自动识别场景\"></a>使用模型来自动识别场景</h3><p>在两个地方调用 <code>detectScene(image:)</code><br>把下面几行添加到 viewDidLoad() 的末端和 imagePickerController(_:didFinishPickingMediaWithInfo:) 的末端：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">guard let ciImage = CIImage(image: image) else &#123;</span><br><span class=\"line\">    fatalError(&quot;couldn&apos;t convert UIImage to CIImage&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">detectScene(image: ciImage)</span><br></pre></td></tr></table></figure></p>\n<p>现在构建并运行。</p>\n<ol>\n<li>场景一:<br>机器识别出了50%的概率是摩天大厦<br><img src=\"http://upload-images.jianshu.io/upload_images/861914-bb5bec38118f91ff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n<li>场景二<br>机器人识别出了75%的概率是水族池<br><img src=\"http://upload-images.jianshu.io/upload_images/861914-e194482f995324a1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n</ol>\n<h3 id=\"什么是深度学习\"><a href=\"#什么是深度学习\" class=\"headerlink\" title=\"什么是深度学习\"></a>什么是深度学习</h3><p>自20世纪50年代以来，AI 研究人员开发了许多机器学习方法。苹果的 Core ML 框架支持神经网络、树组合、支持向量机、广义线性模型、特征工程和流水线模型。但是，神经网络最近已经取得了很多极为神奇的成功，开始于 2012 年谷歌使用 YouTube 视频训练 AI 来识别猫和人。仅仅五年后，谷歌正在赞助一场确定 5000 种植物和动物的比赛。像 Siri 和 Alexa 这样的 App 也存在它们自己的神经网络。<br>神经网络尝试用节点层来模拟人脑流程，并将节点层用不同的方式连接在一起。每增加一层都需要增加大量计算能力：Inception v3，一个对象识别模型，有48层以及大约2000万个参数。但计算基本上都是矩阵乘法，GPU 来处理会非常有效。GPU 成本的下降使我们能够创建多层深度神经网络，此为深度学习。<br>神经网络，circa 2016<br>神经网络需要大量的训练数据，这些训练数据理想化地代表了全部可能性。用户生成的数据爆炸性地产生也促成了机器学习的复兴。<br>训练模型意味着给神经网络提供训练数据，并让它计算公式，此公式组合输入参数以产生输出。训练是离线的，通常在具有多个 GPU 的机器上。<br>要使用这个模型，就给它新的输入，它就会计算输出：这叫做推论。推论仍然需要大量计算，以从新的输入计算输出。因为有了 Metal 这样的框架，现在可以在手持设备上进行这些计算。<br>在本教程的结尾你会发现，深度学习远非完美。真的很难建立具有代表性的训练数据，很容易就会过度训练模型，以至于它会过度重视一些古怪的特征。<br>苹果提供了什么？<br>苹果在 iOS 5 里引入了 NSLinguisticTagger 来分析自然语言。iOS 8 出了 Metal，提供了对设备 GPU 的底层访问。<br>去年，苹果在 Accelerate 框架添加了 Basic Neural Network Subroutines (BNNS)，使开发者可以构建用于推理（不是训练）的神经网络。<br>今年，苹果给了我们 Core ML 和 Vision！<br>Core ML 让我们更容易在 App 中使用训练过的模型。<br>Vision 让我们轻松访问苹果的模型，用于面部检测、面部特征点、文字、矩形、条形码和物体。<br>你还可以在 Vision 模型中包装任意的图像分析 Core ML 模型，我们在这篇教程中就干这个。由于这两个框架是基于 Metal 构建的，它们能在设备上高效运行，所以不需要把用户的数据发送到服务器。</p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"API","path":"api/categories/API.json"}],"tags":[]},{"title":"iOS11ARKit初探","slug":"iOS/iOS11ARKit初探","date":"2017-06-24T19:46:59.000Z","updated":"2017-06-24T22:24:54.000Z","comments":true,"path":"api/articles/iOS/iOS11ARKit初探.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"iOS11新技术\"><a href=\"#iOS11新技术\" class=\"headerlink\" title=\"iOS11新技术\"></a>iOS11新技术</h2><h3 id=\"ARKit教程\"><a href=\"#ARKit教程\" class=\"headerlink\" title=\"ARKit教程\"></a>ARKit教程</h3><p>增强现实(AR)描述用户体验，将2D或3D元素从设备的摄像头中添加到实时视图中，从而使这些元素出现在真实世界中。ARKit结合了设备运动跟踪，摄像镜头捕捉，先进的场景处理，以及显示方便来简化建立AR体验的任务。<br><a href=\"https://developer.apple.com/documentation/arkit\" target=\"_blank\" rel=\"noopener\">ARKit开发文档</a></p>\n<h4 id=\"理解-Augmented-Reality\"><a href=\"#理解-Augmented-Reality\" class=\"headerlink\" title=\"理解 Augmented Reality\"></a>理解 Augmented Reality</h4><p>理解AR概念、特性和最佳实践来构建很好的AR体验，<br><code>ARSession</code>：一个共享对象，可以管理增强现实体验所需的设备摄像头和运动处理。</p>\n<h4 id=\"AR相关配置\"><a href=\"#AR相关配置\" class=\"headerlink\" title=\"AR相关配置\"></a>AR相关配置</h4><p><code>ARSessionConfiguration</code>:只记录设备方向的轨迹的基本配置<br><code>ARWorldTrackingSessionConfiguration</code>:一种跟踪设备定位和位置的配置，它可以检测设备摄像头看到的真实表面。</p>\n<h4 id=\"AR标准视图\"><a href=\"#AR标准视图\" class=\"headerlink\" title=\"AR标准视图\"></a>AR标准视图</h4><p><a href=\"https://developer.apple.com/documentation/arkit/building_a_basic_ar_experience\" target=\"_blank\" rel=\"noopener\">一个基本的AR体验DEMO</a><br>配置一个AR会话并使用SceneKit或SpriteKit来显示AR内容</p>\n<ol>\n<li><a href=\"https://developer.apple.com/documentation/arkit/arscnview/providing_3d_virtual_content_with_scenekit\" target=\"_blank\" rel=\"noopener\">Providing 3D Virtual Content with SceneKit</a><br> <code>ARSCNView</code>:一种显示AR体验的视图，它通过3D SceneKit内容增强了相机视图。</li>\n<li><a href=\"https://developer.apple.com/documentation/arkit/arskview/providing_2d_virtual_content_with_spritekit\" target=\"_blank\" rel=\"noopener\">Providing 2D Virtual Content with SpriteKit</a><br> <code>ARSKView</code>:一种显示AR体验的视图，增加了2D SpriteKit内容的摄像头视图。</li>\n</ol>\n<p>借助 ARKit 和 Core ML，基于 iOS 11 进行开发。<br>iOS 11 为开发者带来了各种可能性。借助 ARKit，开发者可将生动逼真的增强现实带到 app 之中。而有了 Core ML，开发者可利用机器学习来创建各种更智能的 app。<br><a href=\"https://developer.apple.com/cn/ios/\" target=\"_blank\" rel=\"noopener\">进一步了解基于 iOS 11 的开发</a></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"API","path":"api/categories/API.json"}],"tags":[]},{"title":"plantuml语法概览","slug":"导图/plantuml语法概览","date":"2017-06-24T18:08:49.000Z","updated":"2018-05-29T13:58:23.000Z","comments":true,"path":"api/articles/导图/plantuml语法概览.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script>\n\n\t<div class=\"row\">\n    <embed src=\"http://p27uwfdhv.bkt.clouddn.com/static/pdf/PlantUML_Language_Reference_Guide_ZH.pdf\" width=\"100%\" height=\"550\" type=\"application/pdf\">\n\t</div>\n\n\n\n","raw":null,"categories":[{"name":"导图","path":"api/categories/导图.json"}],"tags":[]}]}