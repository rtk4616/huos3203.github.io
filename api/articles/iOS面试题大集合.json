{"title":"iOS面试题大集合[转]","slug":"iOS面试题大集合","date":"2017-01-22T18:55:21.000Z","updated":"2017-01-22T18:55:21.000Z","comments":true,"path":"api/articles/iOS面试题大集合.json","excerpt":null,"covers":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h1 align=\"center\">iOS有用的面试题大集合</h1>\n\n<h2 id=\"面试题从何处得来\"><a href=\"#面试题从何处得来\" class=\"headerlink\" title=\"面试题从何处得来\"></a>面试题从何处得来</h2><ul>\n<li><a href=\"http://blog.sunnyxx.com/2015/07/04/ios-interview/\" target=\"_blank\" rel=\"noopener\">招聘一个靠谱的 iOS</a></li>\n<li><a href=\"http://www.zhihu.com/question/19604641\" target=\"_blank\" rel=\"noopener\">知乎－如何面试 iOS 工程师？</a></li>\n</ul>\n<h2 id=\"阅读面试题之前\"><a href=\"#阅读面试题之前\" class=\"headerlink\" title=\"阅读面试题之前\"></a>阅读面试题之前</h2><p>在正式开始之前，我期望你能对iOS/Mac OS X平台开发有所了解，在iOS开发中已经很少需要自己写复杂的算法了，一般情况下很少会在面试中出现算法的考核，如果你了解一些基础的算法，还是有帮助的。</p>\n<p>Now！！请使用ARC</p>\n<h3 id=\"什么是iOS开发\"><a href=\"#什么是iOS开发\" class=\"headerlink\" title=\"什么是iOS开发\"></a>什么是iOS开发</h3><p>iOS是iPhone iPad等手持设备的操作系统，所谓的iOS开发就是开发运行在iOS系统上的应用或者游戏，比如支付宝，微信，微博等，当然这也包括了iPad版的应用，iOS开发可以归纳到<strong>移动开发</strong>领域。</p>\n<p><strong>有时候面试官是那种’脑残粉’，了解一下Apple的发展历史，可能比较聊的开。</strong></p>\n<p><a href=\"http://digi.tech.qq.com/a/20150127/021898.htm\" target=\"_blank\" rel=\"noopener\">苹果Mac计算机31年发展历程回顾</a></p>\n<p><a href=\"http://baike.baidu.com/link?url=68F4Bl4llkNvdFJ1Md0fkZDDudN-NS46JeZoLrgPeqEbZmm8oBKG92Ocyd983yNQU6FVuDTFZOnjjPjfUHnuoePdfh6zJJ973pXFKYcbIKp5bCnQy_WvUVNJ6P84s8HE1xAlRaGdLVuoCb2p_8uaMa\" target=\"_blank\" rel=\"noopener\">苹果公司</a></p>\n<p><a href=\"http://www.zhihu.com/topic/19551762\" target=\"_blank\" rel=\"noopener\">苹果公司在知乎上的话题</a></p>\n<p><a href=\"http://www.amazon.cn/%E5%8F%B2%E8%92%82%E5%A4%AB%C2%B7%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0-%E6%B2%83%E5%B0%94%E7%89%B9%C2%B7%E8%89%BE%E8%90%A8%E5%85%8B%E6%A3%AE/dp/B00IM4IFL2/ref=sr_1_1?ie=UTF8&amp;qid=1436592631&amp;sr=8-1&amp;keywords=%E4%B9%94%E5%B8%83%E6%96%AF\" target=\"_blank\" rel=\"noopener\">乔布斯个人传记</a></p>\n<h3 id=\"拼写正确的重要性\"><a href=\"#拼写正确的重要性\" class=\"headerlink\" title=\"拼写正确的重要性\"></a>拼写正确的重要性</h3><p>有些面试官可能更注重细节，所以，拼写的单词一定要对，比如iOS，Xcode，iPhone，Objective-C，JSON等，良好的拼写习惯，会让面试官觉得你细心靠谱。</p>\n<h3 id=\"Swift和Objective-C的比较\"><a href=\"#Swift和Objective-C的比较\" class=\"headerlink\" title=\"Swift和Objective-C的比较\"></a>Swift和Objective-C的比较</h3><p>仁者见仁智者见智，从个人的使用角度上来看，Swift在某些情况上比Objective-C更加的严谨了，入门非常简单，但是想开发应用，还是需要学习cocoa框架，这玩意路子还是Objective-C的，所以有基础可能更好的理解Swift在iOS/Mac OS X 中的开发和应用。</p>\n<p><a href=\"http://www.zhihu.com/question/24002984\" target=\"_blank\" rel=\"noopener\">知乎原文</a></p>\n<h3 id=\"了解Watch-OS\"><a href=\"#了解Watch-OS\" class=\"headerlink\" title=\"了解Watch OS\"></a>了解Watch OS</h3><p><code>Watch OS</code>是苹果公司推出的应用在手表上的一个操作系统，<code>Watch OS 1.0</code>需要跟iPhone相结合才能工作。</p>\n<p><a href=\"https://stratechery.com/2014/apple-watch-asking-saying/\" target=\"_blank\" rel=\"noopener\">Apple Watch</a></p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=208847424&amp;idx=1&amp;sn=fac57c5da8136b07fe9cdf53d1ec9f4c#rd\" target=\"_blank\" rel=\"noopener\">Watch OS 2.0 开发概述</a></p>\n<hr>\n<h2 id=\"iOS面试\"><a href=\"#iOS面试\" class=\"headerlink\" title=\"iOS面试\"></a>iOS面试</h2><h5>property 后面可以有哪些修饰符</h5>\n\n<ol>\n<li><p>读写修饰符 <code>readwrite</code> | <code>readonly</code></p>\n<p> <code>readwrite</code> Xcode会帮助我们创建<code>setter</code>，<code>getter</code>方法，<code>readonly</code> Xcode只会帮助我们创建<code>getter</code>方法，不会创建<code>setter</code>方法。</p>\n</li>\n<li><p><code>setter</code>相关的修饰符 <code>assign</code> | <code>retain</code> | <code>copy</code></p>\n<p> 2.1 <code>setter</code>相关的修饰符表明了<code>setter</code>方法该如何实现，<code>assign</code>用于基本数据类型<code>NSInteger</code>，<code>CGFloat</code>，C数据类型<code>int</code>，<code>float</code>，<code>id</code>类型等，这个符号不会涉及内存管理，但是如果是对象类使用了它，可能会导致内存泄漏或者<code>EXC_BAD_ACCESS</code>错误。</p>\n<p> 2.2 <code>retain</code>用于对象类的内存管理，如果基本数据类型使用它，<code>Xcode</code>会直接报错。当对象类使用此修饰符时，<code>setter</code>方法的实现是先<code>release</code>一次，然后再对新的对象做一次<code>retain</code>操作。</p>\n<p> 2.3 <code>copy</code>主要用于<code>NSString</code>，用于内容复制。</p>\n</li>\n<li><p>原子性修饰符 <code>atomic</code> | <code>nonatomic</code></p>\n<p> <code>atomic</code> 表示线程安全</p>\n<p> <code>nonatomic</code> 表示非线程安全，使用此修饰符会提高性能</p>\n</li>\n<li><p><code>getter</code>，<code>setter</code>修饰符</p>\n<p> 这两个修饰符用于设置生成的getter，setter的方法名</p>\n</li>\n<li><p><code>strong</code>，<code>weak</code>修饰符（ARC）<br>在ARC中内存管理都只需要使用这两个修饰符，而且<code>strong</code>是默认全局的，只要你写了<code>Objective-C</code>的对象，不自己添加<code>weak</code>的话，默认就是<code>strong</code>。<br> 5.1 <code>strong</code>表示这个对象的拥有者<br> 一个对象可以有多个拥有者，<code>strong</code>就是用来表示对这个对象的拥有。比如在往<code>NSMutableArray</code>中添加<code>Objective-C</code>对象，当你从数组中删除时，这个对象并不会释放。需要你手动设置为<code>nil</code>，或者在控制器的生命周期内，由系统来释放。<br> 5.2 <code>weak</code>指针变量仍然可以指向一个对象，但不是这个对象的拥有者<br> <code>weak</code>修饰的指针变量也可以指向对象，但不是这个对象的实际拥有者，也就是说<code>weak</code>修饰的指针变量如果想要释放，需要<code>strong</code>修饰的指针变量设置为<code>nil</code>，<code>weak</code>修饰的指针变量也会是一个<code>nil</code>，它指向的对象已经没有了，还需要设置<code>weak</code>修饰的指针变量为<code>nil</code>。</p>\n</li>\n<li><code>nonnull</code> <code>nullable</code> <code>null_resettable</code></li>\n</ol>\n<p>Xcode 6.3推出的<code>nullability annotations</code>，主要是为了更好的Swift与Objective-C混编，在Swift中有可选型的概念<code>!</code>,<code>?</code>，但是Objective-C中木有这玩意，于是Xcode 6.3中才有了这个，<br>从字面可以看出:<br>    <code>nonnull</code> 表示对象不应该为空，如果是这个修饰符对应的就是Swift中已经解包的对象或者<code>!</code><br>    <code>nullable</code>表示可以为<code>nil</code>或者<code>NULL</code>,对应是Swift中的可选<code>?</code><br>    <code>null_resettable</code>则是表达属性的空属性，该属性<code>setter</code>访问器允许将其设置为<code>nil</code>（设置该属性为默认值），但是它的<code>getter</code>访问器不会提供一个<code>nil</code>值（因为它提供了默认值），有一个这样的属性如UIView’s tintColor，如果没有tint颜色指定时它会提供一个默认的tint颜色值，对应的Swift使用是var tintColor:UIColor!</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><ol>\n<li>使用 <code>weak</code> 关键字，相比 <code>assign</code> 有什么不同<br> 一般情况下使用<code>weak</code>是避免循环引用，因为它不是对象的拥有者。而<code>assign</code>则是用于基本数据类型，或者C类型，而且<code>assign</code>是直接赋值，可能会导致一个问题。比如我想a和b共用一块内存，a是用<code>assign</code>修饰的，<code>a = b</code>，现在a使用的目的已经完成，我想释放这个内存，但是a并不知道b到底用没用完，如果此时a释放内存，而b还在使用，那么会导致应用程序crash，使用<code>weak</code>就能避免这样的问题。</li>\n<li>怎么用 copy 关键字<br> <code>copy</code>拷贝的是内容,<code>retain</code>是拷贝的指针<pre><code>* 以`string`为例,如果`string`的属性为`copy`的话,那么传入参数为`NSString`的话,即为不可变`string`,`retain`,`copy`效果一样.\n* 如果传入参数是`mutable`的话,那么`copy`拷贝内容,源随意变化不影响该属性的值.`retain`拷贝指针,源变化则属性值着变化,因为属性和源指向如何使用呢,通常在需要拷贝内容,但是副本和源不要互相影响的情况下使用.`*` 同一内存地址.\n* 例如`array/dictionary`中,可能会需要一个副本来做一些操作(筛选,排序等),但是并不希望影响原始值,则可以使用`copy`\n</code></pre></li>\n<li>@property (copy) NSMutableArray *array; 这样写有什么问题吗<br> 因为用了<code>copy</code>, 内部会深拷贝一次, 指针实际指向的是<code>NSArray</code>, 所以如果调用<code>removeObject</code>和<code>addObject</code>方法的话, 会<code>unRecognized selector</code></li>\n<li>如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？<br> 当一个对象发生改变时不影响另外一个对象，这里就需要使用<code>copy</code>关键字了，实现<code>NSCopying</code>协议，重写- <code>(id)copyWithZone:(NSZone *)zone</code>方法。<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(_name != name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _name = [name <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>@protocol 和 category 中如何使用 @property<br> <code>@protocol</code>可以通过关键字:<code>@synthesize</code>或者在继承的类里面重新定义一次该属性(<code>extension</code>里面定义是不行的)<br> <code>category</code>通过关联:<code>objc_setAssociatedObject</code>/<code>objc_getAssociatedObject</code></li>\n<li><code>@property</code> 的本质是什么？<code>ivar</code>、<code>getter</code>、<code>setter</code> 是如何生成并添加到这个类中的<br> <code>@property</code>本质是定义一个<code>objc_property</code>结构体<br><strong>如何生成目前不清楚</strong></li>\n<li><code>weak</code>属性需要在<code>dealloc</code>中置<code>nil</code>么<br> 不需要，因为weak会自动设置nil</li>\n<li><code>@synthesize</code>和@<code>dynamic</code>分别有什么作用<br> 关于@synthesize（现在已经不需要在写这个属性了，它是用来生成getter和setter方法）<br> <code>@dynamic</code> 就是要告诉编译器<code>getter</code>和<code>setter</code>方法会在程序运行或者用到动态绑定的方式，以便让编译器通过编译，这个主要要在<code>NSManagerObject</code>上。</li>\n<li><code>ARC</code>下，不显式指定任何属性关键字时，默认的关键字都有哪些<br> 在默认情况下，所有的实例变量和局部变量都是<code>strong</code>类型的。</li>\n<li>用<code>@property</code>声明的<code>NSString</code>（或<code>NSArray</code>，<code>NSDictionary</code>）经常使用<code>copy</code>关键字，为什么？如果改用strong关键字，可能造成什么问题<br>因为不想改变了其中的值后把原来的值也跟着改变了，用了<code>strong</code>后会出现这样的状况。</li>\n<li>什么是ARC<br>请阅读，然后随便谈谈你的理解即可。<br>ARC是为了解决下面几个问题<ul>\n<li>当我们要释放一个堆内存时，首先要确定指向这个堆空间的指针都被<code>release</code>了。（避免提前释放）</li>\n<li>释放指针指向的堆空间，首先要确定哪些指针指向同一个堆，这些指针只能释放一次。（<code>MRC</code>下即谁创建，谁释放，避免重复释放）</li>\n<li>模块化操作时，对象可能被多个模块创建和使用，不能确定最后由谁去释放。</li>\n<li>多线程操作时，不确定哪个线程最后使用完毕<br><a href=\"http://onevcat.com/2012/06/arc-hand-by-hand/\" target=\"_blank\" rel=\"noopener\">手把手教你ARC——iOS/Mac开发ARC入门和使用</a><br><a href=\"http://www.oschina.net/translate/objc-automatic-reference-counting-in-xcode-explained\" target=\"_blank\" rel=\"noopener\">理解 Objective-C 的 ARC</a></li>\n</ul>\n</li>\n<li>请解释以下keywords的区别： <code>assign</code> vs <code>weak</code>, <code>block</code> vs <code>weak</code><br><code>assign</code>适用于基本数据类型，<code>weak</code>是适用于<code>NSObject</code>对象，并且是一个弱引用。<ul>\n<li><code>assign</code>其实也可以用来修饰对象，那么我们为什么不用它呢？<br>因为被<code>assign</code>修饰的对象在释放之后，指针的地址还是存在的，也就是说指针并没有被置为<code>nil</code>。如果在后续的内存分配中，刚好分到了这块地址，程序就会崩溃掉。</li>\n<li><code>weak</code>修饰的对象在释放之后，指针地址会被置为<code>nil</code>。所以现在一般弱引用就是用<code>weak</code>。</li>\n<li><code>block</code>是用来修饰一个变量，这个变量就可以在<code>block</code>中被修改，使用<code>block</code>修饰的变量在<code>block</code>代码快中会被<code>retain</code>（<code>ARC</code>下，<code>MRC</code>下不会<code>retain</code>） </li>\n<li><code>weak</code>：使用<code>weak</code>修饰的变量不会在<code>block</code>代码块中被<code>retain</code>同时，在ARC下，要避免<code>block</code>出现循环引用 <code>weak typedof(self)weakSelf = self</code></li>\n</ul>\n</li>\n<li><code>__block</code>在<code>arc</code>和<code>非arc</code>下含义一样吗<br>是不一样的，ARC会retain，非ARC不会。</li>\n<li>描述一个你遇到过的<code>retain</code> cycle例子<br>在<code>viewController</code>中避免循环引用<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ downloadData:^(<span class=\"keyword\">id</span> responseData)&#123;</span><br><span class=\"line\">    _data = responseData;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>  \n解决办法<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">weak</span> ViewController *weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">[ downloadData:^(<span class=\"keyword\">id</span> responseData)&#123;</span><br><span class=\"line\">    weakSelf.data = responseData;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></li>\n<li><code>+(void)load;</code> <code>+(void)initialize;</code>有什么用处<br>在Objective-C中，<code>runtime</code>会自动调用每个类的两个方法。<code>+load</code>会在类初始加载时调用，<code>+initialize</code>会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。<br>共同点：两个方法都只会被调用一次。</li>\n<li><code>UIView</code>和<code>CALayer</code>有什么关系<ul>\n<li><code>UIView</code>是iOS界面元素的基础，所有的界面元素都继承于它。它本身是由<code>CoreAnimation</code>来实现的，它真正绘图的部分是由一个<code>CALayer</code>的类来管理的，<code>UIView</code>本身更像是一个<code>CALayer</code>的管理器。</li>\n<li><code>UIView</code>都存在一个<code>layer</code>属性，可以访问到<code>CALayer</code>的实例。</li>\n<li><code>UIView</code>的<code>CALayer</code>类也存在一个<code>view</code>树结构，可以像<code>UIView</code>一样进行添加</li>\n<li><code>UIView</code>的<code>layer</code>树在系统内部，由系统来维护，它存在着三棵树，分别是逻辑树，动画树，显示树</li>\n</ul>\n</li>\n<li>如何高性能的给<code>UIImageView</code>加个圆角<ul>\n<li>使用贝塞尔曲线来切割图片</li>\n<li>使用<code>Quartz2D</code>直接绘制图片</li>\n</ul>\n</li>\n<li>使用<code>drawRect</code>有什么影响<br><code>drawRect</code>方法依赖<code>Core Graphics</code>框架来进行自定义的绘制，但这种方法主要的缺点就是它处理<code>touch</code>事件的方式：每次按钮被点击后，都会用<code>setNeddsDisplay</code>进行强制重绘；而且不止一次，每次单点事件触发两次执行。这样的话从性能的角度来说，对<code>CPU</code>和内存来说都是欠佳的。</li>\n<li>SDWebImage里面给UIImageView加载图片的逻辑是什么样的<br>详情看<a href=\"http://www.cnblogs.com/6duxz/p/4159572.html\" target=\"_blank\" rel=\"noopener\">最新版SDWebImage的使用</a></li>\n<li>麻烦你设计个简单的图片内存缓存器<br>图片的内存缓存，可以考虑将图片数据保存到一个数据模型中，所以在程序运行时这个模型都存在内存中，一定要具备移除策略，即释放数据模型。</li>\n<li>讲讲你用<code>Instrument</code>优化动画性能的经历<br><a href=\"http://www.hrchen.com/2013/05/performance-with-instruments/\" target=\"_blank\" rel=\"noopener\">怎么使用instrument</a></li>\n<li><code>loadView</code>是干嘛用的<br>当你访问一个<code>ViewController</code>的<code>view</code>属性时，如果此时<code>view</code>的值是<code>nil</code>，那么，<code>ViewController</code>就会自动调用<code>loadView</code>这个方法。这个方法就会加载或者创建一个<code>view</code>对象，赋值给<code>view</code>属性。<br><code>loadView</code>默认做的事情是：如果此<code>ViewController</code>存在一个对应的<code>nib</code>文件，那么就加载这个<code>nib</code>。否则，就创建一个<code>UIView</code>对象。<br>如果你用<code>Interface Builder</code>来创建界面，那么不应该重载这个方法。<br>如果你想自己创建<code>view</code>对象，那么可以重载这个方法。此时你需要自己给<code>view</code>属性赋值。你自定义的方法不应该调用<code>super</code>。如果你需要对<code>view</code>做一些其他的定制操作，在<code>viewDidLoad</code>里面去做。<br><a href=\"http://www.cnblogs.com/dyllove98/archive/2013/06/06/3123005.html\" target=\"_blank\" rel=\"noopener\">iOS 的loadView 及使用loadView中初始化View注意的问题</a></li>\n<li>用过<code>CoreData</code>或者<code>SQLite</code>吗？读写是分线程的吗？遇到过死锁没？咋解决的<br>参考<a href=\"http://blog.csdn.net/hanangellove/article/details/44966769\" target=\"_blank\" rel=\"noopener\">CoreData与SQLite的线程安全</a></li>\n<li><code>GCD</code>里面有哪几种<code>Queue</code>？你自己建立过串行<code>queue</code>吗？背后的线程模型是什么样的<ul>\n<li>主队列 <code>dispatch_main_queue();</code> 串行 ，更新UI</li>\n<li>全局队列 <code>dispatch_global_queue();</code> 并行，四个优先级：<code>background</code>，<code>low</code>，<code>default</code>，<code>high</code></li>\n<li>自定义队列 <code>dispatch_queue_t queue;</code> 可以自定义是并行：<code>DISPATCH_QUEUE_CONCURRENT</code>或者串行<code>DISPATCH_QUEUE_SERIAL</code></li>\n</ul>\n</li>\n<li>为什么其他语言里叫函数调用， <code>Objective-C</code>里则是给对象发消息（或者谈下对<code>runtime</code>的理解）<br>网上关于<code>runtime</code>的资料非常多，其实这方面在平时的开发中使用非常非常之少，底层的黑魔法。<br><a href=\"http://www.jianshu.com/p/25a319aee33d\" target=\"_blank\" rel=\"noopener\">Objective-C特性：Runtime</a><br><a href=\"http://tech.glowing.com/cn/objective-c-runtime/\" target=\"_blank\" rel=\"noopener\">Objective-C Runtime</a></li>\n<li>什么是<code>method swizzling</code><br>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是<code>selector</code>的名字。利用<code>Objective-C</code>的动态特性，可以实现在运行时偷换<code>selector</code>对应的方法实现，达到给方法挂钩的目的。<br><a href=\"http://blog.csdn.net/yiyaaixuexi/article/details/9374411\" target=\"_blank\" rel=\"noopener\">详细的案例</a></li>\n<li>runtime 如何实现 weak 属性 <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJC_ASSOCIATION_ASSIGN</span><br><span class=\"line\">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><br><span class=\"line\">OBJC_ASSOCIATION_COPY_NONATOMIC</span><br><span class=\"line\">OBJC_ASSOCIATION_RETAIN</span><br><span class=\"line\">OBJC_ASSOCIATION_COPY</span><br><span class=\"line\">objc_setAssociatedObject(<span class=\"keyword\">self</span>, &amp;myKey, anObject, OBJC_ASSOCIATION_RETAIN);</span><br></pre></td></tr></table></figure>\n可以自定义<code>weak</code>来实现内存管理，Apple已经为我们准备了常量。<br>参考<br><a href=\"http://nshipster.cn/associated-objects/\" target=\"_blank\" rel=\"noopener\">Associated Objects</a><br><a href=\"http://southpeak.github.io/blog/2014/10/30/objective-c-runtime-yun-xing-shi-zhi-er-:cheng-yuan-bian-liang-yu-shu-xing/\" target=\"_blank\" rel=\"noopener\">Objective-C Runtime 运行时之二：成员变量与属性</a></li>\n<li><code>objc</code>中向一个<code>nil</code>对象发送消息将会发生什么<br><code>objc</code>的特性是允许对一个 <code>nil</code> 对象发送消息不会 Crash，因为会被忽略掉。</li>\n<li>什么时候会报<code>unrecognized selector</code>的异常<br>调用一个不存在的方法</li>\n<li><code>objc</code>中向一个对象发送消息<code>[obj foo]</code>和<code>objc_msgSend()</code>函数之间有什么关系<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[obj foo];</span><br><span class=\"line\"><span class=\"comment\">//编译时会变成</span></span><br><span class=\"line\">objc_msgSend(obj,<span class=\"keyword\">@selector</span>(foo));</span><br><span class=\"line\"></span><br><span class=\"line\">[obj foo:parameter];</span><br><span class=\"line\"><span class=\"comment\">//编译时会变成</span></span><br><span class=\"line\">objc_msgSend(obj,<span class=\"keyword\">@selector</span>(foo:),parameter);</span><br></pre></td></tr></table></figure></li>\n<li>一个objc对象如何进行内存布局<br>可参考<a href=\"http://www.cnblogs.com/csutanyu/archive/2011/12/12/objective-c_memory_layout.html\" target=\"_blank\" rel=\"noopener\">Objective-C内存布局</a></li>\n<li>一个objc对象的isa的指针指向什么？有什么作用？<br>isa是一个Class 类型的指针. 每个实例对象有个isa的指针,他指向对象的类，而Class里也有个isa的指针, 指向meteClass(元类)。元类保存了类方法的列表。当类方法被调用时，先会从本身查找类方法的实现，如果没有，元类会向他父类查找该方法。同时注意的是：元类（meteClass）也是类，它也是对象。元类也有isa指针,它的isa指针最终指向的是一个根元类(root meteClass).根元类的isa指针指向本身，这样形成了一个封闭的内循环。</li>\n<li>下面的代码输出什么<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Son</span> : <span class=\"title\">Father</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">super</span> <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n输出Son</li>\n<li>runtime如何通过selector找到对应的IMP地址<br>id (*IMP)(id, SEL, …)<br>这个函数使用当前CPU架构实现的标准的C调用约定。第一个参数是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是方法选择器(selector)，接下来是方法的实际参数列表。<br>前面介绍过的SEL就是为了查找方法的最终实现IMP的。由于每个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确地获得它所对应的IMP，查找过程将在下面讨论。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。<br>通过取得IMP，我们可以跳过Runtime的消息传递机制，直接执行IMP指向的函数实现，这样省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些。</li>\n</ol>\n<h2 id=\"Hybrid-混合开发\"><a href=\"#Hybrid-混合开发\" class=\"headerlink\" title=\"Hybrid 混合开发\"></a>Hybrid 混合开发</h2>","categories":[{"name":"资源","path":"api/categories/资源.json"}],"tags":[{"name":"汇总","path":"api/tags/汇总.json"},{"name":"资源","path":"api/tags/资源.json"},{"name":"面试","path":"api/tags/面试.json"}]}