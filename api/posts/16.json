{"total":157,"pageSize":10,"pageCount":16,"data":[{"title":"instrument之Zombie工具","slug":"调试/instrument之Zombie工具","date":"2014-07-01T19:54:02.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/调试/instrument之Zombie工具.json","excerpt":null,"keywords":null,"cover":"/images/templateOfTraceDcument.jpg","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>Zombie:针对<strong>僵尸对象</strong>导致应用程序崩溃，即已经<code>deallocated</code>的对象，它们的<code>retainCount</code>计数器已经为0，通过正常的手段是无法在<code>debug</code>中跟踪和观察到的。</p>\n<p>如果你开启了 <code>Zombie Enabled</code> ，则当 Zombie 问题出现时，控制台会输出 Zombie 对象的地址，且程序会在此处产生断点：</p>\n<pre><code>-[CALayer retainCount]: message sent to deallocated instance &lt;memoryaddress&gt;\n</code></pre><a id=\"more\"></a>\n<p>虽然可以看到内存地址，知道是某个指针导致了 <code>Zombie</code> 引用，但对于解决问题却毫无帮助，因为仍不知道该地址到底是哪个对象？原因很显然，既然该对象已经<code>deallocated</code>，就无法再从内存中找回它来。虽然可以以对象的形式打印这个指针：</p>\n<pre><code>（GDB）po &lt;内存地址&gt;\n</code></pre><p>仍然会得到一个 <strong><code>message sent to deallocated instance</code></strong> 的错误消息。</p>\n<p>可以在 <code>Instrument</code> 用 <code>Zombie</code> 模板，来观察到这些 <code>Zombie</code> 对象。</p>\n<blockquote>\n<p>提示：只能在模拟器中使用 Zombie 模板，对于在设备中运行的程序， 你只能手动找出<code>Zombie</code>对象，<code>Zombie</code>模板对物理设备无效。</p>\n</blockquote>\n<p>使用操作如下：<br>点击 Xcode 的 Project –&gt; Profile 菜单。在 Instrument 的“模板选择窗口”中，选择“iOSSimulator”下面的 Zombie 模板。<br><img src=\"/images/templateOfTraceDcument.jpg\" alt=\"image\"><br>在模拟器中调试程序，如果 Zombie 问题出现，程序将崩溃，同时 Instrument 会弹出一个“Zombie 消息报告”，同时程序将在此处中断，如下图所示。<br><img src=\"/images/ZombieMsgAlert.jpg\" alt=\"image\"></p>\n<p>点击地址 (0x158b3c00) 右边的箭头，将列出该 Zombie 对象曾经发生过的 retain/release 动作。</p>\n<p>从列表中找到 retain count 在变为 -1 之前的那行,打开 View -&gt; Extended detail，将显示导致了过渡释放的代码调用：<br><img src=\"/images/ErrCodeline.jpg\" alt=\"image\"></p>\n<p>双击这句代码，将在源文件中高亮显示该语句：</p>\n<p><img src=\"/images/Errorcode.png\" alt=\"image\"><br>现在，知道问题出在哪里了吧？</p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"instrument","path":"api/categories/instrument.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"Storyboard","path":"api/tags/Storyboard.json"}]},{"title":"UIDevice类介绍","slug":"iOS/UIDevice类介绍","date":"2014-06-17T15:12:53.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/UIDevice类介绍.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"UIDevice-h\"><a href=\"#UIDevice-h\" class=\"headerlink\" title=\"UIDevice.h\"></a>UIDevice.h</h3><figure class=\"highlight objc\"><figcaption><span>设备的基本属性</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">UIDevice</span> *)currentDevice; \t\t  <span class=\"comment\">// 获取当前设备</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSString</span>    *name;               \t  <span class=\"comment\">// e.g. \"My iPhone\"  </span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span>    *model;              \t  <span class=\"comment\">// e.g. @\"iPhone\", @\"iPod touch\"  </span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span>    *localizedModel;     \t  <span class=\"comment\">// localized version of model  </span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span>    *systemName;     \t\t  <span class=\"comment\">// e.g. @\"iOS\"  </span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span>    *systemVersion;   \t  <span class=\"comment\">// e.g. @\"4.0\"  </span></span><br><span class=\"line\"><span class=\"built_in\">UIDeviceOrientation</span> orientation;    <span class=\"comment\">//除非正在生成设备方向的通知，否则返回UIDeviceOrientationUnknown  </span></span><br><span class=\"line\"><span class=\"built_in\">NSUUID</span> *identifierForVendor         <span class=\"comment\">//可用于唯一标识该设备，同一供应商不同应用具有相同的UUID</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><figcaption><span>方向属性值</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIDeviceOrientationUnknown</span>,</span><br><span class=\"line\"><span class=\"built_in\">UIDeviceOrientationPortrait</span>,                    <span class=\"comment\">// 竖向，头向上</span></span><br><span class=\"line\"><span class=\"built_in\">UIDeviceOrientationPortraitUpsideDown</span>,  \t\t<span class=\"comment\">// 竖向，头向下</span></span><br><span class=\"line\"><span class=\"built_in\">UIDeviceOrientationLandscapeLeft</span>,         \t\t<span class=\"comment\">// 横向，头向左</span></span><br><span class=\"line\"><span class=\"built_in\">UIDeviceOrientationLandscapeRight</span>,       \t\t<span class=\"comment\">// 横向，头向右</span></span><br><span class=\"line\"><span class=\"built_in\">UIDeviceOrientationFaceUp</span>,                  \t<span class=\"comment\">// 平放，屏幕朝下</span></span><br><span class=\"line\"><span class=\"built_in\">UIDeviceOrientationFaceDown</span>                \t <span class=\"comment\">// 平放，屏幕朝下</span></span><br></pre></td></tr></table></figure>\n<p>//使用内置的宏定义的函数，根据<strong>orientation</strong>判断设备方向,返回值类型<strong>BOOL</strong>.<br><figure class=\"highlight\"><figcaption><span>纵向宏定义,返回YES:纵向</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define UIDeviceOrientationIsPortrait(orientation)  ((orientation) == UIDeviceOrientationPortrait || (orientation) == UIDeviceOrientationPortraitUpsideDown)</span><br></pre></td></tr></table></figure><br><figure class=\"highlight\"><figcaption><span>横向宏定义,返回YES:横向</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define UIDeviceOrientationIsLandscape(orientation) ((orientation) == UIDeviceOrientationLandscapeLeft || (orientation) == UIDeviceOrientationLandscapeRight)</span><br></pre></td></tr></table></figure><br><a id=\"more\"></a></p>\n<h4 id=\"横竖屏相关参数-方法与通知\"><a href=\"#横竖屏相关参数-方法与通知\" class=\"headerlink\" title=\"横竖屏相关参数,方法与通知\"></a>横竖屏相关参数,方法与通知</h4><ul>\n<li>检测当前设备是否生成设备转向通知<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">BOOL</span> generatesDeviceOrientationNotifications</span><br></pre></td></tr></table></figure></li>\n<li>设备方向开始改变时，触发该方法，可以重写实现一些操作。<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)beginGeneratingDeviceOrientationNotifications;</span><br></pre></td></tr></table></figure></li>\n<li>设备结束方向改变时，触发的事件，可以重写该实现一些操作。<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)endGeneratingDeviceOrientationNotifications;</span><br></pre></td></tr></table></figure></li>\n<li>通知<figure class=\"highlight objc\"><figcaption><span>屏幕方向变化通知</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIDeviceOrientationDidChangeNotification</span>;</span><br></pre></td></tr></table></figure>\n####手机电池相关属性与通知</li>\n<li>电池属性<figure class=\"highlight objc\"><figcaption><span>电池属性</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">BOOL</span> batteryMonitoringEnabled\t\t      <span class=\"comment\">// 是否启动电池监控，默认为NO </span></span><br><span class=\"line\"><span class=\"built_in\">UIDeviceBatteryState</span> batteryState \t\t<span class=\"comment\">//电池状态</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> batteryLevel   \t\t\t\t\t <span class=\"comment\">//电量百分比， 0 .. 1.0,监控禁用时为-1</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><figcaption><span>电池状态UIDeviceBatteryState属性值</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIDeviceBatteryStateUnknown</span>,\t\t <span class=\"comment\">//禁用电池监控</span></span><br><span class=\"line\"><span class=\"built_in\">UIDeviceBatteryStateUnplugged</span>,      <span class=\"comment\">// 未充电</span></span><br><span class=\"line\"><span class=\"built_in\">UIDeviceBatteryStateCharging</span>,       <span class=\"comment\">// 正在充电</span></span><br><span class=\"line\"><span class=\"built_in\">UIDeviceBatteryStateFull</span>,           <span class=\"comment\">// 满电</span></span><br></pre></td></tr></table></figure></li>\n<li>电池通知<figure class=\"highlight objc\"><figcaption><span>电池状态变化通知</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIDeviceBatteryStateDidChangeNotification</span>   <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">3</span>_0);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><figcaption><span>电池电量变化通知</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIDeviceBatteryLevelDidChangeNotification</span>   <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">3</span>_0);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"设备的其他属性及方法\"><a href=\"#设备的其他属性及方法\" class=\"headerlink\" title=\"设备的其他属性及方法\"></a>设备的其他属性及方法</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">BOOL</span> proximityMonitoringEnabled <span class=\"comment\">// 是否启动接近监控（例如接电话时脸靠近屏幕），默认为NO</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> proximityState <span class=\"comment\">// 如果设备不具备接近感应器，则总是返回NO</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> multitaskingSupported <span class=\"comment\">// 是否支持多任务</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UIUserInterfaceIdiom</span> userInterfaceIdiom <span class=\"comment\">// 当前用户界面模式</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)playInputClick   <span class=\"comment\">// 播放一个输入的声音</span></span><br></pre></td></tr></table></figure>\n<p>//用户界面类型<br><figure class=\"highlight objc\"><figcaption><span>iOS3.2以上有效</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#if __IPHONE_3_2 <span class=\"meta-string\">&lt;= __IPHONE_OS_VERSION_MAX_ALLOWED</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-string\">    UIUserInterfaceIdiomPhone,           // iPhone 和 iPod touch 风格</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-string\">    UIUserInterfaceIdiomPad,              // iPad 风格</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-string\">#endif</span></span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight\"><figcaption><span>获取当前用户界面模式的宏定义</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define UI_USER_INTERFACE_IDIOM() ([[UIDevice currentDevice] respondsToSelector:@selector(userInterfaceIdiom)] ? [[UIDevice currentDevice] userInterfaceIdiom] : UIUserInterfaceIdiomPhone)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"一些协议的定义\"><a href=\"#一些协议的定义\" class=\"headerlink\" title=\"一些协议的定义\"></a>一些协议的定义</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">UIInputViewAudioFeedback</span></span></span><br><span class=\"line\"><span class=\"keyword\">@optional</span></span><br><span class=\"line\"><span class=\"comment\">// 实现该方法，返回YES则自定义的视图能够播放输入的声音</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">BOOL</span> enableInputClicksWhenVisible; </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"其他通知\"><a href=\"#其他通知\" class=\"headerlink\" title=\"其他通知\"></a>其他通知</h4><figure class=\"highlight objc\"><figcaption><span>接近状态变化通知</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIKIT_EXTERN</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIDeviceProximityStateDidChangeNotification</span> <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">3</span>_0);</span><br></pre></td></tr></table></figure>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"设备","path":"api/categories/设备.json"}],"tags":[{"name":"设备","path":"api/tags/设备.json"}]},{"title":"IOS7新宠Text Kit","slug":"iOS/IOS7新宠TextKit","date":"2014-06-16T22:24:48.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/IOS7新宠TextKit.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/TextRenderingArchitecture-iOS6.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"Text-Kit\"><a href=\"#Text-Kit\" class=\"headerlink\" title=\"Text Kit\"></a>Text Kit</h2><p><strong><code>Text Kit</code></strong>：是个庞大的framework，继承了<code>Core Text</code>的全部功能，构建了快速、先进的文本排版和渲染引擎，更让开发者们高兴的是，设计者把它封装在了一个面向对象的API中。并且与UIKit框架很好的集成，它让程序能够通过<strong>NSTextStorage</strong>对象存储文本排版和显示文本等主要信息，并支持排版所需要的所有特性，包括字距调整、连写、换行和对齐等。  </p>\n<blockquote>\n<font size=\"3\">更直观的理解，<strong>UITextView</strong>，<strong>UITextField</strong>、<strong>UILabel</strong>等UIKit控件都已经基于<strong>Text Kit</strong>重新构建，是为UIKit框架提供高质量排版服务而扩展的一些类和协议.<br>例如：NSTextStorage对象，它本身是<strong>NSMutableAttributedString</strong>的子类，支持分批编辑，这就意味着在改变一个范围内的字符样式时，不用整体替换文本内容，就能完成排版效果。其中支持分页文本、文本包装、富文本编辑、交互式文本着色、文本折叠和自定义截取等特性。</font>  \n\n</blockquote>\n<p>IOS6之前，想实现一些丰富的文本排版，例如在textView中显示不同样式的文本，或者图片和文字混排等，就需要借助于UIWebView或者深入研究一下<code>Core Text</code>。后来iOS6，增加一个很棒的属性:<code>NSAttributedString</code>，主要用于支持UILabel、UITextField、UITextView等UIKit控件自主排版的功能。很显然，IOS7并没有满足于这一改进，同时推出一款功能更为齐全，易用的<code>Text Kit</code>新宠。<br>在iOS 6中, 用于文本的UIKit控件是基于WebKit和Core Graphics的字符串绘制方法来实现的。如下面层级体系图所示：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextRenderingArchitecture-iOS6.png?imageMogr2/2/w/800\"><br>iOS 7的整体构架要更清晰，所有基于文本的UIKit控件（除了UIWebView）现在都可以使用Text Kit，如下图所示：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextRenderingArchitecture-iOS7.png?imageMogr2/2/w/800\"></p>\n<a id=\"more\"></a>\n<h2 id=\"Text-Kit中4个重要的角色\"><a href=\"#Text-Kit中4个重要的角色\" class=\"headerlink\" title=\"Text Kit中4个重要的角色\"></a>Text Kit中4个重要的角色</h2><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit_obj.jpg?imageMogr2/2/w/800\">\n<ul>\n<li><ul>\n<li><strong><code>Text Views</code></strong>: 用来显示文本内容的控件，主要包括<code>UILabel</code>、<code>UITextView</code>和<code>UITextField</code>。  </li>\n</ul>\n</li>\n<li><ul>\n<li><strong><code>Text containers</code></strong>: 对应着<code>NSTextContainer</code>类。<code>NSTextContainer</code>定义了文本可以排版的区域。一般来说，都是矩形区域，当然，也可以根据需求，通过子类化<code>NSTextContainer</code>来创建别的一些形状，例如圆形、不规则的形状等。<code>NSTextContainer</code>不仅可以创建文本可以填充的区域，它还维护着一个数组——该数组定义了一个区域，排版的时候文字不会填充该区域，因此，我们可以在排版文字的时候，填充非文本元素。    </li>\n</ul>\n</li>\n<li><ul>\n<li><strong><code>Layout manager</code></strong>: 对应着<code>NSLayoutManager</code>类。该类负责对文字进行编辑排版处理——通过将存储在<code>NSTextStorage</code>中的数据转换为可以在视图控件中显示的文本内容，并把统一的字符编码映射到对应的字形(<code>glyphs</code>)上，然后将字形排版到<code>NSTextContainer</code>定义的区域中。  </li>\n</ul>\n</li>\n<li><ul>\n<li><strong><code>Text storage</code></strong>: 对应着<code>NSTextStorage</code>类。该类定义了<code>Text Kit</code>扩展文本处理系统中的基本存储机制。<code>NSTextStorage</code>继承自<code>NSmutableAttributedString</code>，主要用来存储文本的字符和相关属性。另外，当<code>NSTextStorage</code>中的字符或属性发生了改变，会通知<code>NSLayoutManager</code>，进而做到文本内容的显示更新。<br>通常情况下，<strong><code>NSTextStorage</code></strong>、<strong><code>NSLayoutManager</code></strong>和<strong><code>NSTextContainer</code></strong>是一一对应关系:  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit_obj1.jpg?imageMogr2/2/w/800\">\n如果将文字显示为多列，或多页，可以按照下图关系，使用多个<strong><code>NSTextContainer</code></strong>:<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit_obj2.jpg?imageMogr2/2/w/800\">\n如果针对不同的排版方式，可以按照下图关系，使用多个<strong><code>NSLayoutManager</code></strong>:<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit_obj3.jpg?imageMogr2/2/w/800\">\n通常由<strong><code>NSLayoutManager</code></strong>从<strong><code>NSTextStorage</code></strong>中读取出文本数据，然后根据一定的排版方式，将文本排版到<strong><code>NSTextContainer</code></strong>中，再由<strong><code>NSTextContainer</code></strong>结合<code>UITextView</code>将最终效果显示出来。<br>如下图，为了更直观理解，对<code>UITextView</code>的组成做了分解: <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit.jpg?imageMogr2/2/w/800\">\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Text-Kit示例\"><a href=\"#Text-Kit示例\" class=\"headerlink\" title=\"Text Kit示例\"></a>Text Kit示例</h2><ol>\n<li>打开Xcode 5，新建一个Single View Application模板的程序，将工程命名为ExclusionPath。</li>\n<li>打开Main.storyboard文件，然后再默认View Controller的View里面分别添加一个UITextView和UIImageView。并将这两个控件连接到ViewController.h中(名称分别为textView何imageView)。然后给textView设置一些字符串，imageView设置一个图片。</li>\n<li><ol>\n<li>打开ViewController.m文件，找到viewDidLoad方法，用如下代码替换该方法：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建一个平移手势对象，该对象可以调用imagePanned：方法</span></span><br><span class=\"line\">    <span class=\"built_in\">UIPanGestureRecognizer</span> *panGes = [[<span class=\"built_in\">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(imagePanned:)];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.imageView addGestureRecognizer:panGes];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.textView.textContainer.exclusionPaths = @[[<span class=\"keyword\">self</span> translatedBezierPath]];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n在上面的代码中，给imageView添加了一个平移手势。另外通过调用translatedBezierPath方法，给textView的textContainer设置exclusionPaths属性值。表示需要排除的区域（也就是图片在排版中显示的位置）。  </li>\n</ol>\n</li>\n<li><ol>\n<li><strong>translatedBezierPath</strong>方法实现如下：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIBezierPath</span> *)translatedBezierPath</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGRect</span> butterflyImageRect = [<span class=\"keyword\">self</span>.textView convertRect:<span class=\"keyword\">self</span>.imageView.frame fromView:<span class=\"keyword\">self</span>.view];</span><br><span class=\"line\">    <span class=\"built_in\">UIBezierPath</span> *newButterflyPath = [<span class=\"built_in\">UIBezierPath</span> bezierPathWithRect:butterflyImageRect];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> newButterflyPath;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n在上面的代码中，利用imageView的frame属性创建了一个UIBezierPath，然后将该值返回。  </li>\n</ol>\n</li>\n<li><ol>\n<li><strong>imagePanned:</strong>方法实现如下：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)imagePanned:(<span class=\"keyword\">id</span>)sender</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([sender isKindOfClass:[<span class=\"built_in\">UIPanGestureRecognizer</span> <span class=\"keyword\">class</span>]]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">UIPanGestureRecognizer</span> *localSender = sender;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (localSender.state == <span class=\"built_in\">UIGestureRecognizerStateBegan</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.gestureStartingPoint = [localSender translationInView:<span class=\"keyword\">self</span>.textView];</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.gestureStartingCenter = <span class=\"keyword\">self</span>.imageView.center;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (localSender.state == <span class=\"built_in\">UIGestureRecognizerStateChanged</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">CGPoint</span> currentPoint = [localSender translationInView:<span class=\"keyword\">self</span>.textView];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">CGFloat</span> distanceX = currentPoint.x - <span class=\"keyword\">self</span>.gestureStartingPoint.x;</span><br><span class=\"line\">            <span class=\"built_in\">CGFloat</span> distanceY = currentPoint.y - <span class=\"keyword\">self</span>.gestureStartingPoint.y;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">CGPoint</span> newCenter = <span class=\"keyword\">self</span>.gestureStartingCenter;</span><br><span class=\"line\"></span><br><span class=\"line\">            newCenter.x += distanceX;</span><br><span class=\"line\">            newCenter.y += distanceY;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.imageView.center = newCenter;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.textView.textContainer.exclusionPaths = @[[<span class=\"keyword\">self</span> translatedBezierPath]];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (localSender.state == <span class=\"built_in\">UIGestureRecognizerStateEnded</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.gestureStartingPoint = <span class=\"built_in\">CGPointZero</span>;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.gestureStartingCenter = <span class=\"built_in\">CGPointZero</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n在上面的代码中首先根据平移的距离来设置imageView的位置，然后利用<code>translatedBezierPath</code>方法重新计算了一下排除区域。<br>示例效果:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TextKit_gif.gif)</li>?imageMogr2/2/w/800\"></li></ol></li></ol>","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"}],"tags":[{"name":"TextKit","path":"api/tags/TextKit.json"},{"name":"概念","path":"api/tags/概念.json"}]},{"title":"IOS7的变革","slug":"iOS/IOS7的变革","date":"2014-06-11T10:17:19.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/IOS7的变革.json","excerpt":null,"keywords":null,"cover":"/images/uiimagerenderingmode.png","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"性能提高以及被遗弃的功能\"><a href=\"#性能提高以及被遗弃的功能\" class=\"headerlink\" title=\"性能提高以及被遗弃的功能\"></a>性能提高以及被遗弃的功能</h2><h3 id=\"新增截屏通知-UIApplicationUserDidTakeScreenshotNotification\"><a href=\"#新增截屏通知-UIApplicationUserDidTakeScreenshotNotification\" class=\"headerlink\" title=\"新增截屏通知:UIApplicationUserDidTakeScreenshotNotification\"></a>新增截屏通知:<code>UIApplicationUserDidTakeScreenshotNotification</code></h3><p>在IOS 7之前，开发者使用了一种<strong><a href=\"http://dlj.bz/XflV\" target=\"_blank\" rel=\"noopener\">很赞的方法</a></strong>，来<strong>拦截</strong>截屏事件的.<br>比如，Snapchat的实现原理: 用户通过<strong>Snapchat</strong>发送的照片将会在数秒内自动被删除，而且在浏览照片时，必须将手指按在屏幕上，否则会立即关闭。然而，在 iOS 6 中，<font color=\"red\"><strong>截屏将打断触控操作</strong></font>，开发者就利用这个功能点，在恰当时机捕捉到了截屏事件。  </p>\n<p>在iOS 7中，专门为<font color=\"red\"><strong>截屏完成后</strong></font>提供了一个通知:<br>  <code>UIApplicationUserDidTakeScreenshotNotification</code>.同时，也规避了IOS 6中<font color=\"red\"><strong>截屏将打断触控操作</strong></font>的关键功能点。以至于在截屏之前，无法拦截用户的截屏操作。<br>注册<font color=\"red\"><strong>截屏完成后</strong></font>通知:<br><figure class=\"highlight objc\"><figcaption><span>注册监听事件，接收截屏完成后的通知</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter]  addObserver:<span class=\"keyword\">self</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t  selector:<span class=\"keyword\">@selector</span>(mymethod:)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t  \t    name:<span class=\"built_in\">UIApplicationUserDidTakeScreenshotNotification</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t    object:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure></p>\n<p>Note:<br>    1.This notification is posted after the screenshot is taken.<br>    2.This notification does not contain a userInfo dictionary.</p>\n<h3 id=\"新增手势-UIScreenEdgePanGestureRecognizer\"><a href=\"#新增手势-UIScreenEdgePanGestureRecognizer\" class=\"headerlink\" title=\"新增手势: UIScreenEdgePanGestureRecognizer\"></a>新增手势: UIScreenEdgePanGestureRecognizer</h3><p><code>UIScreenEdgePanGestureRecognizer</code> inherits from <code>UIPanGestureRecognizer</code> and lets you <strong>detect gestures starting near the edge of the screen</strong>.<br>Using this new gesture recognizer is quite simple, as shown below:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIScreenEdgePanGestureRecognizer</span> *recognizer = [[<span class=\"built_in\">UIScreenEdgePanGestureRecognizer</span> alloc] </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\tinitWithTarget:<span class=\"keyword\">self</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\taction:<span class=\"keyword\">@selector</span>(handleScreenEdgeRecognizer:)];</span><br><span class=\"line\"><span class=\"comment\">// accept gestures that start from the left; we're probably building another hamburger menu!</span></span><br><span class=\"line\">recognizer.edges = <span class=\"built_in\">UIRectEdgeLeft</span>; </span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addGestureRecognizer:recognizer];</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h3 id=\"新增返回类型-–-instancetype\"><a href=\"#新增返回类型-–-instancetype\" class=\"headerlink\" title=\"新增返回类型 – instancetype\"></a>新增返回类型 – <code>instancetype</code></h3><p>  苹果改变了大部分 initializer和简易构造函数（convenience constructors），<code>instancetype</code>可以代替<code>id</code>作返回类型。</p>\n<pre><code>instancetype 作用：\n        1.作为从Objective-C方法的返回类型。\n        2.在编译时，该方法的返回类型将是该方法所属的类的实例，编译器就会对返回的实例做一些检查，有bug及时发现及时解决。这一点优于id类型。\n        3.在调用子类方法时，就可以省去对返回值的强制类型转换。\n</code></pre><p>  举例:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *d = [<span class=\"built_in\">NSArray</span> arrayWithObjects:@(<span class=\"number\">1</span>),@(<span class=\"number\">2</span>), <span class=\"literal\">nil</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%i\"</span>, d.count);</span><br><span class=\"line\">```  </span><br><span class=\"line\">这段代码显然有错误，但在Xcode4<span class=\"number\">.6</span>上是可以编译通过的。是由于Objective-C是动态性语言。</span><br><span class=\"line\">``` objc</span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)arrayWithObjects:(<span class=\"keyword\">id</span>)firstObj, ...;</span><br></pre></td></tr></table></figure></p>\n<p>并且，arrayWithObjects:返回<code>id</code>类型：是运行时的动态类型，编译器无法知道它的真实类型，即使调用一个id类型没有的方法，也不会产生编译警告。</p>\n<p>那么，为什么<code>arrayWithObjects:</code>方法的返回类型还是<code>id</code>类型？来看看<code>NSArray</code>子类：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyArray</span> : <span class=\"title\">NSArray</span></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>Now consider the use of your new subclass in the code below:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\tMyArray *array = [MyArray arrayWithObjects:@(<span class=\"number\">1</span>), @(<span class=\"number\">2</span>), <span class=\"literal\">nil</span>];</span><br><span class=\"line\">```  </span><br><span class=\"line\">如果方法`arrayWithObjects:`返回值的类型是`<span class=\"built_in\">NSArray</span> *`，那么子类`MyArray`就需要被强制转换为所需的类`<span class=\"built_in\">NSArray</span>`。这是正是`<span class=\"keyword\">instancetype</span>`返回类型的用武之地。</span><br><span class=\"line\">在iPhone <span class=\"number\">7.0</span> SDK的<span class=\"built_in\">NSArray</span>中的头文件，已更新为：</span><br><span class=\"line\">``` objc</span><br><span class=\"line\">\t+ (<span class=\"keyword\">instancetype</span>)arrayWithObjects:(<span class=\"keyword\">id</span>)firstObj, ...;</span><br></pre></td></tr></table></figure></p>\n<p>唯一的区别是返回类<code>instancetype</code>取代<code>id</code>。这种新的返回类型会告知编译器，返回值是该方法所属的类的实例对象。<br>也就是说:当<code>NSArray</code>调用<code>arrayWithObjects:</code>时，返回类型推断为NSArray*;<br>当<code>MyArray</code>调用<code>arrayWithObjects:</code>时，返回类型推断为MyArray*。  </p>\n<p><code>instancetype</code>解决<code>id</code>类型的问题，同时也继承<code>id</code>类型功能。如果编译在Xcode 5的原代码，你会看到下面的警告：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\twarning: incompatible pointer types initializing 'NSDictionary *' with an expression of type 'NSArray *' [-Wincompatible-pointer-types]</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *d = [<span class=\"built_in\">NSArray</span> arrayWithObjects:@(<span class=\"number\">1</span>), @(<span class=\"number\">2</span>), <span class=\"literal\">nil</span>];</span><br><span class=\"line\">                ^    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  </span><br><span class=\"line\">```  </span><br><span class=\"line\">  w00t — now that’s helpful! You now have the opportunity to fix the problem before it turns into a crash later down the line.  </span><br><span class=\"line\"></span><br><span class=\"line\">  Initializers are also candidates <span class=\"keyword\">for</span> using <span class=\"keyword\">this</span> new <span class=\"keyword\">return</span> type. The compiler has warned you <span class=\"keyword\">for</span> some time now <span class=\"keyword\">if</span> you set the <span class=\"keyword\">return</span> type of an initializer to that of an incompatible type. But presumably it’s just implicitly converting the <span class=\"keyword\">id</span> <span class=\"keyword\">return</span> type to <span class=\"keyword\">instancetype</span> under the hood. You should still use <span class=\"keyword\">instancetype</span> <span class=\"keyword\">for</span> initializers though, because it’s better to be <span class=\"keyword\">explicit</span> <span class=\"keyword\">for</span> habit’s sake.  </span><br><span class=\"line\"></span><br><span class=\"line\">  Strive to use <span class=\"keyword\">instancetype</span> as much as possible going forward; it’s become a standard <span class=\"keyword\">for</span> Apple — and you never know when it will save you some painful debugging time later on.</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">### UIScrollView新增属性：`UIScrollViewKeyboardDismissMode`</span></span><br><span class=\"line\">像Messages app一样在滚动的时候，将键盘隐藏，是一种非常好的体验。  </span><br><span class=\"line\">在以前，将这项功能整合到app很难，现在仅仅只需要在Storyboard中简单的改变一个属性值，或者增加一行代码即可。</span><br><span class=\"line\"></span><br><span class=\"line\">这个属性使用了新的`<span class=\"built_in\">UIScrollViewKeyboardDismissMode</span>` <span class=\"keyword\">enum</span>枚举类型。这个<span class=\"keyword\">enum</span>枚举类型可能的值如下：  </span><br><span class=\"line\">``` objc  <span class=\"built_in\">UIScrollViewKeyboardDismissMode</span>枚举值</span><br><span class=\"line\">\t<span class=\"comment\">// the keyboard is not dismissed automatically when scrolling</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">UIScrollViewKeyboardDismissModeNone</span>   </span><br><span class=\"line\">    <span class=\"comment\">// dismisses the keyboard when a drag begins </span></span><br><span class=\"line\">\t\t<span class=\"built_in\">UIScrollViewKeyboardDismissModeOnDrag</span>  </span><br><span class=\"line\">    <span class=\"comment\">// the keyboard follows the dragging touch off screen, and may be pulled upward again to cancel the dismiss </span></span><br><span class=\"line\">\t\t<span class=\"built_in\">UIScrollViewKeyboardDismissModeInteractive</span>  </span><br><span class=\"line\">```  </span><br><span class=\"line\">在storyboard中设置该属性值:  </span><br><span class=\"line\">![<span class=\"built_in\">UIScrollViewKeyboardDismissMode</span>](/images/<span class=\"built_in\">UIScrollViewKeyboardDismissMode</span>.png)  </span><br><span class=\"line\"><span class=\"meta\">### UIKit使用[NSAttributedString]((http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSAttributedString_Class/)显示HTML，[TextKit](http://)</span></span><br><span class=\"line\">在app中使用Webviews有时会让人非常沮丧，即使只是显示少量的HTML内容 ,Webviews也会消耗大量的内存。</span><br><span class=\"line\">现在提供了一种全新的简单易用的方式来展示HTML内容，适用于任意的`<span class=\"built_in\">UIKit</span>`控件，如`<span class=\"built_in\">UILabel</span>`或`<span class=\"built_in\">UITextField</span>`等。   </span><br><span class=\"line\"><span class=\"number\">1.</span>用少量HTML片段，初始化`<span class=\"built_in\">NSAttributedString</span>`对象:</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% codeblock lang:objc Time to be Awesome - awesome.rb %&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *html = <span class=\"string\">@\"&lt;bold&gt;Wow!&lt;/bold&gt; Now &lt;em&gt;iOS&lt;/em&gt; can create &lt;h3&gt;NSAttributedString&lt;/h3&gt; from HTMLs!\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *options = @&#123;<span class=\"built_in\">NSDocumentTypeDocumentAttribute</span>: <span class=\"built_in\">NSHTMLTextDocumentType</span>&#125;;</span><br><span class=\"line\">&#123;% endcodeblock %&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">``` objc 用少量HTML片段，初始化`<span class=\"built_in\">NSAttributedString</span>`对象 http:<span class=\"comment\">//developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSAttributedString_Class/</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *html = <span class=\"string\">@\"&lt;bold&gt;Wow!&lt;/bold&gt; Now &lt;em&gt;iOS&lt;/em&gt; can create &lt;h3&gt;NSAttributedString&lt;/h3&gt; from HTMLs!\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *options = @&#123;<span class=\"built_in\">NSDocumentTypeDocumentAttribute</span>: <span class=\"built_in\">NSHTMLTextDocumentType</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">NSData</span> *htmlData = [html dataUsingEncoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSAttributedString</span> *attrString = [[<span class=\"built_in\">NSAttributedString</span> alloc] initWithData:htmlData</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t                      options:options </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t                       documentAttributes:<span class=\"literal\">nil</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t   \t\t\t                        error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">```\t\t\t\t\t\t\t\t   \t</span><br><span class=\"line\"><span class=\"built_in\">NSDocumentTypeDocumentAttribute</span>包括:</span><br><span class=\"line\">&lt;!--https:<span class=\"comment\">//gist.githubusercontent.com/huos3203/ecba275d5e4404678354/raw/1636f62209b056b4acbe07021f596e1ffd5ef301/%E8%A7%A3%E6%9E%90NSAttributedString%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%88%90HTML%E7%89%87%E6%AE%B5</span></span><br><span class=\"line\">--&gt;</span><br><span class=\"line\">\t<span class=\"built_in\">NSPlainTextDocumentType</span>\t\t<span class=\"comment\">//Plain text document.</span></span><br><span class=\"line\">    <span class=\"built_in\">NSRTFTextDocumentType</span>\t\t<span class=\"comment\">//Rich text format document.</span></span><br><span class=\"line\">    <span class=\"built_in\">NSRTFDTextDocumentType</span>\t\t<span class=\"comment\">//Rich text format with attachments document.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>相反，也可以将`<span class=\"built_in\">NSAttributedString</span>`对象，解析成HTML片段：</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% gist ecba275d5e4404678354 %E8%A7%A3%E6%<span class=\"number\">9</span>E%<span class=\"number\">90</span>NSAttributedString%E5%AF%B9%E8%B1%A1%EF%BC%<span class=\"number\">8</span>C%E8%<span class=\"number\">8</span>E%B7%E5%<span class=\"number\">8</span>F%<span class=\"number\">96</span>%E6%<span class=\"number\">88</span>%<span class=\"number\">90</span>HTML%E7%<span class=\"number\">89</span>%<span class=\"number\">87</span>%E6%AE%B5.m %&#125;\t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">### NSLinkAttributeName让标签（UILabel,UITextView）支持超链接</span></span><br><span class=\"line\"> </span><br><span class=\"line\">首先，创建一个`<span class=\"built_in\">NSAttributedString</span>`对象,然后，调用`addAttribute:value:range:`方法，添加 `<span class=\"built_in\">NSLinkAttributeName</span>`属性并赋值，如下：  </span><br><span class=\"line\">``` objc <span class=\"built_in\">UITextView</span>支持超链接</span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableAttributedString</span> *attributedString = [[<span class=\"built_in\">NSMutableAttributedString</span> alloc] initWithString:<span class=\"string\">@\"This is an example by @marcelofabri_\"</span>]; </span><br><span class=\"line\">\t[attributedString addAttribute:<span class=\"built_in\">NSLinkAttributeName</span> </span><br><span class=\"line\">                         value:<span class=\"string\">@\"username://marcelofabri_\"</span> </span><br><span class=\"line\">                         range:[[attributedString string] rangeOfString:<span class=\"string\">@\"@marcelofabri_\"</span>]]; </span><br><span class=\"line\">\t<span class=\"built_in\">NSDictionary</span> *linkAttributes = @&#123;<span class=\"built_in\">NSForegroundColorAttributeName</span>: [<span class=\"built_in\">UIColor</span> greenColor], </span><br><span class=\"line\">                                 <span class=\"built_in\">NSUnderlineColorAttributeName</span>: [<span class=\"built_in\">UIColor</span> lightGrayColor], </span><br><span class=\"line\">                                 <span class=\"built_in\">NSUnderlineStyleAttributeName</span>: @(<span class=\"built_in\">NSUnderlinePatternSolid</span>)&#125;;  </span><br><span class=\"line\">\t<span class=\"comment\">// assume that textView is a UITextView previously created (either by code or Interface Builder) </span></span><br><span class=\"line\">\ttextView.linkTextAttributes = linkAttributes; <span class=\"comment\">// customizes the appearance of links </span></span><br><span class=\"line\">\ttextView.attributedText = attributedString; </span><br><span class=\"line\">\ttextView.delegate = <span class=\"keyword\">self</span>;</span><br></pre></td></tr></table></figure></p>\n<p>当然，也可以使用<code>UITextViewDelegate</code>新增的协议方法<font color=\"red\"><strong>shouldInteractWithURL</strong></font>，来自定义点击事件：<br><figure class=\"highlight objc\"><figcaption><span>协议方法shouldInteractWithURL</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)textView:(<span class=\"built_in\">UITextView</span> *)textView shouldInteractWithURL:(<span class=\"built_in\">NSURL</span> *)URL </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t               inRange:(<span class=\"built_in\">NSRange</span>)characterRange &#123; </span><br><span class=\"line\">\t\t\t    <span class=\"keyword\">if</span> ([[URL scheme] isEqualToString:<span class=\"string\">@\"username\"</span>]) &#123; </span><br><span class=\"line\">\t\t\t        <span class=\"built_in\">NSString</span> *username = [URL host];  </span><br><span class=\"line\">\t\t\t        <span class=\"comment\">// do something with this username </span></span><br><span class=\"line\">\t\t\t        <span class=\"comment\">// ... </span></span><br><span class=\"line\">\t\t\t        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>; </span><br><span class=\"line\">\t\t\t    &#125; </span><br><span class=\"line\">\t\t\t    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>; <span class=\"comment\">// let the system open this URL </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Tint-images-with-UIImage-renderingMode\"><a href=\"#Tint-images-with-UIImage-renderingMode\" class=\"headerlink\" title=\"Tint images with UIImage.renderingMode\"></a>Tint images with <code>UIImage.renderingMode</code></h3><p>Tinting is a big part of the new look and feel of iOS 7, and you have control whether your image is tinted or not when rendered.<br>UIImage now has a read-only property named <code>renderingMode</code> as well as a new method <code>imageWithRenderingMode:</code> which uses the new enum <code>UIImageRenderingMode</code> containing the following possible values:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Use the default rendering mode for the context where the image is used</span><br><span class=\"line\">\tUIImageRenderingModeAutomatic  </span><br><span class=\"line\">// Always draw the original image, without treating it as a template</span><br><span class=\"line\">\tUIImageRenderingModeAlwaysOriginal  </span><br><span class=\"line\">// Always draw the image as a template image, ignoring its color information</span><br><span class=\"line\">\tUIImageRenderingModeAlwaysTemplate</span><br></pre></td></tr></table></figure></p>\n<p>The code below shows how easy it is to create an image with a given rendering mode:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIImage</span> *img = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"myimage\"</span>]; </span><br><span class=\"line\">img = [img imageWithRenderingMode:<span class=\"built_in\">UIImageRenderingModeAlwaysTemplate</span>];</span><br></pre></td></tr></table></figure></p>\n<p>The default value of renderingMode is UIImageRenderingModeAutomatic.<br>Whether the image will be tinted or not depends on where it’s being displayed as shown by the examples below:<br><img src=\"/images/uiimagerenderingmode.png\" alt=\"image\"></p>\n<h3 id=\"Usage-of-tintColor-vs-barTintColor\"><a href=\"#Usage-of-tintColor-vs-barTintColor\" class=\"headerlink\" title=\"Usage of tintColor vs barTintColor\"></a>Usage of tintColor vs barTintColor</h3><p>In iOS 7 you can tint your entire app with a given color or even implement color themes to help your app stand out from the rest.Setting the tint color of your app is as easy as using the new property <code>tintColor</code> of <code>UIView</code>.<br>Does that property sound familiar? it should — some classes such as <code>UINavigationBar</code>, <code>UISearchBar</code>, <code>UITabBar</code> and <code>UIToolbar</code> already had a property with this name. They now have a new property: <code>barTintColor</code>.<br>In order to avoid getting tripped up by the new property, you should perform the following check if your app needs to support iOS 6 or earlier:</p>\n<figure class=\"highlight objc\"><figcaption><span>bar通过判断是否包含setBarTintColor:确定系统版本</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UINavigationBar</span> *bar = <span class=\"keyword\">self</span>.navigationController.navigationBar;</span><br><span class=\"line\"><span class=\"built_in\">UIColor</span> *color = [<span class=\"built_in\">UIColor</span> greenColor];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> ([bar respondsToSelector:<span class=\"keyword\">@selector</span>(setBarTintColor:)]) &#123; </span><br><span class=\"line\">\t\t<span class=\"comment\">// iOS 7+</span></span><br><span class=\"line\">\t\t    bar.barTintColor = color;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">\t\t<span class=\"comment\">// iOS 6 or earlier</span></span><br><span class=\"line\">\t\t    bar.tintColor = color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```\t  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">### Check which wireless routes are available</span></span><br><span class=\"line\">The ability to customize a video player (and friends) has evolved throughout the past few iOS versions. As an example, prior to iOS <span class=\"number\">6</span> you couldn’t change the AirPlay icon on a `<span class=\"built_in\">MPVolumeView</span>`.  </span><br><span class=\"line\">In iOS <span class=\"number\">7</span>, you’re finally able to know <span class=\"keyword\">if</span> a remote device is available via AirPlay, Bluetooth, or some other wireless mechanism. This allows your app to behave appropriately, such as hiding an AirPlay icon when that service isn’t available on other devices.  </span><br><span class=\"line\">The following two new properties and notifications have been added to <span class=\"built_in\">MPVolumeView</span>:  </span><br><span class=\"line\"></span><br><span class=\"line\">``` objc  </span><br><span class=\"line\"><span class=\"comment\">// is there a route that the device can connect to?</span></span><br><span class=\"line\">\t<span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">BOOL</span> wirelessRoutesAvailable;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"comment\">// is the device currently connected?</span></span><br><span class=\"line\">\t<span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">BOOL</span> wirelessRouteActive;   </span><br><span class=\"line\">  <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">MPVolumeViewWirelessRoutesAvailableDidChangeNotification</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">MPVolumeViewWirelessRouteActiveDidChangeNotification</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"NSArray-firstObject-的实现\"><a href=\"#NSArray-firstObject-的实现\" class=\"headerlink\" title=\"-[NSArray firstObject]的实现\"></a><code>-[NSArray firstObject]</code>的实现</h3><p><code>-[NSArray firstObject]</code>可能是Objective-C中被调用做多的API。 在iOS4.0中<code>firstObject</code>已经被使用，但是那时仅仅是一个私有方法。在iOS7以前，常用方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *arr = @[]; </span><br><span class=\"line\"><span class=\"keyword\">id</span> item = [arr firstObject]; </span><br><span class=\"line\"><span class=\"comment\">// 前你需要做以下工作 </span></span><br><span class=\"line\"><span class=\"keyword\">id</span> item = [arr count] &gt; <span class=\"number\">0</span> ? arr[<span class=\"number\">0</span>] : <span class=\"literal\">nil</span>;</span><br></pre></td></tr></table></figure></p>\n<p>因为上面的方式很常用，一般创建一个类别实现该方法<code>firstObject</code>增加到NSArray中。</p>\n<p>这个方法的问题:<code>方法名</code>必须是唯一的，否则,这个方法所引发的问题无法预估。所以在<code>NSArray</code>中最好不要重载<code>firstObject</code>方法，是有风险的。</p>\n<h3 id=\"UIButtonTypeRoundRect被UIButtonTypeSystem取代\"><a href=\"#UIButtonTypeRoundRect被UIButtonTypeSystem取代\" class=\"headerlink\" title=\"UIButtonTypeRoundRect被UIButtonTypeSystem取代\"></a>UIButtonTypeRoundRect被UIButtonTypeSystem取代</h3><p><img src=\"http://cdn1.raywenderlich.com/wp-content/uploads/2010/05/Rate.jpg\" alt=\"alt text\" title=\"UIButtonTypeRoundRect被UIButtonTypeSystem取代\"></p>\n<h4 id=\"UIPasteboard由共享变为沙盒化了\"><a href=\"#UIPasteboard由共享变为沙盒化了\" class=\"headerlink\" title=\"UIPasteboard由共享变为沙盒化了\"></a><code>UIPasteboard</code>由共享变为沙盒化了</h4><p>UIPasteboard过去是用来做app之间的数据分享的。开发者一般使用它来存储标识符，比如:OpenUDID。<br>但在在iOS7中，使用 <code>+[UIPasteboard pasteboardWithName:create:]</code>和 <code>+[UIPasteboard pasteboardWithUniqueName]</code>创建剪贴板，而且只对相同的app group可见，这样再和其他的相关app分享以前的OpenUDID等标识符时，就会出现问题。</p>\n<h4 id=\"MAC地址-被统一化\"><a href=\"#MAC地址-被统一化\" class=\"headerlink\" title=\"MAC地址:被统一化\"></a><code>MAC地址</code>:被统一化</h4><p>在IOS7之前，生成iOS设备唯一标示符的方法是使用iOS设备的Media Access Control（MAC）地址。 一个MAC地址是一个唯一的号码，它是物理网络层级方面分配给网络适配器的。<br>然而，苹果并不希望有人通过MAC地址来分辨用户，在iOS7以上，查询MAC地址，它现在只会返回02:00:00:00:00:00。<br>目前，苹果推荐开发者使用以下两种方式，来获取作为框架和应用的唯一标示符：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"built_in\">NSString</span> *identifierForVendor = [[<span class=\"built_in\">UIDevice</span> currentDevice].identifierForVendor UUIDString]; </span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> *identifierForAdvertising = [[ASIdentifierManager sharedManager].advertisingIdentifier UUIDString];</span><br><span class=\"line\">``` </span><br><span class=\"line\">`identifierForVendor`：由同一个公司发行的的app在相同的设备上运行的时候都会有这个相同的标识符。然而，如果用户删除了这个供应商的app然后再重新安装的话，这个标识符就会不一致。</span><br><span class=\"line\">`advertisingIdentifier`：返回给在这个设备上所有软件供应商公用的唯一值，所以只能在广告的时候使用。这个值会因为很多情况而有所变化，比如说用户初始化设备的时候便会改变。</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">####  app启动麦克风，需争征得用户同意  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">  以前如果app需要使用用户的位置，通讯录，日历，提醒以及照片，接受推送消息，使用用户的社交网络的时候需要征得用户的同意。</span><br><span class=\"line\">  现在在iOS7当中，使用麦克风也需要取得用户同意了。如果用户不允许app使用麦克风的话，那么需要使用麦克风的app就不能接收不到任何声音。</span><br><span class=\"line\">  以下的代码是用来查询用户是否允许app使用麦克风：  </span><br><span class=\"line\">```\tobjc\t\t</span><br><span class=\"line\">\t<span class=\"comment\">//第一次调用这个方法的时候，系统会提示用户让他同意你的app获取麦克风的数据 </span></span><br><span class=\"line\">\t<span class=\"comment\">// 其他时候调用方法的时候，则不会提醒用户 </span></span><br><span class=\"line\">\t<span class=\"comment\">// 而会传递之前的值来要求用户同意 </span></span><br><span class=\"line\">\t[[<span class=\"built_in\">AVAudioSession</span> sharedInstance] requestRecordPermission:^(<span class=\"built_in\">BOOL</span> granted) &#123; </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t    <span class=\"keyword\">if</span> (granted) &#123; </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t        <span class=\"comment\">// 用户同意获取数据 </span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t    &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t        <span class=\"comment\">// 可以显示一个提示框告诉用户这个app没有得到允许？ </span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t    &#125; </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t    &#125;</span><br><span class=\"line\">    ];</span><br></pre></td></tr></table></figure></p>\n<p>如果没有经过用户同意，就调用麦克风，iOS系统自动弹出以下警示栏：<br><img src=\"/images/microphone.jpg\" alt=\"image\"></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"特性","path":"api/categories/特性.json"}],"tags":[{"name":"IOS7","path":"api/tags/IOS7.json"}]},{"title":"在IOS中像SnapChat一样监控screenshots","slug":"iOS/在IOS中像SnapChat一样监控screenshots","date":"2014-06-10T18:45:37.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/在IOS中像SnapChat一样监控screenshots.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>A <a href=\"http://stackoverflow.com/questions/2121970/notification-of-or-detecting-screenshot-being-taken/2122117\" target=\"_blank\" rel=\"noopener\">number</a> of <a href=\"http://stackoverflow.com/questions/13484516/ios-detection-of-screenshot\" target=\"_blank\" rel=\"noopener\">Stack</a>  <a href=\"http://stackoverflow.com/questions/10122212/iphone-screenshot\" target=\"_blank\" rel=\"noopener\">Overflow</a>questions were having issues with this, so I figured I’d explain. From reverse engineering, this is the exact method used by SnapChat, but it’s also pretty much what I’d have done myself.<br><a id=\"more\"></a><br>The process is pretty simple, and relies on a quirk of iOS: taking a screenshot cancels all touches on the screen. Because of that, anything that you want to protect will require you to have the user to touch the screen to see. If that works for your purposes, the general solution is to simply intercept the touch cancellation, and quickly remove any sensitive information from the screen. If you’re also implementing a screenshot counter, as with SnapChat, you will also need to take into account the other cases when a touch might be cancelled: from a system gesture (Notification Center or the iPad’s multitasking gestures), or by activating other pieces of system UI (the power down menu, or the multitasking switcher).</p>\n<p>On a technical level, the two basic pieces are UILongPressGestureRecognizer (or -touchesCancelled:withEvent:, if you want) and UIApplicationDelegate. In your long press handler, you should hide your sensitive information when the gesture recognizer’s state is UIGestureRecognizerStateCancelled, and if you want to track the number of screenshots, increment a counter. Then, in the UIApplicationDelegate, decrement that counter when you receive the -applicationWillEnterBackground: or -applicationDidResignActive: notification to account for the other possibilities for a cancelled touch. You might also need to handle other situations where a touch could be cancelled, if other parts of your app might cause that to happen.</p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"}],"tags":[{"name":"截屏","path":"api/tags/截屏.json"}]},{"title":"IOS7截屏问题","slug":"iOS/IOS7截屏问题","date":"2014-06-10T18:29:31.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/IOS7截屏问题.json","excerpt":null,"keywords":null,"cover":"http://resource.feng.com/resource/h027/h71/img201307301647042.jpg","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"iOS-7截图最新变化-不再影响用户其他操作\"><a href=\"#iOS-7截图最新变化-不再影响用户其他操作\" class=\"headerlink\" title=\"iOS 7截图最新变化: 不再影响用户其他操作\"></a>iOS 7截图最新变化: 不再影响用户其他操作</h3><p>   在 iOS 7 中，截图动作已经发生了变化，就如苹果在版本说明中描述的那样：用户截图时，有效点击不会再失效了。这个微小的变化对于多款依赖截屏来提醒用户一些不必要动作的应用来说，具有很重要的意义，比如 Snapchat 和 Facebook Poke。<br><a id=\"more\"></a><br>　　用户在应用中打开 Snapchat 照片，查看照片时用户需要单指按在屏幕上让照片处于打开的状态。如果用户试图截图，那么照片马上就会关闭。这是 Snapchat 用来检测“非法”截图的办法。用户拍了照片发送给好友后，这些照片会根据用户所预先设定的时间按时自动销毁。如果接收方在此期间试图进行截图的话，用户也将得到通知。</p>\n<p>   Snapchat在美国青少年群体中十分流行，因为它拥有一种独特的“阅后即焚”机制。用户通过该应用发送的照片将会在数秒内自动被删除，而且它还将采用一种特殊手段阻止照片接收者截屏，并将其截屏企图报告给发送者。在 iOS 6 中，截屏将打断触控操作，而用户观看 Snapchat 照片时，必须将手指按在屏幕上。</p>\n<p>　　在 iOS 7 中截图的操作不会迫使 SnapChat 查看照片的窗口关闭，也就是说当用户截图时系统也不会发出提醒通知。截图不会影响用户在屏幕上的操作，照片不会关闭应用也无法识别截图的动作。如果一名 iOS 6 用户试图截图 iOS 7 用户会收到通知，而反过来的话 iOS 6 用户则不会受到通知。这对于 Snapchat 来说，绝对是个恶梦，因为该服务的风靡与阅后即焚机制关系很大。</p>\n<p>　　虽然 iOS 7 的这个变化对于 iOS 7 Snapchat 用户来说有一定的意义，但是这也对 Snapchat 等应用提出更高的要求，他们必须研究出新的办法来检测截图操作，确保这个新特性不会对他们的应用产生影响。</p>\n<p>　　所幸 iOS 7 beta 4 的发布可以让开发商放下心来。9to5Mac 的 Scott Buscemi 不久前宣布，新版本中新增了一个截屏侦测 API。开发者并未透露这个其具体特性，但他暗示说这个 API 对 Snapchat 来说非常至关重要.<br>　　<br><strong>UIApplication.h</strong></p>\n<pre><code>// This notification is posted after the user takes a screenshot (for example by pressing both the home and lock screen buttons)\nUIKIT_EXTERN NSString *const UIApplicationUserDidTakeScreenshotNotification NS_AVAILABLE_IOS(7_0);\n</code></pre><p>　　据悉，iOS 7 beta 2 发布之后，此前一些无法实现的有趣操作也随之变得可行。由于 iOS 6 的截屏将取消触控操作，使得用户难以截取拉了半截的锁屏界面。而在 iOS 7 beta 2 中，一切变得容易起来（见下图）。  </p>\n<p>　　<img src=\"http://resource.feng.com/resource/h027/h71/img201307301647042.jpg\" alt=\"alt text\" title=\"Snapchat福音 iOS 7 beta 4恢复截屏侦测\"></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"}],"tags":[{"name":"截屏","path":"api/tags/截屏.json"}]},{"title":"初步搭建Octopress","slug":"hexo/初步搭建Octopress","date":"2014-06-09T23:26:22.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/hexo/初步搭建Octopress.json","excerpt":null,"keywords":null,"cover":"/images/sourceFrame.png","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h1 id=\"软件支持：\"><a href=\"#软件支持：\" class=\"headerlink\" title=\"软件支持：\"></a>软件支持：</h1><ol>\n<li><strong>Github</strong>:后台新建项目，点击<a href=\"https://help.github.com/articles/set­up­git\" target=\"_blank\" rel=\"noopener\">下载</a></li>\n<li><strong>iTerm2</strong>:可以替代mac终端，相当强大。<a href=\"http://www.iterm2.com/#/section/home\" target=\"_blank\" rel=\"noopener\">下载</a></li>\n<li><strong>ruby</strong>:ruby安装包  <a href=\"http://ruby.taobao.org/mirrors/ruby/\" target=\"_blank\" rel=\"noopener\">下载</a></li>\n<li><strong>Mou</strong>:MarkDown编辑软件，可用于后期发布博客文章。<a href=\"http://mouapp.com/\" target=\"_blank\" rel=\"noopener\">下载</a></li>\n<li><strong>Xcode</strong>：它将帮助你安装好Unix环境需要的开发包。</li>\n</ol>\n<p>￼<!--显示文章缩略部分的标记方法--><br><a id=\"more\"></a></p>\n<h1 id=\"学习目的：\"><a href=\"#学习目的：\" class=\"headerlink\" title=\"学习目的：\"></a>学习目的：</h1><p>要求:搭建一个独立博客网站,首先要有台连接到英特网服务器,要有前端的页面和后端的数据库,以及域名等.</p>\n<ol>\n<li><p>github可以提供给我们的是,github一个免费的代码托管仓库,它支持用户html页面的显示,用户可以上传HTML文件,然后在远程像访问网页一样访问它。</p>\n</li>\n<li><p>这时，博客还缺具有管理能力的网站后台,github不提供数据库等，对于博客这种数据规模很小,便可返璞归真,用回静态页面。</p>\n</li>\n<li><strong>Octopress</strong>:能将易于编写的<strong>Markdown</strong>的文本，翻译成为繁琐的<strong>html</strong>页面，同时帮助用户管理<strong>html</strong>页面并发布到github page上。</li>\n</ol>\n<h1 id=\"搭建环境：\"><a href=\"#搭建环境：\" class=\"headerlink\" title=\"搭建环境：\"></a>搭建环境：</h1><ol>\n<li><p><strong>Github</strong>:既然要托管到github,那么便要有github的环境. 检查本机的git环境,在命令行输入 <code>git--version</code></p>\n</li>\n<li><p><strong>Octopress</strong>:是基于Jekyll的,需要ruby的环境编译。检查本机ruby环境，命令行：<code>ruby-v</code>ruby的version1.9.3以上,新版的Mac,这些都是有装的。</p>\n</li>\n<li><strong>gcc</strong>和<strong>make</strong>,ruby的环境需要gcc,这个会通过安装xcode的command line tool来完成安装 检查本机gcc环境，命令行：<code>gcc -v</code></li>\n</ol>\n<h1 id=\"安装Octpress\"><a href=\"#安装Octpress\" class=\"headerlink\" title=\"安装Octpress:\"></a>安装Octpress:</h1><p>通过Git安装:</p>\n<ul>\n<li>下载<strong>Octopress</strong>：<code>gitclonegit://github.com/imathis/octopress.git octopress</code></li>\n<li>进入<strong>Octopress</strong>目录：<code>cd octopress</code></li>\n<li>安装必要的依赖包：<ul>\n<li><code>gem install bundler</code></li>\n<li><code>rbenv rehash</code> # If you use rbenv, rehash to be able to run the bundle command</li>\n<li><code>bundle install</code></li>\n</ul>\n</li>\n<li>最后安装Octopress:<code>rake install</code></li>\n</ul>\n<h2 id=\"配置：\"><a href=\"#配置：\" class=\"headerlink\" title=\"配置：\"></a>配置：</h2><ul>\n<li>修改配置文件<strong>_config.yml</strong>：<ul>\n<li>配置个人站点的信息：<strong>url</strong>:git远程库地址，<strong>title</strong>:博客题目,<strong>author</strong>:作者名,等。<ul>\n<li>注意：最好将twitter相关的配置信息全部删掉,否则由于GFW的原因,将会造成页面load很慢。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>修改定制文件：/source/_includes/custom/head.html把google的自定义字体去掉,原因同上。</li>\n</ul>\n<h2 id=\"写博客：\"><a href=\"#写博客：\" class=\"headerlink\" title=\"写博客：\"></a>写博客：</h2><p>博文是用markdown语法，另外扩充一些插件，网上相关介绍很多，例如：<a href=\"http://daringfireball.net/projects/markdown/\" target=\"_blank\" rel=\"noopener\">这个</a></p>\n<ul>\n<li><p>新建Markdown文件:          <code>rake new_post[&#39;文章名&#39;]</code>或 <code>rake new_page[&#39;404&#39;]</code></p>\n</li>\n<li><p>翻译Mardown为静态文件:   <code>rake generate</code></p>\n</li>\n<li><p>检测文件变化：            <code>rake watch</code></p>\n</li>\n<li><p>启动本机测试端口4000：  <code>rake preview</code></p>\n</li>\n<li><p>发布至git库：            <code>rake deploy</code></p>\n</li>\n</ul>\n<h2 id=\"添加多说：\"><a href=\"#添加多说：\" class=\"headerlink\" title=\"添加多说：\"></a>添加多说：</h2><p>  需要在多说网注册个帐号，添加站点，获取站点 <font color=\"red\">short_name</font>.</p>\n<ul>\n<li><p>######底部评论：</p>\n<ul>\n<li>在 <font color=\"red\"> _config.yml</font>     中添加<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#duoshuo comments</span></span><br><span class=\"line\"><span class=\"symbol\">duoshuo_comments:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"symbol\">duoshuo_short_name:</span> yourname</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>在<font color=\"red\"><code>source/_layouts/post.html</code></font>中的<font color=\"red\"> disqus</font>代码：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; % <span class=\"keyword\">if</span> site.disqus_short_name and page.comments == <span class=\"literal\">true</span> % &#125;</span><br><span class=\"line\">\t&lt;section&gt;</span><br><span class=\"line\">\t\t&lt;h1&gt;Comments&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"> \t\t&lt;div id=\"disqus_thread\" aria-live=\"polite\"&gt;&#123; % include post/</span>disqus_thread.html % &#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t&lt;/</span>section&gt;</span><br><span class=\"line\">&#123; % endif % &#125;</span><br></pre></td></tr></table></figure>\n<p>下方添加 <font color=\"red\">多说评论</font> 模块:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; % <span class=\"keyword\">if</span> site.duoshuo_short_name and site.duoshuo_comments == <span class=\"literal\">true</span> and  page.comments == <span class=\"literal\">true</span> % &#125;</span><br><span class=\"line\">&lt;section&gt;</span><br><span class=\"line\"> \t\t\t&lt;h1&gt;Comments&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"> \t\t\t\t&lt;div id=\"comments\" aria-live=\"polite\"&gt;&#123; % include post/</span>duoshuo.html % &#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"> \t\t\t\t&lt;/</span>section&gt;</span><br><span class=\"line\">&#123; % endif % &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>然后就按路径创建一个<font color=\"red\">source/_includes/post/duoshuo.html</font></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Duoshuo Comment BEGIN --&gt;</span><br><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"ds-thread\"</span> data-title=<span class=\"string\">\"\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> duoshuoQuery = &#123;<span class=\"attr\">short_name</span>:<span class=\"string\">\"\"</span>&#125;;</span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ds = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);</span><br><span class=\"line\">    ds.type = <span class=\"string\">'text/javascript'</span>;</span><br><span class=\"line\">    ds.async = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    ds.src = <span class=\"string\">'http://static.duoshuo.com/embed.js'</span>;</span><br><span class=\"line\">    ds.charset = <span class=\"string\">'UTF-8'</span>;</span><br><span class=\"line\">    (<span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'head'</span>)[<span class=\"number\">0</span>]  || <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'body'</span>)[<span class=\"number\">0</span>]).appendChild(ds);</span><br><span class=\"line\">    &#125;)();</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;!-- Duoshuo Comment END --&gt;</span></span><br></pre></td></tr></table></figure>\n<p>随后，再修改 <font color=\"red\">_includes/article.html </font>文件,<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; % <span class=\"keyword\">if</span> site.disqus_short_name and page.comments != <span class=\"literal\">false</span> and post.comments !=<span class=\"literal\">false</span> and site.disqus_show_comment_count == <span class=\"literal\">true</span> % &#125;</span><br><span class=\"line\">\t\t\t | &lt;a href=\"&#123; % if index % &#125;&#123;&#123; root_url &#125;&#125;&#123;&#123; post.url &#125;&#125;&#123; % endif % &#125;#disqus_thread\"&gt;Comments&lt;/a&gt;</span><br><span class=\"line\">&#123; % endif % &#125;</span><br></pre></td></tr></table></figure></p>\n<p>下方添加如下<font color=\"red\">多说评论链接路径</font>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; % <span class=\"keyword\">if</span> site.duoshuo_short_name and page.comments != <span class=\"literal\">false</span> and post.comments != <span class=\"literal\">false</span> and site.duoshuo_comments == <span class=\"literal\">true</span> % &#125;</span><br><span class=\"line\">| <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"&#123; % if index % &#125;&#123; % endif % &#125;#comments\"</span>&gt;</span>Comments<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br><span class=\"line\">&#123; % endif % &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>######首页侧边栏插入最新评论</p>\n<ul>\n<li><p>首先在 _config.yml 中再插入如下代码</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">duoshuo_asides_num:</span> <span class=\"number\">10</span>      <span class=\"comment\"># 侧边栏评论显示条目数</span></span><br><span class=\"line\"><span class=\"symbol\">duoshuo_asides_avatars:</span> <span class=\"number\">0</span>   <span class=\"comment\"># 侧边栏评论是否显示头像</span></span><br><span class=\"line\"><span class=\"symbol\">duoshuo_asides_time:</span> <span class=\"number\">0</span>      <span class=\"comment\"># 侧边栏评论是否显示时间</span></span><br><span class=\"line\"><span class=\"symbol\">duoshuo_asides_title:</span> <span class=\"number\">0</span>     <span class=\"comment\"># 侧边栏评论是否显示标题</span></span><br><span class=\"line\"><span class=\"symbol\">duoshuo_asides_admin:</span> <span class=\"number\">0</span>     <span class=\"comment\"># 侧边栏评论是否显示作者评论</span></span><br><span class=\"line\"><span class=\"symbol\">duoshuo_asides_length:</span> <span class=\"number\">18</span>   <span class=\"comment\"># 侧边栏评论截取的长度</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>再创建 <font color=\"red\">_includes/custom/asides/recent_comments.html</font></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Recent Comments<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">\"ds-recent-comments\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">data-num-items</span>=<span class=\"string\">\"\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">data-show-avatars</span>=<span class=\"string\">\"\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">data-show-time</span>=<span class=\"string\">\"\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">data-show-title</span>=<span class=\"string\">\"\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">data-show-admin</span>=<span class=\"string\">\"\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">data-excerpt-length</span>=<span class=\"string\">\"\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">   &#123; % if index % &#125;</span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 多说js加载开始，一个页面只需要加载一次 --&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">\t\t  <span class=\"keyword\">var</span> duoshuoQuery = &#123;<span class=\"attr\">short_name</span>:<span class=\"string\">\"\"</span>&#125;;</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t    <span class=\"keyword\">var</span> ds = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t    ds.type = <span class=\"string\">'text/javascript'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t    ds.async = <span class=\"literal\">true</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t    ds.src = <span class=\"string\">'http://static.duoshuo.com/embed.js'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t    ds.charset = <span class=\"string\">'UTF-8'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t    (<span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'head'</span>)[<span class=\"number\">0</span>]  ||</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t    <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'body'</span>)[<span class=\"number\">0</span>]).appendChild(ds);</span></span><br><span class=\"line\"><span class=\"undefined\">\t\t    &#125;)();</span></span><br><span class=\"line\"><span class=\"undefined\">\t\t</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 多说js加载结束，一个页面只需要加载一次 --&gt;</span></span><br><span class=\"line\">   &#123; % endif % &#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>最后修改：<font color=\"red\">_config.yml </font>配置:</p>\n<ul>\n<li>方式一：在<font color=\"red\"> blog_index_asides</font> 行或 <font color=\"red\">page_asides </font>行或 <font color=\"red\">post_asides </font>添加：</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">blog_index_asides:</span>[custom/asides/recent_comments.html]</span><br><span class=\"line\">或</span><br><span class=\"line\"><span class=\"symbol\">page_asides:</span>[custom/asides/recent_comments.html]</span><br><span class=\"line\">或</span><br><span class=\"line\"><span class=\"symbol\">post_asides:</span>[custom/asides/recent_comments.html]</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>方式二：将路径添加到 default_asides:[…] 中</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">default_asides:</span> [custom/asides/recent_comments.html, asides/recent_posts.html, ...]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Update</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多说评论似乎升级了系统，无法自动获取到页面文章标题，所以手动在评论页插入 data-title。--2013.09.10</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips:\"></a>Tips:</h1><ul>\n<li><h6 id=\"发布图文：\"><a href=\"#发布图文：\" class=\"headerlink\" title=\"发布图文：\"></a>发布图文：</h6></li>\n</ul>\n<p>如果在文章中上传图片：</p>\n<pre><code>* 直接copy到/source/images目录即可。便可以以相对路径(/images/imgname.png)的形式，在文章中引用。\n\n* 或找一个图库站点，例如flickr之类，然后在文章中引用该图片远程路径即可。\n</code></pre><ul>\n<li><h6 id=\"域名：\"><a href=\"#域名：\" class=\"headerlink\" title=\"域名：\"></a>域名：</h6>如果有自己的域名空间，可以将域名指向自己的博客，步骤如下：</li>\n</ul>\n<pre><code>* **配置DNS(需购买域名)**:在域名管理中，新建一个CNAME指向，将自己的域名指向yourname.github.com.\n\n* **给repo配置域名**:在source目录里，新建一个名为CNAME的文件，然后将自己的域名输入即可。\n\n* 将内容push到github后，大概需审核一个小时左右生效，然后就可以使用自己的域名访问该博客了。\n</code></pre><ul>\n<li><h6 id=\"添加百度统计和google-analytics\"><a href=\"#添加百度统计和google-analytics\" class=\"headerlink\" title=\"添加百度统计和google analytics\"></a>添加百度统计和google analytics</h6><ul>\n<li>从<a href=\"http://tongji.baidu.com/\" target=\"_blank\" rel=\"noopener\">百度统计</a>获取脚本,然后添加到文件source/_includes/after_footer.html文件中。</li>\n<li>从<a href=\"https://support.google.com/analytics/\" target=\"_blank\" rel=\"noopener\">google analytics</a>获取跟踪ID,然后将这个ID添加到_config.yml文件的google_analytics_tracking_id后面即可。<!--![alt text](https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png \"title text\")-->\n</li>\n</ul>\n</li>\n<li><p><strong>Octopress</strong>目录结构，及之间的关系：</p>\n</li>\n</ul>\n<p>￼<img src=\"/images/sourceFrame.png\" alt=\"alt text\" title=\"Octopress目录图解\"></p>\n<ul>\n<li><h6 id=\"原理：\"><a href=\"#原理：\" class=\"headerlink\" title=\"原理：\"></a>原理：</h6><ul>\n<li><p>Octopress版本库：</p>\n<ul>\n<li><p><strong>gh-pages</strong>分支：用于存放生成的最终网页。</p>\n</li>\n<li><p><strong>source</strong>分支:用于存放最初的markdown文件。</p>\n</li>\n</ul>\n<p>职责详述：平时写作和提交都在<strong>source</strong>分支下，当需要发布时，<code>rake deploy</code> 命令会将内容生成到public这个目录，然后将这个目录中的内容push到<strong>gh-pages</strong>分支中。</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><ul>\n<li>其中<strong>sass</strong>和<strong>source</strong>:这是博客的源代码文件目录。发布时，需要把源代码也上传到github上,这样便可以多台机写博客了。</li>\n</ul>\n</li>\n<li><ul>\n<li><strong>_deploy</strong>:是通过octopress生成的静态页面的博客文件夹,我们可以看到它的里面也有.git的文件。<ul>\n<li>cd进到该目录,使用<code>git remote ­v</code>查看<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">origin http:<span class=\"comment\">//github.com/....github.io(fetch)</span></span><br><span class=\"line\">origin http:<span class=\"comment\">//github.com/....github.io(push)</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>它会在我们使用<code>rake deploy</code>时自动push到该远程库的<strong>gh-pages</strong>分支。这时就不需要再手动push。只需要将博客源代码手动push到该远程库的<strong>source</strong>分支中.<br>  <strong>以上细节可参照Octopress根目录中Rakefile配置信息</strong></li>\n<li><ul>\n<li>使用多台电脑的同时写博客<ul>\n<li><ol>\n<li>需要先拿把<strong>source</strong> code拿下来 <code>git pull origin source</code></li>\n</ol>\n</li>\n<li><ol>\n<li><code>check in</code>更新,将本地 <strong>source</strong>分支上的代码，合并到远程仓库上<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &apos;yourmessage&apos;</span><br><span class=\"line\">git push origin source</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"版本管理\"><a href=\"#版本管理\" class=\"headerlink\" title=\"版本管理\"></a>版本管理</h1><p>你可以先去github上新建一个空的Repo（最好是private的，否则可能会被其他人拿到你的source），拿到repo的url，然后到octopress目录下执行下面这些操作：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 因为你是从octopress github上clone的，所以需要把origin这个branch换一个名字</span></span><br><span class=\"line\">git remote rename origin octopress</span><br><span class=\"line\">git remote add origin (your github url)</span><br><span class=\"line\"><span class=\"comment\"># 把你的github branch作为默认的branch</span></span><br><span class=\"line\">git config branch.master.remote origin</span><br><span class=\"line\"><span class=\"comment\"># 把你的octopress导入到github上去</span></span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure></p>\n<p>如果你新增加了博客或者修改了某些内容，你可以把你的改动commit到github上去：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add source</span><br><span class=\"line\">git commit -a -m &apos;new blog or edit some blog&apos;</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure></p>\n<p>如果octopress有更新，你可以直接pull octopress这个branch进行更新即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull octopress master</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"hexo","path":"api/categories/hexo.json"}],"tags":[{"name":"octopress","path":"api/tags/octopress.json"},{"name":"blog","path":"api/tags/blog.json"},{"name":"github","path":"api/tags/github.json"},{"name":"mou","path":"api/tags/mou.json"},{"name":"ruby","path":"api/tags/ruby.json"}]}]}