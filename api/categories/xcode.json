{"name":"xcode","postlist":[{"title":"Otherlinkerflags设置ld命令执行的参数","slug":"xcode/Otherlinkerflags设置ld命令执行的参数","date":"2018-04-11T16:42:57.000Z","updated":"2018-04-11T19:16:17.000Z","comments":true,"path":"api/articles/xcode/Otherlinkerflags设置ld命令执行的参数.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>Other linker flags设置的值实际上就是ld命令执行时后面所加的参数。</p>\n<p>3个常用参数：<br><code>-ObjC</code>：加了这个参数后，链接器就会把静态库中所有的Objective-C类和分类都加载到最后的可执行文件中<br><code>-all_load</code>：会让链接器把所有找到的目标文件都加载到可执行文件中，但是千万不要随便使用这个参数！假如你使用了不止一个静态库文件，然后又使用了这个参数，那么你很有可能会遇到<code>ld: duplicate symbol</code>错误，因为不同的库文件里面可能会有相同的目标文件，所以建议在遇到<code>-ObjC</code>失效的情况下使用<code>-force_load</code>参数。<br><code>-force_load</code>：所做的事情跟<code>-all_load</code>其实是一样的，但是<code>-force_load</code>需要指定要进行全部加载的库文件的路径，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载.</p>\n<h3 id=\"加载FrameWork\"><a href=\"#加载FrameWork\" class=\"headerlink\" title=\"加载FrameWork\"></a>加载FrameWork</h3><h3 id=\"加载静态库\"><a href=\"#加载静态库\" class=\"headerlink\" title=\"加载静态库\"></a>加载静态库</h3>","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"}],"tags":[]},{"title":"iOS插件化开发之Small","slug":"xcode/iOS插件化开发之Small","date":"2018-04-11T16:42:17.000Z","updated":"2018-04-11T19:16:17.000Z","comments":true,"path":"api/articles/xcode/iOS插件化开发之Small.json","excerpt":null,"keywords":null,"cover":"https://camo.githubusercontent.com/25aac173476e3a5eecdf2853b0e233bf8179bece/687474703a2f2f636f64652e7765717569636b2e6e65742f6173736574732f696d616765732f736d616c6c2d696f732d74656d706c6174652e706e67","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><div id=\"badge-container-huos3203-Small-04f08ae4a26\" class=\"hexo-github\" style=\"width: =\"></div>\n<script src=\"/hexo-github/badge.js\"></script>\n<script type=\"text/javascript\">\n  loadStyle(\"/hexo-github/style.css\");\n  loadStyle(\"/hexo-github/octicons/octicons.css\");\n  new Badge(\"#badge-container-huos3203-Small-04f08ae4a26\", \"huos3203\", \"Small\", \"04f08ae4a26\", false);\n</script>\n\n<p><a href=\"http://code.wequick.net/Small/cn/home\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h2 id=\"iOS组件化基础\"><a href=\"#iOS组件化基础\" class=\"headerlink\" title=\"iOS组件化基础\"></a>iOS组件化基础</h2><p>iOS组件化基于<a href=\"https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Framework.html#//apple_ref/doc/uid/TP40008195-CH56-SW1\" target=\"_blank\" rel=\"noopener\">Cocoa Touch Framework</a>（以下简称CTF）通过<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSBundle_Class/index.html#//apple_ref/occ/cl/NSBundle\" target=\"_blank\" rel=\"noopener\">NSBundle</a>实现。</p>\n<ul>\n<li>CTF首次公开在WWDC2014，要求Xcode6 beta以上版本。</li>\n<li>CTF官方表示支持8.0以上系统，但在6.0、7.0上测试正常。</li>\n<li>如果你的App包含了CTF，但是<strong>Deployment Target</strong> &lt; 8.0，上传二进制文件到App Store时会报警中断。</li>\n</ul>\n<p>受苹果官方限制，如果你的CTF没有签名，将无法实现代码级别更新。</p>\n<p>Framework 模式无法上传到App Store。只能应用到企业版</p>\n<h2 id=\"使用文档\"><a href=\"#使用文档\" class=\"headerlink\" title=\"使用文档\"></a>使用文档</h2><ol>\n<li><p>导入模板，重启Xcode</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/wequick/Small.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> Small/iOS</span><br><span class=\"line\">cp -r Templates ~/Library/Developer/Xcode/Templates</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建工程<br><code>File-&gt;New-&gt;Project...</code>，选择Small-pods模板<br><img src=\"https://camo.githubusercontent.com/25aac173476e3a5eecdf2853b0e233bf8179bece/687474703a2f2f636f64652e7765717569636b2e6e65742f6173736574732f696d616765732f736d616c6c2d696f732d74656d706c6174652e706e67\" alt=\"Small iOS Template\"></p>\n</li>\n<li><p>安装Pods</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> [your-project-path]</span><br><span class=\"line\">pod install --no-repo-update</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>关闭工程并打开xcworkspace</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open *.xcworkspace</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><ul>\n<li>使用者模式<a href=\"Sample\">Sample</a></li>\n</ul>\n<blockquote>\n<p>需要先编译Pods</p>\n</blockquote>\n<ul>\n<li>开发者模式<a href=\"DevSample\">DevSample</a></li>\n</ul>\n<blockquote>\n<p>需要去除并行编译模式：<code>Edit Scheme...-&gt;Build-&gt;Build Options-&gt; [ ] Parallelize Build</code></p>\n<p>各个组件需要签名后才支持代码级别更新。示例中更新例子为xib内容更新。<br><br>在没有设置签名之前，请在模拟器上跑示例。</p>\n</blockquote>\n<h2 id=\"TODO-List\"><a href=\"#TODO-List\" class=\"headerlink\" title=\"TODO List\"></a>TODO List</h2><ul>\n<li>Sample支持CocoaPods</li>\n<li>设置签名脚本（现在需要对每个组件Project手动设置签名）</li>\n<li>热更新（现在需要重启生效）</li>\n<li>Xcode Template for creating new <code>Small Bundle</code></li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://github.com/wequick/small/wiki/iOS\" target=\"_blank\" rel=\"noopener\">Wiki/iOS</a><br><a href=\"http://www.cocoachina.com/industry/20140613/8810.html\" target=\"_blank\" rel=\"noopener\">WWDC2014之iOS使用动态库</a></p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"}],"tags":[]},{"title":"Xcode9新特性","slug":"xcode/Xcode9新特性","date":"2017-06-15T16:54:38.000Z","updated":"2017-06-23T10:51:22.000Z","comments":true,"path":"api/articles/xcode/Xcode9新特性.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/Connectvianetwork.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"无线调试\"><a href=\"#无线调试\" class=\"headerlink\" title=\"无线调试\"></a>无线调试</h2><h3 id=\"升级设备系统\"><a href=\"#升级设备系统\" class=\"headerlink\" title=\"升级设备系统\"></a>升级设备系统</h3><p>体验iOS11系统需要几步操作：</p>\n<ol>\n<li><a href=\"https://profile.apple.xsico.cn\" target=\"_blank\" rel=\"noopener\">下载配置文件：iOS_11_beta_Configuration_Profile</a>，在手机端使用safari浏览器打开链接，自动安装到描述文件中。</li>\n<li>设置中的“软件更新”会自动检测到iOS11 Developer beta版本，表明可以下载更新了。</li>\n</ol>\n<h3 id=\"配置设备信息\"><a href=\"#配置设备信息\" class=\"headerlink\" title=\"配置设备信息\"></a>配置设备信息</h3><ol>\n<li>链接你的设备<br>选择Window -&gt; Device and Simulators，完成之后左侧Connected区域你的设备右侧会显示小地图的图标，表示你已经连接上，此时断开数据线，就可以开始无线调试了。如下图所示：<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/Connectvianetwork.png?imageMogr2/2/w/800\"></li>\n<li>如果iphone和mac不在同一局域网，你可以按照下图进行设置：<br><img src=\"https://static.oschina.net/uploads/space/2017/0610/112915_7tCQ_2279344.png\" alt=\"\"></li>\n</ol>\n<h2 id=\"xcode-的新特性\"><a href=\"#xcode-的新特性\" class=\"headerlink\" title=\"xcode 的新特性\"></a>xcode 的新特性</h2><ol>\n<li>集成github<ol>\n<li>在偏好设置中，新增github账号<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcode9github.png?imageMogr2/2/w/800\"></li>\n<li>在导航栏中，新增git版本库导航器<br>快速查看本地版本的Branches／Tags和commit时间轴，以及Remotes远程版本库信息。支持版本库基本操作：新建／合并／切换分支，打tag标签。还支持新建远程仓库，删除远程分支。<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcode9daohang.png?imageMogr2/2/w/800\">\n通过双击commit的时间轴的一个条目来查看某次提交中文件的更改详情<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcode9doublelog.png?imageMogr2/2/w/800\"></li>\n<li>xcode欢迎页面，clone已有库的界面，可以直接查看readme.md<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcode9clone.png?imageMogr2/2/w/800\"> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcode9readme.png?imageMogr2/2/w/800\">\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"markdown的支持\"><a href=\"#markdown的支持\" class=\"headerlink\" title=\"markdown的支持\"></a>markdown的支持</h3><p>在Markdown文件中，您键入时，标题，粗体和斜体文本，链接和其他格式将立即在编辑器中呈现。Jump Bar甚至可以了解Markdown结构，因此您可以快速浏览README.md和文档文件。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcode9markdown.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"色彩管理\"><a href=\"#色彩管理\" class=\"headerlink\" title=\"色彩管理\"></a>色彩管理</h3><p>在Xcode中的xcassets中添加自定义的颜色，指定颜色名字:<code>MyColor</code>，这样就可以在代码和IB中方便的引用了。</p>\n<ol>\n<li>右键选择添加New Color Set</li>\n<li>点击Any，在右侧区域中轻松设置你的颜色</li>\n<li><p>使用<br> 代码中引用：UIColor(named:) 新方法引用你的颜色</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view.backgroundColor = <span class=\"type\">UIColor</span>(named:<span class=\"string\">\"MyColor\"</span>)</span><br></pre></td></tr></table></figure>\n<p> IB中引用你的颜色<br> <img src=\"https://static.oschina.net/uploads/space/2017/0610/113750_bVTy_2279344.png\" alt=\"\"></p>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"特性","path":"api/categories/特性.json"}],"tags":[]},{"title":"Xcode8中SB适配横竖屏按钮VaryforTraits","slug":"xcode/Xcode8中SB适配横竖屏按钮VaryforTraits","date":"2017-06-13T17:33:59.000Z","updated":"2017-06-23T10:51:21.000Z","comments":true,"path":"api/articles/xcode/Xcode8中SB适配横竖屏按钮VaryforTraits.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/TraitVariations.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>升级xcode8之后，打开storyboard发现xcode7适配界面的size class被Trait Variations所取代:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/TraitVariations.png?imageMogr2/2/w/800\"><br>Trait Variations只是size class的直观表现方式，改善了原本九宫格选取过于抽象的问题，直接选机型很清晰直观，但本质未变。</p>\n<h3 id=\"添加竖屏约束\"><a href=\"#添加竖屏约束\" class=\"headerlink\" title=\"添加竖屏约束\"></a>添加竖屏约束</h3><p>xcode8版本的选择器，由原来的九宫格形式，改进为机型选择器：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/VaryforTraits.png?imageMogr2/2/w/800\">   </p>\n<p>以前版本：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/sizeclass.png?imageMogr2/2/w/800\">   </p>\n<h4 id=\"Vary-for-Traits\"><a href=\"#Vary-for-Traits\" class=\"headerlink\" title=\"Vary for Traits\"></a>Vary for Traits</h4><p>对不同设备和方向上添加约束</p>\n<ol>\n<li>点击右侧的Vary for Traits 会弹出选择Width／Height或组合, 左边的会立即显示将适配的所有机型和方向，即此时新增的约束应用到的不同方向的所有机型<br>假如：选width，会发现约束会同时应用到iPhone的横竖屏：<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/VaryforTraits.png?imageMogr2/2/w/800\">   \n选中了Height之后（这里Width选不选中都是可以的），会发现左侧横屏的设备消失，接下来添加的约束就只会运用到竖屏界面上了<br>接下来为竖屏状态的界面添加约束，</li>\n<li>点击Done Varying按钮完成对约束的添加   </li>\n</ol>\n<h3 id=\"iPad适配时无法区分横竖屏\"><a href=\"#iPad适配时无法区分横竖屏\" class=\"headerlink\" title=\"iPad适配时无法区分横竖屏\"></a>iPad适配时无法区分横竖屏</h3><p>对比iPhone横竖屏：<br>竖屏状态是wC：hR 横屏下是wC：hC (w是width h是height，C是Compact R是Regular) ，所以可以方便横竖屏俩套UI是由于横竖屏的size class是不同的。<br>但iPad横竖屏都是wR：hR, 所以在竖屏设置的约束同样会应用到横屏上。<br>所以iPad横竖屏布局还得监听屏幕旋转更改约束，或者在layoutSubview中修改frame了。所以就目前而言一套界面同时适配iPhone与iPad横竖屏这4种界面还是有些困难，也很少(没有？)有应用这样干，大多数应用还是单独做了HD版本，或者直接用iPhone的布局方案。</p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"SB","path":"api/categories/SB.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"}]},{"title":"Xcode8插件制作替代Alcatraz","slug":"xcode/Xcode8插件制作替代Alcatraz","date":"2017-05-15T14:09:30.000Z","updated":"2017-06-23T10:51:21.000Z","comments":true,"path":"api/articles/xcode/Xcode8插件制作替代Alcatraz.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/插件架构图.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><ol>\n<li>Xcode7插件工具Alcatraz<br>开发者可以在Xcode运行的时候通过注入代码去实现插件的功能。插件可以在一个Alcatraz这个优秀的APP上面提交和分发。</li>\n<li>Xcode8编辑源码的插件Xcode source editor extensions<br>Xcode 8验证每个库和包，以防止恶意代码未经您的许可运行。苹果公司在今年的WWDC上宣布了可以通过开发<code>Xcode source editor extensions</code>来扩展现有的源代码编辑功能。<br>当Xcode启动的时候，先前通过<code>Alcatraz</code>安装的插件不会再被加载。</li>\n</ol>\n<h2 id=\"源码编辑器插件\"><a href=\"#源码编辑器插件\" class=\"headerlink\" title=\"源码编辑器插件\"></a>源码编辑器插件</h2><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/插件架构图.png?imageMogr2/2/w/800\">\n<h3 id=\"Info-plist文件\"><a href=\"#Info-plist文件\" class=\"headerlink\" title=\"Info.plist文件\"></a>Info.plist文件</h3><p>Source Editor Command是命令默认的名字。开发者可以在extension的Info.plist文件里面修改。打开之后修改为 Clean Syntax</p>\n<h3 id=\"解析插件启动类SourceEditorExtension-swift\"><a href=\"#解析插件启动类SourceEditorExtension-swift\" class=\"headerlink\" title=\"解析插件启动类SourceEditorExtension.swift\"></a>解析插件启动类SourceEditorExtension.swift</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Foundation</span><br><span class=\"line\"><span class=\"keyword\">import</span> XcodeKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SourceEditorExtension</span>: <span class=\"title\">NSObject</span>, <span class=\"title\">XCSourceEditorExtension</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1. 启动extension被调用，自定义相关操作</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">extensionDidFinishLaunching</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//commandDefinitions属性的getter方法可以动态的展示或是隐藏特定的指令</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> commandDefinitions: [[<span class=\"type\">XCSourceEditorCommandDefinitionKey</span>: <span class=\"type\">AnyObject</span>]]&#123;<span class=\"keyword\">return</span> []&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"解析插件核心类SourceEditorCommand-swift\"><a href=\"#解析插件核心类SourceEditorCommand-swift\" class=\"headerlink\" title=\"解析插件核心类SourceEditorCommand.swift\"></a>解析插件核心类SourceEditorCommand.swift</h3><p>在这个文件里面可以实现extension的相关逻辑<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SourceEditorCommand</span>: <span class=\"title\">NSObject</span>, <span class=\"title\">XCSourceEditorCommand</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//当通过Xcode菜单键调用插件时调用，实现插件功能的主体</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">perform</span><span class=\"params\">(with invocation: XCSourceEditorCommandInvocation,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               completionHandler: @escaping <span class=\"params\">(Error?)</span></span></span> -&gt; <span class=\"type\">Void</span> ) -&gt; <span class=\"type\">Void</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 正则匹配含有 闭包 的文本</span></span><br><span class=\"line\">       <span class=\"keyword\">var</span> updatedLineIndexes = [<span class=\"type\">Int</span>]()</span><br><span class=\"line\">       <span class=\"keyword\">for</span> lineIndex <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; invocation.buffer.lines.<span class=\"built_in\">count</span></span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           <span class=\"keyword\">let</span> line = invocation.buffer.lines[lineIndex] <span class=\"keyword\">as</span>! <span class=\"type\">NSString</span></span><br><span class=\"line\">           <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">let</span> results = <span class=\"keyword\">try</span> findClosureSyntax(line: line)</span><br><span class=\"line\">               <span class=\"comment\">//简化所有闭包语法格式：移除闭包里面括号</span></span><br><span class=\"line\">               <span class=\"number\">_</span> = results.<span class=\"built_in\">map</span> &#123; result <span class=\"keyword\">in</span></span><br><span class=\"line\">                   <span class=\"keyword\">let</span> cleanLine = line.remove(characters: [<span class=\"string\">\"(\"</span>, <span class=\"string\">\")\"</span>], <span class=\"keyword\">in</span>: result.range)</span><br><span class=\"line\">                   updatedLineIndexes.append(lineIndex)</span><br><span class=\"line\">                   invocation.buffer.lines[lineIndex] = cleanLine</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">               completionHandler(error <span class=\"keyword\">as</span> <span class=\"type\">NSError</span>)</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       completionHandler(<span class=\"literal\">nil</span>)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">//使用正则表达式去遍历每一行代码是否含有闭包</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findClosureSyntax</span><span class=\"params\">(line:NSString)</span></span> <span class=\"keyword\">throws</span> -&gt;[<span class=\"type\">NSTextCheckingResult</span>]</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       <span class=\"keyword\">let</span> regex =  <span class=\"keyword\">try</span> <span class=\"type\">NSRegularExpression</span>(pattern: <span class=\"string\">\"\\\\&#123;.*\\\\(.+\\\\).+in\"</span>, options: .caseInsensitive)</span><br><span class=\"line\">       <span class=\"keyword\">let</span> range = <span class=\"type\">NSRange</span>(<span class=\"number\">0</span> ..&lt; line.length)</span><br><span class=\"line\">       <span class=\"keyword\">return</span> regex.matches(<span class=\"keyword\">in</span>: line <span class=\"keyword\">as</span> <span class=\"type\">String</span>, options: .reportProgress, range: range)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"一个方法两个参数\"><a href=\"#一个方法两个参数\" class=\"headerlink\" title=\"一个方法两个参数\"></a>一个方法两个参数</h4><ol>\n<li><p>方法<br>当通过Xcode菜单键调用插件时：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perform(with:completionHandler:)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>两个参数<br><code>buffer</code>属性：访问当前选中的文件源代码，<code>XCSourceEditorCommandInvocation</code>对象的<code>buffer</code>属性；<br><code>completionhandler</code>：将会以参数为nil进行调用，否则将会给它传递一个<code>NSError</code>实例作为参数。</p>\n</li>\n</ol>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><ol>\n<li>选择scheme后编译运行自定义的extensions插件</li>\n<li>选择测试安装插件的Xcode<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/extensionsApp.png?imageMogr2/2/w/800\"></li>\n<li>点击run按钮会单独启动一个全新的Xcode<br>在新的Xcode实例中，创建一个新的工程或是打开一个存在的工程。</li>\n<li>然后执行Editor &gt; Clean Closure &gt; Source Editor Command，需要确保在当前的文件里面含有一个闭包。这样就可以看到如下的效果，刚才开发的extension工作了！<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcodeAPP.gif?imageMogr2/2/w/800\">\n</li>\n</ol>\n<h2 id=\"命令快捷键\"><a href=\"#命令快捷键\" class=\"headerlink\" title=\"命令快捷键\"></a>命令快捷键</h2><p>设置快捷键去自动调用Clean Syntax命令</p>\n<ol>\n<li>打开Xcode的Preferences，选择Key Bindings ;</li>\n<li>搜索Clean Syntax，点击右边然后输入快捷键，例如：Command-Alt-Shift-+。<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/KeyBindings.png?imageMogr2/2/w/800\">\n</li>\n</ol>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"插件","path":"api/categories/插件.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"}]},{"title":"高期望实现异步单元测试","slug":"测试/高期望实现异步单元测试","date":"2017-02-20T23:09:30.000Z","updated":"2017-05-26T11:03:05.000Z","comments":true,"path":"api/articles/测试/高期望实现异步单元测试.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"异步单元测试\"><a href=\"#异步单元测试\" class=\"headerlink\" title=\"异步单元测试\"></a>异步单元测试</h2><p>在Xcode 6之前的版本里面并没有内置<code>XCTest</code>，只能是在主线程的<code>RunLoop</code>里面使用一个<code>while循环</code>,然后一直等待响应或者直到<code>timeout</code>.</p>\n<p>在Xcode 6里，苹果以<code>XCTestExpection类</code>的方式向<code>XCTest框架</code>里添加了<code>测试期望</code>(test expection)。<br>XCTest框架中相关的方法：设置期望，实现期望，通知期望，谓词计算期望等，以及期望的传递。</p>\n<h3 id=\"常规实现方式\"><a href=\"#常规实现方式\" class=\"headerlink\" title=\"常规实现方式\"></a>常规实现方式</h3><p>在主线程里，使用<code>while循环</code>每隔10毫秒会执行一次，直到有响应或者5秒之后超出响应时间限制才会跳出：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testAsyncTheOldWay</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timeoutDate = <span class=\"type\">Date</span>.<span class=\"keyword\">init</span>(timeIntervalSinceNow: <span class=\"number\">5.0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> responseHasArrived = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"type\">Alamofire</span>.request(<span class=\"string\">\"https://www.baidu.com\"</span>).responseData&#123;response <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"获取到的数据长度：\\(String(data: response.data!, </span></span><br><span class=\"line\"><span class=\"string\">                                   encoding:String.Encoding.utf8)!)\"</span>)</span><br><span class=\"line\">        responseHasArrived = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"type\">XCTAssert</span>((response.data?.<span class=\"built_in\">count</span>)! &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (responseHasArrived == <span class=\"literal\">false</span> </span><br><span class=\"line\">            &amp;&amp; (timeoutDate.timeIntervalSinceNow &gt; <span class=\"number\">0</span>)) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">CFRunLoopRunInMode</span>(<span class=\"type\">CFRunLoopMode</span>.defaultMode, <span class=\"number\">0.01</span>, <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (responseHasArrived == <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">XCTFail</span>(<span class=\"string\">\"Test timed out\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"XCTest相关API\"><a href=\"#XCTest相关API\" class=\"headerlink\" title=\"XCTest相关API\"></a>XCTest相关API</h2><p>在Xcode 6里，苹果以<code>XCTestExpection类</code>的方式向<code>XCTest框架</code>里添加了<code>测试期望</code>(test expection)。</p>\n<h3 id=\"XCTestExpection-高期望-High-Expectations-的实现和使用\"><a href=\"#XCTestExpection-高期望-High-Expectations-的实现和使用\" class=\"headerlink\" title=\"XCTestExpection:高期望(High Expectations)的实现和使用\"></a>XCTestExpection:高期望(High Expectations)的实现和使用</h3><p>设置期望，实现期望，通知期望，谓词计算期望等，以及期望的传递。</p>\n<h4 id=\"expectation-description-为XCTest测试单元设置期望\"><a href=\"#expectation-description-为XCTest测试单元设置期望\" class=\"headerlink\" title=\"expectation(description:):为XCTest测试单元设置期望\"></a><code>expectation(description:)</code>:为XCTest测试单元设置期望</h4><p>为XCTest单元测试，设置一个测试期望以及错误信息描述，并在某一时刻<code>fulfill</code>实现该期望对象<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//expectation(description: String) -&gt; XCTestExpectation</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> expection = expectation(description: <span class=\"string\">\"失败时显示原因\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"fulfill-调用它表示测试达到期望值\"><a href=\"#fulfill-调用它表示测试达到期望值\" class=\"headerlink\" title=\"fulfill():调用它表示测试达到期望值\"></a><code>fulfill()</code>:调用它表示测试达到期望值</h5><p>一般在单元测试通过时调用，告知测试已达期望，这一方法替代了<code>responseHasArrived</code>作为Flag的方式<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//- (void)fulfill;</span></span><br><span class=\"line\">expection.fulfill()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"waitForExpectations-timeout-handler-在方法底部设置测试期望的时效\"><a href=\"#waitForExpectations-timeout-handler-在方法底部设置测试期望的时效\" class=\"headerlink\" title=\"waitForExpectations(timeout:handler:):在方法底部设置测试期望的时效\"></a><code>waitForExpectations(timeout:handler:)</code>:在方法底部设置测试期望的时效</h4><p>在方法底部指定一个超时，如果测试条件不适合时间范围便会结束执行<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// open func waitForExpectations(timeout: TimeInterval, handler: XCTest.XCWaitCompletionHandler? = nil)</span></span><br><span class=\"line\">waitForExpectations(timeout: <span class=\"number\">5</span>) &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"错误信息:\\(error?.localizedDescription)\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如果完成处理的代码在指定时限里执行并调用了<code>fulfill()</code>方法，那么就说明所有的测试期望在此期间都已经被实现。否则就测试就被打断不再执行</p>\n<h4 id=\"expectation-forNotification-object-handler-通知期望\"><a href=\"#expectation-forNotification-object-handler-通知期望\" class=\"headerlink\" title=\"expectation(forNotification:object:handler:):通知期望\"></a>expectation(forNotification:object:handler:):通知期望</h4><p>该方法监听一个通知,如果在规定时间内正确收到通知则测试通过<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//expectation(forNotification notificationName: String, object objectToObserve: Any?, handler: XCTest.XCNotificationExpectationHandler? = nil) -&gt; XCTestExpectation</span></span><br><span class=\"line\"><span class=\"comment\">//设置一个测试通知期望</span></span><br><span class=\"line\">expectation(forNotification: <span class=\"string\">\"BLDownloadImageNotification\"</span>, </span><br><span class=\"line\">                     object: <span class=\"literal\">nil</span>) </span><br><span class=\"line\">&#123;(notification) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> userInfo = notification.userInfo <span class=\"keyword\">as</span>! [<span class=\"type\">String</span>:<span class=\"type\">String</span>]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name = userInfo[<span class=\"string\">\"name\"</span>]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"name:\\(name)\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">来定义一个通知并发送通知，来测试：</span><br><span class=\"line\"><span class=\"keyword\">let</span> notif =  <span class=\"type\">Notification</span>.<span class=\"type\">Name</span>(rawValue: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\"><span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.post(name: notif, object: <span class=\"keyword\">self</span>, userInfo: [<span class=\"string\">\"name\"</span>:<span class=\"string\">\"huosan\"</span>,<span class=\"string\">\"sex\"</span>:<span class=\"string\">\"man\"</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置延迟多少秒后，如果没有满足测试条件就报错</span></span><br><span class=\"line\">waitForExpectations(timeout: <span class=\"number\">3</span>, handler: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"使用expectation-description-实现\"><a href=\"#使用expectation-description-实现\" class=\"headerlink\" title=\"使用expectation(description:)实现\"></a>使用<code>expectation(description:)</code>实现</h5><p>帮助理解 <code>expectation(forNotification:object:handler:)</code> 方法和 <code>expectation(description:)</code> 的区别<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testAsynForNotificationWithExpectation</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> expectation = <span class=\"keyword\">self</span>.expectation(description: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> notif = <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>(rawValue: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sub = <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(forName: notif, object: <span class=\"literal\">nil</span>, queue: <span class=\"literal\">nil</span>) &#123; (notification) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        expectation.fulfill()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//发送一个通知</span></span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.post(name: notif, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//waitForExpectations</span></span><br><span class=\"line\">    waitForExpectations(timeout: <span class=\"number\">1</span>, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//移除通知</span></span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.removeObserver(sub)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"expectation-for-evaluatedWith-handler-谓词计算测试法\"><a href=\"#expectation-for-evaluatedWith-handler-谓词计算测试法\" class=\"headerlink\" title=\"expectation(for:evaluatedWith:handler:):谓词计算测试法\"></a>expectation(for:evaluatedWith:handler:):谓词计算测试法</h4><p>利用谓词计算，判断<code>button</code>的<code>backgroundImageForState</code>方法，是否正确的获得了<code>backgroundImage</code>，如果<code>20秒</code>内正确获得则通过测试，否则失败<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//open func expectation(for predicate: NSPredicate, evaluatedWith object: Any, handler: XCTest.XCPredicateExpectationHandler? = nil) -&gt; XCTestExpectation</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testThatBackgroundImageChanges</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> viewController = <span class=\"type\">OnclickLikeViewController</span>()</span><br><span class=\"line\">    <span class=\"comment\">//viewController.loadView()  //不执行viewDidload方法</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"number\">_</span> = viewController.view</span><br><span class=\"line\">    <span class=\"keyword\">let</span> button = viewController.button</span><br><span class=\"line\">    <span class=\"keyword\">let</span> img = button.backgroundImage(<span class=\"keyword\">for</span>: .normal)</span><br><span class=\"line\">    <span class=\"type\">XCTAssertNil</span>(img,<span class=\"string\">\"此时img不为nil,中止执行\"</span>)  <span class=\"comment\">//当img不是nil时，执行断言</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> predicate = <span class=\"type\">NSPredicate</span>.<span class=\"keyword\">init</span> &#123; (anyobject, bindings) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> button = anyobject <span class=\"keyword\">as</span>! <span class=\"type\">UIButton</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> button.backgroundImage(<span class=\"keyword\">for</span>: <span class=\"type\">UIControlState</span>()) != <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    expectation(<span class=\"keyword\">for</span>: predicate, evaluatedWith: button, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    waitForExpectations(timeout: <span class=\"number\">20</span>, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"使用expectation-description-实现-1\"><a href=\"#使用expectation-description-实现-1\" class=\"headerlink\" title=\"使用expectation(description:)实现\"></a>使用<code>expectation(description:)</code>实现</h5><p>帮助理解 <code>expectation(for:evaluatedWith:handler:)</code> 方法和 <code>expectation(description:)</code> 的区别<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testThatBackgroundImageChanges</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//设置期望</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> expectation = <span class=\"keyword\">self</span>.expectation(description: <span class=\"string\">\"backgroundImageForState\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> viewController = <span class=\"type\">OnclickLikeViewController</span>()</span><br><span class=\"line\">    <span class=\"comment\">//viewController.loadView()  //不执行viewDidload方法</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"number\">_</span> = viewController.view</span><br><span class=\"line\">    <span class=\"keyword\">let</span> button = viewController.button</span><br><span class=\"line\">    <span class=\"keyword\">let</span> img = button.backgroundImage(<span class=\"keyword\">for</span>: .normal)</span><br><span class=\"line\">    <span class=\"type\">XCTAssertNil</span>(img,<span class=\"string\">\"此时img不为nil,中止执行\"</span>)  <span class=\"comment\">//当img不是nil时，执行断言</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> predicate = <span class=\"type\">NSPredicate</span>.<span class=\"keyword\">init</span> &#123; (anyobject, bindings) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> button = anyobject <span class=\"keyword\">as</span>! <span class=\"type\">UIButton</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> button.backgroundImage(<span class=\"keyword\">for</span>: <span class=\"type\">UIControlState</span>()) != <span class=\"literal\">nil</span></span><br><span class=\"line\">        <span class=\"comment\">//实现测试期望</span></span><br><span class=\"line\">        expectation.fulfill()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//等待期望实现</span></span><br><span class=\"line\">    waitForExpectations(timeout: <span class=\"number\">20</span>, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传递expectation在目的方法中再fulfill-实现期望\"><a href=\"#传递expectation在目的方法中再fulfill-实现期望\" class=\"headerlink\" title=\"传递expectation在目的方法中再fulfill()实现期望\"></a>传递expectation在目的方法中再fulfill()实现期望</h3><p>例如将期望封装在字典中，通过通知来传递给异步下载的方法中调用该期望的<code>fulfill()</code>方法，实现单元测试的期望<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*/</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testAsynForNotificationWithExpectation2</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> expectation = <span class=\"keyword\">self</span>.expectation(description: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> notif = <span class=\"type\">Notification</span>.<span class=\"type\">Name</span>(rawValue: <span class=\"string\">\"BLDownloadImageNotification\"</span>)</span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(<span class=\"keyword\">self</span>, selector: #selector(<span class=\"type\">AsyncTheOldWayTest</span>.downLoadImage(<span class=\"number\">_</span>:)), name: notif, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//将期望封装在字典中传递</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> userInf = [<span class=\"string\">\"name\"</span>:<span class=\"string\">\"huosan\"</span>,<span class=\"string\">\"sex\"</span>:<span class=\"string\">\"man\"</span>,<span class=\"string\">\"expectation\"</span>:expectation]</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.post(name: notif, object: <span class=\"keyword\">self</span>, userInfo: userInf)</span><br><span class=\"line\">        <span class=\"comment\">//等待期望实现</span></span><br><span class=\"line\">        waitForExpectations(timeout: <span class=\"number\">1</span>, handler: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.removeObserver(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">downLoadImage</span><span class=\"params\">(<span class=\"number\">_</span> notification:Notification)</span></span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> userInfo = notification.userInfo <span class=\"keyword\">as</span>! [<span class=\"type\">String</span>:<span class=\"type\">AnyObject</span>]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> name = userInfo[<span class=\"string\">\"name\"</span>]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> sex = userInfo[<span class=\"string\">\"sex\"</span>]</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"name:\\(name), sex = \\(sex)\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> expectation = userInfo[<span class=\"string\">\"expectation\"</span>] <span class=\"keyword\">as</span>! <span class=\"type\">XCTestExpectation</span></span><br><span class=\"line\">        expectation.fulfill()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"测试","path":"api/categories/测试.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"单元测试","path":"api/tags/单元测试.json"}]},{"title":"UI自动测试开发相关API","slug":"测试/UI自动测试学习","date":"2017-02-20T17:16:49.000Z","updated":"2017-05-26T11:03:05.000Z","comments":true,"path":"api/articles/测试/UI自动测试学习.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/XCUIElementAttributes.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"UI-Testing-和-Accessibility\"><a href=\"#UI-Testing-和-Accessibility\" class=\"headerlink\" title=\"UI Testing 和 Accessibility\"></a>UI Testing 和 Accessibility</h2><p>UI Accessibility 早在 iOS 3.0 就被引入了，用来辅助身体不便的人士使用 app。VoiceOver 是 Apple 的屏幕阅读技术，而 UI Accessibility 的基本原则就是对屏幕上的 UI 元素进行分类和标记。两者配合，通过阅读或者聆听这些元素，用户就可以在不接触屏幕的情况下通过声音来使用 app。</p>\n<p>Accessibility 的核心思想是对 UI 元素进行分类和标记 – 将屏幕上的 UI 分类为像是按钮，文本框，cell 或者是静态文本 (也就是 label) 这样的类型，然后使用 identifier 来区分不同的 UI 元素。用户可以通过语音控制 app 的按钮点击，或是询问某个 label 的内容等等，十分方便。iOS SDK 中的控件都实现了默认的 Accessibility 支持，而我们如果使用自定义的控件的话，则需要自行使用 Accessibility 的 API 来进行添加。</p>\n<h2 id=\"UI-Testing-API\"><a href=\"#UI-Testing-API\" class=\"headerlink\" title=\"UI Testing API\"></a>UI Testing API</h2><h3 id=\"XCUIApplication-获取APP实例\"><a href=\"#XCUIApplication-获取APP实例\" class=\"headerlink\" title=\"XCUIApplication()获取APP实例\"></a>XCUIApplication()获取APP实例</h3><p><code>XCUIApplication()</code>继承<code>XCUIElement</code>，这个类掌管应用程序的生命周期，里面包含两个主要方法<br><code>launch():</code>启动程序<br><code>terminate():</code>终止程序</p>\n<h3 id=\"获取XCUIElementQuery对象的四种方式\"><a href=\"#获取XCUIElementQuery对象的四种方式\" class=\"headerlink\" title=\"获取XCUIElementQuery对象的四种方式\"></a>获取<code>XCUIElementQuery</code>对象的四种方式</h3><h4 id=\"第一种简写形式：buttons-gt-XCUIElementQuery\"><a href=\"#第一种简写形式：buttons-gt-XCUIElementQuery\" class=\"headerlink\" title=\"第一种简写形式：buttons-&gt;XCUIElementQuery\"></a>第一种简写形式：<code>buttons-&gt;XCUIElementQuery</code></h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttons:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().buttons</span><br><span class=\"line\"><span class=\"keyword\">let</span> textFields:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().textFields</span><br></pre></td></tr></table></figure>\n<h4 id=\"三种通过XCUIElementType的枚举值\"><a href=\"#三种通过XCUIElementType的枚举值\" class=\"headerlink\" title=\"三种通过XCUIElementType的枚举值\"></a>三种通过<code>XCUIElementType</code>的枚举值</h4><p>通过<code>XCUIElementType</code>的枚举值来获取<code>XCUIElementQuery</code>对象，其中第二种是简写方式。<br><code>XCUIElementType</code>枚举声明如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">XCUIElementType</span> : <span class=\"title\">UInt</span> </span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">case</span> button</span><br><span class=\"line\">    <span class=\"keyword\">case</span> radioButton</span><br><span class=\"line\">    <span class=\"keyword\">case</span> textField</span><br><span class=\"line\">    <span class=\"keyword\">case</span> comboBox</span><br><span class=\"line\">    <span class=\"keyword\">case</span> menuButton</span><br><span class=\"line\">    <span class=\"keyword\">case</span> toolbarButton</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"第一种获取所有的元素：descendantsMatchingType-gt-XCUIElementQuery\"><a href=\"#第一种获取所有的元素：descendantsMatchingType-gt-XCUIElementQuery\" class=\"headerlink\" title=\"第一种获取所有的元素：descendantsMatchingType-&gt;XCUIElementQuery\"></a>第一种获取所有的元素：<code>descendantsMatchingType-&gt;XCUIElementQuery</code></h5><p>取某种类型的元素以及它的子类集合，能获取到系统级控件如<code>UIButton</code>，和用户自定义的UI控件<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttons:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().descendantsMatchingType(.<span class=\"type\">Button</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> textFields:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().descendantsMatchingType(.textField)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"第三种仅获取当前层级子元素：childrenMatchingType\"><a href=\"#第三种仅获取当前层级子元素：childrenMatchingType\" class=\"headerlink\" title=\"第三种仅获取当前层级子元素：childrenMatchingType\"></a>第三种仅获取当前层级子元素：<code>childrenMatchingType</code></h5><p>取某种类型的元素集合，不包含它的子类，即仅获取系统级控件如<code>UIButton</code>，不获取用户自定义的UI控件<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttons:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().childrenMatchingType(.<span class=\"type\">Button</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> textFields:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().childrenMatchingType(.textField)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"第四种所有包含的元素：containingType\"><a href=\"#第四种所有包含的元素：containingType\" class=\"headerlink\" title=\"第四种所有包含的元素：containingType\"></a>第四种所有包含的元素：<code>containingType</code></h5><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttons:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().containingType(.<span class=\"type\">Button</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> textFields:<span class=\"type\">XCUIElementQuery</span> = <span class=\"type\">XCUIApplication</span>().containingType(.textField)</span><br></pre></td></tr></table></figure>\n<h3 id=\"XCUIElement表示系统的各种UI控件\"><a href=\"#XCUIElement表示系统的各种UI控件\" class=\"headerlink\" title=\"XCUIElement表示系统的各种UI控件\"></a>XCUIElement表示系统的各种UI控件</h3><p><code>XCUIElement</code>UI控件在测试框架中的代理，继承<code>NSObject</code>，实现<code>XCUIElementAttributes</code>协议, <code>XCUIElementTypeQueryProvider</code>协议，可以表示系统的各种UI控件。</p>\n<ol>\n<li>XCUIElementAttributes协议：里面包含了UIAccessibility中的部分属性<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/XCUIElementAttributes.png?imageMogr2/2/w/800\">\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/UIAccessibility.jpg?imageMogr2/2/w/800\"></li>\n<li>XCUIElementTypeQueryProvider协议：包含了系统中大部分UI控件的类型，可通过读属性的方式取得某种类型的UI集合<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/XCUIElementTypeQueryProvider.png?imageMogr2/2/w/800\">\n</li>\n</ol>\n<h4 id=\"访问UI控件\"><a href=\"#访问UI控件\" class=\"headerlink\" title=\"访问UI控件\"></a>访问UI控件</h4><ol>\n<li><code>exist:</code>判断当前的UI元素是否存在，如果对一个不存在的元素进行操作，会导致测试组件抛出异常并中断测试.</li>\n<li><code>element()</code>／<code>下标方法</code>：<code>XCUIElementQuery</code>实例的方法获取UI控件，不能直接通过<code>XCUIElement</code> 来访问 app 中的元素，只能通过 <code>Accessibility</code> 中的像是 <code>identifier</code> 或者 <code>frame</code> 这样的属性来获取 UI 的信息。<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> userNameTextField:<span class=\"type\">XCUIElement</span> = app.textFields.element(boundBy: <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> userNameTextField:<span class=\"type\">XCUIElement</span> = app.textFields[<span class=\"string\">\"username\"</span>]</span><br></pre></td></tr></table></figure>\n对于 <code>XCUIElementQuery</code>，<code>Query</code>的执行是有延迟的，它和最后我们得到的 <code>XCUIElement</code> 并不是一一对应的。和 <code>NSURL</code> 与请求到的内容的关系类似，随着时间的变化，同一个 <code>URL</code> 有可能请求到不同的内容。<br>在拿到<code>Query</code>实例后，只有在通过<code>下标</code>或<code>访问方法</code>访问时，才会真正寻找对应的 <code>UI 控件</code>。这就是说，随着我们的 UI 的变化，同样的 <code>query</code> 也可能获取到不用的<code>UI控件</code>。为了获取UI元素准确：我们可以通过在 <code>Interface Builder</code> 或者<code>代码</code>中，对UI控件的 <code>identifier</code>属性进行设置，这样就可以使用下标的方式进行访问了。</li>\n</ol>\n<h4 id=\"设置UI控件触发事件和属性值\"><a href=\"#设置UI控件触发事件和属性值\" class=\"headerlink\" title=\"设置UI控件触发事件和属性值\"></a>设置UI控件<code>触发事件</code>和<code>属性值</code></h4><p>使用<code>typeText(text:String)</code>,<code>tap()</code>,<code>doubleTap()</code>等方法。<br>以获取userNameTextField控件为例：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> userNameTextField:<span class=\"type\">XCUIElement</span> = app.textFields.element(boundBy: <span class=\"number\">0</span>)</span><br><span class=\"line\">userNameTextField.tap()</span><br><span class=\"line\">userNameTextField.typeText(<span class=\"string\">\"文本内容\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"XCUIElementAttributes协议\"><a href=\"#XCUIElementAttributes协议\" class=\"headerlink\" title=\"XCUIElementAttributes协议\"></a>XCUIElementAttributes协议</h4><p>UI元素中包含的各个属性，<code>identifier</code>，<code>frame</code>,<code>title</code>,<code>label</code>等…</p>\n<ol>\n<li>使用: 可使用这些属性来获取UI元素对象。<figure class=\"highlight swift\"><figcaption><span>title获取</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> username = <span class=\"string\">\"hsg\"</span></span><br><span class=\"line\">userNameTextField.typeText(username)</span><br><span class=\"line\">app.textFields[username].tap()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><figcaption><span>identifier获取</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> identifier = <span class=\"string\">\"hsg\"</span></span><br><span class=\"line\">userNameTextField.typeText(username)</span><br><span class=\"line\">app.textFields[username].tap()</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"测试","path":"api/categories/测试.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"单元测试","path":"api/tags/单元测试.json"}]},{"title":"Crash文件分析方法","slug":"调试/Crash文件分析方法","date":"2017-02-07T12:38:58.000Z","updated":"2017-05-26T11:03:05.000Z","comments":true,"path":"api/articles/调试/Crash文件分析方法.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>第一步：在任意目录创建调试crash的目录</p>\n<p>第二步：将之前Archive的文件copy到crash目录里面,其中包括两个文件.app和.app.dSYM</p>\n<p>第三步：将symbolicatecrash工具copy到crash目录<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /Applications/Xcode.app -name symbolicatecrash -type f</span><br></pre></td></tr></table></figure></p>\n<p>2.用命令将symbolicatecrash拷贝到桌面的crash文件夹里面，与.app和.app.dSYM放一起<br>拷贝到crash目录：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /Applications/Xcode.app/.../symbolicatecrash /Users/Desktop/crash</span><br></pre></td></tr></table></figure></p>\n<p>第四步：执行symbolicatecrash<br>1.打开终端用命令切换到桌面的crash目录下：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /Users/你的电脑名称/Desktop/crash</span><br></pre></td></tr></table></figure></p>\n<p>2.执行命令<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./symbolicatecrash /Users/Desktop/crash/PBB.crash /Users/Desktop/crash/Control.app.dSYM &gt; Control_symbol.crash</span><br></pre></td></tr></table></figure></p>\n<p>这时候终端有可能会出现：<code>Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 60.</code></p>\n<p>3.输入命令：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> DEVELOPER_DIR=<span class=\"string\">\"/Applications/XCode.app/Contents/Developer\"</span></span><br></pre></td></tr></table></figure></p>\n<p>4.再执行 2.的命令行</p>\n<p>5.将终端完成以后，在crash文件夹里面会多出一个文件Control_symbol.crash。<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Unsupported crash <span class=\"built_in\">log</span> version: 12 at ./symbolicatecrash line 614.</span><br></pre></td></tr></table></figure></p>\n<p>第五步：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dwarfdump --lookup 0x000cf358 --arch armv7 appname.app.dSYM/</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"调试","path":"api/categories/调试.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"测试","path":"api/tags/测试.json"}]},{"title":"Xcode7编译发布问题","slug":"编译/Xcode7编译发布问题","date":"2015-09-25T15:58:17.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/编译/Xcode7编译发布问题.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"Xcode7编译发布问题\"><a href=\"#Xcode7编译发布问题\" class=\"headerlink\" title=\"Xcode7编译发布问题\"></a>Xcode7编译发布问题</h4><ol>\n<li><p>ERROR ITMS-90535: “Unexpected CFBundleExecutable Key. The bundle at ‘Payload/PBBReader.app/TencentOpenApi_IOS_Bundle.bundle’ does not contain a bundle executable. If this bundle intentionally does not contain an executable, consider removing the CFBundleExecutable key from its Info.plist and using a CFBundlePackageType of BNDL. If this bundle is part of a third-party framework, consider contacting the developer of the framework for an update to address this issue.”</p>\n<p> 解决办法：搜索CFBundleExecutable 字段，删除所有第三方框架中的info.plist文件中包含的字段，重新打包上传。</p>\n</li>\n</ol>\n<ol>\n<li>ERROR ITMS-90475: “Invalid Bundle. iPad Multitasking support requires launch story board in bundle ‘pyc.com.cn.pbbReader’.”\f</li>\n<li><p>苹果邮件：We have discovered one or more issues with your recent delivery for “PBB Reader”. To process your delivery, the following issues must be corrected:<br>Invalid Bundle - A nested bundle doesn’t have the right platforms listed in CFBundleSupportedPlatforms Info.plist key.</p>\n</li>\n<li><p>IOS9访问网络设置：<strong>NSAppTransportSecurity</strong> 字典，字段：<strong>NSAllowsArbitraryLoads</strong>  字段值：<strong>YES</strong></p>\n</li>\n<li>搜索Target对应的build setting中，把<strong>bitCode</strong>支持设置为NO</li>\n<li><a href=\"http://onevcat.com/2015/06/multitasking/\" target=\"_blank\" rel=\"noopener\">iPad 中的多任务适配</a><br>如果你不想你的 app 可以作为多任务的副 app 被使用的话，你可以在 Info.plist 中添加 <strong>UIRequiresFullScreen</strong> 并将其设为 <strong>YES</strong></li>\n<li>对第三方SDK后台运行，有严格的把控，要求bundle资源必须为最新有效，上传包时必要条件</li>\n</ol>\n<h3 id=\"解决办法：\"><a href=\"#解决办法：\" class=\"headerlink\" title=\"解决办法：\"></a>解决办法：</h3><p>退回Xcode6.4,进行打包发布</p>\n<h4 id=\"Cannot-proceed-with-delivery-an-existing-transporter-instance-is-currently-uploading-this-package\"><a href=\"#Cannot-proceed-with-delivery-an-existing-transporter-instance-is-currently-uploading-this-package\" class=\"headerlink\" title=\"Cannot proceed with delivery: an existing transporter instance is currently uploading this package\"></a>Cannot proceed with delivery: an existing transporter instance is currently uploading this package</h4><p>把Application Loader(XCode-&gt;Organizer-&gt;Archived Applications-&gt;Submit)中正在上传的文件中断或者删除，再次Submit提示：<br>Cannot proceed with delivery: an existing transporter instance is currently uploading this package。<br>无论如何Clean All、重新Submit都失败，给出上述提示。<br>原因：上传的动作被记录在UploadToken中了。<br>解决方法：<br>（1）打开终端，输入cd，到达个人用户目录下。<br>（2）输入ls -a，可以看到一个隐藏的目录 .itmstransporter<br>（3）cd .itmstransporter/UploadTokens<br>（4）ls ，可以看到一个类似 xxxxx.local_itunesConnectUSERxxxxxx.itmsp.token文件<br>（5）nano  xxxxx.local_itunesConnectUSERxxxxxx.itmsp.token，在里面把内容都删除，保存。<br>（6）重新在Organizer里面submit，ok了  </p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"编译","path":"api/categories/编译.json"}],"tags":[]},{"title":"代码实现AutoLayout相关特性","slug":"iOS/代码实现AutoLayout相关特性","date":"2014-09-02T15:53:11.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/代码实现AutoLayout相关特性.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/runbtn1.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"按比例缩放\"><a href=\"#按比例缩放\" class=\"headerlink\" title=\"按比例缩放\"></a>按比例缩放</h2><p>按比例缩放，这是在Interface Builder中无法设置的内容。<br>而在代码中，有如下两种实现方式:</p>\n<ol>\n<li>使用<code>NSLayoutConstraint</code>类型的初始化函数中的<code>multiplier</code>参数就可以非常简单的设置按比例缩放。  </li>\n<li>同时也可以设置不同<code>NSLayoutAttribute</code>参数来达到意想不到的效果，比如“A的Width等于B的Height的2倍”这样的效果。  </li>\n</ol>\n<p>现在就拿一个简单的<strong><code>UIButton</code></strong>做示例，在ViewController中创建一个UIButton字段：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIButton</span> *btn;  </span><br></pre></td></tr></table></figure>  </p>\n<h4 id=\"需求-1：\"><a href=\"#需求-1：\" class=\"headerlink\" title=\"需求 1：\"></a>需求 1：</h4><ol>\n<li>要求<strong><code>UIButton</code></strong>水平居中，始终距离父View底部<strong>20</strong>单位，其高度是父View高度的三分之一。</li>\n<li>使用<strong>KVO</strong>来监控<strong><code>UIButton</code></strong>的大小并实时输出到屏幕上。  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建UIButton，不需要设置frame</span></span><br><span class=\"line\">    btn = [<span class=\"built_in\">UIButton</span> buttonWithType:<span class=\"built_in\">UIButtonTypeRoundedRect</span>];</span><br><span class=\"line\">    [btn setTitle:<span class=\"string\">@\"mgen\"</span> forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">    btn.backgroundColor = [<span class=\"built_in\">UIColor</span> greenColor];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:btn];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//禁止自动转换AutoresizingMask</span></span><br><span class=\"line\">    btn.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//居中</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addConstraint:[<span class=\"built_in\">NSLayoutConstraint</span></span><br><span class=\"line\">                              constraintWithItem:btn</span><br><span class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeCenterX</span></span><br><span class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></span><br><span class=\"line\">                              toItem:<span class=\"keyword\">self</span>.view</span><br><span class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeCenterX</span></span><br><span class=\"line\">                              multiplier:<span class=\"number\">1</span></span><br><span class=\"line\">                              constant:<span class=\"number\">0</span>]];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//距离底部20单位</span></span><br><span class=\"line\">    <span class=\"comment\">//注意NSLayoutConstraint创建的constant是加在toItem参数的，所以需要-20。</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addConstraint:[<span class=\"built_in\">NSLayoutConstraint</span></span><br><span class=\"line\">                              constraintWithItem:btn</span><br><span class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeBottom</span></span><br><span class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></span><br><span class=\"line\">                              toItem:<span class=\"keyword\">self</span>.view</span><br><span class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeBottom</span></span><br><span class=\"line\">                              multiplier:<span class=\"number\">1</span></span><br><span class=\"line\">                              constant:<span class=\"number\">-20</span>]];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//定义高度是父View的三分之一</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addConstraint:[<span class=\"built_in\">NSLayoutConstraint</span></span><br><span class=\"line\">                              constraintWithItem:btn</span><br><span class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeHeight</span></span><br><span class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></span><br><span class=\"line\">                              toItem:<span class=\"keyword\">self</span>.view</span><br><span class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeHeight</span></span><br><span class=\"line\">                              multiplier:<span class=\"number\">0.3</span></span><br><span class=\"line\">                              constant:<span class=\"number\">0</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//注册KVO方法</span></span><br><span class=\"line\">    [btn addObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"bounds\"</span> options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span> | <span class=\"built_in\">NSKeyValueObservingOptionInitial</span> context:<span class=\"literal\">nil</span>];    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;!--more--&gt;</span><br><span class=\"line\"><span class=\"comment\">//KVO回调</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"keyword\">id</span>)object change:(<span class=\"built_in\">NSDictionary</span> *)change context:(<span class=\"keyword\">void</span> *)context</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (object == btn &amp;&amp; [keyPath isEqualToString:<span class=\"string\">@\"bounds\"</span>])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [btn setTitle:<span class=\"built_in\">NSStringFromCGSize</span>(btn.bounds.size) forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  \n运行结果：  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/runbtn1.png?imageMogr2/2/w/800\"><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/runbtn2.png?imageMogr2/2/w/800\">\n<a id=\"more\"></a>\n<h4 id=\"需求-2：\"><a href=\"#需求-2：\" class=\"headerlink\" title=\"需求 2：\"></a>需求 2：</h4></li>\n<li>在横向的显示中，Button的高度只有96，所以要求Button的最小高度为150。   </li>\n</ol>\n<p>涉及到的相关特性：</p>\n<ul>\n<li><strong>优先级</strong>：当两个<strong><code>Constraint</code></strong>同时作用在一个控件时，在某些情况下是有冲突的，可以通过设置<strong><code>Constraint</code></strong>的优先级来解决。<br>优先级对应<strong><code>NSLayoutConstraint</code></strong>类型的<strong><code>priority</code></strong>属性，默认值是<strong><code>UILayoutPriorityRequired</code></strong>，数值上等于<strong>1000</strong>. 设置一个低的值代表更低的优先级。  </li>\n<li><strong>最小值的定义</strong>：使用<strong><code>NSLayoutRelationGreaterThanOrEqual</code></strong>作为<strong><code>NSLayoutConstraint</code></strong>类型创建时的<strong><code>relatedBy</code></strong>参数。</li>\n</ul>\n<p>修改上面的比例Constraint，并在下方加入一个新的限制最小值的Constraint，代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义高度是父View的三分之一</span></span><br><span class=\"line\"><span class=\"comment\">//设置优先级低于UILayoutPriorityRequired(1000)，UILayoutPriorityDefaultHigh是750</span></span><br><span class=\"line\"><span class=\"built_in\">NSLayoutConstraint</span> *con = [<span class=\"built_in\">NSLayoutConstraint</span></span><br><span class=\"line\">                          constraintWithItem:btn</span><br><span class=\"line\">                          attribute:<span class=\"built_in\">NSLayoutAttributeHeight</span></span><br><span class=\"line\">                          relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></span><br><span class=\"line\">                          toItem:<span class=\"keyword\">self</span>.view</span><br><span class=\"line\">                          attribute:<span class=\"built_in\">NSLayoutAttributeHeight</span></span><br><span class=\"line\">                          multiplier:<span class=\"number\">0.3</span></span><br><span class=\"line\">                          constant:<span class=\"number\">0</span>];</span><br><span class=\"line\">con.priority = <span class=\"built_in\">UILayoutPriorityDefaultHigh</span>;</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:con];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置btn最小高度为150</span></span><br><span class=\"line\">[btn addConstraint:[<span class=\"built_in\">NSLayoutConstraint</span></span><br><span class=\"line\">                    constraintWithItem:btn</span><br><span class=\"line\">                    attribute:<span class=\"built_in\">NSLayoutAttributeHeight</span></span><br><span class=\"line\">                    relatedBy:<span class=\"built_in\">NSLayoutRelationGreaterThanOrEqual</span></span><br><span class=\"line\">                    toItem:<span class=\"literal\">nil</span></span><br><span class=\"line\">                    attribute:<span class=\"built_in\">NSLayoutAttributeNotAnAttribute</span></span><br><span class=\"line\">                    multiplier:<span class=\"number\">1</span></span><br><span class=\"line\">                    constant:<span class=\"number\">150</span>]];</span><br></pre></td></tr></table></figure><br>运行后，横向屏幕中的Button高度成了150：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/runbtn3.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"intrinsicContentSize-控件的内置大小\"><a href=\"#intrinsicContentSize-控件的内置大小\" class=\"headerlink\" title=\"intrinsicContentSize 控件的内置大小\"></a>intrinsicContentSize 控件的内置大小</h4><p>控件的内置大小是由控件本身的内容所决定的，比如一个<code>UILabel</code>的文字很长，那么该<code>UILabel</code>的内置大小自然会很长。<br>在代码中获取控件的内置大小的方法：  </p>\n<ol>\n<li>通过<code>UIView</code>的<code>intrinsicContentSize</code>属性来获取；</li>\n<li>通过<code>invalidateIntrinsicContentSize</code>方法来在下次UI规划事件中重新计算<code>intrinsicContentSize</code>。  </li>\n</ol>\n<p>注意：如果直接创建一个原始的UIView对象，它的内置大小为0。  </p>\n<p>先写一个辅助方法来快速设置UIView的边距限制：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设置Autolayout中的边距辅助方法</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setEdge:(<span class=\"built_in\">UIView</span>*)superview view:(<span class=\"built_in\">UIView</span>*)view attr:(<span class=\"built_in\">NSLayoutAttribute</span>)attr constant:(<span class=\"built_in\">CGFloat</span>)constant</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [superview addConstraint:[<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t    attribute:attr </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t    relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t       toItem:superview</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t    attribute:attr </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t   multiplier:<span class=\"number\">1.0</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t     constant:constant]</span><br><span class=\"line\">    ];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>接下来，创建一个UIView，利用上面的辅助方法快速设置其在父控件的左，上，右边距为20单位。如下代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//view1</span></span><br><span class=\"line\"><span class=\"built_in\">UIView</span> *view1 = [<span class=\"built_in\">UIView</span> new];</span><br><span class=\"line\">view1.backgroundColor = [<span class=\"built_in\">UIColor</span> yellowColor];</span><br><span class=\"line\"><span class=\"comment\">//不允许AutoresizingMask转换成Autolayout</span></span><br><span class=\"line\">view1.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:view1];</span><br><span class=\"line\"><span class=\"comment\">//设置左，上，右边距为20.</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> setEdge:<span class=\"keyword\">self</span>.view view:view1 attr:<span class=\"built_in\">NSLayoutAttributeLeft</span> constant:<span class=\"number\">20</span>];</span><br><span class=\"line\">[<span class=\"keyword\">self</span> setEdge:<span class=\"keyword\">self</span>.view view:view1 attr:<span class=\"built_in\">NSLayoutAttributeTop</span> constant:<span class=\"number\">20</span>];</span><br><span class=\"line\">[<span class=\"keyword\">self</span> setEdge:<span class=\"keyword\">self</span>.view view:view1 attr:<span class=\"built_in\">NSLayoutAttributeRight</span> constant:<span class=\"number\">-20</span>];</span><br></pre></td></tr></table></figure><br>但是运行后会发现，界面上不会显示任何东西。原因就是上面讲的，<code>UIView</code>默认是没有<strong><code>intrinsicContentSize</code></strong>的。</p>\n<p>创建一个自定义的<code>UIView</code>来改写<strong><code>intrinsicContentSize</code></strong>：MyView:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/MyView.png?imageMogr2/2/w/800\"><br>然后在.m文件中改写<strong>intrinsicContentSize</strong>方法，并返回有效值，比如这样：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//改写UIView的intrinsicContentSize</span></span><br><span class=\"line\">- (<span class=\"built_in\">CGSize</span>)intrinsicContentSize</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">70</span>, <span class=\"number\">40</span>);</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure><br>接着修改最上面的代码，把上面view1变量的类型从UIView替换成我们自定义的View：MyView类型：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyView *view1 = [MyView new];  </span><br></pre></td></tr></table></figure><br>再次运行代码，View会按照要求显示在屏幕上：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/Myview2.png?imageMogr2/2/w/800\"><br>按照同样的方式，在下方添加另一个<code>MyView</code>，要求其距离父控件边距左，下，右各为<strong>20</strong>，代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//view2  </span></span><br><span class=\"line\">MyView *view2 = [MyView new];  </span><br><span class=\"line\">view2.backgroundColor = [<span class=\"built_in\">UIColor</span> yellowColor];  </span><br><span class=\"line\"><span class=\"comment\">//不允许AutoresizingMask转换成Autolayout  </span></span><br><span class=\"line\">view2.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>;  </span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:view2];  </span><br><span class=\"line\"><span class=\"comment\">//设置左，下，右边距为20.  </span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> setEdge:<span class=\"keyword\">self</span>.view view:view2 attr:<span class=\"built_in\">NSLayoutAttributeLeft</span> constant:<span class=\"number\">20</span>];  </span><br><span class=\"line\">[<span class=\"keyword\">self</span> setEdge:<span class=\"keyword\">self</span>.view view:view2 attr:<span class=\"built_in\">NSLayoutAttributeBottom</span> constant:<span class=\"number\">-20</span>];  </span><br><span class=\"line\">[<span class=\"keyword\">self</span> setEdge:<span class=\"keyword\">self</span>.view view:view2 attr:<span class=\"built_in\">NSLayoutAttributeRight</span> constant:<span class=\"number\">-20</span>];  </span><br></pre></td></tr></table></figure><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/myview4.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"需求：\"><a href=\"#需求：\" class=\"headerlink\" title=\"需求：\"></a>需求：</h4><ol>\n<li><p>通过代码加入Autolayout中的间距，命令view1和view2上下必须间隔20个单位。 </p>\n<ol>\n<li><ul>\n<li>这里要求view2在view1之下的<strong>20</strong>单位，所以创建<strong>NSLayoutConstraint</strong>中view2参数在前面。  </li>\n</ul>\n</li>\n<li><ul>\n<li>view2的<strong><code>attribute</code></strong>参数是<strong><code>NSLayoutAttributeTop</code></strong>，而view1的<strong><code>attribute</code></strong>参数是<strong><code>NSLayoutAttributeBottom</code></strong>  </li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>拉伸view2,而不拉伸view1。  </p>\n<ol>\n<li><ul>\n<li>控件的<strong><code>Content Hugging Priority</code></strong>拒绝拉伸的优先级，优先级越高，控件会越不容易被拉伸。    </li>\n</ul>\n</li>\n<li><ul>\n<li>控件的<strong><code>Content Compression Resistance Priority</code></strong>拒绝压缩内置空间(<code>intrinsicContentSize</code>)的优先级。优先级越高，控件的内置空间(<code>intrinsicContentSize</code>)会越不容易被压缩。  </li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设置两个View上下间距为20</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:[<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view2 </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\tattribute:<span class=\"built_in\">NSLayoutAttributeTop</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\trelatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t   toItem:view1</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t    attribute:<span class=\"built_in\">NSLayoutAttributeBottom</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t   multiplier:<span class=\"number\">1.0</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t constant:<span class=\"number\">20</span>]</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t];</span><br></pre></td></tr></table></figure>  \n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/view1Toview2.png?imageMogr2/2/w/800\">\n<p>OK，的确，此时view1和view2相互间隔20单位，但是view1被拉伸了。</p>\n<p>使用控件的<strong><code>Content Hugging Priority</code></strong>，如下图：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/ContentHuggingPriority.png?imageMogr2/2/w/800\"><br>如图,把view1（上图中被拉伸的，在上面的View）的<strong><code>Content Hugging Priority</code></strong>设置一个更高的值，那么当<code>Autolayout</code>遇到这种决定谁来拉伸的情况时，view1不会被优先拉伸，而优先级稍低的view2才会被拉伸。<br>可以直接通过UIView的<code>setContentHuggingPriority:forAxis</code>方法来设置控件的<strong><code>Content Hugging Priority</code></strong>，其中<code>forAxis</code>参数代表横向和纵向，本例中只需要设置纵向，所以传入<strong><code>UILayoutConstraintAxisVertical</code></strong>。整句代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//提高view1的Content Hugging Priority</span></span><br><span class=\"line\">[view1 setContentHuggingPriority:<span class=\"built_in\">UILayoutPriorityDefaultHigh</span> forAxis:<span class=\"built_in\">UILayoutConstraintAxisVertical</span>];</span><br></pre></td></tr></table></figure><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/runview1.png?imageMogr2/2/w/800\"></p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"SB","path":"api/categories/SB.json"}],"tags":[{"name":"Storyboard","path":"api/tags/Storyboard.json"},{"name":"AutoLayout","path":"api/tags/AutoLayout.json"},{"name":"布局","path":"api/tags/布局.json"}]},{"title":"Xcode HeaderDoc 教程","slug":"xcode/XcodeHeaderDoc教程","date":"2014-08-28T15:18:41.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/xcode/XcodeHeaderDoc教程.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/car.jpg?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>HeaderDoc 是在Xcode 5 和 iOS7 发布时，新增的一个命令行工具，功能：可以从代码中自动生成格式良好的HTML文档——当然，必须依赖于特定格式的注释来完成的。</p>\n<p>另外，Xcode 还会在 quick look 面板中以<strong>HeaderDoc</strong>风格显示你的注释。</p>\n<p>通过本教程，将学习如下几点：</p>\n<ul>\n<li>如何书写 HeaderDoc 风格的注释</li>\n<li>分如何在 Xcode 中预览文档</li>\n<li>如何生成 HTML 文档</li>\n<li>如何使用 VVDocumenter-Xcode(一个易于使用的第3方文档制作工具)</li>\n</ul>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>下载本教程中用到的 <a href=\"http://cdn2.raywenderlich.com/wp-content/uploads/2014/03/DocumentationExamples_Starter.zip\" target=\"_blank\" rel=\"noopener\">示例项目</a></p>\n<p>这个简单的示例程序只包含了两个类：</p>\n<ul>\n<li>Car: 包含几个属性及一个 “drive” 方法以及一个 completion 块。</li>\n<li>MathAPI: 包含了1个方法，用于累加两个数。<br>现在，这两个类还没有任何注释。以便演示如何通过 <strong>HeaderDoc</strong> 为这两个类创建文档。<a id=\"more\"></a>\n<h4 id=\"HeaderDoc-注释\"><a href=\"#HeaderDoc-注释\" class=\"headerlink\" title=\"HeaderDoc 注释\"></a>HeaderDoc 注释</h4></li>\n</ul>\n<p><strong>HeaderDoc</strong> 可以从命令行中运行，也可以通过 Xcode 运行。它扫描文件中以某种格式书写的注释,包括这3种形式：<br>这3中语法在 Xcode 中产生同样效果的文档</p>\n<pre><code>注释 1. 一般用于单行注释\n    /// Your documentation comment will go here\n注释 2.\n    /**  * Your documentation comment will go here  */\n注释 3: 一般用于较长的注释块\n    /*!  * Your documentation comment will go here  */\n\n注意：在注释2和注释3中，在每一行开头都会有一个额外的*，直至结尾的 */。这仅仅是为了美观，而不是必须的。\n</code></pre><h4 id=\"HeaderDoc-标签\"><a href=\"#HeaderDoc-标签\" class=\"headerlink\" title=\"HeaderDoc 标签\"></a>HeaderDoc 标签</h4><p>当 <strong>HeaderDoc</strong> 发现上述3种注释，它就开始寻找其中的<strong>HeaderDoc 标签</strong>。<strong>HeaderDoc 标签</strong> 用来修饰<strong>HeaderDoc 注释</strong>。</p>\n<p><strong>HeaderDoc 标签</strong>以 <strong>@</strong> 符号开头，然后是关键字，然后是一个空格，最后才是相应的文本（例如 @param foo）。<br>HeaderDoc 标签可以分为两种：</p>\n<ol>\n<li><p>顶级标签: 这些标签声明所要注释的对象的类型（例如头部声明、类、方法等等）。</p>\n<ul>\n<li>顶级标签，例如 @typedef，用于表示 <strong>typedef</strong> 定义的类型，比如枚举、结构体和函数指针。</li>\n<li><strong>HeaderDoc</strong> 能够根据上下文自动产生顶级标签，因此通常不是必须的。</li>\n</ul>\n</li>\n<li><p>二级标签:这些标签才是具体的注释内容。</p>\n<ul>\n<li>@brief: 简单描述你准备文档化的数据的类型，方法等等。</li>\n<li>@abstract: 等于 @brief。<ul>\n<li>@discussion: 类似 @abstract 和 @brief，但允许多行。它不是必须的，仅仅是为了使描述更清晰。</li>\n<li>@param: 描述方法、回调或函数的参数名称。</li>\n<li>@return: 描述方法或函数的返回值。（等同于 @result）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<!-- More -->\n<h4 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h4><ul>\n<li><h6 id=\"属性的文档化\"><a href=\"#属性的文档化\" class=\"headerlink\" title=\"属性的文档化\"></a>属性的文档化</h6><p>用 Xcode 打开<strong>DocumentationExamples</strong> 项目, 打开<strong>ViewController.h</strong>,<br>在<strong> car </strong>属性的前面，加入一行注释:</p>\n<pre><code>/*!  * @brief The ViewController class&apos; car object.  */\n\n@property (nonatomic) Car *car;\n</code></pre></li>\n</ul>\n<p>编译项目。编译结束，按住 alt/option 键，点击<strong>car</strong> 变量名。你将看到<strong>pop菜单</strong>中显示了刚才的注释内容。<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/car.jpg?imageMogr2/2/w/800\"><br>另一种方法:切换到Utitlities 面板的<strong>Quick Help</strong> 检查器窗口。点击 <strong>car</strong> 变量名，通过<strong>Quick Help</strong>,你将看到如下效果：<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/carquickhelp.jpg?imageMogr2/2/w/800\"></p>\n<ul>\n<li><h6 id=\"方法的文档化\"><a href=\"#方法的文档化\" class=\"headerlink\" title=\"方法的文档化\"></a>方法的文档化</h6><p><strong>MathAPI</strong>包含一个方法需要文档化。打开<strong>MathAPI.h</strong>,找到<code>addNumber:toNumber:</code>。</p>\n</li>\n</ul>\n<p>这个方法有两个参数及一个返回值。因此需要一个 @description 标签、两个@param标签，以及一个@return 标签，如下面所示：</p>\n<pre><code>/*!  * @discussion A really simple way to calculate the sum of two numbers.\n\n      * @param firstNumber An NSInteger to be used in the summation of two numbers\n\n      * @param secondNumber The second half of the equation.\n\n       * @return The sum of the two numbers passed in.\n\n*/\n\n+ (NSInteger)addNumber:(NSInteger)firstNumber toNumber:(NSInteger)secondNumber;\n</code></pre><p>编译，再 <strong>alt + 左键</strong>：<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/method.jpg?imageMogr2/2/w/800\"></p>\n<p> 问题: 在 Xcode 文本编辑窗口，很多地方都支持 <strong>alt+左键</strong>。请确保你点击在正确的地方。在上面的例子里，你应当在addNumber: 和 toNumber: 两处使用 alt+左键。</p>\n<p>你也许不知道，这个方法的实现真的很恶心。它只能使用非负数作为参数。为了让用户明白这一点，你应当在注释中添加更多的说明。因此，我们可以在 @return 前面加入一个 @warning 标签。</p>\n<pre><code>* @warning Please make note that this method is only good for adding non-negative numbers.\n</code></pre><p>编译项目，然后使用 alt+左键。我们添加的 @warning 标签效果如下：<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/warning.jpg?imageMogr2/2/w/800\"></p>\n<h4 id=\"Code-Snippets，让一切变得更简单\"><a href=\"#Code-Snippets，让一切变得更简单\" class=\"headerlink\" title=\"Code Snippets，让一切变得更简单:\"></a>Code Snippets，让一切变得更简单:</h4><p>一个<strong>snippet</strong> 是一个可以重用的代码块（存储在 snippet 库中）。<strong>Snippets</strong> 甚至可以包含一些需要你去填充的占位符。<br>这意味着, 可以用 <strong>snipppet</strong>来进行文档化。</p>\n<p>在 <strong>MathAPI.h</strong> 中，在原有的注释上面加入以下内容：</p>\n<pre><code>/*!  * @discussion &lt;#description#&gt;\n\n     * @param &lt;#param description#&gt;\n\n     * @return &lt;#return description#&gt;\n*/\n</code></pre><p> 注意，当粘贴上述代码时，“&lt;# #&gt;”之间的内容会变成一个<strong>token</strong>,意味着可以通过 <strong>tab 键</strong>在 <strong>token</strong> 之间来回切换。就像编写代码时的自动完成功能。<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/token.png?imageMogr2/2/w/800\"></p>\n<h6 id=\"学习使用Code-Snippets工具\"><a href=\"#学习使用Code-Snippets工具\" class=\"headerlink\" title=\"学习使用Code Snippets工具\"></a>学习使用Code Snippets工具</h6><p> 打开 <strong>Utilities 面板</strong>中的 <strong>CodeSnippets Library 检查器</strong>窗口，选中上述注释块，将它拖到该检查器窗口中（从某个 token 例如&lt;#description#&gt;开始拖）:<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/codesnippet.jpg?imageMogr2/2/w/800\"><br> 将会弹出一个编辑窗口让输入 snippet 的某些信息，并以此来创建一个<strong>自动完成快捷方式</strong>。要修改某个<strong>snippet</strong>时,直接点击 <strong>Code Snippet Library</strong> 中的 snippet，然后点 Edit 按钮。按照如下形式填写：<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/snippetwindow.jpg?imageMogr2/2/w/800\"></p>\n<p>要想让 <strong>snippet</strong> 生效，首先删除原有注释，然后将鼠标放到addNumber:toNumber: 方法的 + 号前面,输入<strong>doccomment</strong>，然后回车，该<strong>snippet</strong> 将自动生成。然后，通过 Tab 键在3个 token 间移动，并填充它们。最终完成的文档化结果如下:</p>\n<pre><code>/*!  * @discussion A really simple way to calculate the sum of two numbers.\n\n     * @param firstNumber An NSInteger to be used in the summation of two numbers.\n\n     * @param secondNumber The second half of the equation.\n\n     * @warning Please make note that this method is only good for adding non-negative numbers.\n\n     * @return The sum of the two numbers passed in.\n*/\n</code></pre><p><strong>@param 标签</strong>和 <strong>@warning 标签</strong>需要手动书写。</p>\n<h4 id=\"Typedefs的文档化\"><a href=\"#Typedefs的文档化\" class=\"headerlink\" title=\"Typedefs的文档化\"></a>Typedefs的文档化</h4><p> 打开 Car.h，在 class 之,有一个NS_ENUM，即 typedef enum，一个块，几个属性，一个空方法等，需要文档化。</p>\n<p>还记得 @typedef 标签吗？<br>这个顶级标签稍微特殊一点。它可以对<strong>typedef enum</strong> 或者 <strong>typedef struct</strong> 的类型进行注释。<br>根据注释的对象的不同，它会包含与定义的类型相关的二级标签。</p>\n<p>以 enum 为例，它会包含 @constant 标签，用于每个常量（对于struct，则会是 @field 标签）。</p>\n<p>找到 <strong>enum OldCarType</strong>。它包含两个常量，是用于古典汽车的。在<strong>typedef</strong> 声明之上，将原来的注释替换为：</p>\n<pre><code>/*!  * @typedef OldCarType\n\n     * @brief A list of older car types.\n\n     * @constant OldCarTypeModelT A cool old car.\n\n     * @constant OldCarTypeModelA A sophisticated old car.\n*/\n\ntypedef enum {\n        /// A cool, old car.\n\n         OldCarTypeModelT,\n\n        /// A sophisticated older car.\n\n        OldCarTypeModelA\n\n} OldCarType;\n</code></pre><p> 编译，然后在 <strong>OldCarType</strong> 或上<strong>OldCarTypeModelT</strong>使用<strong>alt + 左键</strong>。</p>\n<p>在这个类中只有一个 <strong>NS_ENUM</strong>，因此接下来进行进行文档化。常量已经注释了，只要对整个<strong>NS_ENUM</strong> 进行一个总体的注释就可以了。</p>\n<pre><code>/*!  * @typedefCarType\n\n     * @brief Alist of newer car types.\n\n     * @constantCarTypeHatchback Hatchbacks are fun, but small.\n\n     * @constantCarTypeSedan Sedans should have enough room to put your kids, and your golfclubs\n\n     * @constantCarTypeEstate Estate cars should hold your kids, groceries, sport equipment,etc.\n\n     * @constantCarTypeSport Sport cars should be fast, fun, and hard on the back.\n*/\n</code></pre><p>注意:这个enum 是通过宏来声明的，悲催的 Xcode 不能完全支持和 <strong>typedef enum</strong> 一样的文档特性，虽然<strong>NS_ENUM</strong> 实际上是声明 enums 的推荐的方法。</p>\n<h4 id=\"typedef-block-文档化\"><a href=\"#typedef-block-文档化\" class=\"headerlink\" title=\"typedef block 文档化\"></a>typedef block 文档化</h4><pre><code>/*!  * @brief A block that makes the car drive.\n     * @param distance The distance is equal to a distance driven when the block is ready to execute. It could be miles, or kilometers, but not both. Just pick one and stick with it. ;]\n*/\n\ntypedef void(^driveCompletion)(CGFloat distance);\n</code></pre><p><strong>typedef block</strong> 的文档化和之前的并无多少不同，它包含了：</p>\n<ul>\n<li>一个 @brief 标签，简单说明了一下这个块的作用。</li>\n<li>一个 @param 标签，说明调用块时需要传递的参数。</li>\n</ul>\n<h4 id=\"添加格式化代码到文档中\"><a href=\"#添加格式化代码到文档中\" class=\"headerlink\" title=\"添加格式化代码到文档中\"></a>添加格式化代码到文档中</h4><p>例如，Car 类的 <strong>driveCarWithComplete:</strong> 方法。</p>\n<p>这个方法以块作为参数，因为块对于新手来说一般比较困难，因此最好是告诉程序员如何使用这个方法。</p>\n<p>这需要使用 <strong>@code 标签</strong>。在 <strong>driveCarWithCompletion</strong>方法声明之前添加如下内容：</p>\n<pre><code>/*!  * @brief The car will drive, and then execute the drive block\n\n     * @param completion A driveCompletion block\n\n     * @code [car driveCarWithCompletion:^(CGFloat distance){\n\n                            NSLog(@&quot;Distance driven %f&quot;, distance);\n\n                         }];\n*/\n</code></pre><p>编译，在方法名上使用<strong>alt+左键</strong>。如下图所示：<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/driveCar.jpg?imageMogr2/2/w/800\"></p>\n<h4 id=\"检查文档\"><a href=\"#检查文档\" class=\"headerlink\" title=\"检查文档\"></a>检查文档</h4><p>学会了如何添加注释，如果 <strong>Xcode</strong> 能帮你检查你的工作，就像Xcode会自动检查代码中的语法错误，那岂不是更好？有一个好消息，Clang 有一个标志，叫做“<strong>CLANG_WARN_DOCUMENTATION_COMMENTS</strong>”,可以用于检查 <strong>HeaderDoc</strong> 格式的注释。</p>\n<p>打开 <strong>DocumentationExamples</strong>的项目设置，点击 <strong>Build Settings</strong>，找到 <strong>DocumentationComments</strong>, 将值设置为 <strong>YES</strong>。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/buildsetting.jpg?imageMogr2/2/w/800\"><br>如下，打开 <strong>MathAPI.h</strong>，将第一个 @param 标签的参数名由<strong>firstNumber</strong> 修改为 <strong>thirdNumber</strong>,然后编译。<br>有一个警告发生，甚至提出了修改建议。它不会影响任何事情，但有助于检查文档中的错误。<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/RW_Documentation_WarningEx.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"特殊注释\"><a href=\"#特殊注释\" class=\"headerlink\" title=\"特殊注释\"></a>特殊注释</h4><p><strong>Xcode</strong> 还支持几种特殊注释，对于你或者使用你代码的人非常有用。</p>\n<p>打开 Car.m，在 <strong>driveCarWithCompletion:</strong> 方法中，在调用<strong>completion</strong> 块之前添加下列注释：</p>\n<pre><code>// FIXME: This is broken\n\n// !!!: Holy cow, it should be checked!\n\n// ???: Perhaps check if the block is not nil first?\n</code></pre><p>这里出现了3中注释：</p>\n<ul>\n<li>FIXME: 某个地方需要修正</li>\n<li>!!!: 某个地方需要注意。</li>\n<li>???: 代码中有问题，或者代码是可疑的。</li>\n</ul>\n<p>这些注释不但有助于浏览代码，而且 Xcode 绘制 <strong>Jump Bar</strong> 中显示它们。点击<strong>Jump Bar</strong>，如下图所示：</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/RW_Documentation_JumpBar-700x151.png?imageMogr2/2/w/800\">\n<p> 你将看到这3个注释以粗体显示：</p>\n <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/RW_Documentation_JumpBarSelect-700x287.png?imageMogr2/2/w/800\">\n<p> 到此，你已经完全掌握了如何对项目进行文档化。花一些时间对项目的其他属性和方法操作一番，并加入一些自己的东西。看看在注释块中改变一些东西或者删除某个标签会发生什么。这将让你明白注释格式如何对文档造成影响的。</p>\n<p>#用headerdoc2html 创建 HTML文档<br>文档化是由一个 <strong>HeaderDoc 工具</strong>完成的。当 Xcode 安装时，它就已经安装好了。<br>它除了解释已添加的注释，显示一个弹出菜单以及将注释在<strong>Quick Help</strong> 中显示之外，还可以在文档化之后创建 HTML、XML 以及联机帮助手册。</p>\n<p>本节介绍 HTML 文件的制作。如果你对用 HeaderDoc 如何创建在线文档感兴趣，请参考<a href=\"https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/HeaderDoc/usage/usage.html\" target=\"_blank\" rel=\"noopener\">HeaderDoc 用户指南</a>.</p>\n<p>打开终端，转到 DocumentationExamples 项目目录：</p>\n<pre><code>cd /path/to/your/folder\n\n确保该路径下包含了 Xcodeproject  文件(“DocumentationExamples.xcodeproj”)。\n</code></pre><p>然后用下列命令创建 HTML 文档：</p>\n<pre><code>headerdoc2html -o ~/Desktop/documentation DocumentationExamples/\n</code></pre><p>此时终端会有许多输出。当创建完毕，返回桌面，出现一个名为documentation 的目录。双击打开，找到 Car_h 目录，打开 index.html：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/Screen-Shot-2014-04-05-at-5.58.18-PM.png?imageMogr2/2/w/800\"></p>\n<p><strong>headerdoc2html 脚本</strong>有两个参数：</p>\n<p>So what justhappened? Well, you ran the headerdoc2htmlscript with 2 options:</p>\n<ul>\n<li>-o ~/Desktop/documentation – 这个参数指定输出的 Html 文件路径——即桌面的 documentation 目录。</li>\n<li>DocumentationExamples/ – 该参数指定要解析的源文件位于 DocumentationExamples 目录（不包含项目目录下的其他目录，因为它们并不包含源代码）</li>\n</ul>\n<p>问题:</p>\n<ol>\n<li>最新版本<strong>headerdoc2html</strong>有个问题，用 google chrome打开 index.html后，左边的目录显示不正常，但 Safari打开正常。</li>\n<li>最新版本的<strong>headerdoc2html</strong> 不能正确解析 /// 类的注释，可以使用 /*! 类型的注释代替。</li>\n</ol>\n<p>这很酷，但还可以更进一步。除了手动进入到输出目录中进行导航，<strong>HeaderDoc</strong>还会创建一个主目录索引。<br>返回终端，导航至新建的 <strong>documentation</strong> 目录，输入：</p>\n<pre><code>cd ~/Desktop/documentation\n</code></pre><p>然后输入命令，创建内容索引:</p>\n<pre><code>gatherheaderdoc .\n</code></pre><p><strong>gatherheaderdoc</strong>自动查找目录，为 <strong>.</strong> 目录（表示当前目录）创建索引。<br>用 Finder 打开 documentation  目录。你会发现多出一个 <strong>masterTOC.html</strong> 文件。打开它，它将列出所有已文档化的属性、方法、枚举和块的链接。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/Screen-Shot-2014-04-05-at-6.01.35-PM.png?imageMogr2/2/w/800\"><br>你可以将所有 HTML 文件放到 web 服务器上，然后所有人都可以访问你的文档！</p>\n<p>#VVDocumenter-Xcode</p>\n<p>最后的内容是 <strong>VVDocumenter-Xcode</strong>，一个第三方 Xcode插件，它能让你的文档化工作简单至比使用早先介绍的 <strong>Code Snippet</strong> 更容易。</p>\n<p>首先，从 <a href=\"https://github.com/onevcat/VVDocumenter-Xcode\" target=\"_blank\" rel=\"noopener\">Github</a> 下载插件。</p>\n<p>你所需要做的全部工作就是打开项目，然后 <strong>Build</strong>。它会将插件自动安装到~/Library/ApplicationSupport/Developer/Shared/Xcode/Plug-ins 目录。</p>\n<p>然后重启 Xcode。再次打开 DocumentationExamples项目。在 MathAPI.h，删除 <strong><code>addNumber:toNumber</code></strong> 方法的注释块，然后在方法声明上面输入：</p>\n<pre><code>///\n</code></pre><p><strong>VVDocumenter-Xcode</strong> 将自动创建注释块，包括所有必要的 <strong>@param</strong> 标签以及自动完成 <strong>token</strong>。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/RW_Documentation_VVDocumentor-700x184.png?imageMogr2/2/w/800\"></p>\n<p>打开 Car.h，删除 <strong>NS_ENUM CarType</strong> 的注释，以及每个常量的注释。在<strong>NS_ENUM</strong> 声明之上，输入：</p>\n<pre><code>///\n</code></pre><p>这回，它会在 enum 之上创建 <strong>discussion</strong> 标签，甚至还每个常量上面放入了必要的注释！</p>\n<p><strong>VVDocumenter-Xcode</strong> 使你的生活更加轻松。如果你想定制<strong>VVDocumenter-Xcode</strong>，在Xcode中，使用 <strong>Window&gt;VVDocumenter菜单</strong>。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/VW_Documentation_VVDocPrefs-700x410.png?imageMogr2/2/w/800\"></p>\n<p>这里，你可以改变自动完成关键字、注释风格以及其他。你想怎样定制 VVDocumenter-Xcode都行。VVDocumenter-Xcode 为我省下了大量的时间！<br>接下来做什么？</p>\n<p>最终完成的示例项目在 这里<a href=\"http://cdn2.raywenderlich.com/wp-content/uploads/2014/03/DocumentationExamples_Final.zip\" target=\"_blank\" rel=\"noopener\">下载</a>。</p>\n<p>在你自己的代码中进行文档化。尝试自己编写 <strong>code snippet</strong> 并使用<strong>VVDocumentor</strong>。</p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"文档","path":"api/categories/文档.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"}]},{"title":"Storyboard之Segue","slug":"iOS/Storyboard之Segue","date":"2014-07-22T10:59:49.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/Storyboard之Segue.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h5 id=\"Segue原理\"><a href=\"#Segue原理\" class=\"headerlink\" title=\"Segue原理:\"></a>Segue原理:</h5><p>在iOS开发中，segue用来实现storyboard中源视图控制器和目标视图控制器连接，当segue被触发时，系统将完成下列操作：</p>\n<ol>\n<li>实例化目标视图控制器</li>\n<li>实例化一个新segue对象，该对象持有所有的信息</li>\n<li>调用源视图控制器的prepareForSegue:sender:方法，</li>\n<li>调用segue的 perform 方法将目标控制器带到屏幕上。<br>这个动作行为依赖segue的类型如modal,push,custom,modal segue告诉源视图控制器present目标视图控制器。</li>\n</ol>\n<p>在源视图控制器的prepareForSegue:sender:的方法中，执行对目标视图控制器所有必要的属性配置，包括委托设置（如目标视图控制器有协议）。<br><a id=\"more\"></a><br>在apple的文档库中第二个示例应用开发文档中，介绍了这样一个segue的使用例子。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>) prepareForSegue:(<span class=\"built_in\">UIStoryboardSegue</span> *)segue sender:(<span class=\"keyword\">id</span>)sender  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([[segue identifier] isEqualToString:<span class=\"string\">@\"ShowSightingsDetails\"</span>])  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">    <span class=\"comment\">//当用户选择表视图中的一行时，触发**segue**事件，传输数据到目标视图控制器，使目标控制器上能显示`sighting`</span></span><br><span class=\"line\">        DetailViewController *detailViewController = [segue destinationViewController];  </span><br><span class=\"line\">        detailViewController.sighting = [<span class=\"keyword\">self</span>.dataController objectInListAtIndex:[<span class=\"keyword\">self</span>.tableView indexPathForSelectedRow].row];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([[segue identifier] isEqualToString:<span class=\"string\">@\"ShowAddSightingView\"</span>])  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        AddSightingViewController *addSightingViewController = [[[segue destinationViewController] viewControllers] objectAtIndex:<span class=\"number\">0</span>];  </span><br><span class=\"line\">        addSightingViewController.delegate = <span class=\"keyword\">self</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure><br>在<code>storyboard</code>中，这个实现方法代码是用来处理从主视图控制器到两个不同的目标视图控制器的<strong>segue</strong>。这两个<strong>segue</strong>通过它们的<code>identifier</code>属性进行判断，具体解释如下：  </p>\n<ul>\n<li><p><code>identifier</code>为”<strong>ShowSightingsDetails</strong>“时，目标视图控制器是一个展示明细信息的视图控制器,使用的<strong>segue</strong>类型为<code>push</code>。这种通常用于<strong>navigator</strong>视图控制器中。  </p>\n</li>\n<li><p>在<code>identifier</code>为”<strong>ShowAddSightingView</strong>“时，目标视图控制器管理的是一个新加的<strong>sighting</strong>信息视图，我们称之为<strong>add</strong>视图控制器。它是不需要从主视图控制器（源）传什么数据过来的。但是，主视图控制器需要获取在add视图控制器（目标）上输入的数据。  </p>\n<ul>\n<li><ul>\n<li>实现方式是采用<code>delegate</code>，将主视图控制器设置为add视图控制器(目标)的委托。在add目标视图控制器上执行它的委托中方法，该方法需要先在主视图控制器的实现代码中实现，方法包括如何读取add视图控制器的数据，并dismiss掉add视图控制器。  </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>在add视图控制器上，有两个按钮，用于执行<strong>cancel</strong>和<strong>done</strong>操作。这两个按钮操作的方法在主视图控制器中实现。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)addSightingViewControllerDidCancel:(AddSightingViewController *)controller  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">\t[<span class=\"keyword\">self</span> dismissViewControllerAnimated:<span class=\"literal\">YES</span> completion:<span class=\"literal\">NULL</span>];  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)addSightingViewControllerDidFinish:(AddSightingViewController *)controller name:(<span class=\"built_in\">NSString</span> *)name location:(<span class=\"built_in\">NSString</span> *)location &#123;  </span><br><span class=\"line\"><span class=\"keyword\">if</span> ([name length] || [location length]) &#123;  </span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.dataController addBirdSightingWithName:name location:location];  </span><br><span class=\"line\">\t[[<span class=\"keyword\">self</span> tableView] reloadData];  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">\t[<span class=\"keyword\">self</span> dismissModalViewControllerAnimated:<span class=\"literal\">YES</span>];  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在add视图控制器实现代码中，调用它的委托中这两个方法。  </p>\n<h5 id=\"segue三种类型-modal-segue、push-segue、custom-segue\"><a href=\"#segue三种类型-modal-segue、push-segue、custom-segue\" class=\"headerlink\" title=\"segue三种类型:modal segue、push segue、custom segue\"></a>segue三种类型:modal segue、push segue、custom segue</h5><ul>\n<li><h6 id=\"modal-segue\"><a href=\"#modal-segue\" class=\"headerlink\" title=\"modal segue\"></a>modal segue</h6>是一个视图控制器（源）为了完成一个任务而模态地（<strong>modally</strong>）呈现另一个视图控制器（目标）。这个目标视图控制器不是导航视图控制器(<strong>navigation view controller</strong>)的栈中的一部分。<br>在任务完成后，使用<code>delegate</code>将呈现的视图控制器（目标）释放掉，应用界面切换到原来的视图控制器（源）上。  </li>\n</ul>\n<p>这个过程的实现代码可以看成是<code>present</code>和<code>dismiss</code>两个操作。  </p>\n<ul>\n<li><h6 id=\"push-segue\"><a href=\"#push-segue\" class=\"headerlink\" title=\"push segue\"></a>push segue</h6>是将另一个视图控制器压入到导航控制器的栈中。它通常和导航视图控制器(<strong>navigation view controller</strong>)一起使用。<br>新压入的视图控制器会有一个回退按钮，可以退回来上一层。</li>\n</ul>\n<p>这个过程的实现代码可以看成是<code>push</code>和<code>pop</code>两个操作。</p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"SB","path":"api/categories/SB.json"}],"tags":[{"name":"转场","path":"api/tags/转场.json"},{"name":"Storyboard","path":"api/tags/Storyboard.json"}]},{"title":"instrument之Zombie工具","slug":"调试/instrument之Zombie工具","date":"2014-07-01T19:54:02.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/调试/instrument之Zombie工具.json","excerpt":null,"keywords":null,"cover":"/images/templateOfTraceDcument.jpg","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>Zombie:针对<strong>僵尸对象</strong>导致应用程序崩溃，即已经<code>deallocated</code>的对象，它们的<code>retainCount</code>计数器已经为0，通过正常的手段是无法在<code>debug</code>中跟踪和观察到的。</p>\n<p>如果你开启了 <code>Zombie Enabled</code> ，则当 Zombie 问题出现时，控制台会输出 Zombie 对象的地址，且程序会在此处产生断点：</p>\n<pre><code>-[CALayer retainCount]: message sent to deallocated instance &lt;memoryaddress&gt;\n</code></pre><a id=\"more\"></a>\n<p>虽然可以看到内存地址，知道是某个指针导致了 <code>Zombie</code> 引用，但对于解决问题却毫无帮助，因为仍不知道该地址到底是哪个对象？原因很显然，既然该对象已经<code>deallocated</code>，就无法再从内存中找回它来。虽然可以以对象的形式打印这个指针：</p>\n<pre><code>（GDB）po &lt;内存地址&gt;\n</code></pre><p>仍然会得到一个 <strong><code>message sent to deallocated instance</code></strong> 的错误消息。</p>\n<p>可以在 <code>Instrument</code> 用 <code>Zombie</code> 模板，来观察到这些 <code>Zombie</code> 对象。</p>\n<blockquote>\n<p>提示：只能在模拟器中使用 Zombie 模板，对于在设备中运行的程序， 你只能手动找出<code>Zombie</code>对象，<code>Zombie</code>模板对物理设备无效。</p>\n</blockquote>\n<p>使用操作如下：<br>点击 Xcode 的 Project –&gt; Profile 菜单。在 Instrument 的“模板选择窗口”中，选择“iOSSimulator”下面的 Zombie 模板。<br><img src=\"/images/templateOfTraceDcument.jpg\" alt=\"image\"><br>在模拟器中调试程序，如果 Zombie 问题出现，程序将崩溃，同时 Instrument 会弹出一个“Zombie 消息报告”，同时程序将在此处中断，如下图所示。<br><img src=\"/images/ZombieMsgAlert.jpg\" alt=\"image\"></p>\n<p>点击地址 (0x158b3c00) 右边的箭头，将列出该 Zombie 对象曾经发生过的 retain/release 动作。</p>\n<p>从列表中找到 retain count 在变为 -1 之前的那行,打开 View -&gt; Extended detail，将显示导致了过渡释放的代码调用：<br><img src=\"/images/ErrCodeline.jpg\" alt=\"image\"></p>\n<p>双击这句代码，将在源文件中高亮显示该语句：</p>\n<p><img src=\"/images/Errorcode.png\" alt=\"image\"><br>现在，知道问题出在哪里了吧？</p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"instrument","path":"api/categories/instrument.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"Storyboard","path":"api/tags/Storyboard.json"}]}]}