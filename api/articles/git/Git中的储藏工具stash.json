{"title":"Git中的储藏工具stash","slug":"git/Git中的储藏工具stash","date":"2015-01-19T19:57:04.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/Git中的储藏工具stash.json","excerpt":"Stashing储藏工作应用储藏被暂存的文件重新暂存应用后，移除储藏的内容取消储藏(Un-applying a Stash)新建stash-unapply别名从储藏中创建分支Git工具 - 储藏（Stashing）git原文<br>场景：当项目中某一部分正在编码中，突然接到新任务，又必须换至其他分支去完成。问题：你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决：git stash 命令。“Stashing”可以获取工作目录的中间状态，即：将修改过的被追踪的文件和暂存的变更，保存到一个未完结变更的堆栈中，随时可以重新应用。储藏工作进入项目目录，修改某个文件，有可能还暂存其中的一个变更。git status 命令,查看中间状态：1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>$ git status<br># On branch master<br># Changes to be committed:<br>#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)<br>#<br>#      modified:   index.html<br>#<br># Changes not staged for commit:<br>#   (use \"git add &lt;file&gt;...\" to update what will be committed)<br>#<br>#      modified:   lib/simplegit.rb<br>#<br>切换分支，但不提交step 1 中的变更，所以储藏这些变更。<br>执行git stash 命令，往堆栈中推送一个新的储藏：1<br>2<br>3<br>4<br>5<br>$ git stash<br>Saved working directory and index state \\<br>  \"WIP on master: 049d078 added the index file\"<br>HEAD is now at 049d078 added the index file<br>(To restore them type \"git stash apply\")<br>执行step 2查看目录库，中间状态就不见了：1<br>2<br>3<br>$ git status<br>#######On branch master<br>nothing to commit, working directory clean<br>这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。使用git stash list要查看现有的储藏：1<br>2<br>3<br>4<br>$ git stash list<br>stash@&#123;0&#125;: WIP on master: 049d078 added the index file<br>stash@&#123;1&#125;: WIP on master: c264051 Revert \"added file_size\"<br>stash@&#123;2&#125;: WIP on master: 21d80a5 added number to log<br>在这个案例中，之前已经进行了两次储藏，所以你可以访问到三个不同的储藏。应用储藏执行git stash apply命令, 可以重新应用最近的一次储藏；<br>执行git stash apply stash@{2}命令，即通过指定储藏的名字，来应用更早的储藏。<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>$ git stash apply<br># On branch master<br># Changes not staged for commit:<br>#   (use \"git add &lt;file&gt;...\" to update what will be committed)<br>#<br>#      modified:   index.html<br>#      modified:   lib/simplegit.rb<br>#<br><br>","covers":null,"content":"<script src=\"/assets/js/APlayer.min.js\"> </script><ol>\n<li><a href=\"#Stashing\">Stashing</a></li>\n<li><a href=\"#work\">储藏工作</a></li>\n<li><a href=\"#apply\">应用储藏</a></li>\n<li><a href=\"#applyIndex\">被暂存的文件重新暂存</a></li>\n<li><a href=\"#drop\">应用后，移除储藏的内容</a></li>\n<li><a href=\"#unapply\">取消储藏(Un-applying a Stash)</a></li>\n<li><a href=\"#stash-unapply\">新建stash-unapply别名</a></li>\n<li><a href=\"#stashBranch\">从储藏中创建分支</a></li>\n</ol>\n<h3 id=\"Git工具-储藏（Stashing）git\"><a href=\"#Git工具-储藏（Stashing）git\" class=\"headerlink\" title=\"Git工具 - 储藏（Stashing）git\"></a><a name=\"Stashing\">Git工具 - 储藏（Stashing）</a>git</h3><hr>\n<p><a href=\"https://git-scm.com/book/zh/v2/Git-工具-储藏与清理\" target=\"_blank\" rel=\"noopener\">原文</a><br>场景：当项目中某一部分正在编码中，突然接到新任务，又必须换至其他分支去完成。</p>\n<p>问题：你不想提交进行了一半的工作，否则以后你无法回到这个工作点。</p>\n<p>解决：<strong><font color=\"red\">git stash </font></strong>命令。</p>\n<p>“Stashing”可以获取工作目录的中间状态，即：将修改过的被追踪的文件和暂存的变更，保存到一个未完结变更的堆栈中，随时可以重新应用。</p>\n<h3 id=\"储藏工作\"><a href=\"#储藏工作\" class=\"headerlink\" title=\"储藏工作\"></a><a name=\"work\">储藏工作</a></h3><hr>\n<ol>\n<li>进入项目目录，修改某个文件，有可能还暂存其中的一个变更。</li>\n<li><strong><font color=\"red\">git status </font></strong>命令,查看中间状态：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\"># Changes to be committed:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   index.html</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   lib/simplegit.rb</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure></li>\n<li>切换分支，但不提交step 1 中的变更，所以储藏这些变更。<br>执行<strong><font color=\"red\">git stash </font></strong>命令，往堆栈中推送一个新的储藏：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash</span><br><span class=\"line\">Saved working directory and index state \\</span><br><span class=\"line\">  <span class=\"string\">\"WIP on master: 049d078 added the index file\"</span></span><br><span class=\"line\">HEAD is now at 049d078 added the index file</span><br><span class=\"line\">(To restore them <span class=\"built_in\">type</span> <span class=\"string\">\"git stash apply\"</span>)</span><br></pre></td></tr></table></figure></li>\n<li>执行step 2查看目录库，中间状态就不见了：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\"><span class=\"comment\">#######On branch master</span></span><br><span class=\"line\">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>\n这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。</li>\n<li>使用<strong><font color=\"red\">git stash list</font></strong>要查看现有的储藏：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash list</span><br><span class=\"line\">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class=\"line\">stash@&#123;1&#125;: WIP on master: c264051 Revert <span class=\"string\">\"added file_size\"</span></span><br><span class=\"line\">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to <span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n在这个案例中，之前已经进行了两次储藏，所以你可以访问到三个不同的储藏。<h3 id=\"应用储藏\"><a href=\"#应用储藏\" class=\"headerlink\" title=\"应用储藏\"></a><a name=\"apply\">应用储藏</a></h3></li>\n</ol>\n<hr>\n<p>执行<strong><font color=\"red\">git stash apply</font></strong>命令, 可以重新应用最近的一次储藏；<br>执行<strong><font color=\"red\">git stash apply stash@{2}</font></strong>命令，即通过指定储藏的名字，来应用更早的储藏。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash apply</span><br><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   index.html</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   lib/simplegit.rb</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure><br><a id=\"more\"></a><br>可以看到 Git 重新修改了你所储藏的那些当时尚未提交的文件。在这个案例里，你尝试应用储藏的工作目录是干净的，并且属于同一分支；但是一个干净的工作目录和应用到相同的分支上并不是应用储藏的必要条件。你可以在其中一个分支上保留一份储藏，随后切换到另外一个分支，再重新应用这些变更。在工作目录里包含已修改和未提交的文件时，你也可以应用储藏——Git 会给出归并冲突如果有任何变更无法干净地被应用。</p>\n<h3 id=\"被暂存的文件重新暂存\"><a href=\"#被暂存的文件重新暂存\" class=\"headerlink\" title=\"被暂存的文件重新暂存\"></a><a name=\"applyIndex\">被暂存的文件重新暂存</a></h3><hr>\n<p>执行<strong><font color=\"red\">git stash apply</font></strong>命令,虽然对文件的变更被重新应用，但是被暂存的文件没有重新被暂存。<br>执行<strong><font color=\"red\">git stash apply –index</font></strong>命令,即可让被暂存的文件重新暂存。<br><strong>–index</strong>选项告诉命令重新应用被暂存的变更：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash apply --index</span><br><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\"># Changes to be committed:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   index.html</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   lib/simplegit.rb</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"应用后，移除储藏的内容\"><a href=\"#应用后，移除储藏的内容\" class=\"headerlink\" title=\"应用后，移除储藏的内容\"></a><a name=\"drop\">应用后，移除储藏的内容</a></h3><hr>\n<p><strong>apply </strong>选项只尝试应用储藏的工作——储藏的内容仍然在栈上。<br>执行<strong><font color=\"red\">git stash drop 储藏的名字</font></strong>命令，，即可从栈中彻底移除储藏内容：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash list</span><br><span class=\"line\">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class=\"line\">stash@&#123;1&#125;: WIP on master: c264051 Revert <span class=\"string\">\"added file_size\"</span></span><br><span class=\"line\">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to <span class=\"built_in\">log</span></span><br><span class=\"line\">$ git stash drop stash@&#123;0&#125;</span><br><span class=\"line\">Dropped stash@&#123;0&#125; (364e91f3f268f0900bc3ee613f9f733e82aaed43)</span><br></pre></td></tr></table></figure><br>你也可以运行 <strong><font color=\"red\">git stash pop</font></strong>命令，来重新应用储藏，同时立刻将其从堆栈中移走。</p>\n<h3 id=\"取消储藏-Un-applying-a-Stash\"><a href=\"#取消储藏-Un-applying-a-Stash\" class=\"headerlink\" title=\"取消储藏(Un-applying a Stash)\"></a><a name=\"unapply\">取消储藏(Un-applying a Stash)</a></h3><hr>\n<p>在某些情况下，重新应用了之前的储藏的变更，进行了一些其他的修改后，又想要取消之前所应用储藏的修改。<br>Git没有提供类似于 <strong><font color=\"red\">stash unapply</font></strong>的命令，但是可以通过取消该储藏的补丁达到同样的效果：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash show -p stash@&#123;0&#125; | git apply -R</span><br></pre></td></tr></table></figure><br>同样的，如果你沒有指定具体的某个储藏，Git 会选择最近的储藏：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash show -p | git apply -R</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"新建stash-unapply别名\"><a href=\"#新建stash-unapply别名\" class=\"headerlink\" title=\"新建stash-unapply别名\"></a><a name=\"stash-unapply\">新建stash-unapply别名</a></h4><hr>\n<p>你可能会想要新建一个別名，在你的 Git 里增加一个<strong><font color=\"red\">stash-unapply</font></strong> 命，这样更有效率。例如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global alias.stash-unapply <span class=\"string\">'!git stash show -p | git apply -R'</span></span><br><span class=\"line\">$ git stash apply</span><br><span class=\"line\">$ <span class=\"comment\">#... work work work</span></span><br><span class=\"line\">$ git stash-unapply</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"从储藏中创建分支\"><a href=\"#从储藏中创建分支\" class=\"headerlink\" title=\"从储藏中创建分支\"></a><a name=\"stashBranch\">从储藏中创建分支</a></h3><hr>\n<p>如果你储藏了一些工作，暂时不去理会，然后继续在你储藏工作的分支上工作，你在重新应用工作时可能会碰到一些问题。如果尝试应用的变更是针对一个你那之后修改过的文件，你会碰到一个归并冲突并且必须去化解它。如果你想用更方便的方法来重新检验你储藏的变更，你可以运行 git stash branch，这会创建一个新的分支，检出你储藏工作时的所处的提交，重新应用你的工作，如果成功，将会丢弃储藏。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash branch testchanges</span><br><span class=\"line\">Switched to a new branch <span class=\"string\">\"testchanges\"</span></span><br><span class=\"line\"><span class=\"comment\"># On branch testchanges</span></span><br><span class=\"line\"><span class=\"comment\"># Changes to be committed:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   index.html</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   lib/simplegit.rb</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">Dropped refs/stash@&#123;0&#125; (f0dfc4d5dc332d1cee34a634182e168c4efc3359)</span><br></pre></td></tr></table></figure><br>这是一个很棒的捷径来恢复储藏的工作然后在新的分支上继续当时的工作。</p>\n","categories":[{"name":"git","path":"api/categories/git.json"},{"name":"工具","path":"api/categories/工具.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"git","path":"api/tags/git.json"},{"name":"坑","path":"api/tags/坑.json"}]}