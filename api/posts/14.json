{"total":157,"pageSize":10,"pageCount":16,"data":[{"title":"敏捷开发总结","slug":"管理/敏捷开发总结","date":"2015-11-20T10:06:38.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/管理/敏捷开发总结.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>传统开发模型的局限性<br>什么是敏捷软件开发<br>Scrum概述<br>Scrum角色<br>Scrum活动<br>Scrum实践<br>Scrum工具和模板<br>Scrum常见问题<br>推荐书籍<br>敏捷方法强调以人为本，专注于交付对客户有价值的软件。在高度协作的开发环境中，使用迭代式的方式进行增量开发，经常使用反馈进行思考、反省和总结，不停的进行自我调整和完善。</p>\n<p>Scrum Team中的三种角色</p>\n<p>Product Owner- 产品所有者<br>个人：代表所有的干系人</p>\n<p>Scrum Master:<br>个人：负责指导过程的执行</p>\n<p>Scrum Team – Scrum团队:<br>承诺完成工作，向干系人交付产品价值</p>\n<p>Product Owner- 产品所有者：</p>\n<p>1 利益相关方的代表,重点是产品方面，与Scrum Master和Team合作</p>\n<p>2 从业务角度出发对需求进行排序</p>\n<p>3 合理的调整产品功能和迭代顺序</p>\n<p>4 侧重于投资回报</p>\n<p>Scrum Master职责:<br>1 为Scrum Team服务,确保每个成员都认同Scrum价值观和游戏规则</p>\n<p>2 帮助Scrum Team规划Sprit计划</p>\n<p>3 组织每天的Daily Scrum会议</p>\n<p>4 负责保证Scrum Team 高效持续运转</p>\n<p>5 决策和免除障碍，保证团队不受外来无端的影响</p>\n<p>Scrum Team – Scrum团队:  </p>\n<p>1 尽一切可能去完成任务-发布产品</p>\n<p>2 充分理解产品负责人的产品愿景</p>\n<p>3 合作完成冲刺(Sprint)中每一个目标</p>\n<p>4 更好的支持可能需要进一步开发的产品发布</p>\n","raw":null,"categories":[{"name":"管理","path":"api/categories/管理.json"}],"tags":[{"name":"Scrum","path":"api/tags/Scrum.json"}]},{"title":"清除git历史记录大文件bfg","slug":"git/清除git历史记录大文件bfg","date":"2015-10-20T11:17:27.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/清除git历史记录大文件bfg.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><ol>\n<li><a href=\"https://search.maven.org/remote_content?g=com.madgag&amp;a=bfg&amp;v=LATEST\" target=\"_blank\" rel=\"noopener\">下载bfg</a> 到本地soft/bfg目录下。</li>\n<li>sudo vi ~/.bash_profile  添加如下：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias bfg=&quot;java -jar ~/Downloads/soft/bfg/bfg.jar&quot;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>cd 到库目录，执行bfg命令： <a href=\"https://rtyley.github.io/bfg-repo-cleaner/\" target=\"_blank\" rel=\"noopener\">bfg官网</a> </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd PBB_SSH所属目录下</span><br><span class=\"line\">$ bfg --delete-folders universal --no-blob-protection  PBB_SSH</span><br><span class=\"line\">$ cd PBB_SSH</span><br><span class=\"line\">$ git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</span><br><span class=\"line\">$ git push</span><br></pre></td></tr></table></figure>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"工具","path":"api/categories/工具.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"git","path":"api/tags/git.json"},{"name":"坑","path":"api/tags/坑.json"}]},{"title":"calabash一款跨平台UI测试工具初探","slug":"测试/calabash一款跨平台UI测试工具初探","date":"2015-10-06T08:32:41.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/测试/calabash一款跨平台UI测试工具初探.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>参考：<a href=\"http://blog.csdn.net/zangcw/article/details/25299243\" target=\"_blank\" rel=\"noopener\">使用jenkins+calabash+cocoapods搭建ios持续集成环境</a></p>\n<ol>\n<li>calabash  是一款开源的跨平台UI测试工具，目前支持iOS和Android。它使用Cucumber作为测试核心，Cucumber是一个在敏捷团队十分流行的自动化的功能测试工具，它使用接近于自然语言的特性文档进行用例的书写和测试，支持多语言和多平台。</li>\n<li><p>安装Calabash  </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem install calabash-cucumber</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装Calabash中文支持包  </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem install calabash-cucumber-cn</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"For-automatic-setup\"><a href=\"#For-automatic-setup\" class=\"headerlink\" title=\"For automatic setup:\"></a>For automatic setup:</h4><ol>\n<li><p>In a terminal, go to your iOS project  </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\tcd path-to-my-ios-project (i.e. directory containing .xcodeproj file)</span><br><span class=\"line\">\t```  </span><br><span class=\"line\">2. Install calabash-cucumber gem (this make take some time because of dependencies)</span><br></pre></td></tr></table></figure>\n<p> gem install calabash-cucumber</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3. Setup your project for Calabash-iOS.</span><br></pre></td></tr></table></figure>\n<p> calabash-ios setup  //Answer the questions and read the output :)</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4. Generate a skeleton features folder for your tests</span><br></pre></td></tr></table></figure>\n<p> calabash-ios gen</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5. In Xcode, build your project using the -cal scheme</span><br><span class=\"line\"></span><br><span class=\"line\">6. Run the generated test!</span><br></pre></td></tr></table></figure>\n<p> cucumber</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">If all goes well, you are now ready to write your first test. Start by editing the file features/my_first.feature.</span><br><span class=\"line\">&lt;!--more--&gt;</span><br><span class=\"line\">#### [cucumber官网](https://cukes.info/)   </span><br><span class=\"line\"></span><br><span class=\"line\">\t\t* Feature（功能）  </span><br><span class=\"line\">\t\t* Scenario（情景）  </span><br><span class=\"line\">\t\t*  Given（给定）  </span><br><span class=\"line\">\t\t*  When（当）  </span><br><span class=\"line\">\t\t*  Then（则） </span><br><span class=\"line\">#####[运行原理](http://www.educity.cn/se/619226.html)  </span><br><span class=\"line\">![image](http://img.educity.cn/img_7/262/2013122000/125005907.jpg)  </span><br><span class=\"line\">cucumber是一种BDD测试框架，核心为cucumber的calabash的脚本在运行测试的时候会在虚拟机/真机上预装一个web服务器，这个web服务器就是解释calabash的脚本，将其解释为robotium的脚本，然后这个web服务器会想测试app发送robotium的脚本，测试app拿到robotium脚本后，将其解释为instumentation命令向被测试的app发送这些命令，被测试的app执行这些命令，然后将结果返回给测试app，然后一级一级返得到最后的测试结果。    </span><br><span class=\"line\">#####结构框架</span><br><span class=\"line\">calabash完全采用了cucumber的结构模式，calabash是脚本与TC分离设计，在业务变化的情况下，只要功能存在基本只需要修改TC逻辑，在业务不变，功能变化的情况下，基本只需要修改脚本。   </span><br><span class=\"line\">![image](http://img.educity.cn/img_7/262/2013122000/126005907.jpg)  </span><br><span class=\"line\">feature为主件夹，step_definitions目录内是你封装的脚本，my_first.feature文件就是你的TC逻辑。  </span><br><span class=\"line\">再看一下其中的内容：</span><br><span class=\"line\"></span><br><span class=\"line\">\t　　my_first.feature</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　Feature： 登陆</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　Scenario： 输入正确的用户名密码能够正常登陆</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　When 打开登陆页面</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　And    输入用户名XXX输入密码XXX</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　And   点击登陆</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t　　Then  验证登陆成功</span><br><span class=\"line\"></span><br><span class=\"line\">　　看起来很简单吧，想要验证其他功能也是类似的语言描述即可。  </span><br><span class=\"line\">如果你没有用过cucumber或者calabash那么你肯定现在有一个疑问，计算机怎么能识别汉字来进行测试的呢，  </span><br><span class=\"line\">那么看一下step_definition，以 输入用户名XXX输入密码XXX为例：</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tWhen /^ 输入用户名\\&quot;([^\\\\\\&quot;]*)\\&quot; 输入密码\\&quot;([^\\\\\\&quot;]*)\\&quot;  $/ do |username，password|</span><br><span class=\"line\">\t\tperformAction(&apos;enter_text_into_numbered_field&apos;，username，1)</span><br><span class=\"line\">\t\tperformAction(&apos;enter_text_into_numbered_field&apos;，password，2)</span><br><span class=\"line\">\t\tend</span><br><span class=\"line\">现在应该能明白为什么你需要写汉字的脚本就可以了吧。  </span><br><span class=\"line\">在这里解释一下为什么如果业务存在功能修改这种情况，自动化脚本的修改量会小。  </span><br><span class=\"line\">还是以这个登录脚本为例：</span><br><span class=\"line\"></span><br><span class=\"line\">\t假如现在输入用户名和密码的输入框顺序变了，在你的页面显示上，可能是从左下角移到中间了，这种变化，那么feature文件你不用改，只需要改step_definition脚本就好了</span><br><span class=\"line\">#####运行报告</span><br><span class=\"line\">alabash-android支持很多报告生成模式，支持html，json，junit等等报告模式，只需要你在run的时候添加-f参数-o参数就可以了。</span><br><span class=\"line\"></span><br><span class=\"line\">　　例如 calabash-android run xxxx.apk -f html -o l，上图展示一下强大html报告  </span><br><span class=\"line\">　　![image](http://img.educity.cn/img_7/262/2013122000/127005907.jpg)</span><br><span class=\"line\"></span><br><span class=\"line\">[【cucumber解析features文件】](http://blog.csdn.net/qs_csu/article/details/9000262) \t\t</span><br><span class=\"line\">1. my_first.feature: 描述在这个条件下需要做什么事情；</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFeature: Running a test  </span><br><span class=\"line\">\t\t  As an iOS developer  </span><br><span class=\"line\">\t\t  I want to have a sample feature file  </span><br><span class=\"line\">\t\t  So I can begin testing quickly  </span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\tScenario: Example steps1  </span><br><span class=\"line\">\t\t  Given I am on the Welcome Screen  </span><br><span class=\"line\">\t\t  Then I swipe left  </span><br><span class=\"line\">\t\t  And I wait until I don&apos;t see &quot;Please swipe left&quot;  </span><br><span class=\"line\">\t\t  And take picture  </span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\tScenario: Example steps2  </span><br><span class=\"line\">\t\t  Given I am on the Welcome Screen  </span><br><span class=\"line\">\t\t #ASSERTION  </span><br><span class=\"line\">\t\t  Then I should see a &quot;login&quot; button  </span><br><span class=\"line\">\t\t #INPUT TEXT  </span><br><span class=\"line\">\t\t  Then I enter &quot;my_username&quot; into text field number 1  </span><br><span class=\"line\">\t\t#  Then I touch &quot;Return&quot;  </span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\t #TOGGLE SWITCH  </span><br><span class=\"line\">\t\t  Then I toggle the switch  </span><br><span class=\"line\">\t\t  Then I touch &quot;Login&quot;  </span><br><span class=\"line\">\t\t  And I touch &quot;Second&quot;  </span><br><span class=\"line\">\t\t  And take picture  </span><br><span class=\"line\">\t该文件描述了在“on the Welcome Screen”这个Step中需要做的事情，两个场景:steps1 和 steps2. </span><br><span class=\"line\"></span><br><span class=\"line\">2. my_first_step.rb: 解释了Given的具体条件</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tGiven /^I am on the Welcome Screen$/ do  </span><br><span class=\"line\">\t\t  element_exists(&quot;view&quot;)  </span><br><span class=\"line\">\t\t  check_element_exists(&quot;label text:&apos;First View&apos;&quot;)  </span><br><span class=\"line\">\t\t  sleep(STEP_PSEAU)  </span><br><span class=\"line\">\t\tend</span><br><span class=\"line\">\t这个语句，判定了当前条件&quot;on the Welcome Screen&quot;是否满足，如果element存在，则就在&quot;Welcome Screen&quot;</span><br><span class=\"line\">\t</span><br><span class=\"line\">[更多的测试框架](http://www.infoq.com/cn/articles/build-ios-continuous-integration-platform-part2)</span><br><span class=\"line\"></span><br><span class=\"line\">UIAutomation</span><br><span class=\"line\"></span><br><span class=\"line\">UIAutomation是随着iOS SDK 4.0引入，帮助开发者在真实设备和模拟器上执行自动化的UI测试。其本质上是一个Javascript的类库，通过 界面上的标签和值的访问性来获得UI元素，完成相应的交互操作，从而达到测试的目的，类似于Web世界的Selenium。</span><br><span class=\"line\"></span><br><span class=\"line\">通过上面的描述，可以得知，使用UIAutomation做测试时，开发者必须掌握两件事：</span><br><span class=\"line\"></span><br><span class=\"line\">- 如何找到界面上的一个UI元素</span><br><span class=\"line\">- 如何指定针对一个UI元素的操作</span><br><span class=\"line\"></span><br><span class=\"line\">在UIAutomation中，界面就是由一堆UI元素构建的层级结构，所有UI元素都继承对象UIAElement ，该对象提供了每个UI元素必须具备的一些属性：</span><br><span class=\"line\"></span><br><span class=\"line\">- name</span><br><span class=\"line\">- value</span><br><span class=\"line\">- elements</span><br><span class=\"line\">- parent</span><br><span class=\"line\">- …</span><br><span class=\"line\"></span><br><span class=\"line\">而整个界面的层级结构如下：</span><br><span class=\"line\"></span><br><span class=\"line\">\target（设备级别的UI，用于支持晃动，屏幕方向变动等操作）</span><br><span class=\"line\">\t    Application（设备上的应用，比方说Status Bar，keyboard等）</span><br><span class=\"line\">\t      Main window（应用的界面，比方说导航条）</span><br><span class=\"line\">\t        View（界面下的View，比方说UITableView）</span><br><span class=\"line\">\t           Element（View下的一个元素）</span><br><span class=\"line\">\t              Child element(元素下的一个子元素)</span><br><span class=\"line\">下面是一个访问到Child element的例子：</span><br><span class=\"line\"></span><br><span class=\"line\">\tUIATarget.localTarget().HamcrestDemo().tableViews()[0].cells()[0].elements()</span><br><span class=\"line\">开发者还可以通过“UIATarget.localTarget().logElementTree()”在控制台打印出该target下所有的的elements。</span><br><span class=\"line\"></span><br><span class=\"line\">找到UI元素之后，开发者可以基于该UI元素做期望的操作，UIAutomation作为原生的UI测试框架，基本上支持iOS上的所有UI元素和操作，比方说：</span><br><span class=\"line\"></span><br><span class=\"line\">- 点击按钮，例: ***.buttons[“add”].tap()</span><br><span class=\"line\">- 输入文本, 例:***.textfields[0].setValue(“new”)</span><br><span class=\"line\">- 滚动屏幕，例:***.scrollToElementWithPredicate(“name begin with ’test’”)</span><br><span class=\"line\">- ……</span><br><span class=\"line\">关于使用UIAutomation做UI测试，推荐大家一定要看一下2010的WWDC的Session 306：[Automating User Interface Testing with Instruments](https://developer.apple.com/videos/wwdc/2010/?id=306)。 另外，这儿还有一篇很好的博客，详细的讲解了[如何使用UIAutomation做UI自动化测试](http://blog.manbolo.com/2012/04/08/ios-automated-tests-with-uiautomation)  </span><br><span class=\"line\">Apple通过Instruments为UIAutomation测试用例的命令行运行提供了支持，这样就为UIAutomation和CI服务器的集成提供了便利。开发者可以通过如下的步骤在命令行中运行UIAutomation测试脚本:</span><br><span class=\"line\">1. 指定目标设备，构建被测应用，该应用会被安装到指定的DSTROOT目录下</span><br><span class=\"line\">```ruby</span><br><span class=\"line\">xcodebuild</span><br><span class=\"line\">-project &quot;/Users/twer/Documents/xcodeworkspace/AudioDemo/AudioDemo.xcodeproj&quot; </span><br><span class=\"line\">-schemeAudioDemo</span><br><span class=\"line\">-sdk iphonesimulator6.1 </span><br><span class=\"line\">-configuration Release SYMROOT=&quot;/Users/twer/Documents/xcodeworkspace/</span><br><span class=\"line\">AudioDemo/build&quot; DSTROOT=&quot;/Users/twer/Documents/xcodeworkspace/AudioDemo/</span><br><span class=\"line\">build&quot; TARGETED_DEVICE_FAMILY=&quot;1&quot; </span><br><span class=\"line\">install</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动Instruments，基于第一步生成的应用运行UIAutomation测试</p>\n<pre><code class=\"ruby\">instruments\n-t  <span class=\"string\">\"/Applications/Xcode.app/Contents/Applications/Instruments.app/</span>\n<span class=\"string\">Contents/PlugIns/AutomationInstrument.bundle/Contents/Resources/</span>\n<span class=\"string\">Automation.tracetemplate\"</span> <span class=\"string\">\"/Users/twer/Documents/xcodeworkspace/AudioDemo</span>\n<span class=\"string\">/build/Applications/TestExample.app\"</span>\n-e UIASCRIPT &lt;absolute_path_to_the_test_file&gt;\n</code></pre>\n<p>为了更好的展示测试效果以及与CI服务器集成，活跃的社区开发者们还尝试把UIAutomation和Jasmine集成: <a href=\"https://github.com/shaune/jasmine-ios-acceptance-tests\" target=\"_blank\" rel=\"noopener\">https://github.com/shaune/jasmine-ios-acceptance-tests</a></p>\n</li>\n</ol>\n<p>UIAutomation因其原生支持，并且通过和Instruments的绝佳配合，开发者可以非常方便的使用录制操作自动生成测试脚本，赢得了很多开发者的支持，但是因苹果公司的基因，其系统非常封闭，导致开发者难以扩展，于是活跃的社区开发者们开始制造自己的轮子，<a href=\"https://gorillalogic.com/fonemonkey-0-7-1-released/\" target=\"_blank\" rel=\"noopener\">Fone Monkey,最新版本更新于2010年，估计过时</a>就是其中的一个优秀成果。</p>\n","raw":null,"categories":[{"name":"工具","path":"api/categories/工具.json"},{"name":"集成","path":"api/categories/集成.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"测试","path":"api/tags/测试.json"}]},{"title":"使用SmartSVN创建版本库","slug":"git/使用SmartSVN创建版本库","date":"2015-10-05T19:16:47.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/使用SmartSVN创建版本库.json","excerpt":null,"keywords":null,"cover":"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/adeb039a-b429-481a-ac25-2044b871e45e/screenshot.png?resizeSmall&amp;width=832","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>SmartSVN有以下版本：</p>\n<ol>\n<li>SmartSVN enterprise 9 企业版</li>\n<li>SmartSVN foundation 8 基础版</li>\n</ol>\n<p>由于企业版只能建立本地的版本库，无法创建&amp;使用svn://localhost方式。</p>\n<h4 id=\"用基础版来说明创建版本库。\"><a href=\"#用基础版来说明创建版本库。\" class=\"headerlink\" title=\"用基础版来说明创建版本库。\"></a>用基础版来说明创建版本库。</h4><p>参考：<a href=\"http://hammadk.com/how-to-create-repository-in-smartsvn-tutorial/\" target=\"_blank\" rel=\"noopener\">Create Repository in SmartSVN – Tutorial</a>  </p>\n<ol>\n<li>启动SmartSVN SmartSVN foundation 8 基础版  </li>\n<li>菜单栏Project-&gt; set up Local Repository…<br>需要设置如下两个参数：  <ol>\n<li>svnadmin 在终端执行： whereis svnadmin  </li>\n<li>svnserve 在终端执行： whereis svnserve<br>￼<img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/adeb039a-b429-481a-ac25-2044b871e45e/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\">  </li>\n</ol>\n</li>\n<li>指定版本库的目录位置：<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/a3f00903-101c-4848-a10a-3479643baea7/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\">  </li>\n<li>初始化账户密码：<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/140f257e-e452-47ea-8317-34a5ed8d6c7f/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\">  </li>\n<li>完成。<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/ed975623-72bb-4132-8d04-ac9a7b1d2fc9/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\"><br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/53306789-9d97-485c-a54d-a143e7b078f1/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\"><a id=\"more\"></a>    \n<h5 id=\"开始导入项目源码，来跟踪版本变化，实现版本控制。\"><a href=\"#开始导入项目源码，来跟踪版本变化，实现版本控制。\" class=\"headerlink\" title=\"开始导入项目源码，来跟踪版本变化，实现版本控制。\"></a>开始导入项目源码，来跟踪版本变化，实现版本控制。</h5></li>\n<li>新建SmartSVNRepos目录，存放APP源码，用于导入版本库的原始目录。导入后，该目录源码就被版本跟踪了，在开发时，不用再从版本库导出，可以用该目录的代码直接在版本上开发了。<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/ee02bf65-27e3-435a-8300-8189bc087eb8/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\"></li>\n<li>菜单栏Project -&gt; Import Into Repository…<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/eccc10f0-4c5a-435c-8397-062028d0d4f4.png?resizeSmall&amp;width=832\" alt=\"image\"></li>\n<li>选择以上新建的SmartSVN版本库：svn://localhost<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/ecfe16b4-17ac-4fc1-a64f-1ce259d77b3b/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\"> </li>\n</ol>\n<p>查看是否安装SVN服务：</p>\n<pre><code>svnserve —version\n</code></pre><p>SVN随系统一起启动：</p>\n<pre><code>vi /etc/rc.local   //(此文件Mac系统中默认是不存在的，需手动创建)\n\n添加启动SVN服务： \nsvnserve -d -r /data/svn/repos  \n</code></pre><p>关闭svn服务:</p>\n<pre><code>直接ps aux | grep svn，然后kill -9 进程号\n</code></pre><ol>\n<li><p>创建库:<br> 打印应用目录命令：</p>\n<pre><code>whereis svn\n</code></pre><p> 新建版本库目录：</p>\n<pre><code>sudo mkdir -p /data/svn/repos/local    \nchmod u+w 文件名\n</code></pre><p> 创建：</p>\n<pre><code>sudo svnadmin create /data/svn/repos/local\n查看文件权限： ls -l\n</code></pre></li>\n<li><p>配置版本库的访问权限</p>\n<pre><code>cd conf/ \n</code></pre><ol>\n<li><p>开启密码权限，普通用户/匿名用户</p>\n<pre><code>sudo vi svnserve.conf\n</code></pre></li>\n<li><p>设置用户：密码</p>\n<pre><code>sudo vi passwd\n</code></pre></li>\n<li><p>分组设置，组权限</p>\n<pre><code>sudo vi authz\n</code></pre></li>\n</ol>\n</li>\n<li><p>启动svnserve服务  </p>\n<pre><code>sudo svnserve -d -r /data/svn/repos —log-file=/var/log/svn.log\n</code></pre></li>\n<li><p>测试端口：</p>\n<pre><code>telnet localhost 3690\n</code></pre></li>\n<li><p>重启必先kill ：</p>\n<pre><code>sudo kill PID\n</code></pre></li>\n<li><p>版本库路径：</p>\n<pre><code>svn://localhost/local\n</code></pre><p>其他：</p>\n<pre><code>svn ls svn://svnpath 可以查询snv仓库内容  \nlsof -i :3690 查看svn是否启动  \nps aux | grep ‘svn’ 查找所有svn启动的进程id  \nkill -9 pid 将pid替换为上面查到的进程id可以杀掉svn进程  \n</code></pre></li>\n</ol>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"svn","path":"api/categories/svn.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"svn","path":"api/tags/svn.json"}]},{"title":"[转]Swift最佳实践","slug":"swift/[转]Swift最佳实践","date":"2015-09-29T17:05:21.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/swift/[转]Swift最佳实践.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>[英文][SwiftCommunityBestPractices]<br>[SwiftCommunityBestPractices]: <a href=\"https://github.com/schwa/Swift-Community-Best-Practices\" target=\"_blank\" rel=\"noopener\">https://github.com/schwa/Swift-Community-Best-Practices</a><br>[SwiftCommunity]: <a href=\"http://swift-lang.schwa.io/\" target=\"_blank\" rel=\"noopener\">http://swift-lang.schwa.io/</a><br>[swiftCaptureLists]: <a href=\"http://www.russbishop.net/swift-capture-lists\" target=\"_blank\" rel=\"noopener\">http://www.russbishop.net/swift-capture-lists</a><br>[SwiftURL]: <a href=\"https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html</a><br>[驼峰命名法URL]: <a href=\"http://www.wikiwand.com/en/Studly_caps\" target=\"_blank\" rel=\"noopener\">http://www.wikiwand.com/en/Studly_caps</a><br>[匈牙利命名法URL]: <a href=\"http://www.wikiwand.com/en/Hungarian_notation\" target=\"_blank\" rel=\"noopener\">http://www.wikiwand.com/en/Hungarian_notation</a></p>\n<h2 id=\"黄金法则\"><a href=\"#黄金法则\" class=\"headerlink\" title=\"黄金法则\"></a>黄金法则</h2><ul>\n<li>Apple 通常是对的。应紧随苹果所推荐的或他的 Demo 中所展示的方式。您应该尽可能地遵守 Apple 在 [The Swift Programming Language][SwiftURL] 一书中所定义的代码风格。但我们还是可以看到他们的示例代码中有不符合这些规则的地方，毕竟 Apple 是一家大公司嘛。</li>\n<li>不要仅仅为了减少字符的键入数量而使用模棱两可的简短命名，较长的命名都可以依赖自动完成、自我暗示、复制粘贴来减低键入的难度。命名的详细程度往往对代码维护者很有帮助。但过于冗长的命名却会绕过Swift的主要特性之一: 类型推导,所以命名的原则应该是简洁明了。</li>\n</ul>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><h3 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a>命名</h3><p>按照 [The Swift Programming Language][SwiftURL] 所推荐的命名法则，类型名称应该使用[首字母大写的驼峰命名法][uppercamelcaseURL] (例如: “VehicleController”)。</p>\n<p>变量与常量应该使用首字母小写的驼峰命名法(例如: “ vehicleName “ )。</p>\n<p>推荐使用 Swift 模块来定义代码的命名空间，而非在 Swift 代码上使用 Objective-C 样式的类前缀(除非接口要与 Objective-C 交互)。</p>\n<p>不推荐使用任何形式的[匈牙利命名法][匈牙利命名法URL]（比如：k 代表常量，m 代表方法）,取代代之我们应该使用短而简洁的名字并使用 Xcode 的类型快速帮助 (⌥ + 左击)。同样我们也不要使用类似 <code>SNAKE_CASE</code> 这样的名字。</p>\n<p>这些法则之上，唯一例外的情况就是枚举值了，枚举值在这里应该首字母大写(这是 Apple 的 [The Swift Programming Language][SwiftURL] 中的规范)：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Planet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"type\">Mercury</span>, <span class=\"type\">Venus</span>, <span class=\"type\">Earth</span>, <span class=\"type\">Mars</span>, <span class=\"type\">Jupiter</span>, <span class=\"type\">Saturn</span>, <span class=\"type\">Uranus</span>, <span class=\"type\">Nepture</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>有必要的话命名不要缩写<br>实际上在 Xcode 的”文本自动补全”功能下你可以轻而易举地键入 类似 <code>ViewController</code> 的长命名。</li>\n<li>极为常见的缩写<br>例如: <code>URL</code> 缩写应该是全部大写 ( “URL” )或者酌情全部小写( “url” )。<blockquote>\n<p>URL 的类型和变量命名推荐的规则： 如果 url 是一个类型，它应该被大写，如果是一个变量，那么应该小写。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>不应该使用注释来禁用代码,被注释掉的代码会污染你的源代码。<br>如果你当前想要删除一段代码，但将来又可能会用到，推荐你依赖 git 或你的 bug 追踪系统来管理。</p>\n<p>(TODO: 追加一个关于文档注释的小节，使用 nshipster 的链接)</p>\n<h3 id=\"类型推导\"><a href=\"#类型推导\" class=\"headerlink\" title=\"类型推导\"></a>类型推导</h3><p>如果可能的话，使用 Swift 的类型推导，以避免冗余的类型信息。例如：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> currentLocation = <span class=\"type\">Location</span>()</span><br></pre></td></tr></table></figure></p>\n<p>而非：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> currentLocation: <span class=\"type\">Location</span> = <span class=\"type\">Location</span>()</span><br></pre></td></tr></table></figure>\n<h3 id=\"内省\"><a href=\"#内省\" class=\"headerlink\" title=\"内省\"></a>内省</h3><p>让编译器自动推断所有的情况，这是可以做到的。在一些领域 <code>self</code> 应该被显式地使用，包括在 init 中设置参数，或者 <code>non-escaping</code>闭包。<br>例如：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Example</span></span>&#123;</span><br><span class=\"line\"> \t  <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">\t   <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\"> \t      <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\"> \t  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"捕获列表的类型推导\"><a href=\"#捕获列表的类型推导\" class=\"headerlink\" title=\"捕获列表的类型推导\"></a>捕获列表的类型推导</h3><p>在一个捕获列表( capture list )中指定参数类型会导致代码冗余。如果需要的话，仅指定类型即可。  </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> people = [</span><br><span class=\"line\">    (<span class=\"string\">\"Mary\"</span>, <span class=\"number\">42</span>),</span><br><span class=\"line\">    (<span class=\"string\">\"Susan\"</span>, <span class=\"number\">27</span>),</span><br><span class=\"line\">    (<span class=\"string\">\"Charlie\"</span>, <span class=\"number\">18</span>),</span><br><span class=\"line\">]\t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = people.<span class=\"built_in\">map</span>() &#123;</span><br><span class=\"line\">    (name: <span class=\"type\">String</span>, age: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">String</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"\\(name) is \\(age) years old\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果编译器可以推导出来的话，完全可以把类型删掉：<br><code>(name: String, age: Int) -&gt; String</code><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> strings = people.<span class=\"built_in\">map</span>() &#123;</span><br><span class=\"line\">    (name, age) <span class=\"keyword\">in</span> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"\\(name) is \\(age) years old\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用编号的参数名 (“$0”) 进一步降低冗长，往往能彻底消除捕获列表的代码冗余。在闭包中当参数名没有附带任何更多信息时仅使用编号形式即可( 如非常简单的映射和过滤器 )。</p>\n<p>Apple 能够并且将会改变闭包的参数类型，通过他们的 Objective-C 框架的 Swift 变种提供出来。<br>例如，<code>optionals</code> 被删除或更改为 <code>auto-unwrapping</code> 等。故意 under-specifying 可选并依赖 Swift 来推导类型，可以减少在这些情况下代码被破译的风险。</p>\n<p>你应该避免指定返回类型，例如这个捕获列表( capture list )就是完全多余的:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    ()-&gt;<span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Fired.\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>(以上内容也可以参考:[这里][swiftCaptureLists])</p>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>类型定义中使用的常量应当被申明成静态类型。例如:<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PhysicsModel</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> speedOfLightInAVacuum = <span class=\"number\">299_792_458</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Spaceship</span> </span>&#123;</span><br><span class=\"line\">  \t\t <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> topSpeed = <span class=\"type\">PhysicsModel</span>.speedOfLightInAVacuum</span><br><span class=\"line\"> \t     <span class=\"keyword\">var</span> speed: <span class=\"type\">Double</span></span><br><span class=\"line\">  \t\t <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fullSpeedAhead</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      \t\t speed = <span class=\"type\">Spaceship</span>.topSpeed</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>将常量标示为 <code>static</code> ，允许它们可以被无类型的实例引用。</p>\n<p>一般应该避免生成全局范围的常量，单例除外。</p>\n","raw":null,"categories":[{"name":"swift","path":"api/categories/swift.json"},{"name":"语法","path":"api/categories/语法.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"}]},{"title":"Mac安装gitLab服务器","slug":"git/Mac安装gitLab服务器","date":"2015-09-27T19:25:38.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/Mac安装gitLab服务器.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"必要配置\"><a href=\"#必要配置\" class=\"headerlink\" title=\"必要配置\"></a>必要配置</h4><pre><code>*创建一个名称为&quot;gitlab&quot;管理员用户，然后再创建一个名称为&quot;gitlab&quot;的群组\n*开启gitlab用户的远程登录\n</code></pre><p>在系统启动界面:<br>隐藏gitlab用户 </p>\n<pre><code>sudo defaults write /Library/Preferences/com.apple.loginwindow HiddenUsersList -array-add gitlab\n</code></pre><p>显示git用户</p>\n<pre><code>sudo defaults delete /Library/Preferences/com.apple.loginwindow HiddenUsersList\n</code></pre><h4 id=\"添加系统账户gitlab\"><a href=\"#添加系统账户gitlab\" class=\"headerlink\" title=\"添加系统账户gitlab\"></a>添加系统账户gitlab</h4><h6 id=\"生成gitlab服务器目录，即用户根目录\"><a href=\"#生成gitlab服务器目录，即用户根目录\" class=\"headerlink\" title=\"生成gitlab服务器目录，即用户根目录\"></a>生成gitlab服务器目录，即用户根目录</h6><p>进入<strong>系统偏好设置…</strong>,在管理<strong>用户与群组</strong>中，添加其他用户，暂时定为：gitlab ，登录密码假设为：gitlab，添加完成后，会自动在/Users目录下，生成用户根目录gitlab.</p>\n<h6 id=\"安装-Gitlab-Shell\"><a href=\"#安装-Gitlab-Shell\" class=\"headerlink\" title=\"安装 Gitlab Shell\"></a>安装 Gitlab Shell</h6><pre><code>cd /Users/gitlab\nsudo -u gitlab git clone https://github.com/gitlabhq/gitlab-shell.git\ncd gitlab-shell\nsudo -u gitlab git checkout v1.9.1\nsudo -u gitlab cp config.yml.example config.yml\n</code></pre><p>打开 config.yml,然后进行编辑<br>设置  gitlab_url. 把 gitlab.example.com 替换成你自己的域名 （如果本地就不用了）<br>把所有的/home 替换成 /Users</p>\n<pre><code>sudo -u gitlab sed -i &quot;&quot; &quot;s/\\/home\\//\\/Users\\//g&quot; config.yml\nsudo -u gitlab sed -i &quot;&quot; &quot;s/\\/usr\\/bin\\/redis-cli/\\/usr\\/local\\/bin\\/redis-cli/&quot; config.yml\n</code></pre><p>然后执行安装脚本：<code>sudo -u gitlab -H ./bin/install</code>  <strong>//需在gitlab-shell目录下载执行</strong></p>\n<h6 id=\"安装gitlab\"><a href=\"#安装gitlab\" class=\"headerlink\" title=\"安装gitlab\"></a>安装gitlab</h6><p>先下载gitlab</p>\n<pre><code>cd /Users/gitlab\nsudo -u gitlab git clone https://github.com/gitlabhq/gitlabhq.git\ncd gitlab\nsudo -u gitlab git checkout 6-7-stable\n</code></pre><p>配置gitlab</p>\n<pre><code>sudo -u gitlab cp config/gitlab.yml.example config/gitlab.yml\nsudo -u gitlab sed -i &quot;&quot; &quot;s/\\/usr\\/bin\\/git/\\/usr\\/local\\/bin\\/git/g&quot; config/gitlab.yml\nsudo -u gitlab sed -i &quot;&quot; &quot;s/\\/home/\\/Users/g&quot; config/gitlab.yml\nsudo -u gitlab sed -i &quot;&quot; &quot;s/localhost/domain.com/g&quot; config/gitlab.yml\n</code></pre><p>配置MySQL数据库，创建gitlab用户，数据库，和gitlab用户的管理权限</p>\n<pre><code># Login to MySQL\n$ mysql -u root -p\n\n# Create the GitLab production database\nmysql&gt; CREATE DATABASE IF NOT EXISTS `gitlabhq_production` DEFAULT CHARACTER SET `utf8` COLLATE `utf8_unicode_ci`;\n\n# Create the MySQL User change $password to a real password\nmysql&gt; CREATE USER &apos;gitlab&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;$password&apos;;\n\n# Grant proper permissions to the MySQL User\nmysql&gt; GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER ON `gitlabhq_production`.* TO &apos;gitlab&apos;@&apos;localhost&apos;;\n</code></pre><h6 id=\"安装-Gitolite帮助管理git内部用户\"><a href=\"#安装-Gitolite帮助管理git内部用户\" class=\"headerlink\" title=\"安装 Gitolite帮助管理git内部用户\"></a>安装 Gitolite帮助管理git内部用户</h6><p>克隆gitlab的gitolite分支源代码：</p>\n<pre><code>sudo -H -u gitlab git clone -b gl-v304 https://github.com/gitlabhq/gitolite.git /Users/gitlab/gitolite\n</code></pre><p>安装：</p>\n<pre><code>cd /Users/gitlab\nsudo -u gitlab -H mkdir bin\nsudo -u gitlab sh -c &apos;echo -e &quot;PATH=\\$PATH:/Users/gitlab/bin\\nexport PATH&quot; &gt;&gt; /Users/gitlab/.profile&apos;\nsudo -u gitlab sh -c &apos;gitolite/install -ln /Users/gitlab/bin&apos;\n\nsudo cp ~/.ssh/id_rsa.pub /Users/gitlab/gitlab.pub\nsudo chmod 0444 /Users/gitlab/gitlab.pub\n\nsudo -u gitlab -H sh -c &quot;PATH=/Users/gitlab/bin:$PATH; gitolite setup -pk /Users/gitlab/gitlab.pub&quot;\n</code></pre><p>为 Git 创建用户：    </p>\n<pre><code>sudo adduser \\\n  --system \\\n  --shell /bin/sh \\\n  --gecos &apos;git version control&apos; \\\n  --group \\\n  --disabled-password \\\n  --home /home/git \\\n  git\n</code></pre><p>若干问题解决办法：<a href=\"http://www.cnblogs.com/whj198579/archive/2013/04/09/3009350.html\" target=\"_blank\" rel=\"noopener\">Mac搭建Git服务器—开启SSH</a></p>\n<pre><code>Cloning into &apos;/tmp/gitolite-admin&apos;...\nssh: connect to host localhost port 22: Connection refused\nfatal: Could not read from remote repository.\n</code></pre><p>SSH无密码登陆设置：</p>\n<pre><code>$ cd /etc\n$ chmod 666 sshd_config\n$ vim sshd_config\n\n#PermitRootLogin yes  改为：PermitRootLogin no\n#UsePAM yes             改为: UsePAM no\n</code></pre><p>Remove the # from the following</p>\n<pre><code>#RSAAuthentication yes\n#PubkeyAuthentication yes\n#AuthorizedKeysFile     .ssh/authorized_keys    \n#PasswordAuthentication no\n#PermitEmptyPasswords no\n</code></pre>","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"gitLab","path":"api/categories/gitLab.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"git","path":"api/tags/git.json"},{"name":"gitLab","path":"api/tags/gitLab.json"}]},{"title":"小米路由常用操作","slug":"小米路由常用操作","date":"2015-09-25T23:59:16.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/小米路由常用操作.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h4><ol>\n<li><p>ssh登录</p>\n<pre><code>局域网登录:\nssh [user@]hostname [command]\n 例如：ssh root@192.168.31.1  或  远程登录：ssh root@222.35.145.28 -p 2195\n回车\n输入密码\n\n**修改密码：**\nroot@xiaoqiang:~#passwd   \n回车\n输入新密码\n回车\n再次输入新密码\n</code></pre></li>\n<li><p>远程拷贝数据</p>\n<pre><code>scp Desktop/ar71xx/* root@192.168.31.1:/userdisk/myWorkspace/ar71xx\n</code></pre></li>\n<li><p>每次重启路由获取IP:</p>\n<pre><code>vi /etc/rc.local\nsh /etc/getIP.sh\n</code></pre><p>//启动后，等待20秒，然后，获取当前时间作为文件名称<br>//使用ifconfig 获取路由器的ip信息<br>//使用 | grep 通道，和grep正则来过滤出，wan口的ip所在行<br>// &gt; 使用重定向，将过滤的ip行，写入路由硬盘/userdisk/data/my/ip目录中<br>//通过小米路由手机客户端，找到该txt文件，并下载到手机sd卡中<br>//查看该文件，既有路由重启后的当前IP  </p>\n<a id=\"more\"></a>\n<p> 详见getIP.sh</p>\n<pre><code>#!/bin/sh\nsleep 20\ncurrent_date=`date +%Y_%m_%d`\ncurrent_time=`date +%H_%M_%S`\necho $current_date\necho $current_time\n#local_ip=`ifconfig |grep &apos;[0-9]\\{1,3\\}.*P-t-P&apos;`\nlocal_ip=`ifconfig | grep P-t-P`\necho $local_ip &gt; /userdisk/data/my/ip/$current_date:$current_time.txt\n</code></pre></li>\n<li><p>修改防火墙设置<strong>/etc/config</strong>目录下的<strong>dropbear</strong>和<strong>firewall</strong>  </p>\n<pre><code>cd /etc/config  //把备份文件内容覆盖新文件即可\n1.cat dropbear.bak &gt; dropbear  \n    增加如下内容：\n    config dropbear\n    option PasswordAuth &apos;on&apos;\n    option RootPasswordAuth &apos;on&apos;\n    option Interface &apos;wan&apos;\n    option Port &apos;2195&apos;\n2.保存文件修改后，再重启dropbear服务，一次输入下面两行命令：\n    /etc/init.d/dropbear reload\n    /etc/init.d/dropbear restart\n1.cat firewall.bak &gt; firewall\n    增加如下内容： \n    config rule\n    option name &apos;Allow-wan-ssh&apos;\n    option src &apos;wan&apos;\n    option proto &apos;tcp&apos;\n    option dest_port &apos;2195&apos;\n    option target &apos;ACCEPT&apos;\n2.保存文档的更改后，重启防火墙服务，依次输入以下两条命令：\n    /etc/init.d/firewall reload\n    /etc/init.d/firewall restart\n</code></pre></li>\n</ol>\n<p>5.由于铁通机制，分配的独立iP，并不能被外网访问</p>\n<h4 id=\"ssh登录数据库-转\"><a href=\"#ssh登录数据库-转\" class=\"headerlink\" title=\"ssh登录数据库    转\"></a>ssh登录数据库    <a href=\"http://bbs.xiaomi.cn/thread-10339070-1-1.html\" target=\"_blank\" rel=\"noopener\">转</a></h4><p>先确保能访问<a href=\"http://192.168.31.1:8088/phpinfo.php\" target=\"_blank\" rel=\"noopener\">LLMP搭建的个人网站地址</a>  </p>\n<p>修复教程：  </p>\n<ol>\n<li>登录路由： <code>ssh root@192.168.31.1</code>  mm:admin</li>\n<li>执行命令：<code>/userdisk/data/lamp.sh fix</code>  </li>\n<li><p>再次访问个人网站地址。  <a href=\"http://192.168.31.1:8088/phpinfo.php\" target=\"_blank\" rel=\"noopener\">LLMP搭建的个人网站地址</a> 。 </p>\n<pre><code>1./userdisk/data/lamp.sh  (安装本插件，一键开启llmp，具体安装过程可见前面的安装步骤）       \n2./userdisk/data/lamp.sh a（卸载本插件，恢复安装前，注：卸载本插件时路由器会自动重启一次，自动断网几分钟）\n3./userdisk/data/lamp.sh fix（升级小米路由器固件后，能瞬间恢复自己搭建的网站功能，另外，如果在极特殊的情况的情况下，本功能无效，可使用如下方法恢复自建网站的功能：先尝试重新安装本插件，如果提示不能重复安装，可先卸载本插件，再重新安装本插件，并按说明3对数据库执行修改密码命令，改回原来的密码，原来自己搭建网站就可恢复使用）\n4./userdisk/data/lamp.sh help  (插件用法的帮助信息）\n</code></pre></li>\n</ol>\n<p>登录数据库：<code>ssh mysql@192.168.31.1 -p 2222</code></p>\n<p>正确日志：</p>\n<pre><code>AdmindeMacBook-Air:~ admin$ ssh mysql@192.168.31.1 -p 2222\nThe authenticity of host &apos;[192.168.31.1]:2222 ([192.168.31.1]:2222)&apos; can&apos;t be established.\nRSA key fingerprint is SHA256:bLH9smUb7sD9CZLWCsT6t9YqPy2jciznepkscFNd59M.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added &apos;[192.168.31.1]:2222&apos; (RSA) to the list of known hosts.\nmysql@192.168.31.1&apos;s password:admin\n\nBusyBox v1.19.4 (2015-05-08 18:41:26 CST) built-in shell (ash)\nEnter &apos;help&apos; for a list of built-in commands.\n\n    ~ $\n</code></pre><p>错误日志：<br>需要修改本地的ssh配置。</p>\n<ol>\n<li>vi /Users/admin/.ssh/known_hosts文件</li>\n<li>删除包含[192.168.31.1]:2222的一行内容。</li>\n<li><p>重新登录数据库：ssh mysql@192.168.31.1 -p 2222。  </p>\n<pre><code>AdmindeMacBook-Air:~ admin$ ssh mysql@192.168.31.1 -p 2222\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nSHA256:bLH9smUb7sD9CZLWCsT6t9YqPy2jciznepkscFNd59M.\nPlease contact your system administrator.\nAdd correct host key in /Users/admin/.ssh/known_hosts to get rid of this message.\nOffending RSA key in /Users/admin/.ssh/known_hosts:10\nRSA host key for [192.168.31.1]:2222 has changed and you have requested strict checking.\nHost key verification failed.\n</code></pre></li>\n</ol>\n<h5 id=\"客户端MySQLWorkbench无法连接LLMP个人网站的MySql数据库\"><a href=\"#客户端MySQLWorkbench无法连接LLMP个人网站的MySql数据库\" class=\"headerlink\" title=\"客户端MySQLWorkbench无法连接LLMP个人网站的MySql数据库\"></a>客户端MySQLWorkbench无法连接LLMP个人网站的MySql数据库</h5>","raw":null,"categories":[{"name":"shell","path":"api/categories/shell.json"},{"name":"路由器","path":"api/categories/路由器.json"}],"tags":[{"name":"小米路由","path":"api/tags/小米路由.json"},{"name":"SSH","path":"api/tags/SSH.json"},{"name":"协议","path":"api/tags/协议.json"}]},{"title":"Xcode7编译发布问题","slug":"编译/Xcode7编译发布问题","date":"2015-09-25T15:58:17.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/编译/Xcode7编译发布问题.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"Xcode7编译发布问题\"><a href=\"#Xcode7编译发布问题\" class=\"headerlink\" title=\"Xcode7编译发布问题\"></a>Xcode7编译发布问题</h4><ol>\n<li><p>ERROR ITMS-90535: “Unexpected CFBundleExecutable Key. The bundle at ‘Payload/PBBReader.app/TencentOpenApi_IOS_Bundle.bundle’ does not contain a bundle executable. If this bundle intentionally does not contain an executable, consider removing the CFBundleExecutable key from its Info.plist and using a CFBundlePackageType of BNDL. If this bundle is part of a third-party framework, consider contacting the developer of the framework for an update to address this issue.”</p>\n<p> 解决办法：搜索CFBundleExecutable 字段，删除所有第三方框架中的info.plist文件中包含的字段，重新打包上传。</p>\n</li>\n</ol>\n<ol>\n<li>ERROR ITMS-90475: “Invalid Bundle. iPad Multitasking support requires launch story board in bundle ‘pyc.com.cn.pbbReader’.”\f</li>\n<li><p>苹果邮件：We have discovered one or more issues with your recent delivery for “PBB Reader”. To process your delivery, the following issues must be corrected:<br>Invalid Bundle - A nested bundle doesn’t have the right platforms listed in CFBundleSupportedPlatforms Info.plist key.</p>\n</li>\n<li><p>IOS9访问网络设置：<strong>NSAppTransportSecurity</strong> 字典，字段：<strong>NSAllowsArbitraryLoads</strong>  字段值：<strong>YES</strong></p>\n</li>\n<li>搜索Target对应的build setting中，把<strong>bitCode</strong>支持设置为NO</li>\n<li><a href=\"http://onevcat.com/2015/06/multitasking/\" target=\"_blank\" rel=\"noopener\">iPad 中的多任务适配</a><br>如果你不想你的 app 可以作为多任务的副 app 被使用的话，你可以在 Info.plist 中添加 <strong>UIRequiresFullScreen</strong> 并将其设为 <strong>YES</strong></li>\n<li>对第三方SDK后台运行，有严格的把控，要求bundle资源必须为最新有效，上传包时必要条件</li>\n</ol>\n<h3 id=\"解决办法：\"><a href=\"#解决办法：\" class=\"headerlink\" title=\"解决办法：\"></a>解决办法：</h3><p>退回Xcode6.4,进行打包发布</p>\n<h4 id=\"Cannot-proceed-with-delivery-an-existing-transporter-instance-is-currently-uploading-this-package\"><a href=\"#Cannot-proceed-with-delivery-an-existing-transporter-instance-is-currently-uploading-this-package\" class=\"headerlink\" title=\"Cannot proceed with delivery: an existing transporter instance is currently uploading this package\"></a>Cannot proceed with delivery: an existing transporter instance is currently uploading this package</h4><p>把Application Loader(XCode-&gt;Organizer-&gt;Archived Applications-&gt;Submit)中正在上传的文件中断或者删除，再次Submit提示：<br>Cannot proceed with delivery: an existing transporter instance is currently uploading this package。<br>无论如何Clean All、重新Submit都失败，给出上述提示。<br>原因：上传的动作被记录在UploadToken中了。<br>解决方法：<br>（1）打开终端，输入cd，到达个人用户目录下。<br>（2）输入ls -a，可以看到一个隐藏的目录 .itmstransporter<br>（3）cd .itmstransporter/UploadTokens<br>（4）ls ，可以看到一个类似 xxxxx.local_itunesConnectUSERxxxxxx.itmsp.token文件<br>（5）nano  xxxxx.local_itunesConnectUSERxxxxxx.itmsp.token，在里面把内容都删除，保存。<br>（6）重新在Organizer里面submit，ok了  </p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"编译","path":"api/categories/编译.json"}],"tags":[]},{"title":"Xcode&amp;Jenkins持续集成的几种实现方式","slug":"工具/Xcode和Jenkins持续集成的几种实现方式","date":"2015-09-18T23:52:06.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/工具/Xcode和Jenkins持续集成的几种实现方式.json","excerpt":null,"keywords":null,"cover":"http://img.educity.cn/img_7/262/2013122000/125005907.jpg","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"CI服务器\"><a href=\"#CI服务器\" class=\"headerlink\" title=\"CI服务器\"></a>CI服务器</h2><p>写到这儿，对于iOS开发者来说，需要准备好：</p>\n<ul>\n<li>一个比较容易获取的源代码仓库(包含源代码)</li>\n<li>一套自动化构建脚本</li>\n<li>一系列围绕构建的可执行测试  </li>\n</ul>\n<p>接下来就需要一个CI服务器来根据源代码的变更触发构建，监控测试结果。</p>\n<p>目前，业界比较流行的，支持iOS构建的CI服务器有</p>\n<ul>\n<li><a href=\"https://travis-ci.org\" target=\"_blank\" rel=\"noopener\">Travis CI</a>：是一个免费的云服务平台，基本上支持所有目前主流的语言，Object-C自然也在其中，但是只支持github极大的限制了其应用场景。目前国内无法访问，<a href=\"http://www.infoq.com/cn/articles/build-ios-continuous-integration-platform-part3\" target=\"_blank\" rel=\"noopener\">详见</a></li>\n<li><strong>Jenkins</strong>：经过多年的发展，其活跃的社区和丰富的插件让其成为了业界最受欢迎的CI服务器。通过使用Xcode插件，可以非常方便在Jenkins中运行iOS项目的构建脚本。</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"xcode-持续集成的实现\"><a href=\"#xcode-持续集成的实现\" class=\"headerlink\" title=\"xcode 持续集成的实现\"></a>xcode 持续集成的实现</h2><p><a href=\"https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/adopt_continuous_integration.html#//apple_ref/doc/uid/TP40013292-CH3-SW1\" target=\"_blank\" rel=\"noopener\">Setting Up Xcode Server</a></p>\n<p>jenkins使用配置：  </p>\n<ol>\n<li>下载：<a href=\"http://mirrors.jenkins-ci.org/war/lastest/jenkins.war\" target=\"_blank\" rel=\"noopener\">http://mirrors.jenkins-ci.org/war/lastest/jenkins.war</a>  </li>\n<li><p>运行命令行：  </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> \t nohup java -jar ~/Downloads/jenkins.war —httpPort=8081 —ajp13Port=8010 &gt; /tmp/jenkins.log 2&gt;&amp;1 &amp;</span><br><span class=\"line\">\t```  </span><br><span class=\"line\">3. 写入启动文件中，起别名</span><br></pre></td></tr></table></figure>\n<p> vi /Users/(username)/.bash_profile<br> 输入:alias jenkins=”nohup java -jar ~/Downloads/SVNRepos/jenkins.war –httpPort=8081 –ajp13Port=8010 &gt; /tmp/jenkins.log 2&gt;&amp;1 &amp;”  </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4. 启动时，在命令行中输入：**`jenkins`** 回车  即可启动</span><br><span class=\"line\">5. 访问：http://127.0.0.1:8081/</span><br><span class=\"line\">6. 重启：http://[jenkins-server]/[command] exit推出，restart重启，reload重载。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 方法二：</span><br><span class=\"line\">安装jenkins还是使用brew</span><br><span class=\"line\"></span><br><span class=\"line\">brew install jenkins</span><br><span class=\"line\">安装好之后，可以通过使用命令行启动</span><br><span class=\"line\"></span><br><span class=\"line\">\tjava -jar /usr/local/opt/jenkins/libexec/jenkins.war</span><br><span class=\"line\">如果想**开机自动启动**，需要先执行以下命令，创建启动项：</span><br><span class=\"line\"></span><br><span class=\"line\">\tln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents</span><br><span class=\"line\">可以编辑一下~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist这个文件</span><br><span class=\"line\"></span><br><span class=\"line\">\topen ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</span><br><span class=\"line\">\t</span><br><span class=\"line\">具体内容：</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">\t&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class=\"line\">\t&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class=\"line\">\t  &lt;dict&gt;</span><br><span class=\"line\">\t    &lt;key&gt;Label&lt;/key&gt;</span><br><span class=\"line\">\t    &lt;string&gt;homebrew.mxcl.jenkins&lt;/string&gt;</span><br><span class=\"line\">\t    &lt;key&gt;ProgramArguments&lt;/key&gt;</span><br><span class=\"line\">\t    &lt;array&gt;</span><br><span class=\"line\">\t      &lt;string&gt;/usr/bin/java&lt;/string&gt;</span><br><span class=\"line\">\t      &lt;string&gt;-Dmail.smtp.starttls.enable=true&lt;/string&gt;</span><br><span class=\"line\">\t      &lt;string&gt;-jar&lt;/string&gt;</span><br><span class=\"line\">\t      &lt;string&gt;/usr/local/opt/jenkins/libexec/jenkins.war&lt;/string&gt;</span><br><span class=\"line\">\t      &lt;string&gt;--httpListenAddress=127.0.0.1&lt;/string&gt;</span><br><span class=\"line\">\t      &lt;string&gt;--httpPort=8088&lt;/string&gt;</span><br><span class=\"line\">\t    &lt;/array&gt;</span><br><span class=\"line\">\t    &lt;key&gt;RunAtLoad&lt;/key&gt;</span><br><span class=\"line\">\t    &lt;true/&gt;</span><br><span class=\"line\">\t  &lt;/dict&gt;</span><br><span class=\"line\">\t&lt;/plist&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">想要让局域网都可以访问或修改端口号，需要把—httpListenAddress=127.0.0.1改成自己的局域网IP  </span><br><span class=\"line\"></span><br><span class=\"line\">手动启动启动项可以执行,制作替身：</span><br><span class=\"line\"></span><br><span class=\"line\">\tlaunchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist  </span><br><span class=\"line\">之后用浏览器就可以访问 **http://localhost:8088/** 来登录jenkins了</span><br><span class=\"line\"></span><br><span class=\"line\">#### 方法三：</span><br><span class=\"line\">使用tomcat</span><br><span class=\"line\">制作替身：</span><br><span class=\"line\"></span><br><span class=\"line\">\tcd ~/Downloads/soft/Tomcat/</span><br><span class=\"line\">\tln -sfv apache-tomcat-8.0.27 tomcat</span><br><span class=\"line\">\t</span><br><span class=\"line\">将jenkins.war拷贝到 $tomcat/webapp下面。  </span><br><span class=\"line\">\t</span><br><span class=\"line\">\t $tomcat/bin/start.sh  </span><br><span class=\"line\">用浏览器打开 **localhost:8080/jenkins** tomcat默认端口号为8080，就可以看到 jenkin运行了。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 自动化构建和依赖管理[参考](http://www.infoq.com/cn/articles/build-ios-continuous-integration-platform-part1/)</span><br><span class=\"line\">作为以GUI和命令行操作结合的完美性著称的苹果公司来说，当然也不会忘记为自己的封闭的iOS系统提供开发环境下命令行编译工具：xcodebuild</span><br><span class=\"line\">在介绍xcodebuild之前，需要先弄清楚一些在XCode环境下的一些概念【4】：</span><br><span class=\"line\"></span><br><span class=\"line\">- **Workspace**：简单来说，Workspace就是一个容器，在该容器中可以存放多个你创建的Xcode Project， 以及其他的项目中需要使用到的文件。使用Workspace的好处有，1),扩展项目的可视域，即可以在多个项目之间跳转，重构，一个项目可以使用另一个项目的输出。Workspace会负责各个Project之间提供各种相互依赖的关系;2),多个项目之间共享Build目录。</span><br><span class=\"line\">- **Project**：指一个项目，该项目会负责管理生成一个或者多个软件产品的全部文件和配置，一个Project可以包含多个Target。</span><br><span class=\"line\">- **Target**：一个Target是指在一个Project中构建的一个产品，它包含了构建该产品的所有文件，以及如何构建该产品的配置。</span><br><span class=\"line\">- **Scheme**：一个定义好构建过程的Target成为一个Scheme。可在Scheme中定义的Target的构建过程有：Build/Run/Test/Profile/Analyze/Archive</span><br><span class=\"line\">- **BuildSetting**：配置产品的Build设置，比方说，使用哪个Architectures？使用哪个版本的SDK？。在Xcode Project中，有Project级别的Build Setting，也有Target级别的Build Setting。Build一个产品时一定是针对某个Target的，因此，XCode中总是优先选择Target的Build Setting，如果Target没有配置，则会使用Project的Build Setting。</span><br><span class=\"line\"></span><br><span class=\"line\">xcodebuild就是用了构建产品的命令行工具，其用法可以归结为3个部分：</span><br><span class=\"line\"></span><br><span class=\"line\">- 可构建的对象</span><br><span class=\"line\">- 构建行为</span><br><span class=\"line\">- 一些其他的辅助命令</span><br><span class=\"line\"></span><br><span class=\"line\">可以构建的对象有，默认情况下会运行project下的第一个target：</span><br><span class=\"line\"></span><br><span class=\"line\">- workspace：必须和“-scheme”一起使用，构建该workspace下的一个scheme。</span><br><span class=\"line\">- project：当根目录下有多个Project的时候，必须使用“-project”指定project，然后会运行</span><br><span class=\"line\">- target：构建某个Target</span><br><span class=\"line\">- scheme：和“-workspace”一起使用，指定构建的scheme。</span><br><span class=\"line\">- ……</span><br><span class=\"line\"></span><br><span class=\"line\">构建行为包括：</span><br><span class=\"line\"></span><br><span class=\"line\">- clean:清除build目录下的</span><br><span class=\"line\">- build: 构建</span><br><span class=\"line\">- test: 测试某个scheme，必须和&quot;-scheme&quot;一起使用</span><br><span class=\"line\">- archive:打包，必须和“-scheme”一起使用</span><br><span class=\"line\">- ……</span><br><span class=\"line\">辅助命令包括：</span><br><span class=\"line\"></span><br><span class=\"line\">- -sdk：指定构建使用的SDK</span><br><span class=\"line\">- -list：列出当前项目下所有的Target和scheme。</span><br><span class=\"line\">- -version：版本信息</span><br><span class=\"line\">- …...</span><br><span class=\"line\">关于xcodebuild更多详细的命令行请参见：[点击](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html)</span><br><span class=\"line\"></span><br><span class=\"line\">xcodebuild的主要缺陷：</span><br><span class=\"line\"></span><br><span class=\"line\">- 其脚本输出的可读性极差，</span><br><span class=\"line\">- 只能要么完整的运行一个target或者scheme，要么全部不运行。不能指定运行Target中特定的测试。</span><br><span class=\"line\"></span><br><span class=\"line\">**安装xctool** </span><br><span class=\"line\"></span><br><span class=\"line\">xctool的安装非常简单，只需要clone xctool的repository到项目根目录就可以使用， 如果你的机器上安装有Homebrew，可以通过“brew install xctool”命令直接安装。（**注意：使用xctool前一定要首先确认xcodebuild已安装且能正确工作**）。</span><br><span class=\"line\"></span><br><span class=\"line\">**用法**</span><br><span class=\"line\"></span><br><span class=\"line\">关于xctool的用法就更加人性化了，几乎可以重用所有的xcodebuild的指令，配置。只需要注意一下几点：</span><br><span class=\"line\"></span><br><span class=\"line\">- xctool不支持target构建，只能使用scheme构建。</span><br><span class=\"line\">- 支持“-only”指令运行指定的测试。</span><br><span class=\"line\">- 支持多种格式的build报告。</span><br><span class=\"line\">例子：</span><br><span class=\"line\">```ruby</span><br><span class=\"line\">path/to/xctool.sh </span><br><span class=\"line\">  -workspaceYourWorkspace.xcworkspace</span><br><span class=\"line\">  -schemeYourScheme</span><br><span class=\"line\">test -only SomeTestTarget:SomeTestClass/testSomeMethod</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"自动化部署\"><a href=\"#自动化部署\" class=\"headerlink\" title=\"自动化部署\"></a>自动化部署</h4><p>这儿的想谈的“部署”不是传统意义上的直接部署到产品环境的部署，而是指如何把最新版本的应用快速的部署到测试用户的机器上以收集反馈，或者做一些探索性的测试。  </p>\n<p>在我写第一个iOS应用的时候，我想把应用安装到多个机器上测试的时候，需要非常繁琐的步骤：</p>\n<ul>\n<li>需要申请到苹果开发者账号，获得开发者证书。</li>\n<li>需要在苹果的开发者网站上注册我想使用的设备。</li>\n<li>使用开发者证书打包应用，使用Ad-HOC部署模式，生成ipa文件。</li>\n<li>通过ipa文件把应用安装到iTunes上。</li>\n<li>通过iTunes把应用同步到多台测试机器上。</li>\n</ul>\n<p>如果是测试机器在多个地理位置的时候，还需要把ipa文件发送到对应的地点，每个地点都需要重复的做第4，5步。 这样一个繁琐，且低效的过程让开发者非常痛苦，直到TestFlight的出现。</p>\n<h4 id=\"TestFlight\"><a href=\"#TestFlight\" class=\"headerlink\" title=\"TestFlight\"></a>TestFlight</h4><p>TestFlight：就是一个专门解决上面提到的痛点的云服务方案，它可以帮助开发者：</p>\n<ul>\n<li>轻松采集测试用户的UDID和iOS 版本、硬件版本，并发送给开发者。</li>\n<li>实时反馈应用是否成功安装到测试机器</li>\n<li>轻松部署最新版本应用到测试用机上。</li>\n<li>开发者可以灵活选择部署哪个版本到哪部分测试机器上。</li>\n</ul>\n<p>使用使用Test Flight服务非常简单，只需要到Test Flight注册一个账号。然后把链接发送给测试设备，测试设备只要打开该链接，并授权给Test Flight，在Test Flight的设备中心就可以看到这些设备。</p>\n<h4 id=\"使用jenkins-calabash-cocoapods搭建ios持续集成环境\"><a href=\"#使用jenkins-calabash-cocoapods搭建ios持续集成环境\" class=\"headerlink\" title=\"使用jenkins+calabash+cocoapods搭建ios持续集成环境\"></a><a href=\"http://blog.csdn.net/zangcw/article/details/25299243\" target=\"_blank\" rel=\"noopener\">使用jenkins+calabash+cocoapods搭建ios持续集成环境</a></h4><ol>\n<li>calabash  是一款开源的跨平台UI测试工具，目前支持iOS和Android。它使用Cucumber作为测试核心，Cucumber是一个在敏捷团队十分流行的自动化的功能测试工具，它使用接近于自然语言的特性文档进行用例的书写和测试，支持多语言和多平台。</li>\n<li><p>安装Calabash  </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem install calabash-cucumber</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装Calabash中文支持包  </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem install calabash-cucumber-cn</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"For-automatic-setup\"><a href=\"#For-automatic-setup\" class=\"headerlink\" title=\"For automatic setup:\"></a>For automatic setup:</h4><ol>\n<li><p>In a terminal, go to your iOS project  </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\tcd path-to-my-ios-project (i.e. directory containing .xcodeproj file)</span><br><span class=\"line\">\t```  </span><br><span class=\"line\">2. Install calabash-cucumber gem (this make take some time because of dependencies)</span><br></pre></td></tr></table></figure>\n<p> gem install calabash-cucumber</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3. Setup your project for Calabash-iOS.</span><br></pre></td></tr></table></figure>\n<p> calabash-ios setup  //Answer the questions and read the output :)</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4. Generate a skeleton features folder for your tests</span><br></pre></td></tr></table></figure>\n<p> calabash-ios gen</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5. In Xcode, build your project using the -cal scheme</span><br><span class=\"line\"></span><br><span class=\"line\">6. Run the generated test!</span><br></pre></td></tr></table></figure>\n<p> cucumber<br> ```</p>\n</li>\n</ol>\n<p>If all goes well, you are now ready to write your first test. Start by editing the file features/my_first.feature.</p>\n<h4 id=\"cucumber官网\"><a href=\"#cucumber官网\" class=\"headerlink\" title=\"cucumber官网\"></a><a href=\"https://cukes.info/\" target=\"_blank\" rel=\"noopener\">cucumber官网</a></h4><pre><code>* Feature（功能）  \n* Scenario（情景）  \n*  Given（给定）  \n*  When（当）  \n*  Then（则） \n</code></pre><h5 id=\"运行原理\"><a href=\"#运行原理\" class=\"headerlink\" title=\"运行原理\"></a><a href=\"http://www.educity.cn/se/619226.html\" target=\"_blank\" rel=\"noopener\">运行原理</a></h5><p><img src=\"http://img.educity.cn/img_7/262/2013122000/125005907.jpg\" alt=\"image\"><br>cucumber是一种BDD测试框架，核心为cucumber的calabash的脚本在运行测试的时候会在虚拟机/真机上预装一个web服务器，这个web服务器就是解释calabash的脚本，将其解释为robotium的脚本，然后这个web服务器会想测试app发送robotium的脚本，测试app拿到robotium脚本后，将其解释为instumentation命令向被测试的app发送这些命令，被测试的app执行这些命令，然后将结果返回给测试app，然后一级一级返得到最后的测试结果。    </p>\n<h5 id=\"结构框架\"><a href=\"#结构框架\" class=\"headerlink\" title=\"结构框架\"></a>结构框架</h5><p>calabash完全采用了cucumber的结构模式，calabash是脚本与TC分离设计，在业务变化的情况下，只要功能存在基本只需要修改TC逻辑，在业务不变，功能变化的情况下，基本只需要修改脚本。<br><img src=\"http://img.educity.cn/img_7/262/2013122000/126005907.jpg\" alt=\"image\"><br>feature为主件夹，step_definitions目录内是你封装的脚本，my_first.feature文件就是你的TC逻辑。<br>再看一下其中的内容：</p>\n<pre><code>　　my_first.feature\n\n　　Feature： 登陆\n\n　　Scenario： 输入正确的用户名密码能够正常登陆\n\n　　When 打开登陆页面\n\n　　And    输入用户名XXX输入密码XXX\n\n　　And   点击登陆\n\n　　Then  验证登陆成功\n</code></pre><p>　　看起来很简单吧，想要验证其他功能也是类似的语言描述即可。<br>如果你没有用过cucumber或者calabash那么你肯定现在有一个疑问，计算机怎么能识别汉字来进行测试的呢，<br>那么看一下step_definition，以 输入用户名XXX输入密码XXX为例：</p>\n<pre><code>When /^ 输入用户名\\&quot;([^\\\\\\&quot;]*)\\&quot; 输入密码\\&quot;([^\\\\\\&quot;]*)\\&quot;  $/ do |username，password|\nperformAction(&apos;enter_text_into_numbered_field&apos;，username，1)\nperformAction(&apos;enter_text_into_numbered_field&apos;，password，2)\nend\n</code></pre><p>现在应该能明白为什么你需要写汉字的脚本就可以了吧。<br>在这里解释一下为什么如果业务存在功能修改这种情况，自动化脚本的修改量会小。<br>还是以这个登录脚本为例：</p>\n<pre><code>假如现在输入用户名和密码的输入框顺序变了，在你的页面显示上，可能是从左下角移到中间了，这种变化，那么feature文件你不用改，只需要改step_definition脚本就好了\n</code></pre><h5 id=\"运行报告\"><a href=\"#运行报告\" class=\"headerlink\" title=\"运行报告\"></a>运行报告</h5><p>alabash-android支持很多报告生成模式，支持html，json，junit等等报告模式，只需要你在run的时候添加-f参数-o参数就可以了。</p>\n<p>　　例如 calabash-android run xxxx.apk -f html -o l，上图展示一下强大html报告<br>　　<img src=\"http://img.educity.cn/img_7/262/2013122000/127005907.jpg\" alt=\"image\"></p>\n<p><a href=\"http://blog.csdn.net/qs_csu/article/details/9000262\" target=\"_blank\" rel=\"noopener\">【cucumber解析features文件】</a>         </p>\n<ol>\n<li><p>my_first.feature: 描述在这个条件下需要做什么事情；</p>\n<pre><code>Feature: Running a test  \n  As an iOS developer  \n  I want to have a sample feature file  \n  So I can begin testing quickly  \n\nScenario: Example steps1  \n  Given I am on the Welcome Screen  \n  Then I swipe left  \n  And I wait until I don&apos;t see &quot;Please swipe left&quot;  \n  And take picture  \n\nScenario: Example steps2  \n  Given I am on the Welcome Screen  \n #ASSERTION  \n  Then I should see a &quot;login&quot; button  \n #INPUT TEXT  \n  Then I enter &quot;my_username&quot; into text field number 1  \n#  Then I touch &quot;Return&quot;  \n\n #TOGGLE SWITCH  \n  Then I toggle the switch  \n  Then I touch &quot;Login&quot;  \n  And I touch &quot;Second&quot;  \n  And take picture  \n</code></pre><p> 该文件描述了在“on the Welcome Screen”这个Step中需要做的事情，两个场景:steps1 和 steps2. </p>\n</li>\n<li><p>my_first_step.rb: 解释了Given的具体条件</p>\n<pre><code>Given /^I am on the Welcome Screen$/ do  \n  element_exists(&quot;view&quot;)  \n  check_element_exists(&quot;label text:&apos;First View&apos;&quot;)  \n  sleep(STEP_PSEAU)  \nend\n</code></pre><p> 这个语句，判定了当前条件”on the Welcome Screen”是否满足，如果element存在，则就在”Welcome Screen”；</p>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"工具","path":"api/categories/工具.json"},{"name":"集成","path":"api/categories/集成.json"}],"tags":[{"name":"TDD","path":"api/tags/TDD.json"},{"name":"BDD","path":"api/tags/BDD.json"}]},{"title":"mupdf集成pyc加密算法","slug":"编译/mupdf集成pyc加密算法","date":"2015-08-14T10:45:35.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/编译/mupdf集成pyc加密算法.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"加密算法中区分64位\"><a href=\"#加密算法中区分64位\" class=\"headerlink\" title=\"加密算法中区分64位\"></a>加密算法中区分64位</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if __LP64__ || (TARGET_OS_EMBEDDED &amp;&amp; !TARGET_OS_IPHONE) || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64</span><br><span class=\"line\">    #ifndef uint32</span><br><span class=\"line\">        #define uint32 unsigned int</span><br><span class=\"line\">    #endif</span><br><span class=\"line\">#else</span><br><span class=\"line\">    #ifndef uint32</span><br><span class=\"line\">        #define uint32 unsigned long int</span><br><span class=\"line\">    #endif</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<ol>\n<li>把SMS4.h文件内容合并到include/mupdf/fitz/stream.h文件中，然后删除SMS4.h文件</li>\n<li>把SMS4.c文件内容合并到source/fitz/stream-open.c 文件中，然后删除SMS4.c</li>\n<li>在include/mupdf/fitz/stream.h增加以下内容:  用于方法声明，供其他类使用。<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> void set_key_info(char* key, long long code_len);  </span><br><span class=\"line\">int pbb_read(int fd, unsigned char *buf, int size);  </span><br><span class=\"line\">int fpbb_read(unsigned char *buf, int count, int size, FILE* fp);  \t</span><br><span class=\"line\"> ```  </span><br><span class=\"line\">4. 替换source/pdf/pdf-write.c  2530：fread 替换为 fpbb_read</span><br><span class=\"line\">5. 替换source/fitz/stream-prog.c  57: read 替换为  pbb_read</span><br><span class=\"line\">6. 替换source/fitz/stream-open.c  73: read 替换为  pbb_read </span><br><span class=\"line\">7. 配置document Type    public.data,public.centent</span><br><span class=\"line\"></span><br><span class=\"line\">传递秘钥：</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>char keycode[] = {-12,7,106,95,82,118,-64,-78,-98,5,-3,-128,-28,95,-84,120};<br>long long keylength = 37761;<br>set_key_info(keycode, keylength);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t</span><br><span class=\"line\">#### ijkplayer</span><br><span class=\"line\">- https://github.com/kolyvan/kxmovie.git  </span><br><span class=\"line\">- https://github.com/Bilibili/ijkplayer.git</span><br><span class=\"line\">- 支持所有视频格式的操作：</span><br><span class=\"line\">\t- cd ijkplyer-master/config/</span><br><span class=\"line\">\t- rm module.sh</span><br><span class=\"line\">\t- ln -s module-default.sh module.sh</span><br><span class=\"line\">- 加密集成  </span><br><span class=\"line\">  - 处理文件的目录位置：ijkplyer-master/ios/ffmpeg-arm64,armv7,armv7s,i386,x86_64/libavformat目录</span><br><span class=\"line\">  - 把pyckey.h,sms4.h文件内容移动到处理文件目录中的avformat.h文件中</span><br><span class=\"line\">  - 把pyckey.c, sms4.c文件内容移动到处理文件目录中的file.c文件中  </span><br><span class=\"line\">  - 将extra.tar.gz解压，放入ijkplayer-master/extra目录下 </span><br><span class=\"line\">  - 暴漏头文件，编辑目录中的Makefile文件</span><br><span class=\"line\">  - - HEADERS = 新增.h文件，例如:url.h</span><br><span class=\"line\">  - - OBJS = 新增.o文件，例如:url.o</span><br></pre></td></tr></table></figure></p>\n<p>  注意：要替换ios目录下针对不同内核的目录arm64,armv7,armv7s,i386，都需要操作如上步骤。<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">然后，在IOS目录下执行编译命令脚本集合文件:</span><br></pre></td></tr></table></figure></p>\n<p>  ./compile-ffmpeg.sh clean<br>  ./compile-ffmpeg.sh all<br>```</p>\n<h4 id=\"将ijkplayer集成到自己的项目中\"><a href=\"#将ijkplayer集成到自己的项目中\" class=\"headerlink\" title=\"将ijkplayer集成到自己的项目中\"></a>将ijkplayer集成到自己的项目中</h4><ol>\n<li>将ijkplayer-master/ios、目录下的IJKMediaPlayer目录拷贝到自己项目的同目录下</li>\n<li>打开自己的项目，将IJKMediaPlayer.xcodeproj项目文件拖入自己项目中</li>\n<li>选择项目名称，配置Targets<ul>\n<li>选中 build phases标签，添加 Target Dpendencies  ，选中IJKMediaFramework 添加即可。 </li>\n</ul>\n</li>\n<li>因为移动了IJK项目目录到本项目，需要重新配置IJKMediaPlayer中文件关联设置<ul>\n<li>需要将ijkplayer-master/目录下的ijkmedia目录中的ijkplayer目录和ijksdl目录(Android.mk除外)，拷贝到IJKMediaPlyaer项目的IJKMediaPlyaer/IJKMediaPllayer/ijkmedia/目录下</li>\n<li>需要将编译后得到的静态库（ijkplayer-master/ios/build/universal/目录）拷贝至IJKMediaPlayer目录：$(PROJECT_DIR)/ffmpeg/universal/lib</li>\n<li>选中IJKMediaPlayer项目名称，配置Targets</li>\n<li>选中 build Setting标签：<br><strong>设置HeaderSearch Paths</strong>:$(PROJECT_DIR)/IJKMediaPlayer/ijkmedia $(PROJECT_DIR)/ffmpeg/universal/include<br><strong>设置Library Search Paths</strong>:$(PROJECT_DIR)/ffmpeg/universal/lib  </li>\n</ul>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"}],"tags":[{"name":"加密","path":"api/tags/加密.json"}]}]}