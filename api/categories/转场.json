{"name":"转场","postlist":[{"title":"自定义展示型控制器","slug":"自定义展示型控制器","date":"2017-02-17T12:26:11.000Z","updated":"2018-04-24T11:49:45.000Z","comments":true,"path":"api/articles/自定义展示型控制器.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/semi-transparent.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><div id=\"badge-container-huos3203-PresentationsDemo-2cce4c908\" class=\"hexo-github\" style=\"width: =\"></div>\n<script src=\"/hexo-github/badge.js\"></script>\n<script type=\"text/javascript\">\n  loadStyle(\"/hexo-github/style.css\");\n  loadStyle(\"/hexo-github/octicons/octicons.css\");\n  new Badge(\"#badge-container-huos3203-PresentationsDemo-2cce4c908\", \"huos3203\", \"PresentationsDemo\", \"2cce4c908\", false);\n</script>\n\n<h2 id=\"触发转场的方式\"><a href=\"#触发转场的方式\" class=\"headerlink\" title=\"触发转场的方式\"></a>触发转场的方式</h2><h3 id=\"官方支持的自定义转场\"><a href=\"#官方支持的自定义转场\" class=\"headerlink\" title=\"官方支持的自定义转场\"></a>官方支持的自定义转场</h3><ul>\n<li>在 <code>UINavigationController</code> 中 <code>push</code> 和 <code>pop</code>;</li>\n<li>在 <code>UITabBarController</code> 中切换 <code>Tab</code>;</li>\n<li>Modal 转场：<code>presentation</code> 和 <code>dismissal</code>，俗称视图控制器的模态显示和消失，仅限于<code>modalPresentationStyle</code>属性为 <code>UIModalPresentationFullScreen</code> 或 <code>UIModalPresentationCustom</code> 这两种模式;<br><code>UICollectionViewController</code> 的布局转场：仅限于 <code>UICollectionViewController</code> 与 <code>UINavigationController</code> 结合的转场方式，与上面三种都有点不同，不过实现很简单，可跳转至该链接查看。<br>官方的支持包含了 iOS 中的大部分转场方式，还有一种自定义容器中的转场并没有得到系统的直接支持，不过借助协议这种灵活的方式，我们依然能够实现对自定义容器控制器转场的定制，在压轴环节我们将实现这一点。<h3 id=\"相关触发转场的动作\"><a href=\"#相关触发转场的动作\" class=\"headerlink\" title=\"相关触发转场的动作\"></a>相关触发转场的动作</h3><h4 id=\"UINavigationController\"><a href=\"#UINavigationController\" class=\"headerlink\" title=\"UINavigationController\"></a>UINavigationController</h4><code>UINavigationController</code> 中所有修改其<code>viewControllers</code>栈中 <code>VC</code> 的方法都可以自定义转场动画：<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//我们使用的最广泛的 push 和 pop 方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pushViewController</span><span class=\"params\">(<span class=\"number\">_</span> viewController: UIViewController, animated animated: Bool)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">popViewControllerAnimated</span><span class=\"params\">(<span class=\"number\">_</span> animated: Bool)</span></span> -&gt; <span class=\"type\">UIViewController</span>?</span><br><span class=\"line\"><span class=\"comment\">//不怎么常用的 pop 方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">popToRootViewControllerAnimated</span><span class=\"params\">(<span class=\"number\">_</span> animated: Bool)</span></span> -&gt; [<span class=\"type\">UIViewController</span>]?</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">popToRootViewControllerAnimated</span><span class=\"params\">(<span class=\"number\">_</span> animated: Bool)</span></span> -&gt; [<span class=\"type\">UIViewController</span>]?</span><br><span class=\"line\"><span class=\"comment\">//这个方法有有点特别，是对 VC 栈的整体更新，开启动画后的执行比较复杂，具体参考文档说明。不建议在这种情况下开启转场动画。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setViewControllers</span><span class=\"params\">(<span class=\"number\">_</span> viewControllers: [UIViewController], animated animated: Bool)</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"UITabBarController\"><a href=\"#UITabBarController\" class=\"headerlink\" title=\"UITabBarController\"></a>UITabBarController</h4><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注意传递的参数必须是其下的子 VC</span></span><br><span class=\"line\"><span class=\"keyword\">unowned</span>(unsafe) <span class=\"keyword\">var</span> selectedViewController: <span class=\"type\">UIViewController</span>?</span><br><span class=\"line\"><span class=\"keyword\">var</span> selectedIndex: <span class=\"type\">Int</span></span><br><span class=\"line\"><span class=\"comment\">//和上面类似的整体更新</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setViewControllers</span><span class=\"params\">(<span class=\"number\">_</span> viewControllers: [UIViewController]?, animated animated: Bool)</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Modal-转场：\"><a href=\"#Modal-转场：\" class=\"headerlink\" title=\"Modal 转场：\"></a>Modal 转场：</h4><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Presentation 转场</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentViewController</span><span class=\"params\">(<span class=\"number\">_</span> viewControllerToPresent: UIViewController, animated flag: Bool, completion completion: <span class=\"params\">(<span class=\"params\">()</span></span></span></span> -&gt; <span class=\"type\">Void</span>)?)</span><br><span class=\"line\"><span class=\"comment\">// Dismissal 转场</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dismissViewControllerAnimated</span><span class=\"params\">(<span class=\"number\">_</span> flag: Bool, completion completion: <span class=\"params\">(<span class=\"params\">()</span></span></span></span> -&gt; <span class=\"type\">Void</span>)?)</span><br></pre></td></tr></table></figure>\n<h4 id=\"Segue\"><a href=\"#Segue\" class=\"headerlink\" title=\"Segue\"></a>Segue</h4>在 <code>storyboard</code> 里设置 <code>segue</code>有两种方式：<code>Button to VC</code>，这种在点击 <code>Button</code> 的时候触发转场；<code>VC to VC</code>，这种需要在代码中调用<code>performSegueWithIdentifier:sender:</code>。<code>prepareForSegue:sender:</code>方法是在转场发生前修改转场参数的最后机会。这点对于 <code>Modal</code> 转场比较重要，因为在 <code>storyboard</code>里 <code>Modal</code> 转场的 <code>Segue</code> 类型不支持选择 <code>Custom</code> 模式，使用 <code>segue</code> 方式触发时必须在<code>prepareForSegue:sender:</code>里修改模式。</li>\n</ul>\n<h4 id=\"iOS-8-的变化\"><a href=\"#iOS-8-的变化\" class=\"headerlink\" title=\"iOS 8 的变化\"></a>iOS 8 的变化</h4><p>iOS 8 引入了适应性布局，由此添加了两种新的方式来显示一个视图控制器：<br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">showViewController</span><span class=\"params\">(<span class=\"number\">_</span> vc: UIViewController, sender sender: AnyObject?)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">showDetailViewController</span><span class=\"params\">(<span class=\"number\">_</span> vc: UIViewController, sender sender: AnyObject?)</span></span></span><br></pre></td></tr></table></figure><br>这两个方法咋看上去是给 <code>UISplitViewController</code> 用的，在 <code>storyboard</code> 里 <code>segue</code> 的候选模式里，直接给出了<code>Show(e.g. Push)</code>和<code>Show Detail(e.g. Replace)</code>这样的提示，以至于我之前一直对这两个 segue 有误解。实际上这两个方法智能判断当前的显示环境来决定如何显示，iOS 8 想统一显示视图控制器的方式，不过引入这两个方法增加了使用的复杂性，来看看这两个方法的使用规则。<br>这两个方法在 <code>UISplitViewController</code> 上的确是按名字显示的那样去工作的，而在本文关注的控制器上是这样工作的：<br>|  |ViewController|NavigationController|TabBarController|<br>|:——-|:——-|:——–|:——–|<br>|showViewController:sender: |Presentation| Push | Presentation(by self) |<br>|showDetailViewController:sender: |Presentation| Presentation(by self) | Presentation(by self)|<br><code>UINavigationController</code> 重写了<code>showViewController:sender:</code>而执行 <code>push</code> 操作，上面的<code>by self</code>意思是用容器 <code>VC</code> 本身而非其下子 <code>VC</code> 去执行 <code>presentation</code>。这两个方法的行为可以通过重写来改变。<br>当非容器类 VC 内嵌在这两种容器 VC 里时，会通过最近的容器 VC 来执行：<br>||VC in NavigationController|VC in TabBarController|<br>|:——-|:——-|:——–|<br>|showViewController:sender: |Push(by NavigationController)| Presentation(by TabBarController) |<br>|showDetailViewController:sender: |Presentation(by NavigationController)| Presentation(by TabBarController) |</p>\n<h3 id=\"转场五大工具\"><a href=\"#转场五大工具\" class=\"headerlink\" title=\"转场五大工具\"></a>转场五大工具</h3><p>iOS 7 以协议的方式开放了自定义转场的 API，协议的好处是不再拘泥于具体的某个类，只要是遵守该协议的对象都能参与转场，非常灵活。转场协议由5种协议组成，在实际中只需要我们提供其中的两个或三个便能实现绝大部分的转场动画：</p>\n<h4 id=\"转场代理-Transition-Delegate-：\"><a href=\"#转场代理-Transition-Delegate-：\" class=\"headerlink\" title=\"转场代理(Transition Delegate)：\"></a>转场代理(Transition Delegate)：</h4><p>有如下三种容器转场代理，对应上面三种类型的转场：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"type\">UINavigationControllerDelegate</span>&gt; <span class=\"comment\">//UINavigationController 的 delegate 属性遵守该协议。</span></span><br><span class=\"line\">&lt;<span class=\"type\">UITabBarControllerDelegate</span>&gt; <span class=\"comment\">//UITabBarController 的 delegate 属性遵守该协议。</span></span><br><span class=\"line\">&lt;<span class=\"type\">UIViewControllerTransitioningDelegate</span>&gt; <span class=\"comment\">//UIViewController 的 transitioningDelegate 属性遵守该协议。</span></span><br></pre></td></tr></table></figure><br>这里除了<uiviewcontrollertransitioningdelegate>是 iOS 7 新增的协议，其他两种在 iOS 2 里就存在了，在 iOS 7 时扩充了这两种协议来支持自定义转场。</uiviewcontrollertransitioningdelegate></p>\n<h4 id=\"动画控制器-Animation-Controller-：\"><a href=\"#动画控制器-Animation-Controller-：\" class=\"headerlink\" title=\"动画控制器(Animation Controller)：\"></a>动画控制器(Animation Controller)：</h4><p>最重要的部分，负责添加视图以及执行动画；遵守<uiviewcontrolleranimatedtransitioning>协议；由我们实现。</uiviewcontrolleranimatedtransitioning></p>\n<h4 id=\"交互控制器-Interaction-Controller-：\"><a href=\"#交互控制器-Interaction-Controller-：\" class=\"headerlink\" title=\"交互控制器(Interaction Controller)：\"></a>交互控制器(Interaction Controller)：</h4><p>通过交互手段，通常是手势来驱动动画控制器实现的动画，使得用户能够控制整个过程；遵守<uiviewcontrollerinteractivetransitioning>协议；系统已经打包好现成的类供我们使用。</uiviewcontrollerinteractivetransitioning></p>\n<h4 id=\"转场环境-Transition-Context\"><a href=\"#转场环境-Transition-Context\" class=\"headerlink\" title=\"转场环境(Transition Context):\"></a>转场环境(Transition Context):</h4><p>提供转场中需要的数据；遵守<uiviewcontrollercontexttransitioning>协议；由 UIKit 在转场开始前生成并提供给我们提交的动画控制器和交互控制器使用。</uiviewcontrollercontexttransitioning></p>\n<h4 id=\"转场协调器-Transition-Coordinator-：\"><a href=\"#转场协调器-Transition-Coordinator-：\" class=\"headerlink\" title=\"转场协调器(Transition Coordinator)：\"></a>转场协调器(Transition Coordinator)：</h4><p>可在转场动画发生的同时并行执行其他的动画，其作用与其说协调不如说辅助，主要在 Modal 转场和交互转场取消时使用，其他时候很少用到；遵守<uiviewcontrollertransitioncoordinator>协议；由 UIKit 在转场时生成，UIViewController 在 iOS 7 中新增了方法transitionCoordinator()返回一个遵守该协议的对象，且该方法只在该控制器处于转场过程中才返回一个此类对象，不参与转场时返回 nil。</uiviewcontrollertransitioncoordinator></p>\n<p>总结下，5个协议只需要我们操心3个；实现一个最低限度可用的转场动画，我们只需要提供上面五个组件里的两个：转场代理和动画控制器即可，还有一个转场环境是必需的，不过这由系统提供；当进一步实现交互转场时，还需要我们提供交互控制器，也有现成的类供我们使用。</p>\n<h2 id=\"特殊的-Modal-转场\"><a href=\"#特殊的-Modal-转场\" class=\"headerlink\" title=\"特殊的 Modal 转场\"></a>特殊的 Modal 转场</h2><p>容器类 VC 的转场里 <code>fromView</code> 和 <code>toView</code> 是 <code>containerView</code> 的子层次的视图，而 Modal 转场里 <code>presentingView</code> 与 <code>containerView</code> 是同层次的视图，只有 <code>presentedView</code> 是 <code>containerView</code> 的子层次视图。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/semi-transparent.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"iOS-8引入的UIPresentationController\"><a href=\"#iOS-8引入的UIPresentationController\" class=\"headerlink\" title=\"iOS 8引入的UIPresentationController\"></a>iOS 8引入的UIPresentationController</h3><p><code>UIPresentationController</code>类，该类接管了 <code>UIViewController</code> 的显示过程，为其提供转场和视图管理支持。在 iOS 8.0 以上的系统里，你可以在 <code>presentation</code> 转场结束后打印视图控制器的结构，会发现 <code>presentedVC</code> 是由一个<code>UIPresentationController</code>对象来显示的，查看视图结构也能看到 <code>presentedView</code> 是 <code>UIView</code> 私有子类的<code>UITtansitionView</code>的子视图，这就是前面 <code>containerView</code> 的真面目.<br>当<code>UIViewController</code>的<code>modalPresentationStyle</code>属性为<code>.Custom</code>时(不支持.FullScreen)，我们有机会通过控制器的转场代理提供<code>UIPresentationController</code>的子类对 <code>Modal 转场</code>进行进一步的定制。实际上该类也可以在<code>.FullScreen</code>模式下使用，但是会丢失由该类负责的动画，保险起见还是遵循官方的建议，只在<code>.Custom</code>模式下使用该类。<br><code>UIPresentationController</code>类赋予 Modal 转场以下特性：</p>\n<ol>\n<li>定制 <code>presentedView</code> 的外观，尺寸以及在 <code>containerView</code> 中添加自定义视图并为这些视图添加动画；</li>\n<li>可以选择是否移除 <code>presentingView</code></li>\n<li>可以在不需要动画控制器的情况下单独工作</li>\n<li>iOS 8 中的自适应适应性布局<br><code>UIPresentationController</code>类提供了如下的方法参与转场，对转场过程实现了更加细致的控制，从命名便可以看出与动画控制器里的<code>animateTransition:</code>的关系：<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationTransitionWillBegin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationTransitionDidEnd</span><span class=\"params\">(<span class=\"number\">_</span> completed: Bool)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dismissalTransitionWillBegin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dismissalTransitionDidEnd</span><span class=\"params\">(<span class=\"number\">_</span> completed: Bool)</span></span></span><br></pre></td></tr></table></figure>\n除了 presentingView，UIPresentationController类拥有转场过程中剩下的角色：<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//指定初始化方法。</span></span><br><span class=\"line\"><span class=\"keyword\">init</span>(presentedViewController presentedViewController: <span class=\"type\">UIViewController</span>, presentingViewController presentingViewController: <span class=\"type\">UIViewController</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> presentingViewController: <span class=\"type\">UIViewController</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> presentedViewController: <span class=\"type\">UIViewController</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> containerView: <span class=\"type\">UIView</span>? &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"><span class=\"comment\">//提供给动画控制器使用的视图，默认返回 presentedVC.view，通过重写该方法返回其他视图，但一定要是 presentedVC.view 的上层视图。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentedView</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">UIView</span>?    </span><br></pre></td></tr></table></figure>\n没有 <code>presentingView</code> 是因为 <code>Custom</code> 模式下 <code>presentingView</code> 不受 <code>containerView</code> 管理，<code>UIPresentationController</code>类并没有改变这一点。iOS 8 扩充了转场环境协议，可以通过<code>viewForKey:</code>方便获取转场的视图，而该方法在 <code>Modal</code> 转场中获取的是<code>presentedView()</code>返回的视图。因此我们可以在子类中将 <code>presentedView</code> 包装在其他视图后重写该方法返回包装后的视图当做 <code>presentedView</code> 在动画控制器中使用。</li>\n</ol>\n<h3 id=\"定制presentedView\"><a href=\"#定制presentedView\" class=\"headerlink\" title=\"定制presentedView\"></a>定制presentedView</h3><h4 id=\"外观：重载size方法和frameOfPresentedViewInContainerView属性\"><a href=\"#外观：重载size方法和frameOfPresentedViewInContainerView属性\" class=\"headerlink\" title=\"外观：重载size方法和frameOfPresentedViewInContainerView属性\"></a>外观：重载size方法和frameOfPresentedViewInContainerView属性</h4><p>重载存储属性：get方法返回登场页面的位置和大小<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">var</span> frameOfPresentedViewInContainerView: <span class=\"type\">CGRect</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> presentViewFrame = <span class=\"type\">CGRect</span>.zero</span><br><span class=\"line\">    <span class=\"keyword\">let</span> containerBounds = containerView?.bounds</span><br><span class=\"line\">    <span class=\"comment\">//登场控制器内容页面的大小</span></span><br><span class=\"line\">    presentViewFrame.size = size(forChildContentContainer: presentedViewController, </span><br><span class=\"line\">                                  withParentContainerSize: (containerBounds?.size)!)</span><br><span class=\"line\">    presentViewFrame.origin.x = (containerBounds?.size.width)! - presentViewFrame.size.width</span><br><span class=\"line\">    <span class=\"keyword\">return</span> presentViewFrame</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回登场控制器内容页面的大小，在这里设置为屏幕宽度的三分之一款</span></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">size</span><span class=\"params\">(forChildContentContainer container: UIContentContainer, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   withParentContainerSize parentSize: CGSize)</span></span> -&gt; <span class=\"type\">CGSize</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">CGSize</span>.<span class=\"keyword\">init</span>(width:<span class=\"type\">CGFloat</span>(floorf(<span class=\"type\">Float</span>(parentSize.width/<span class=\"number\">3.0</span>))), height: parentSize.height)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"过渡动画，转场协调器-Transition-Coordinator\"><a href=\"#过渡动画，转场协调器-Transition-Coordinator\" class=\"headerlink\" title=\"过渡动画，转场协调器(Transition Coordinator)\"></a>过渡动画，转场协调器(Transition Coordinator)</h4><p>参与角色都准备好了，但有个问题，无法直接访问动画控制器，不知道转场的持续时间，怎么与转场过程同步？这时候前面提到的用处甚少的转场协调器(Transition Coordinator)将在这里派上用场。该对象可通过 <code>UIViewController</code> 的<code>transitionCoordinator()</code>方法获取，这是 iOS 7 为自定义转场新增的 API，该方法只在控制器处于转场过程中才返回一个与当前转场有关的有效对象，其他时候返回 <code>nil</code>。</p>\n<h5 id=\"转场开始\"><a href=\"#转场开始\" class=\"headerlink\" title=\"转场开始\"></a>转场开始</h5><ol>\n<li>在<code>containerView</code>中插入过渡视图<code>chromeView</code></li>\n<li>为转场中<code>chromeView</code>过渡视图添加转场动画</li>\n<li><code>presentedViewController.transitionCoordinator</code>转场协调器，添加转场的登场和退场动画<figure class=\"highlight swift\"><figcaption><span>presentationTransitionWillBegin</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationTransitionWillBegin</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    chromeView.frame = (<span class=\"keyword\">self</span>.containerView?.bounds)!</span><br><span class=\"line\">    chromeView.alpha = <span class=\"number\">0.0</span></span><br><span class=\"line\">    <span class=\"comment\">//在`containerView`中插入视图`chromeView`    </span></span><br><span class=\"line\">    containerView?.insertSubview(chromeView, at:<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//coordinator转场协调器负责转场动画的呈现和dismissal</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> coordinator = presentedViewController.transitionCoordinator</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (coordinator != <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//添加登场动画</span></span><br><span class=\"line\">        coordinator!.animate(alongsideTransition: &#123;</span><br><span class=\"line\">        (context:<span class=\"type\">UIViewControllerTransitionCoordinatorContext</span>!) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"comment\">//animate the alpha to 1.0.</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.chromeView.alpha = <span class=\"number\">1.0</span></span><br><span class=\"line\">        &#125;, completion:<span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        chromeView.alpha = <span class=\"number\">1.0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"转场结束\"><a href=\"#转场结束\" class=\"headerlink\" title=\"转场结束\"></a>转场结束</h5><p>在<code>presentedViewController.transitionCoordinator</code>转场协调器中添加转场的退场动画<br><figure class=\"highlight swift\"><figcaption><span>dismissalTransitionWillBegin</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dismissalTransitionWillBegin</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> coordinator = presentedViewController.transitionCoordinator</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (coordinator != <span class=\"literal\">nil</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//添加退场动画</span></span><br><span class=\"line\">        coordinator!.animate(alongsideTransition: &#123;</span><br><span class=\"line\">        (context:<span class=\"type\">UIViewControllerTransitionCoordinatorContext</span>!) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.chromeView.alpha = <span class=\"number\">0.0</span></span><br><span class=\"line\">        &#125;, completion:<span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        chromeView.alpha = <span class=\"number\">0.0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"适配屏幕旋转\"><a href=\"#适配屏幕旋转\" class=\"headerlink\" title=\"适配屏幕旋转\"></a>适配屏幕旋转</h4><p>在设备旋转的情况下，重置背景视图的外观和登场控制器内容的外观<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">containerViewWillLayoutSubviews</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    chromeView.frame = (containerView?.bounds)!</span><br><span class=\"line\">    presentedView?.frame = frameOfPresentedViewInContainerView</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Modal的两种PresentationStyle\"><a href=\"#Modal的两种PresentationStyle\" class=\"headerlink\" title=\"Modal的两种PresentationStyle\"></a>Modal的两种PresentationStyle</h4><ol>\n<li>设置整个转场动画是否将覆盖全屏幕<br> <code>.OverFullScreen</code>: 浮动式全屏，即：登场视图下方的视图不会完全被遮挡<br> <code>.FullScreen</code>  : 全覆盖全屏 即：占据全屏来显示登场视图<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设置整个转场动画是否将覆盖全屏幕</span></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">var</span> shouldPresentInFullscreen: <span class=\"type\">Bool</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">var</span> adaptivePresentationStyle: <span class=\"type\">UIModalPresentationStyle</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">UIModalPresentationStyle</span>.fullScreen</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"交互式转场\"><a href=\"#交互式转场\" class=\"headerlink\" title=\"交互式转场\"></a>交互式转场</h2><h3 id=\"实现交互化\"><a href=\"#实现交互化\" class=\"headerlink\" title=\"实现交互化\"></a>实现交互化</h3><p>在非交互转场的基础上将之交互化需要两个条件：<br>由转场代理提供交互控制器，这是一个遵守<uiviewcontrollerinteractivetransitioning>协议的对象，不过系统已经打包好了现成的类<code>UIPercentDrivenInteractiveTransition</code>供我们使用。我们不需要做任何配置，仅仅在转场代理的相应方法中提供一个该类实例便能工作。另外交互控制器必须有动画控制器才能工作。<br>交互控制器还需要交互手段的配合，最常见的是使用手势，或是其他事件，来驱动整个转场进程。</uiviewcontrollerinteractivetransitioning></p>\n<h3 id=\"使用一个变量来标记交互状态配合转场交互\"><a href=\"#使用一个变量来标记交互状态配合转场交互\" class=\"headerlink\" title=\"使用一个变量来标记交互状态配合转场交互\"></a>使用一个变量来标记交互状态配合转场交互</h3><p>如果在转场代理中提供了交互控制器，而转场发生时并没有方法来驱动转场进程(比如手势)，转场过程将一直处于开始阶段无法结束。<br>在两个容器控制器<code>NavigationController</code>和<code>TabBarController</code>转场为例：</p>\n<ol>\n<li>在 <code>NavigationController</code> 中点击 <code>NavigationBar</code> 也能实现 <code>pop</code> 返回操作，但此时没有了交互手段的支持，转场过程卡壳；</li>\n<li>在 <code>TabBarController</code> 的代理里提供交互控制器存在同样的问题，点击 <code>TabBar</code> 切换页面时也没有实现交互控制。因此仅在确实处于交互状态时才提供交互控制器，可以使用一个变量来标记交互状态，该变量由交互手势来更新状态。</li>\n</ol>\n<h3 id=\"转场动画控制器：向转场中添加视图，执行转场动画\"><a href=\"#转场动画控制器：向转场中添加视图，执行转场动画\" class=\"headerlink\" title=\"转场动画控制器：向转场中添加视图，执行转场动画\"></a>转场动画控制器：向转场中添加视图，执行转场动画</h3><p>转场 API 是协议的好处是不受限于具体的类，只要对象实现该协议便能参与转场过程，这也带来另外一个好处：封装便于复用，尽管三大转场代理协议的方法不尽相同。<br>但它们返回的动画控制器遵守的是同一个协议，因此可以将动画控制器封装作为第三方动画控制器在其他控制器的转场过程中使用。<br><code>UIViewControllerAnimatedTransitioning</code>代理协议方法，提供了转场所需要的重要数据：</p>\n<ol>\n<li><code>containerView()</code>：运行转场动画的容器视图</li>\n<li>转场视图控制器<ul>\n<li>方法一：<code>viewController(forKey:)</code>：<code>UITransitionContextViewControllerKey</code>枚举值：<code>from</code>，<code>to</code></li>\n<li>方法二：<code>viewForKey(_ key: String) -&gt; UIView? AVAILABLE_IOS(8_0)</code>:iOS 8新增 API 用于方便获取参与转场的视图.两个键值：<code>UITransitionContextFromViewKey</code>,<code>UITransitionContextToViewKey</code>.</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleAnimatedTransitioning</span>: <span class=\"title\">NSObject</span>,<span class=\"title\">UIViewControllerAnimatedTransitioning</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//used to determine if the presentation animation is presenting (as opposed to dismissing).</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> isPresentation : <span class=\"type\">Bool</span> = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//returns the duration in seconds of the transition animation.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">transitionDuration</span><span class=\"params\">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class=\"type\">TimeInterval</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//返回动画时间</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0.5</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//get the respective views of these view controllers. </span></span><br><span class=\"line\">    <span class=\"comment\">//Next we get the container view and if the presentation animation is presenting, we add the to view to the container view.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animateTransition</span><span class=\"params\">(using transitionContext: UIViewControllerContextTransitioning)</span></span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//get the from and to view controllers from the UIViewControllerContextTransitioning object.</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> fromVC = transitionContext.viewController(forKey: <span class=\"type\">UITransitionContextViewControllerKey</span>.from)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> toVC = transitionContext.viewController(forKey: <span class=\"type\">UITransitionContextViewControllerKey</span>.to)</span><br><span class=\"line\">        <span class=\"comment\">//determine the start and end positions of the view.</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> fromView = fromVC?.view</span><br><span class=\"line\">        <span class=\"keyword\">let</span> toView = toVC?.view</span><br><span class=\"line\">        <span class=\"keyword\">let</span> containerView = transitionContext.containerView</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> isPresentation </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            containerView.addSubview(toView!)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//decide on which view controller to animate based on whether the transition is a presentation or dismissal</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> animatingVC = isPresentation ? toVC : fromVC</span><br><span class=\"line\">        <span class=\"keyword\">let</span> animatingView = animatingVC?.view</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> finalFrameForVC = transitionContext.finalFrame(<span class=\"keyword\">for</span>: animatingVC!)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> initialFrameForVC = finalFrameForVC</span><br><span class=\"line\">        <span class=\"comment\">//This will animate the view from right to left during a presentation and vice versa during dismissal.</span></span><br><span class=\"line\">        initialFrameForVC.origin.x += initialFrameForVC.size.width</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> initialFrame = isPresentation ? initialFrameForVC : finalFrameForVC</span><br><span class=\"line\">        <span class=\"keyword\">let</span> finalFrame = isPresentation ? finalFrameForVC : initialFrameForVC</span><br><span class=\"line\"></span><br><span class=\"line\">        animatingView?.frame = initialFrame</span><br><span class=\"line\">        <span class=\"comment\">//根据协议中的方法获取动画的时间。</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> duration = transitionDuration(using: transitionContext)</span><br><span class=\"line\">        <span class=\"type\">UIView</span>.animate(withDuration: duration, delay:<span class=\"number\">0</span>, usingSpringWithDamping:<span class=\"number\">300.0</span>, initialSpringVelocity:<span class=\"number\">5.0</span>, options:<span class=\"type\">UIViewAnimationOptions</span>.allowUserInteraction, animations:&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//we move the view to the final position.</span></span><br><span class=\"line\">            animatingView?.frame = finalFrame</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;, completion:&#123; (value: <span class=\"type\">Bool</span>) <span class=\"keyword\">in</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> !<span class=\"keyword\">self</span>.isPresentation &#123;</span><br><span class=\"line\">                <span class=\"comment\">//If the transition is a dismissal, we remove the view.</span></span><br><span class=\"line\">                fromView?.removeFromSuperview()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//we complete the transition by calling transitionContext.completeTransition()</span></span><br><span class=\"line\">            transitionContext.completeTransition(<span class=\"literal\">true</span>)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//    UIView.transitionFromView(fromView, toView: toView, duration: durantion, options: .TransitionCurlDown, completion: &#123; _ in</span></span><br><span class=\"line\">    <span class=\"comment\">//    let isCancelled = transitionContext.transitionWasCancelled()</span></span><br><span class=\"line\">    <span class=\"comment\">//    transitionContext.completeTransition(!isCancelled)</span></span><br><span class=\"line\">    <span class=\"comment\">//    &#125;)</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//如果实现了，会在转场动画结束后调用，可以执行一些收尾工作。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationEnded</span><span class=\"params\">(<span class=\"number\">_</span> transitionCompleted: Bool)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"转场代理协议-Transition-Delegate\"><a href=\"#转场代理协议-Transition-Delegate\" class=\"headerlink\" title=\"转场代理协议(Transition Delegate)\"></a>转场代理协议(Transition Delegate)</h2><p>自定义转场的第一步便是提供转场代理，告诉系统使用我们提供的代理而不是系统的默认代理来执行转场。</p>\n<h3 id=\"实现转场代理协议方法，整合动画控制器和自定义展示控制器\"><a href=\"#实现转场代理协议方法，整合动画控制器和自定义展示控制器\" class=\"headerlink\" title=\"实现转场代理协议方法，整合动画控制器和自定义展示控制器\"></a>实现转场代理协议方法，整合动画控制器和自定义展示控制器</h3><ol>\n<li>返回管理用户信息视图控制器如何展示的控制器。前面实现的<code>ExamplePresentationViewController</code>类可同时处理 <code>presentation</code>转场 和 <code>dismissal</code> 转场。</li>\n<li>动画控制器为 <code>presentation</code> 和 <code>dismissal</code> 转场分别提供了动画控制器。<blockquote>\n<p><code>UIPresentationController</code>只在 iOS 8中可用，通过available关键字可以解决 API 的版本差异。</p>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleTransitioningDelegate</span>: <span class=\"title\">NSObject</span>,<span class=\"title\">UIViewControllerTransitioningDelegate</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//returns a presentation controller that manages the presentation of a view controller.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationController</span><span class=\"params\">(forPresented presented: UIViewController, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                            presenting: UIViewController?, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                source: UIViewController)</span></span> -&gt; <span class=\"type\">UIPresentationController</span>? </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//presentation动画控制器</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> presentationController = <span class=\"type\">ExamplePresentationViewController</span>(presentedViewController:presented, </span><br><span class=\"line\">                                                                                    presenting:presenting)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> presentationController</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//为presentation转场提供登场转场动画控制器</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationController</span><span class=\"params\">(forPresented presented: UIViewController, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                         presenting: UIViewController, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                             source: UIViewController)</span></span> -&gt; <span class=\"type\">UIViewControllerAnimatedTransitioning</span>? </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//登场转场动画控制器</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> animator = <span class=\"type\">ExampleAnimatedTransitioning</span>()</span><br><span class=\"line\">        animator.isPresentation = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> animator</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//为dismissal 转场提供退场转场动画控制器</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationController</span><span class=\"params\">(forDismissed dismissed: UIViewController)</span></span> -&gt; <span class=\"type\">UIViewControllerAnimatedTransitioning</span>? </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//退场转场动画控制器</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> animator = <span class=\"type\">ExampleAnimatedTransitioning</span>()</span><br><span class=\"line\">        animator.isPresentation = <span class=\"literal\">false</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> animator</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用自定义的转场的代理\"><a href=\"#使用自定义的转场的代理\" class=\"headerlink\" title=\"使用自定义的转场的代理\"></a>使用自定义的转场的代理</h3><p>自定义转场的第一步便是提供转场代理，告诉系统使用我们提供的代理而不是系统的默认代理来执行转场。<br>UIViewControllerTransitioningDelegate转场代理：</p>\n<ol>\n<li>强引用代理变量:强引用的变量来维护该代理</li>\n<li>Modal转场代理的特性：由presentedVC自身来遵循转场代理<code>presentedVC.modalPresentationStyle</code>，和前两个容器控制器转场代理不同。</li>\n<li>两种支持自定义转场模式：<code>.Custom</code>或<code>.FullScreen</code>,默认值为<code>.FullScreen</code><figure class=\"highlight swift\"><figcaption><span>fromVC.class</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//强引用的变量来维护该代理</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> exampleTransitionDelegate = <span class=\"type\">ExampleTransitioningDelegate</span>()</span><br><span class=\"line\"><span class=\"comment\">//create an instance of ExampleViewController which will provide the content to display.</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> presentedVC = <span class=\"type\">ExampleViewController</span>()</span><br><span class=\"line\">presentedVC.modalPresentationStyle = .custom</span><br><span class=\"line\">presentedVC.transitioningDelegate = exampleTransitionDelegate</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//present this view controller.</span></span><br><span class=\"line\">present(toVC, animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"两种常规的转场方式\"><a href=\"#两种常规的转场方式\" class=\"headerlink\" title=\"两种常规的转场方式\"></a>两种常规的转场方式</h2><h3 id=\"UIView方式-transitionFromView\"><a href=\"#UIView方式-transitionFromView\" class=\"headerlink\" title=\"UIView方式:transitionFromView\"></a>UIView方式:transitionFromView</h3><p>不需要获取 <code>containerView</code> 以及手动添加 <code>toView</code> 就能实现一个指定类型的转场动画，而缺点则是只能使用指定类型的动画。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UIView</span>.transitionFromView(fromView, toView: toView, duration: durantion, options: .<span class=\"type\">TransitionCurlDown</span>, completion: &#123; <span class=\"number\">_</span> <span class=\"keyword\">in</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isCancelled = transitionContext.transitionWasCancelled()</span><br><span class=\"line\">transitionContext.completeTransition(!isCancelled)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"UIViewController方式：在子-VC-间转换的方法\"><a href=\"#UIViewController方式：在子-VC-间转换的方法\" class=\"headerlink\" title=\"UIViewController方式：在子 VC 间转换的方法\"></a>UIViewController方式：在子 VC 间转换的方法</h3><p>该方法用 toVC 的视图转换 fromVC 的视图在父视图中的位置，并且执行<code>animations闭包</code>里的动画。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transitionFromViewController:toViewController:duration:options:animations:completion:</span><br></pre></td></tr></table></figure><br>该方法仅限于在自定义容器控制器里使用，如果直接使用 <code>UINavigationController</code> 和 <code>UITabBarController</code> 调用该方法执行子VC间转换会抛出异常。</p>\n<blockquote>\n<p>不过 iOS 7 中这两个容器控制器开放的自定义转场做的是同样的事情，回头再看第一章 Transition 解释，转场协议 API 将这个方法拆分成了上面的几个组件，并且加入了激动人心的交互控制，以便我们能够方便定制转场动画。</p>\n</blockquote>\n<p><a href=\"http://www.appcoda.com/presentation-controllers-tutorial/\" target=\"_blank\" rel=\"noopener\">原文</a></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"转场","path":"api/categories/转场.json"}],"tags":[{"name":"动画","path":"api/tags/动画.json"},{"name":"转场","path":"api/tags/转场.json"}]},{"title":"整理iOS中几种常用的展示型视图控制器","slug":"iOS中几种常用的展示控制器使用","date":"2017-02-16T17:53:18.000Z","updated":"2017-02-16T21:56:31.000Z","comments":true,"path":"api/articles/iOS中几种常用的展示控制器使用.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/iPhoneipadalert.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><a href=\"https://www.dropbox.com/s/4gj6levvlav2xzc/PresentationsDemoStart.zip?dl=0\" target=\"_blank\" rel=\"noopener\">开始项目</a><br><a href=\"https://github.com/appcoda/Presentation-Controllers-Demo\" target=\"_blank\" rel=\"noopener\">完整项目</a></p>\n<h2 id=\"UIAlertController\"><a href=\"#UIAlertController\" class=\"headerlink\" title=\"UIAlertController\"></a>UIAlertController</h2><p>在iOS8中，提供<code>UIAlertController</code>控制器代替<code>UIAlertView</code>和<code>UIActionSheet</code>两个控件。给用户展示提示信息的新的一种方式。</p>\n<h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><ol>\n<li>能够自适应的（在iPad上，an <code>action sheet</code> style alert will present itself in a popover），</li>\n<li>显示方式：可以轻松切换<code>Action sheets</code>和<code>alert view</code>两种显示样式<code>alert view</code>被以modal态显示presenting视图控制器上，<code>Action sheets</code>被固定在以屏幕底部。 </li>\n<li>按钮事件实现：使用闭包的方式来处理，相较之前通过实现代理的方式要简单很多。</li>\n<li>子控件支持：<code>Alert view</code>支持按钮和输入框两种，Action sheets仅支持按钮一种控件。</li>\n<li>不同于以往的两类<code>UIAlertController</code>继承自<code>UIViewController</code>。这意味着可以使用视图控制器提供展示信息的功能。</li>\n</ol>\n<h3 id=\"创建使用UIAlertController\"><a href=\"#创建使用UIAlertController\" class=\"headerlink\" title=\"创建使用UIAlertController\"></a>创建使用UIAlertController</h3><p>用<code>title</code>，<code>message</code>参数来实例化<code>alertController</code>实例，然后在实例中添加两个闭包的按钮<br><figure class=\"highlight swift\"><figcaption><span>showAlertWasTapped</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@IBAction</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">showAlertWasTapped</span><span class=\"params\">(sender: UIButton)</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> alertController = <span class=\"type\">UIAlertController</span>(title: <span class=\"string\">\"Appcoda\"</span>, message: <span class=\"string\">\"Message in alert dialog\"</span>, preferredStyle: <span class=\"type\">UIAlertControllerStyle</span>.<span class=\"type\">Alert</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> deleteAction = <span class=\"type\">UIAlertAction</span>(title: <span class=\"string\">\"Delete\"</span>, style: <span class=\"type\">UIAlertActionStyle</span>.<span class=\"type\">Destructive</span>, handler: &#123;(alert :<span class=\"type\">UIAlertAction</span>!) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"built_in\">println</span>(<span class=\"string\">\"Delete button tapped\"</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    alertController.addAction(deleteAction)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> okAction = <span class=\"type\">UIAlertAction</span>(title: <span class=\"string\">\"OK\"</span>, style: <span class=\"type\">UIAlertActionStyle</span>.<span class=\"type\">Default</span>, handler: &#123;(alert :<span class=\"type\">UIAlertAction</span>!) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"built_in\">println</span>(<span class=\"string\">\"OK button tapped\"</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    alertController.addAction(okAction)</span><br><span class=\"line\"></span><br><span class=\"line\">    presentViewController(alertController, animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>运行效果：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/iPhoneipadalert.png?imageMogr2/2/w/800\"></p>\n<h3 id=\"UIAlertControllerStyle枚举：Alert切换ActionSheet\"><a href=\"#UIAlertControllerStyle枚举：Alert切换ActionSheet\" class=\"headerlink\" title=\"UIAlertControllerStyle枚举：Alert切换ActionSheet\"></a>UIAlertControllerStyle枚举：<code>Alert</code>切换<code>ActionSheet</code></h3><p>在<code>UIAlertController</code>之前，切换<code>alert</code>和<code>action sheet</code>需要重写大量的代码，但现在只需要改变一个枚举值<code>UIAlertControllerStyle.Alert</code>为<code>UIAlertControllerStyle.ActionSheet</code>.<br><figure class=\"highlight swift\"><figcaption><span>UIAlertControllerStyle.ActionSheet</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> alertController = <span class=\"type\">UIAlertController</span>(title: <span class=\"string\">\"Appcoda\"</span>, message: <span class=\"string\">\"Message in alert dialog\"</span>, preferredStyle: <span class=\"type\">UIAlertControllerStyle</span>.<span class=\"type\">ActionSheet</span>)</span><br></pre></td></tr></table></figure><br>在iPhone上，屏幕底部显示一个<code>action sheet</code>。<br>问题：在iPad上，点击上面的按钮崩溃，需要定义锚点位置。</p>\n<h3 id=\"popoverPresentationController锚点：sourceView-sourceRect\"><a href=\"#popoverPresentationController锚点：sourceView-sourceRect\" class=\"headerlink\" title=\"popoverPresentationController锚点：sourceView/sourceRect\"></a>popoverPresentationController锚点：sourceView/sourceRect</h3><p><code>popover controller</code>在<code>alertController</code>视图内展示，需要一个<code>popover箭头</code>指向<code>alertController</code>视图的某一位置。<br>通过设置<code>sourceView</code>来确定<code>popover箭头</code>位置，这个<code>popover</code>以及<code>popover箭头</code>指向的矩形区域都在这个<code>sourceView</code>上。<br>在调用<code>presentViewController()</code>之前添加代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alertController.popoverPresentationController?.sourceView = view</span><br><span class=\"line\">alertController.popoverPresentationController?.sourceRect = sender.frame</span><br></pre></td></tr></table></figure><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/popover箭头.png?imageMogr2/2/w/800\"></p>\n<h2 id=\"UIPopoverPresentationController\"><a href=\"#UIPopoverPresentationController\" class=\"headerlink\" title=\"UIPopoverPresentationController\"></a>UIPopoverPresentationController</h2><p><code>Alert</code>主要用于显示用户的提示信息，当展示的信息很多时，就需要借助<code>popover presentation controller</code>。</p>\n<h3 id=\"在compact和regular两种屏幕中显示模态视图\"><a href=\"#在compact和regular两种屏幕中显示模态视图\" class=\"headerlink\" title=\"在compact和regular两种屏幕中显示模态视图\"></a>在compact和regular两种屏幕中显示模态视图</h3><p>在<code>storyboard</code>文件，设置视图的<code>storyboard ID</code>:<code>PopoverViewController</code>，设置模态视图展示样式，展示在<code>compact-width</code>和<code>regular-width</code>的两种设备屏幕上。<br>实现如下：<br><figure class=\"highlight swift\"><figcaption><span>actionWasTapped</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@IBAction</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">actionWasTapped</span><span class=\"params\">(sender: UIBarButtonItem)</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> storyboard : <span class=\"type\">UIStoryboard</span> = <span class=\"type\">UIStoryboard</span>(name: <span class=\"string\">\"Main\"</span>, bundle: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> vc = storyboard.instantiateViewControllerWithIdentifier(<span class=\"string\">\"PopoverViewController\"</span>) <span class=\"keyword\">as</span>! <span class=\"type\">UIViewController</span></span><br><span class=\"line\">    vc.modalPresentationStyle = <span class=\"type\">UIModalPresentationStyle</span>.<span class=\"type\">Popover</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> popover: <span class=\"type\">UIPopoverPresentationController</span> = vc.popoverPresentationController!</span><br><span class=\"line\">    popover.barButtonItem = sender  <span class=\"comment\">//`popover箭头`锚的位置</span></span><br><span class=\"line\">    presentViewController(vc, animated: <span class=\"literal\">true</span>, completion:<span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"设置锚点四种方式\"><a href=\"#设置锚点四种方式\" class=\"headerlink\" title=\"设置锚点四种方式\"></a>设置锚点四种方式</h4><ol>\n<li>barButtonItem<br>先获取该视图控制器的<code>popoverPresentationController</code>控制器，通过<code>popover</code>控制器的<code>barButtonItem</code>属性来设置锚点控件。当弹出时<code>popover箭头</code>就指向这个barButtonItem控件。</li>\n<li>通过指定<code>sourceView</code>和<code>sourceRect</code>两个属性，就像前面例子中一样来指定锚点位置。</li>\n<li>通过其他属性来实现，例如：<code>permittedArrowDirections</code>，也能够指定锚点。</li>\n<li>如果在在展示过程中，无法确定箭头的方向时，就是用默认值：<code>UIPopoverArrowDirection.Any</code>.<br>在iPad显示：</li>\n</ol>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/UIPopoverArrowDirection.png?imageMogr2/2/w/800\">\n<p>在iPhone上以模态显示：</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/iPhonemodally.png?imageMogr2/2/w/800\">\n<h3 id=\"在iPhone设备上dissmiss模态视图\"><a href=\"#在iPhone设备上dissmiss模态视图\" class=\"headerlink\" title=\"在iPhone设备上dissmiss模态视图\"></a>在iPhone设备上dissmiss模态视图</h3><p>要在iPhone设备上，实现模态视图dissmiss功能，需要借助导航控制器，同时这个模态视图需要遵循<code>UIPopoverPresentationController</code>协议，实现两个代理方法</p>\n<h4 id=\"实现UIPopoverPresentationController协议\"><a href=\"#实现UIPopoverPresentationController协议\" class=\"headerlink\" title=\"实现UIPopoverPresentationController协议\"></a>实现<code>UIPopoverPresentationController</code>协议</h4><ol>\n<li><code>PopoverViewController</code>类定义修改如下:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PopoverViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">UIPopoverPresentationControllerDelegate</span> </span>&#123;</span><br></pre></td></tr></table></figure></li>\n<li>在actionWasTapped()函数中调用<code>presentViewController()</code>之前添加：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">popover.delegate = <span class=\"keyword\">self</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法一：返回自适应设备的视图展示样式\"><a href=\"#方法一：返回自适应设备的视图展示样式\" class=\"headerlink\" title=\"方法一：返回自适应设备的视图展示样式\"></a>方法一：返回自适应设备的视图展示样式</h4>当APP在<code>compact-width</code>设备上弹出一个视图时调用.这个方法告诉OS系统使用的视图展示样式。<br>这里OS系统被告知在<code>compact-width</code>设备上，使用全屏的样式展示视图。<figure class=\"highlight swift\"><figcaption><span>adaptivePresentationStyleForPresentationController()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">adaptivePresentationStyleForPresentationController</span><span class=\"params\">(controller: UIPresentationController)</span></span> -&gt; <span class=\"type\">UIModalPresentationStyle</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">UIModalPresentationStyle</span>.<span class=\"type\">FullScreen</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二：返回自定义的视图控制器\"><a href=\"#方法二：返回自定义的视图控制器\" class=\"headerlink\" title=\"方法二：返回自定义的视图控制器\"></a>方法二：返回自定义的视图控制器</h4>当前展现的视图和原来的展示方式不同时调用.我们设置这个视图的<code>Popover presentation</code>展示方式，但是我们指定在<code>compact-width</code>设备上，这样它会以full screen样式展示。在这个函数中，样式切换发生时，会return自定义的视图控制器。<figure class=\"highlight swift\"><figcaption><span>presentationController(_:viewControllerForAdaptivePresentationStyle)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationController</span><span class=\"params\">(controller: UIPresentationController, viewControllerForAdaptivePresentationStyle style: UIModalPresentationStyle)</span></span> -&gt; <span class=\"type\">UIViewController</span>? </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> navigationController = <span class=\"type\">UINavigationController</span>(rootViewController: controller.presentedViewController)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> btnDone = <span class=\"type\">UIBarButtonItem</span>(title: <span class=\"string\">\"Done\"</span>, style: .<span class=\"type\">Done</span>, target: <span class=\"keyword\">self</span>, action: <span class=\"string\">\"dismiss\"</span>)</span><br><span class=\"line\">    navigationController.topViewController.navigationItem.rightBarButtonItem = btnDone</span><br><span class=\"line\">    <span class=\"keyword\">return</span> navigationController</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"Done按钮的dismiss事件\"><a href=\"#Done按钮的dismiss事件\" class=\"headerlink\" title=\"Done按钮的dismiss事件\"></a><code>Done</code>按钮的dismiss事件</h4><p>在导航控制器中国封装这个视图，在导航条上添加一个<code>Done</code>按钮，点击<code>Done</code>dismiss这个视图<br><figure class=\"highlight swift\"><figcaption><span>dismiss</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dismiss</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.dismissViewControllerAnimated(<span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在iPhone上，显示修改后的视图控制器，多出带按钮的导航栏。<br>在iPad上，视图控制器显示没有导航控制器，因为它不使用全屏幕显示。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/adaptivePresentationStyleForPresentationController.png?imageMogr2/2/w/800\"><br>如果想让iPhone像iPad一样显示一个Popover，只<code>adaptivePresentationStyleForPresentationController</code>返回：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"type\">UIModalPresentationStyle</span>.<span class=\"type\">None</span></span><br></pre></td></tr></table></figure><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/UIModalPresentationStyle.None.png?imageMogr2/2/w/800\"></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"转场","path":"api/categories/转场.json"}],"tags":[{"name":"动画","path":"api/tags/动画.json"},{"name":"转场","path":"api/tags/转场.json"},{"name":"UI","path":"api/tags/UI.json"}]}]}