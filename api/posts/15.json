{"total":157,"pageSize":10,"pageCount":16,"data":[{"title":"如何使用gitBook协作Octopress同时完成博客和书籍","slug":"git/如何使用gitBook协作Octopress同时完成博客和书籍","date":"2015-08-11T14:41:40.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/如何使用gitBook协作Octopress同时完成博客和书籍.json","excerpt":null,"keywords":null,"cover":"https://raw.githubusercontent.com/huos3203/IOSDev/master/EAC7C104-FCE1-40CF-9766-F14C4F271FCF.png","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"将gitbook添加到github库中\"><a href=\"#将gitbook添加到github库中\" class=\"headerlink\" title=\"将gitbook添加到github库中\"></a>将gitbook添加到github库中</h4><ul>\n<li>使用gitbook新建New book，即在~/GitBook/Library/Import/yourbookName/下，创建了git库</li>\n<li>菜单：Book -&gt; Repository setting… -&gt; <img src=\"https://raw.githubusercontent.com/huos3203/IOSDev/master/EAC7C104-FCE1-40CF-9766-F14C4F271FCF.png\" alt=\"设置库路径\"></li>\n<li>使用SourceTree版本工具，添加本地的yourbookName版本库，来协助gitbook管理版本。</li>\n</ul>\n<h4 id=\"协助Octopress\"><a href=\"#协助Octopress\" class=\"headerlink\" title=\"协助Octopress\"></a>协助Octopress</h4><ul>\n<li>必须在yourBlog目录下，执行rake newe_post[‘’]创建.MarkDown文件。</li>\n<li>将第一步新建的文件，通过Gitbook的Files tree 树形栏，导入yourbookname版本库中。</li>\n<li>在gitbook的Table of Contents中新建章节，命名为第一步创建时的文件名。</li>\n<li>编辑yourbookName 版本库中的SUMMARY.md，将文件与目录关联起来，并保存SUMMARY.md。</li>\n<li>点击目录节点名，即可在编辑框内，对该md文件编辑。</li>\n</ul>\n<h4 id=\"如何将gitbook编辑的md文件内容同步到Octopress中\"><a href=\"#如何将gitbook编辑的md文件内容同步到Octopress中\" class=\"headerlink\" title=\"如何将gitbook编辑的md文件内容同步到Octopress中\"></a>如何将gitbook编辑的md文件内容同步到Octopress中</h4><ul>\n<li>方法一：拷贝gitbook编辑的md文件，覆盖到octpress的_post目录下。</li>\n<li>方法二：通过github，公用一个版本库，来管理同步。</li>\n</ul>\n<p><font color=\"red\">更新：</font>gitbook 4.2.2之后，默认将rake new_post生成的文件目录导入到~/gitbook目录中，至此，以上方法作废了。</p>\n<p>使用GitBook（<strong>版本限于4.0之前的版本</strong>） 来编写Octopress博客的步骤：  </p>\n<ol>\n<li><code>cd ~/MyBlog</code>  </li>\n<li><strong><code>rake new_post[&#39;文章名&#39;]</code></strong>或 <strong><code>rake new_page[&#39;404&#39;]</code></strong>新建md文档.  </li>\n<li><strong><code>mv *.markdown *.md</code></strong> mv命令修改后缀为md，便于gitbook在Preview website识别该文档。  </li>\n<li>配置SUMMARY.md 关联 gitbook，通过目录访问Octopress文档。  </li>\n<li>打开gitbook客户端，对新建的文档进行编写即可。</li>\n</ol>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"IDE","path":"api/categories/IDE.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"gitBook","path":"api/tags/gitBook.json"}]},{"title":"快速正确的安装Ruby,Rails运行环境","slug":"工具/快速正确的安装Ruby,Rails运行环境","date":"2015-01-21T23:00:39.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/工具/快速正确的安装Ruby,Rails运行环境.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>安装ruby环境：<br>方法一：下载源码，编译安装：<a href=\"http://fsjoy.blog.51cto.com/318484/115045/\" target=\"_blank\" rel=\"noopener\">配置中制定安装目录</a><br>方法二：使用rvm安装：<a href=\"https://ruby-china.org/wiki/rvm-guide\" target=\"_blank\" rel=\"noopener\">可以提供一个便捷的多版本 Ruby 环境的管理和切换</a><br>方法三：使用macport安装 <code>port install ruby</code></p>\n<p><a href=\"https://ruby-china.org/wiki/install_ruby_guide\" target=\"_blank\" rel=\"noopener\">详细教程</a></p>\n<p>问题：<br><code>ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/rake</code><br><a href=\"http://stackoverflow.com/questions/30812777/cannot-install-cocoa-pods-after-uninstalling-results-in-error/30851030#30851030\" target=\"_blank\" rel=\"noopener\">stackoverflow方法</a>测试结果没走通。<br>最终通过<a href=\"http://tadaland.com/os-x-rootless.html\" target=\"_blank\" rel=\"noopener\">OS X 10.11中Rootless的实现与解释以及关闭方法</a>解决.</p>\n<h4 id=\"Gem介绍\"><a href=\"#Gem介绍\" class=\"headerlink\" title=\"Gem介绍\"></a>Gem介绍</h4><p>Gem是一个ruby库和程序的标准包，它通过RubyGem来定位、安装、升级和卸载，非常的便捷。</p>\n<p>Ruby 1.9.2版本默认安装RubyGem，如果你使用其它版本，请参考如何安装RubyGem。<br><a id=\"more\"></a></p>\n<h4 id=\"升级RubyGem\"><a href=\"#升级RubyGem\" class=\"headerlink\" title=\"升级RubyGem\"></a>升级RubyGem</h4><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gem update --system</span><br></pre></td></tr></table></figure>\n<h4 id=\"安装新的Gem\"><a href=\"#安装新的Gem\" class=\"headerlink\" title=\"安装新的Gem\"></a>安装新的Gem</h4><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gem install rai</span><br><span class=\"line\"></span><br><span class=\"line\">/<span class=\"regexp\">/指定安装某一版本的Gem包</span></span><br><span class=\"line\"><span class=\"regexp\">gem install [gemname] --version=1.3.2</span></span><br></pre></td></tr></table></figure>\n<p>在安装过程中可以看到如下提示，说明它是从rubygems.org内去寻找并安装gem package的。<br>Fetching source index for <a href=\"http://rubygems.org/\" target=\"_blank\" rel=\"noopener\">http://rubygems.org/</a></p>\n<h4 id=\"gem-的安装方式\"><a href=\"#gem-的安装方式\" class=\"headerlink\" title=\"gem 的安装方式\"></a>gem 的安装方式</h4><h4 id=\"MacPorts安装和使用\"><a href=\"#MacPorts安装和使用\" class=\"headerlink\" title=\"MacPorts安装和使用\"></a>MacPorts安装和使用</h4><p><a href=\"http://ccvita.com/434.html\" target=\"_blank\" rel=\"noopener\">http://ccvita.com/434.html</a><br><a href=\"http://guide.macports.org\" target=\"_blank\" rel=\"noopener\">http://guide.macports.org</a><br><a href=\"http://www.fantageek.com/318/install-pkg-config-for-mac-osx/\" target=\"_blank\" rel=\"noopener\">http://www.fantageek.com/318/install-pkg-config-for-mac-osx/</a>  </p>\n<p>Mac下面除了用dmg、pkg来安装软件外，比较方便的还有用MacPorts来帮助你安装其他应用程序，跟BSD中的ports道理一样。MacPorts就像apt-get、yum一样，可以快速安装些软件。</p>\n<p>安装后，配置：</p>\n<pre><code>sudo vi /etc/profile\nexport PATH=/opt/local/bin:$PATH\nexport PATH=/opt/local/sbin:$PATH\n</code></pre><p>MacPorts使用 <a href=\"http://witcheryne.iteye.com/blog/991821\" target=\"_blank\" rel=\"noopener\">http://witcheryne.iteye.com/blog/991821</a></p>\n<ol>\n<li><p>更新ports tree和MacPorts版本，强烈推荐第一次运行的时候使用-v参数，显示详细的更新过程。<br>sudo port -v selfupdate</p>\n</li>\n<li><p>搜索索引中的软件</p>\n<p> port search name</p>\n</li>\n<li><p>安装新软件<br>sudo port install name</p>\n</li>\n<li><p>卸载软件<br>sudo port uninstall name</p>\n</li>\n<li><p>查看有更新的软件以及版本<br>port outdated</p>\n</li>\n<li><p>升级可以更新的软件<br>sudo port upgrade outdated</p>\n</li>\n</ol>\n<p>实例：<br>Eclipse的插件需要subclipse需要JavaHL，下面通过MacPorts来安装</p>\n<pre><code>sudo port install subversion-javahlbindings\n\ninstalled \n</code></pre><p>列出全部或者指定的已经安装的软件：</p>\n<pre><code>port installed\nport -v installed atlas\n</code></pre><p>dependents 查看哪些软件时依赖与这个软件的</p>\n<pre><code>删除一个软件时候，最好先执行一下这个命令.\n    port dependents openssl\n</code></pre>","raw":null,"categories":[{"name":"工具","path":"api/categories/工具.json"},{"name":"ruby","path":"api/categories/ruby.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"脚本","path":"api/tags/脚本.json"},{"name":"安装","path":"api/tags/安装.json"}]},{"title":"Git中的储藏工具stash","slug":"git/Git中的储藏工具stash","date":"2015-01-19T19:57:04.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/Git中的储藏工具stash.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><ol>\n<li><a href=\"#Stashing\">Stashing</a></li>\n<li><a href=\"#work\">储藏工作</a></li>\n<li><a href=\"#apply\">应用储藏</a></li>\n<li><a href=\"#applyIndex\">被暂存的文件重新暂存</a></li>\n<li><a href=\"#drop\">应用后，移除储藏的内容</a></li>\n<li><a href=\"#unapply\">取消储藏(Un-applying a Stash)</a></li>\n<li><a href=\"#stash-unapply\">新建stash-unapply别名</a></li>\n<li><a href=\"#stashBranch\">从储藏中创建分支</a></li>\n</ol>\n<h3 id=\"Git工具-储藏（Stashing）git\"><a href=\"#Git工具-储藏（Stashing）git\" class=\"headerlink\" title=\"Git工具 - 储藏（Stashing）git\"></a><a name=\"Stashing\">Git工具 - 储藏（Stashing）</a>git</h3><hr>\n<p><a href=\"https://git-scm.com/book/zh/v2/Git-工具-储藏与清理\" target=\"_blank\" rel=\"noopener\">原文</a><br>场景：当项目中某一部分正在编码中，突然接到新任务，又必须换至其他分支去完成。</p>\n<p>问题：你不想提交进行了一半的工作，否则以后你无法回到这个工作点。</p>\n<p>解决：<strong><font color=\"red\">git stash </font></strong>命令。</p>\n<p>“Stashing”可以获取工作目录的中间状态，即：将修改过的被追踪的文件和暂存的变更，保存到一个未完结变更的堆栈中，随时可以重新应用。</p>\n<h3 id=\"储藏工作\"><a href=\"#储藏工作\" class=\"headerlink\" title=\"储藏工作\"></a><a name=\"work\">储藏工作</a></h3><hr>\n<ol>\n<li>进入项目目录，修改某个文件，有可能还暂存其中的一个变更。</li>\n<li><strong><font color=\"red\">git status </font></strong>命令,查看中间状态：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\"># Changes to be committed:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   index.html</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   lib/simplegit.rb</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure></li>\n<li>切换分支，但不提交step 1 中的变更，所以储藏这些变更。<br>执行<strong><font color=\"red\">git stash </font></strong>命令，往堆栈中推送一个新的储藏：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash</span><br><span class=\"line\">Saved working directory and index state \\</span><br><span class=\"line\">  <span class=\"string\">\"WIP on master: 049d078 added the index file\"</span></span><br><span class=\"line\">HEAD is now at 049d078 added the index file</span><br><span class=\"line\">(To restore them <span class=\"built_in\">type</span> <span class=\"string\">\"git stash apply\"</span>)</span><br></pre></td></tr></table></figure></li>\n<li>执行step 2查看目录库，中间状态就不见了：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\"><span class=\"comment\">#######On branch master</span></span><br><span class=\"line\">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>\n这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。</li>\n<li>使用<strong><font color=\"red\">git stash list</font></strong>要查看现有的储藏：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash list</span><br><span class=\"line\">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class=\"line\">stash@&#123;1&#125;: WIP on master: c264051 Revert <span class=\"string\">\"added file_size\"</span></span><br><span class=\"line\">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to <span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n在这个案例中，之前已经进行了两次储藏，所以你可以访问到三个不同的储藏。<h3 id=\"应用储藏\"><a href=\"#应用储藏\" class=\"headerlink\" title=\"应用储藏\"></a><a name=\"apply\">应用储藏</a></h3></li>\n</ol>\n<hr>\n<p>执行<strong><font color=\"red\">git stash apply</font></strong>命令, 可以重新应用最近的一次储藏；<br>执行<strong><font color=\"red\">git stash apply stash@{2}</font></strong>命令，即通过指定储藏的名字，来应用更早的储藏。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash apply</span><br><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   index.html</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   lib/simplegit.rb</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure><br><a id=\"more\"></a><br>可以看到 Git 重新修改了你所储藏的那些当时尚未提交的文件。在这个案例里，你尝试应用储藏的工作目录是干净的，并且属于同一分支；但是一个干净的工作目录和应用到相同的分支上并不是应用储藏的必要条件。你可以在其中一个分支上保留一份储藏，随后切换到另外一个分支，再重新应用这些变更。在工作目录里包含已修改和未提交的文件时，你也可以应用储藏——Git 会给出归并冲突如果有任何变更无法干净地被应用。</p>\n<h3 id=\"被暂存的文件重新暂存\"><a href=\"#被暂存的文件重新暂存\" class=\"headerlink\" title=\"被暂存的文件重新暂存\"></a><a name=\"applyIndex\">被暂存的文件重新暂存</a></h3><hr>\n<p>执行<strong><font color=\"red\">git stash apply</font></strong>命令,虽然对文件的变更被重新应用，但是被暂存的文件没有重新被暂存。<br>执行<strong><font color=\"red\">git stash apply –index</font></strong>命令,即可让被暂存的文件重新暂存。<br><strong>–index</strong>选项告诉命令重新应用被暂存的变更：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash apply --index</span><br><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\"># Changes to be committed:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   index.html</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   lib/simplegit.rb</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"应用后，移除储藏的内容\"><a href=\"#应用后，移除储藏的内容\" class=\"headerlink\" title=\"应用后，移除储藏的内容\"></a><a name=\"drop\">应用后，移除储藏的内容</a></h3><hr>\n<p><strong>apply </strong>选项只尝试应用储藏的工作——储藏的内容仍然在栈上。<br>执行<strong><font color=\"red\">git stash drop 储藏的名字</font></strong>命令，，即可从栈中彻底移除储藏内容：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash list</span><br><span class=\"line\">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class=\"line\">stash@&#123;1&#125;: WIP on master: c264051 Revert <span class=\"string\">\"added file_size\"</span></span><br><span class=\"line\">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to <span class=\"built_in\">log</span></span><br><span class=\"line\">$ git stash drop stash@&#123;0&#125;</span><br><span class=\"line\">Dropped stash@&#123;0&#125; (364e91f3f268f0900bc3ee613f9f733e82aaed43)</span><br></pre></td></tr></table></figure><br>你也可以运行 <strong><font color=\"red\">git stash pop</font></strong>命令，来重新应用储藏，同时立刻将其从堆栈中移走。</p>\n<h3 id=\"取消储藏-Un-applying-a-Stash\"><a href=\"#取消储藏-Un-applying-a-Stash\" class=\"headerlink\" title=\"取消储藏(Un-applying a Stash)\"></a><a name=\"unapply\">取消储藏(Un-applying a Stash)</a></h3><hr>\n<p>在某些情况下，重新应用了之前的储藏的变更，进行了一些其他的修改后，又想要取消之前所应用储藏的修改。<br>Git没有提供类似于 <strong><font color=\"red\">stash unapply</font></strong>的命令，但是可以通过取消该储藏的补丁达到同样的效果：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash show -p stash@&#123;0&#125; | git apply -R</span><br></pre></td></tr></table></figure><br>同样的，如果你沒有指定具体的某个储藏，Git 会选择最近的储藏：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash show -p | git apply -R</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"新建stash-unapply别名\"><a href=\"#新建stash-unapply别名\" class=\"headerlink\" title=\"新建stash-unapply别名\"></a><a name=\"stash-unapply\">新建stash-unapply别名</a></h4><hr>\n<p>你可能会想要新建一个別名，在你的 Git 里增加一个<strong><font color=\"red\">stash-unapply</font></strong> 命，这样更有效率。例如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global alias.stash-unapply <span class=\"string\">'!git stash show -p | git apply -R'</span></span><br><span class=\"line\">$ git stash apply</span><br><span class=\"line\">$ <span class=\"comment\">#... work work work</span></span><br><span class=\"line\">$ git stash-unapply</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"从储藏中创建分支\"><a href=\"#从储藏中创建分支\" class=\"headerlink\" title=\"从储藏中创建分支\"></a><a name=\"stashBranch\">从储藏中创建分支</a></h3><hr>\n<p>如果你储藏了一些工作，暂时不去理会，然后继续在你储藏工作的分支上工作，你在重新应用工作时可能会碰到一些问题。如果尝试应用的变更是针对一个你那之后修改过的文件，你会碰到一个归并冲突并且必须去化解它。如果你想用更方便的方法来重新检验你储藏的变更，你可以运行 git stash branch，这会创建一个新的分支，检出你储藏工作时的所处的提交，重新应用你的工作，如果成功，将会丢弃储藏。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash branch testchanges</span><br><span class=\"line\">Switched to a new branch <span class=\"string\">\"testchanges\"</span></span><br><span class=\"line\"><span class=\"comment\"># On branch testchanges</span></span><br><span class=\"line\"><span class=\"comment\"># Changes to be committed:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   index.html</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#      modified:   lib/simplegit.rb</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">Dropped refs/stash@&#123;0&#125; (f0dfc4d5dc332d1cee34a634182e168c4efc3359)</span><br></pre></td></tr></table></figure><br>这是一个很棒的捷径来恢复储藏的工作然后在新的分支上继续当时的工作。</p>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"工具","path":"api/categories/工具.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"git","path":"api/tags/git.json"},{"name":"坑","path":"api/tags/坑.json"}]},{"title":"XMPP简单研究[转]","slug":"开源库/XMPP简单研究[转]","date":"2015-01-06T14:36:06.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/开源库/XMPP简单研究[转].json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>最近想做一个游戏服务器和 IM 互通的服务。最初的想法是可以增进游戏帐号的安全，比如游戏用户可以通过绑定一个 IM 帐号，从而不用登陆游戏就向游戏服务器发一些指令。这些指定通常是用来冻结一些帐号的功能。而游戏服务器也可以通过 IM 帐号向离线用户发送一些关键消息。这样，只需要解除绑定 IM 帐号需要一定的时间，或使用更安全的途径，即可以让游戏帐号更加安全。（至少，游戏用户可以从 IM 上获知他的游戏帐号每次登陆登出的时间、IP 等等）</p>\n<p>后来细想，这里面可以做的东西还有许多。玩家会因为多一个信息通道，而更轻松的去玩那些需要长期驻留的游戏。游戏厂商也可以多一个挽留玩家的渠道，甚至用来宣传新游戏或游戏的增值服务，等等。好处不再列举。</p>\n<p>其实、绑定 IM 帐号和绑定手机号本质上区别不大。只不过，IM 帐号几乎是零费用，又不像 SMS ，控制权掌控在移动手里。IM 更适合做双向交流（SMS 的双向交流不那么方便，而且对用户和游戏运营商都有经济负担）。独立提供一个 Game2IM 的服务供众多游戏运营商使用也是个有趣的主意。和 SMS 一样，只要给出一个简单接口让游戏运营商调用，把游戏网络和 IM 网络互联就可以了。</p>\n<p>实现这个想法有两个方案。其一是制作各种 IM 的机器人，通过机器人和用户 IM 沟通。这个方案技术门槛稍低，有许多现成的机器人可以使用。缺点是，受 IM 提供商的限制（比如好友数量限制）。无法使用机器人的签名针对性的向用户传递特有的消息。除非你为每个游戏用户定制一个机器人，但那样，每个机器人都需要单独一个连接，对资源消耗过大。<br>￼<!--显示文章缩略部分的标记方法--><br><a id=\"more\"></a><br>第二个方案就是使用已有的 IM 互通方案，自己提供一个特有的 Game-IM 网络，跟已有的 IM 网络互通。比较流行的 IM 互通协议用基于 SIP 的 SIMPLE 和起源于 Jabber 的 XMPP 。</p>\n<p>我最常用的 IM 是 google talk ，本身就实现了标准的 XMPP Client 和 XMPP Server 协议；而我们的 网易 popo 也实现了 XMPP 的 s2s 网关。我想研究一下 XMPP 是个不错的选择。</p>\n<p>花了一整天的时间，把 XMPP 核心协议 仔细通读了一遍，收获颇多。原来以为 XMPP 是个可怕的巨无霸。我对 XML 原本也没有太多好感。最后，看法有所改变。</p>\n<p>其实，XMPP 仅仅是定义了一个网络服务间相互通讯的协议。它已经把服务间需要关心的东西减少到了最少。具体的应用每家服务提供商可以随意扩展。popo 在制作新版本时，我曾多次建议采用已有的标准协议，再此基础上开发自己的东西。当时或许大家都认为标准协议容易促手促脚，我当时也没啥研究，没有多言。今天看来，我更觉得这是一个决策失误。本来我们有一个很好的机会，利用 popo 联系起网易的各种服务，现在这条路将走的更为艰辛。其实，XMPP 定义的东西，即使自己去设计也会定义出类似的一套来。而把各种网络服务互通本该是发展的重点，为 IM Client 增添专有花哨的特性就有些舍本逐末了。更为恼火的是，popo 到现在也没有一个很好的非 Windows 平台解决方案。怎能让诸多把握着互联网上部分话语权的技术人士接受？（或者，同在杭州的 IT 圈子，popo 的开发人员是不是应该看看支付宝的同行们做了些什么？）</p>\n<p>谈谈我对 XMPP 的粗浅理解。这些仅仅建立在我对 RFC3920 的一天阅读的基础上，难免会有错误，不足以做技术参考。</p>\n<p>XMPP 抽象出一个在互联网上唯一的对象实体，用 JID 来表达。通常一个 JID 由三部分组成，node@domain/resource 。比 email 的表达形式多了一个 /resource 。这是因为 email 地址本身虽然可以表达一个实体，都是往往不够表达这个实体下的具体服务。就好比一个 ip 地址可以表示一台机器，但是我们还需要 port 号来表达这台机器具体提供的服务一样。</p>\n<p>用过 gtalk 的人应该很喜欢 gtalk 可以在不同的地方同时登陆这个不错的特性。用过以后，才能体会，无论是 qq 还是 msn 还是 popo ，只允许一个登陆是多么愚蠢的设定。gtalk 其实遵守了标准的 XMPP 协议，它用来区别一个帐号（一般是一个 gmail 邮件地址）的多处登陆，正是利用了不同的 resource 标识。</p>\n<p>XMPP 规范的最重要的一条通信协议就是，如何把消息从一个 JID 发送到另一个 JID (message)。这有点像 email 协议，但不同的是，它强调了实时性和安全性（虽然不是必须的）。因为 JID 可以在不同的 domain 下，这就需要 domain 间相互协作。对于 IM 网络来说（XMPP 远不只用于 IM 协议），就是不同的 IM 服务间互通。</p>\n<p>对于 domain 下的 xmpp 服务的发现，利用了 DNS 协议的一些功能。xmpp 的 s2s 服务提供位置，放在了 DNS 的 SRV 记录里。你可以用 nslookup 做个试验，启动 nslookup ，输入 set type=SRV</p>\n<p>然后查询 _xmpp-server._tcp.gmail.com 你会发现 gmail.com 的 xmpp s2s 服务地址已经端口号 5269 。同样，也可以查询 _xmpp-server._tcp.163.com 或 _xmpp-server._tcp.popo.163.com 查到网易 popo 的 xmpp 中转服务器地址。</p>\n<p>btw, 查询 _xmpp-client._tcp.gmail.com 可以查到 gtalk 的 client 登陆地址，而网易 popo 则没有提供 xmpp client 登陆点。</p>\n<p>按 RFC3920 所述，在 xmpp server 互联的时候，会优先尝试获取 domain 的 SRV 记录，如果失败就直接去连默认的 6259 端口。然后就可以开始握手协议。</p>\n<p>xmpp 比较强调 s2s 的安全性，所以推荐的握手都是建立在 TLS 层之上，使用 SASL 认证。TLS 层需要服务器有一个数字证书，为了安全可信，建议是找个根证书签名。不过自己签名也行，只需要服务器缓存证书即可。握手过程在 RFC3920 中描述的非常细致，可以按照其编码，问题不大。需要注意的是，这里的 XML 流格式要求很精确，不允许传输多余的东西。我一度认为采用 XML 会导致协议的实现上非常臃肿，其实不然。采用 XML 只是一个表象，适合人阅读和调错而已。RFC 中特别要求不去实现 XML 中的某某特性就是一例。我们不应该为了 XML 而去 XML 。</p>\n<p>其实 XMPP 的 c2s 和 s2s 并无太大区别，s2s 做的人手我想是因为开源项目和开源库比较少吧。而开源的 client 实现则是一大堆。c2s 和 s2s 的通讯都是基于那几条协议而已，s2s 的实现难点在于握手比较复杂（其实 c2s 也一样，只是很多库帮你做好了）。c2s 是共享一个 tcp 连接做双向通讯；而 s2s 则是用两条 TCP 连接。两条连接也一定程度上避免了 s2s 的欺骗，当然真正的安全来至于 TLS 和 SASL 的保障。DNS 毕竟是一个很脆弱的东西。</p>\n<p>除了点对点消息外，XMPP 定义了消息的组播。也就是一个 JID 可以以自己的名义发布消息 (presence)。而服务器来决定该发给谁。发送目标是由订阅消息决定的。其它多个 JID 可以订阅某个 JID 的消息。对于 IM 来说，最常用的就是上线下线等状态变化消息了。</p>\n<p>第三条即是对某个 JID 的状态进行设置和获取 (iq)。于 IM 应用来说，设置签名，昵称，状态等都依赖于它。</p>\n<p>XMPP 的核心协议无非规定了以上三种通讯协议，此外规范了服务器间互连的握手认证方案。然后给出了一些错误信息的表述方法。稍微了解过之后，很容易编写。如果希望重造轮子的话，对于 C 语言开发者来说，最繁琐的可能是 XML 的解析于生成。我自己稍微考察了一下，有个叫 LoudMouth 的库还不错。</p>\n<p>如果实现 s2s 网关的话，有些细节做起来可能很麻烦，比如查询 DNS 的 SRV 记录。这个在 jabberd 1.x 里其实有独立的模块实现好了，取来用即可 (见 dnsrv) 。而 TLS SASL 层的实现则早就有现成的开源库了。</p>\n<p>实现一个 jabber server 或许比你想象的还简单。in.jabberd 居然只用 600 多行 C 代码就从零实现了一个 jabber 服务器。当然功能非常的简陋了。</p>\n<p>至于我想做的东西，我希望一个在名为 xyz 的梦幻西游服务器上的 12345 号玩家，一旦选择绑定他的 popo 帐号 player@popo.163.com ，他在他的 popo 上就会收到名叫 12345.xyz@xyq.163.com 的好友请求。当他通过好友认证后，就可以从这个通道获取游戏里的信息，也可以对游戏帐号做有限的操作。我想有了这样一项服务，对玩家对运营商都会有极大的好处的。<br>其他资源：<br><a href=\"http://www.ibm.com/developerworks/cn/xml/tutorials/x-realtimeXMPPtut/\" target=\"_blank\" rel=\"noopener\">使用 XMPP 构建一个基于 web 的通知工具\n</a></p>\n","raw":null,"categories":[{"name":"开源库","path":"api/categories/开源库.json"}],"tags":[{"name":"协议","path":"api/tags/协议.json"},{"name":"socket","path":"api/tags/socket.json"}]},{"title":"代码实现AutoLayout相关特性","slug":"iOS/代码实现AutoLayout相关特性","date":"2014-09-02T15:53:11.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/代码实现AutoLayout相关特性.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/runbtn1.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"按比例缩放\"><a href=\"#按比例缩放\" class=\"headerlink\" title=\"按比例缩放\"></a>按比例缩放</h2><p>按比例缩放，这是在Interface Builder中无法设置的内容。<br>而在代码中，有如下两种实现方式:</p>\n<ol>\n<li>使用<code>NSLayoutConstraint</code>类型的初始化函数中的<code>multiplier</code>参数就可以非常简单的设置按比例缩放。  </li>\n<li>同时也可以设置不同<code>NSLayoutAttribute</code>参数来达到意想不到的效果，比如“A的Width等于B的Height的2倍”这样的效果。  </li>\n</ol>\n<p>现在就拿一个简单的<strong><code>UIButton</code></strong>做示例，在ViewController中创建一个UIButton字段：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIButton</span> *btn;  </span><br></pre></td></tr></table></figure>  </p>\n<h4 id=\"需求-1：\"><a href=\"#需求-1：\" class=\"headerlink\" title=\"需求 1：\"></a>需求 1：</h4><ol>\n<li>要求<strong><code>UIButton</code></strong>水平居中，始终距离父View底部<strong>20</strong>单位，其高度是父View高度的三分之一。</li>\n<li>使用<strong>KVO</strong>来监控<strong><code>UIButton</code></strong>的大小并实时输出到屏幕上。  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建UIButton，不需要设置frame</span></span><br><span class=\"line\">    btn = [<span class=\"built_in\">UIButton</span> buttonWithType:<span class=\"built_in\">UIButtonTypeRoundedRect</span>];</span><br><span class=\"line\">    [btn setTitle:<span class=\"string\">@\"mgen\"</span> forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">    btn.backgroundColor = [<span class=\"built_in\">UIColor</span> greenColor];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:btn];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//禁止自动转换AutoresizingMask</span></span><br><span class=\"line\">    btn.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//居中</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addConstraint:[<span class=\"built_in\">NSLayoutConstraint</span></span><br><span class=\"line\">                              constraintWithItem:btn</span><br><span class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeCenterX</span></span><br><span class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></span><br><span class=\"line\">                              toItem:<span class=\"keyword\">self</span>.view</span><br><span class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeCenterX</span></span><br><span class=\"line\">                              multiplier:<span class=\"number\">1</span></span><br><span class=\"line\">                              constant:<span class=\"number\">0</span>]];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//距离底部20单位</span></span><br><span class=\"line\">    <span class=\"comment\">//注意NSLayoutConstraint创建的constant是加在toItem参数的，所以需要-20。</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addConstraint:[<span class=\"built_in\">NSLayoutConstraint</span></span><br><span class=\"line\">                              constraintWithItem:btn</span><br><span class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeBottom</span></span><br><span class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></span><br><span class=\"line\">                              toItem:<span class=\"keyword\">self</span>.view</span><br><span class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeBottom</span></span><br><span class=\"line\">                              multiplier:<span class=\"number\">1</span></span><br><span class=\"line\">                              constant:<span class=\"number\">-20</span>]];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//定义高度是父View的三分之一</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addConstraint:[<span class=\"built_in\">NSLayoutConstraint</span></span><br><span class=\"line\">                              constraintWithItem:btn</span><br><span class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeHeight</span></span><br><span class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></span><br><span class=\"line\">                              toItem:<span class=\"keyword\">self</span>.view</span><br><span class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeHeight</span></span><br><span class=\"line\">                              multiplier:<span class=\"number\">0.3</span></span><br><span class=\"line\">                              constant:<span class=\"number\">0</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//注册KVO方法</span></span><br><span class=\"line\">    [btn addObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"bounds\"</span> options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span> | <span class=\"built_in\">NSKeyValueObservingOptionInitial</span> context:<span class=\"literal\">nil</span>];    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;!--more--&gt;</span><br><span class=\"line\"><span class=\"comment\">//KVO回调</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"keyword\">id</span>)object change:(<span class=\"built_in\">NSDictionary</span> *)change context:(<span class=\"keyword\">void</span> *)context</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (object == btn &amp;&amp; [keyPath isEqualToString:<span class=\"string\">@\"bounds\"</span>])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [btn setTitle:<span class=\"built_in\">NSStringFromCGSize</span>(btn.bounds.size) forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  \n运行结果：  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/runbtn1.png?imageMogr2/2/w/800\"><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/runbtn2.png?imageMogr2/2/w/800\">\n<a id=\"more\"></a>\n<h4 id=\"需求-2：\"><a href=\"#需求-2：\" class=\"headerlink\" title=\"需求 2：\"></a>需求 2：</h4></li>\n<li>在横向的显示中，Button的高度只有96，所以要求Button的最小高度为150。   </li>\n</ol>\n<p>涉及到的相关特性：</p>\n<ul>\n<li><strong>优先级</strong>：当两个<strong><code>Constraint</code></strong>同时作用在一个控件时，在某些情况下是有冲突的，可以通过设置<strong><code>Constraint</code></strong>的优先级来解决。<br>优先级对应<strong><code>NSLayoutConstraint</code></strong>类型的<strong><code>priority</code></strong>属性，默认值是<strong><code>UILayoutPriorityRequired</code></strong>，数值上等于<strong>1000</strong>. 设置一个低的值代表更低的优先级。  </li>\n<li><strong>最小值的定义</strong>：使用<strong><code>NSLayoutRelationGreaterThanOrEqual</code></strong>作为<strong><code>NSLayoutConstraint</code></strong>类型创建时的<strong><code>relatedBy</code></strong>参数。</li>\n</ul>\n<p>修改上面的比例Constraint，并在下方加入一个新的限制最小值的Constraint，代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义高度是父View的三分之一</span></span><br><span class=\"line\"><span class=\"comment\">//设置优先级低于UILayoutPriorityRequired(1000)，UILayoutPriorityDefaultHigh是750</span></span><br><span class=\"line\"><span class=\"built_in\">NSLayoutConstraint</span> *con = [<span class=\"built_in\">NSLayoutConstraint</span></span><br><span class=\"line\">                          constraintWithItem:btn</span><br><span class=\"line\">                          attribute:<span class=\"built_in\">NSLayoutAttributeHeight</span></span><br><span class=\"line\">                          relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></span><br><span class=\"line\">                          toItem:<span class=\"keyword\">self</span>.view</span><br><span class=\"line\">                          attribute:<span class=\"built_in\">NSLayoutAttributeHeight</span></span><br><span class=\"line\">                          multiplier:<span class=\"number\">0.3</span></span><br><span class=\"line\">                          constant:<span class=\"number\">0</span>];</span><br><span class=\"line\">con.priority = <span class=\"built_in\">UILayoutPriorityDefaultHigh</span>;</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:con];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置btn最小高度为150</span></span><br><span class=\"line\">[btn addConstraint:[<span class=\"built_in\">NSLayoutConstraint</span></span><br><span class=\"line\">                    constraintWithItem:btn</span><br><span class=\"line\">                    attribute:<span class=\"built_in\">NSLayoutAttributeHeight</span></span><br><span class=\"line\">                    relatedBy:<span class=\"built_in\">NSLayoutRelationGreaterThanOrEqual</span></span><br><span class=\"line\">                    toItem:<span class=\"literal\">nil</span></span><br><span class=\"line\">                    attribute:<span class=\"built_in\">NSLayoutAttributeNotAnAttribute</span></span><br><span class=\"line\">                    multiplier:<span class=\"number\">1</span></span><br><span class=\"line\">                    constant:<span class=\"number\">150</span>]];</span><br></pre></td></tr></table></figure><br>运行后，横向屏幕中的Button高度成了150：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/runbtn3.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"intrinsicContentSize-控件的内置大小\"><a href=\"#intrinsicContentSize-控件的内置大小\" class=\"headerlink\" title=\"intrinsicContentSize 控件的内置大小\"></a>intrinsicContentSize 控件的内置大小</h4><p>控件的内置大小是由控件本身的内容所决定的，比如一个<code>UILabel</code>的文字很长，那么该<code>UILabel</code>的内置大小自然会很长。<br>在代码中获取控件的内置大小的方法：  </p>\n<ol>\n<li>通过<code>UIView</code>的<code>intrinsicContentSize</code>属性来获取；</li>\n<li>通过<code>invalidateIntrinsicContentSize</code>方法来在下次UI规划事件中重新计算<code>intrinsicContentSize</code>。  </li>\n</ol>\n<p>注意：如果直接创建一个原始的UIView对象，它的内置大小为0。  </p>\n<p>先写一个辅助方法来快速设置UIView的边距限制：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设置Autolayout中的边距辅助方法</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setEdge:(<span class=\"built_in\">UIView</span>*)superview view:(<span class=\"built_in\">UIView</span>*)view attr:(<span class=\"built_in\">NSLayoutAttribute</span>)attr constant:(<span class=\"built_in\">CGFloat</span>)constant</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [superview addConstraint:[<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t    attribute:attr </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t    relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t       toItem:superview</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t    attribute:attr </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t   multiplier:<span class=\"number\">1.0</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t     constant:constant]</span><br><span class=\"line\">    ];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>接下来，创建一个UIView，利用上面的辅助方法快速设置其在父控件的左，上，右边距为20单位。如下代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//view1</span></span><br><span class=\"line\"><span class=\"built_in\">UIView</span> *view1 = [<span class=\"built_in\">UIView</span> new];</span><br><span class=\"line\">view1.backgroundColor = [<span class=\"built_in\">UIColor</span> yellowColor];</span><br><span class=\"line\"><span class=\"comment\">//不允许AutoresizingMask转换成Autolayout</span></span><br><span class=\"line\">view1.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:view1];</span><br><span class=\"line\"><span class=\"comment\">//设置左，上，右边距为20.</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> setEdge:<span class=\"keyword\">self</span>.view view:view1 attr:<span class=\"built_in\">NSLayoutAttributeLeft</span> constant:<span class=\"number\">20</span>];</span><br><span class=\"line\">[<span class=\"keyword\">self</span> setEdge:<span class=\"keyword\">self</span>.view view:view1 attr:<span class=\"built_in\">NSLayoutAttributeTop</span> constant:<span class=\"number\">20</span>];</span><br><span class=\"line\">[<span class=\"keyword\">self</span> setEdge:<span class=\"keyword\">self</span>.view view:view1 attr:<span class=\"built_in\">NSLayoutAttributeRight</span> constant:<span class=\"number\">-20</span>];</span><br></pre></td></tr></table></figure><br>但是运行后会发现，界面上不会显示任何东西。原因就是上面讲的，<code>UIView</code>默认是没有<strong><code>intrinsicContentSize</code></strong>的。</p>\n<p>创建一个自定义的<code>UIView</code>来改写<strong><code>intrinsicContentSize</code></strong>：MyView:<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/MyView.png?imageMogr2/2/w/800\"><br>然后在.m文件中改写<strong>intrinsicContentSize</strong>方法，并返回有效值，比如这样：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//改写UIView的intrinsicContentSize</span></span><br><span class=\"line\">- (<span class=\"built_in\">CGSize</span>)intrinsicContentSize</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">70</span>, <span class=\"number\">40</span>);</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure><br>接着修改最上面的代码，把上面view1变量的类型从UIView替换成我们自定义的View：MyView类型：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyView *view1 = [MyView new];  </span><br></pre></td></tr></table></figure><br>再次运行代码，View会按照要求显示在屏幕上：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/Myview2.png?imageMogr2/2/w/800\"><br>按照同样的方式，在下方添加另一个<code>MyView</code>，要求其距离父控件边距左，下，右各为<strong>20</strong>，代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//view2  </span></span><br><span class=\"line\">MyView *view2 = [MyView new];  </span><br><span class=\"line\">view2.backgroundColor = [<span class=\"built_in\">UIColor</span> yellowColor];  </span><br><span class=\"line\"><span class=\"comment\">//不允许AutoresizingMask转换成Autolayout  </span></span><br><span class=\"line\">view2.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>;  </span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:view2];  </span><br><span class=\"line\"><span class=\"comment\">//设置左，下，右边距为20.  </span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> setEdge:<span class=\"keyword\">self</span>.view view:view2 attr:<span class=\"built_in\">NSLayoutAttributeLeft</span> constant:<span class=\"number\">20</span>];  </span><br><span class=\"line\">[<span class=\"keyword\">self</span> setEdge:<span class=\"keyword\">self</span>.view view:view2 attr:<span class=\"built_in\">NSLayoutAttributeBottom</span> constant:<span class=\"number\">-20</span>];  </span><br><span class=\"line\">[<span class=\"keyword\">self</span> setEdge:<span class=\"keyword\">self</span>.view view:view2 attr:<span class=\"built_in\">NSLayoutAttributeRight</span> constant:<span class=\"number\">-20</span>];  </span><br></pre></td></tr></table></figure><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/myview4.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"需求：\"><a href=\"#需求：\" class=\"headerlink\" title=\"需求：\"></a>需求：</h4><ol>\n<li><p>通过代码加入Autolayout中的间距，命令view1和view2上下必须间隔20个单位。 </p>\n<ol>\n<li><ul>\n<li>这里要求view2在view1之下的<strong>20</strong>单位，所以创建<strong>NSLayoutConstraint</strong>中view2参数在前面。  </li>\n</ul>\n</li>\n<li><ul>\n<li>view2的<strong><code>attribute</code></strong>参数是<strong><code>NSLayoutAttributeTop</code></strong>，而view1的<strong><code>attribute</code></strong>参数是<strong><code>NSLayoutAttributeBottom</code></strong>  </li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>拉伸view2,而不拉伸view1。  </p>\n<ol>\n<li><ul>\n<li>控件的<strong><code>Content Hugging Priority</code></strong>拒绝拉伸的优先级，优先级越高，控件会越不容易被拉伸。    </li>\n</ul>\n</li>\n<li><ul>\n<li>控件的<strong><code>Content Compression Resistance Priority</code></strong>拒绝压缩内置空间(<code>intrinsicContentSize</code>)的优先级。优先级越高，控件的内置空间(<code>intrinsicContentSize</code>)会越不容易被压缩。  </li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设置两个View上下间距为20</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:[<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view2 </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\tattribute:<span class=\"built_in\">NSLayoutAttributeTop</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\trelatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t   toItem:view1</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t    attribute:<span class=\"built_in\">NSLayoutAttributeBottom</span> </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t   multiplier:<span class=\"number\">1.0</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t constant:<span class=\"number\">20</span>]</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t];</span><br></pre></td></tr></table></figure>  \n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/view1Toview2.png?imageMogr2/2/w/800\">\n<p>OK，的确，此时view1和view2相互间隔20单位，但是view1被拉伸了。</p>\n<p>使用控件的<strong><code>Content Hugging Priority</code></strong>，如下图：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/ContentHuggingPriority.png?imageMogr2/2/w/800\"><br>如图,把view1（上图中被拉伸的，在上面的View）的<strong><code>Content Hugging Priority</code></strong>设置一个更高的值，那么当<code>Autolayout</code>遇到这种决定谁来拉伸的情况时，view1不会被优先拉伸，而优先级稍低的view2才会被拉伸。<br>可以直接通过UIView的<code>setContentHuggingPriority:forAxis</code>方法来设置控件的<strong><code>Content Hugging Priority</code></strong>，其中<code>forAxis</code>参数代表横向和纵向，本例中只需要设置纵向，所以传入<strong><code>UILayoutConstraintAxisVertical</code></strong>。整句代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//提高view1的Content Hugging Priority</span></span><br><span class=\"line\">[view1 setContentHuggingPriority:<span class=\"built_in\">UILayoutPriorityDefaultHigh</span> forAxis:<span class=\"built_in\">UILayoutConstraintAxisVertical</span>];</span><br></pre></td></tr></table></figure><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/runview1.png?imageMogr2/2/w/800\"></p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"SB","path":"api/categories/SB.json"}],"tags":[{"name":"Storyboard","path":"api/tags/Storyboard.json"},{"name":"AutoLayout","path":"api/tags/AutoLayout.json"},{"name":"布局","path":"api/tags/布局.json"}]},{"title":"在IOS中自定义URL Schemes 教程","slug":"iOS/在IOS中自定义URLSchemes教程","date":"2014-08-28T20:32:48.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/在IOS中自定义URLSchemes教程.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2.gif?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"URL-Schemes\"><a href=\"#URL-Schemes\" class=\"headerlink\" title=\"URL Schemes\"></a>URL Schemes</h4><p>iPhone SDK中最酷的功能之一是一个应用程序能够把自己和自定义的URL协议绑定，这个URL协议可用于启动该应用程序（通过浏览器或者iPhone上的另一个程序）。创建这样的绑定并不难，难得的是你忍不住要在你的程序里用它！</p>\n<p>首先，你需要说明你想如何在程序中响应这个URL。最简单的自定义协议的方法是“唤醒”，而且可以通过URL把数据信息传递给程序，这样，程序被唤醒后能做更多的事情。</p>\n<h4 id=\"注册自定义URL协议\"><a href=\"#注册自定义URL协议\" class=\"headerlink\" title=\"注册自定义URL协议\"></a>注册自定义URL协议</h4><p>首先需要向iPhone注册一个自定义URL协议。这是在你的项目文件夹的info.plist文件进行的（就是你改变应用程序图标的同一个文件）。</p>\n<p>默认，Xcode在图形窗口中打开info.pllist，当然也可以直接用文本模式打开——对有的人来说这反而更简单。</p>\n<h6 id=\"Step1-右键，选择“Add-Row”-在下拉选框中选择“URL-types”，类型为Array\"><a href=\"#Step1-右键，选择“Add-Row”-在下拉选框中选择“URL-types”，类型为Array\" class=\"headerlink\" title=\"Step1. 右键，选择“Add Row”,在下拉选框中选择“URL types”，类型为Array:\"></a>Step1. 右键，选择“Add Row”,在下拉选框中选择“<strong>URL types</strong>”，类型为Array:</h6><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2.gif?imageMogr2/2/w/800\">\n<h6 id=\"Step2-打开“Item-0″类型为Dic-添加新key为”URL-identifier”-类型为String。可以是任何值，但建议用“反域名”-例如-“com-myapp”-。\"><a href=\"#Step2-打开“Item-0″类型为Dic-添加新key为”URL-identifier”-类型为String。可以是任何值，但建议用“反域名”-例如-“com-myapp”-。\" class=\"headerlink\" title=\"Step2. 打开“Item 0″类型为Dic,添加新key为”URL identifier”,类型为String。可以是任何值，但建议用“反域名”(例如 “com.myapp”)。\"></a>Step2. 打开“Item 0″类型为Dic,添加新key为”URL identifier”,类型为String。可以是任何值，但建议用“反域名”(例如 “com.myapp”)。</h6><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2a.gif?imageMogr2/2/w/800\">\n<h5 id=\"Step3-打开“Item-0″类型为Dic-添加新key为“URL-Schemes”-类型为Array\"><a href=\"#Step3-打开“Item-0″类型为Dic-添加新key为“URL-Schemes”-类型为Array\" class=\"headerlink\" title=\"Step3. 打开“Item 0″类型为Dic,添加新key为“URL Schemes”,类型为Array:\"></a>Step3. 打开“Item 0″类型为Dic,添加新key为“URL Schemes”,类型为Array:</h5><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2b.gif?imageMogr2/2/w/800\">\n<a id=\"more\"></a>\n<ul>\n<li><p>类型为Array:  </p>\n  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2c.gif?imageMogr2/2/w/800\">\n</li>\n</ul>\n<h5 id=\"Step4-在URL-Schemes数组中添加Value，输入你的URL协议名-例如“myapp-”-应写做“myapp”-。如果有必要，你可以在这里加入多个协议。\"><a href=\"#Step4-在URL-Schemes数组中添加Value，输入你的URL协议名-例如“myapp-”-应写做“myapp”-。如果有必要，你可以在这里加入多个协议。\" class=\"headerlink\" title=\"Step4. 在URL Schemes数组中添加Value，输入你的URL协议名 (例如“myapp://” 应写做“myapp”)。如果有必要，你可以在这里加入多个协议。\"></a>Step4. 在URL Schemes数组中添加Value，输入你的URL协议名 (例如“myapp://” 应写做“myapp”)。如果有必要，你可以在这里加入多个协议。</h5><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2d.gif?imageMogr2/2/w/800\">\n<h6 id=\"完成后如图所示：\"><a href=\"#完成后如图所示：\" class=\"headerlink\" title=\"完成后如图所示：\"></a>完成后如图所示：</h6><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2e.gif?imageMogr2/2/w/800\">\n<ul>\n<li><h6 id=\"另两种视图浏览方式：\"><a href=\"#另两种视图浏览方式：\" class=\"headerlink\" title=\"另两种视图浏览方式：\"></a>另两种视图浏览方式：</h6>在info.plist页面上右击，选择<strong>Raw Keys/Values</strong>显示如下：  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2f.png?imageMogr2/2/w/800\">\n<h6 id=\"xml\"><a href=\"#xml\" class=\"headerlink\" title=\"xml\"></a>xml</h6><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme2g.gif?imageMogr2/2/w/800\">\n<!--more-->\n<h4 id=\"处理URL\"><a href=\"#处理URL\" class=\"headerlink\" title=\"处理URL\"></a>处理URL</h4></li>\n</ul>\n<p>现在，URL已经注册好了。任何人都可以用打开URL的方式通过你的协议去启动一个应用程序。</p>\n<ul>\n<li><h5 id=\"使用Safari-方式启动-app-Calling-Custom-URL-Scheme-from-Safari【下载】\"><a href=\"#使用Safari-方式启动-app-Calling-Custom-URL-Scheme-from-Safari【下载】\" class=\"headerlink\" title=\"使用Safari 方式启动 app:Calling Custom URL Scheme from Safari【下载】\"></a>使用Safari 方式启动 app:Calling Custom URL Scheme from Safari【<a href=\"http://iosdevelopertips.com/downloads/#customURLScheme\" target=\"_blank\" rel=\"noopener\">下载</a>】</h5></li>\n</ul>\n<p>Using the simulator, here’s how to call the app:</p>\n<ul>\n<li>Run the application from within Xcode  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme4a.png?imageMogr2/2/w/800\"></li>\n<li>Once installed, the custom URL scheme will now be registered</li>\n<li>Close the app via the Hardware menu in simulator and choose Home</li>\n<li>Start Safari</li>\n<li>Enter the URL scheme defined previously in the browser address bar (see below)  <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme32.png?imageMogr2/2/w/800\">\n</li>\n</ul>\n<ul>\n<li><h5 id=\"通过其他应用启动：Calling-Custom-URL-Scheme-from-Another-iPhone-App【下载】\"><a href=\"#通过其他应用启动：Calling-Custom-URL-Scheme-from-Another-iPhone-App【下载】\" class=\"headerlink\" title=\"通过其他应用启动：Calling Custom URL Scheme from Another iPhone App【下载】\"></a>通过其他应用启动：Calling Custom URL Scheme from Another iPhone App【<a href=\"http://iosdevelopertips.com/downloads/#customURLScheme\" target=\"_blank\" rel=\"noopener\">下载</a>】</h5><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/urlScheme4b.png?imageMogr2/2/w/800\">  \n</li>\n</ul>\n<p>按钮的实现：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> - (<span class=\"keyword\">void</span>)buttonPressed:(<span class=\"built_in\">UIButton</span> *)button</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSString</span> *customURL = <span class=\"string\">@\"iOSDevTips://\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ([[<span class=\"built_in\">UIApplication</span> sharedApplication] </span><br><span class=\"line\">    canOpenURL:[<span class=\"built_in\">NSURL</span> URLWithString:customURL]])</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    [[<span class=\"built_in\">UIApplication</span> sharedApplication] openURL:[<span class=\"built_in\">NSURL</span> URLWithString:customURL]];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIAlertView</span> *alert = [[<span class=\"built_in\">UIAlertView</span> alloc] initWithTitle:<span class=\"string\">@\"URL error\"</span></span><br><span class=\"line\">                          message:[<span class=\"built_in\">NSString</span> stringWithFormat:</span><br><span class=\"line\">                            <span class=\"string\">@\"No custom URL defined for %@\"</span>, customURL]</span><br><span class=\"line\">                          delegate:<span class=\"keyword\">self</span> cancelButtonTitle:<span class=\"string\">@\"Ok\"</span> </span><br><span class=\"line\">                          otherButtonTitles:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [alert show];</span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>Line 5 we check to see if the custom URL is defined, and if so, use the shared application instance to open the URL (line 8).<br>The <strong><code>openURL:</code></strong>method starts the application and passes the URL into the app. The current application is exited during this process.  </p>\n<ul>\n<li><h5 id=\"通过URL-Schemes-传递参数启动应用：Passing-Parameters-To-App-Via-Custom-URL-Scheme\"><a href=\"#通过URL-Schemes-传递参数启动应用：Passing-Parameters-To-App-Via-Custom-URL-Scheme\" class=\"headerlink\" title=\"通过URL Schemes 传递参数启动应用：Passing Parameters To App Via Custom URL Scheme\"></a>通过URL Schemes 传递参数启动应用：Passing Parameters To App Via Custom URL Scheme</h5>Chances are you’ll need to pass parameters into the application with the custom URL definition. Let’s look at how we can do this with.</li>\n</ul>\n<p>The <strong><code>NSURL</code></strong>class which is the basis for calling from one app to another conforms to the <code>RFC 1808</code> (Relative Uniform Resource Locators). Therefore the same URL formatting you may be familiar with for web-based content will apply here as well.</p>\n<p>In the application with the custom <code>URL scheme</code>, the app delegate must implement the method with the signature below:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application  openURL:(<span class=\"built_in\">NSURL</span> *)url </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t  sourceApplication:(<span class=\"built_in\">NSString</span> *)sourceApplication </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t         annotation:(<span class=\"keyword\">id</span>)annotation</span><br></pre></td></tr></table></figure><br>The trick to passing in parameters from one app to another is via the URL.<br>For example, assume we are using the following custom <code>URL scheme</code>and want to pass in a value for a ‘<strong>token</strong>’ and a flag indicating registration state, we could create URL as follows:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *customURL = <span class=\"string\">@\"iOSDevTips://?token=123abct&amp;registered=1\"</span>;</span><br></pre></td></tr></table></figure><br>As in web development, the string <strong><code>?token=123abct&amp;registered=1</code></strong> is known as the <code>query</code> string.</p>\n<p>Inside the app delegate of the app being called (the app with the custom URL), the code to retrieve the parameters would be as follows:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application openURL:(<span class=\"built_in\">NSURL</span> *)url</span><br><span class=\"line\">        sourceApplication:(<span class=\"built_in\">NSString</span> *)sourceApplication annotation:(<span class=\"keyword\">id</span>)annotation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Calling Application Bundle ID: %@\"</span>, sourceApplication);</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"URL scheme:%@\"</span>, [url scheme]);</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"URL query: %@\"</span>, [url query]);</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>The output from the app with the custom URL (using my Bundle ID), when called from another app, is as follows:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Calling Application Bundle ID: com<span class=\"number\">.3</span>Sixty.CallCustomURL</span><br><span class=\"line\">URL scheme:iOSDevTips</span><br><span class=\"line\">URL query: token=<span class=\"number\">123</span>abct&amp;registered=<span class=\"number\">1</span></span><br></pre></td></tr></table></figure><br>Take note of the ‘<strong>Calling Application Bundle ID</strong>’ as you could use this to ensure that only an application that you define can interact directly with your app.</p>\n<p>Let’s change up the delegate method to verify the calling application Bundle ID is known:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application openURL:(<span class=\"built_in\">NSURL</span> *)url</span><br><span class=\"line\">        sourceApplication:(<span class=\"built_in\">NSString</span> *)sourceApplication annotation:(<span class=\"keyword\">id</span>)annotation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Check the calling application Bundle ID</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ([sourceApplication isEqualToString:<span class=\"string\">@\"com.3Sixty.CallCustomURL\"</span>])</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Calling Application Bundle ID: %@\"</span>, sourceApplication);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"URL scheme:%@\"</span>, [url scheme]);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"URL query: %@\"</span>, [url query]);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>It’s important to note that you cannot prevent another application from calling your app via custom <strong><code>URL scheme</code></strong>, however you can skip any further processing and <code>return NO</code> as shown above. With that said, if you desire to keep other apps from calling your app, create a unique (non-obvious) <code>URL scheme</code>. Although this will guarantee you app won’t be called, it will make it more unlikely.</p>\n<p>Custom URL Scheme Example Projects</p>\n<p>I realize it can be a little tricky to follow all the steps above. I’ve included two (very basic) iOS apps, one that has the custom URL scheme defined and one that calls the app, passing in a short parameter list (query string). These are good starting points to experiment with custom URL’s.</p>\n<p><a href=\"http://iosdevelopertips.com/downloads/#customURLScheme\" target=\"_blank\" rel=\"noopener\">Download Xcode project for app with Custom URL scheme</a><br><a href=\"http://iosdevelopertips.com/downloads/#customURLScheme\" target=\"_blank\" rel=\"noopener\">Download Xcode project for app to call custom URL scheme</a></p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"schemes","path":"api/categories/schemes.json"}],"tags":[{"name":"协议","path":"api/tags/协议.json"},{"name":"scheme","path":"api/tags/scheme.json"}]},{"title":"Xcode HeaderDoc 教程","slug":"xcode/XcodeHeaderDoc教程","date":"2014-08-28T15:18:41.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/xcode/XcodeHeaderDoc教程.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/car.jpg?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>HeaderDoc 是在Xcode 5 和 iOS7 发布时，新增的一个命令行工具，功能：可以从代码中自动生成格式良好的HTML文档——当然，必须依赖于特定格式的注释来完成的。</p>\n<p>另外，Xcode 还会在 quick look 面板中以<strong>HeaderDoc</strong>风格显示你的注释。</p>\n<p>通过本教程，将学习如下几点：</p>\n<ul>\n<li>如何书写 HeaderDoc 风格的注释</li>\n<li>分如何在 Xcode 中预览文档</li>\n<li>如何生成 HTML 文档</li>\n<li>如何使用 VVDocumenter-Xcode(一个易于使用的第3方文档制作工具)</li>\n</ul>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>下载本教程中用到的 <a href=\"http://cdn2.raywenderlich.com/wp-content/uploads/2014/03/DocumentationExamples_Starter.zip\" target=\"_blank\" rel=\"noopener\">示例项目</a></p>\n<p>这个简单的示例程序只包含了两个类：</p>\n<ul>\n<li>Car: 包含几个属性及一个 “drive” 方法以及一个 completion 块。</li>\n<li>MathAPI: 包含了1个方法，用于累加两个数。<br>现在，这两个类还没有任何注释。以便演示如何通过 <strong>HeaderDoc</strong> 为这两个类创建文档。<a id=\"more\"></a>\n<h4 id=\"HeaderDoc-注释\"><a href=\"#HeaderDoc-注释\" class=\"headerlink\" title=\"HeaderDoc 注释\"></a>HeaderDoc 注释</h4></li>\n</ul>\n<p><strong>HeaderDoc</strong> 可以从命令行中运行，也可以通过 Xcode 运行。它扫描文件中以某种格式书写的注释,包括这3种形式：<br>这3中语法在 Xcode 中产生同样效果的文档</p>\n<pre><code>注释 1. 一般用于单行注释\n    /// Your documentation comment will go here\n注释 2.\n    /**  * Your documentation comment will go here  */\n注释 3: 一般用于较长的注释块\n    /*!  * Your documentation comment will go here  */\n\n注意：在注释2和注释3中，在每一行开头都会有一个额外的*，直至结尾的 */。这仅仅是为了美观，而不是必须的。\n</code></pre><h4 id=\"HeaderDoc-标签\"><a href=\"#HeaderDoc-标签\" class=\"headerlink\" title=\"HeaderDoc 标签\"></a>HeaderDoc 标签</h4><p>当 <strong>HeaderDoc</strong> 发现上述3种注释，它就开始寻找其中的<strong>HeaderDoc 标签</strong>。<strong>HeaderDoc 标签</strong> 用来修饰<strong>HeaderDoc 注释</strong>。</p>\n<p><strong>HeaderDoc 标签</strong>以 <strong>@</strong> 符号开头，然后是关键字，然后是一个空格，最后才是相应的文本（例如 @param foo）。<br>HeaderDoc 标签可以分为两种：</p>\n<ol>\n<li><p>顶级标签: 这些标签声明所要注释的对象的类型（例如头部声明、类、方法等等）。</p>\n<ul>\n<li>顶级标签，例如 @typedef，用于表示 <strong>typedef</strong> 定义的类型，比如枚举、结构体和函数指针。</li>\n<li><strong>HeaderDoc</strong> 能够根据上下文自动产生顶级标签，因此通常不是必须的。</li>\n</ul>\n</li>\n<li><p>二级标签:这些标签才是具体的注释内容。</p>\n<ul>\n<li>@brief: 简单描述你准备文档化的数据的类型，方法等等。</li>\n<li>@abstract: 等于 @brief。<ul>\n<li>@discussion: 类似 @abstract 和 @brief，但允许多行。它不是必须的，仅仅是为了使描述更清晰。</li>\n<li>@param: 描述方法、回调或函数的参数名称。</li>\n<li>@return: 描述方法或函数的返回值。（等同于 @result）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<!-- More -->\n<h4 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h4><ul>\n<li><h6 id=\"属性的文档化\"><a href=\"#属性的文档化\" class=\"headerlink\" title=\"属性的文档化\"></a>属性的文档化</h6><p>用 Xcode 打开<strong>DocumentationExamples</strong> 项目, 打开<strong>ViewController.h</strong>,<br>在<strong> car </strong>属性的前面，加入一行注释:</p>\n<pre><code>/*!  * @brief The ViewController class&apos; car object.  */\n\n@property (nonatomic) Car *car;\n</code></pre></li>\n</ul>\n<p>编译项目。编译结束，按住 alt/option 键，点击<strong>car</strong> 变量名。你将看到<strong>pop菜单</strong>中显示了刚才的注释内容。<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/car.jpg?imageMogr2/2/w/800\"><br>另一种方法:切换到Utitlities 面板的<strong>Quick Help</strong> 检查器窗口。点击 <strong>car</strong> 变量名，通过<strong>Quick Help</strong>,你将看到如下效果：<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/carquickhelp.jpg?imageMogr2/2/w/800\"></p>\n<ul>\n<li><h6 id=\"方法的文档化\"><a href=\"#方法的文档化\" class=\"headerlink\" title=\"方法的文档化\"></a>方法的文档化</h6><p><strong>MathAPI</strong>包含一个方法需要文档化。打开<strong>MathAPI.h</strong>,找到<code>addNumber:toNumber:</code>。</p>\n</li>\n</ul>\n<p>这个方法有两个参数及一个返回值。因此需要一个 @description 标签、两个@param标签，以及一个@return 标签，如下面所示：</p>\n<pre><code>/*!  * @discussion A really simple way to calculate the sum of two numbers.\n\n      * @param firstNumber An NSInteger to be used in the summation of two numbers\n\n      * @param secondNumber The second half of the equation.\n\n       * @return The sum of the two numbers passed in.\n\n*/\n\n+ (NSInteger)addNumber:(NSInteger)firstNumber toNumber:(NSInteger)secondNumber;\n</code></pre><p>编译，再 <strong>alt + 左键</strong>：<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/method.jpg?imageMogr2/2/w/800\"></p>\n<p> 问题: 在 Xcode 文本编辑窗口，很多地方都支持 <strong>alt+左键</strong>。请确保你点击在正确的地方。在上面的例子里，你应当在addNumber: 和 toNumber: 两处使用 alt+左键。</p>\n<p>你也许不知道，这个方法的实现真的很恶心。它只能使用非负数作为参数。为了让用户明白这一点，你应当在注释中添加更多的说明。因此，我们可以在 @return 前面加入一个 @warning 标签。</p>\n<pre><code>* @warning Please make note that this method is only good for adding non-negative numbers.\n</code></pre><p>编译项目，然后使用 alt+左键。我们添加的 @warning 标签效果如下：<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/warning.jpg?imageMogr2/2/w/800\"></p>\n<h4 id=\"Code-Snippets，让一切变得更简单\"><a href=\"#Code-Snippets，让一切变得更简单\" class=\"headerlink\" title=\"Code Snippets，让一切变得更简单:\"></a>Code Snippets，让一切变得更简单:</h4><p>一个<strong>snippet</strong> 是一个可以重用的代码块（存储在 snippet 库中）。<strong>Snippets</strong> 甚至可以包含一些需要你去填充的占位符。<br>这意味着, 可以用 <strong>snipppet</strong>来进行文档化。</p>\n<p>在 <strong>MathAPI.h</strong> 中，在原有的注释上面加入以下内容：</p>\n<pre><code>/*!  * @discussion &lt;#description#&gt;\n\n     * @param &lt;#param description#&gt;\n\n     * @return &lt;#return description#&gt;\n*/\n</code></pre><p> 注意，当粘贴上述代码时，“&lt;# #&gt;”之间的内容会变成一个<strong>token</strong>,意味着可以通过 <strong>tab 键</strong>在 <strong>token</strong> 之间来回切换。就像编写代码时的自动完成功能。<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/token.png?imageMogr2/2/w/800\"></p>\n<h6 id=\"学习使用Code-Snippets工具\"><a href=\"#学习使用Code-Snippets工具\" class=\"headerlink\" title=\"学习使用Code Snippets工具\"></a>学习使用Code Snippets工具</h6><p> 打开 <strong>Utilities 面板</strong>中的 <strong>CodeSnippets Library 检查器</strong>窗口，选中上述注释块，将它拖到该检查器窗口中（从某个 token 例如&lt;#description#&gt;开始拖）:<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/codesnippet.jpg?imageMogr2/2/w/800\"><br> 将会弹出一个编辑窗口让输入 snippet 的某些信息，并以此来创建一个<strong>自动完成快捷方式</strong>。要修改某个<strong>snippet</strong>时,直接点击 <strong>Code Snippet Library</strong> 中的 snippet，然后点 Edit 按钮。按照如下形式填写：<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/snippetwindow.jpg?imageMogr2/2/w/800\"></p>\n<p>要想让 <strong>snippet</strong> 生效，首先删除原有注释，然后将鼠标放到addNumber:toNumber: 方法的 + 号前面,输入<strong>doccomment</strong>，然后回车，该<strong>snippet</strong> 将自动生成。然后，通过 Tab 键在3个 token 间移动，并填充它们。最终完成的文档化结果如下:</p>\n<pre><code>/*!  * @discussion A really simple way to calculate the sum of two numbers.\n\n     * @param firstNumber An NSInteger to be used in the summation of two numbers.\n\n     * @param secondNumber The second half of the equation.\n\n     * @warning Please make note that this method is only good for adding non-negative numbers.\n\n     * @return The sum of the two numbers passed in.\n*/\n</code></pre><p><strong>@param 标签</strong>和 <strong>@warning 标签</strong>需要手动书写。</p>\n<h4 id=\"Typedefs的文档化\"><a href=\"#Typedefs的文档化\" class=\"headerlink\" title=\"Typedefs的文档化\"></a>Typedefs的文档化</h4><p> 打开 Car.h，在 class 之,有一个NS_ENUM，即 typedef enum，一个块，几个属性，一个空方法等，需要文档化。</p>\n<p>还记得 @typedef 标签吗？<br>这个顶级标签稍微特殊一点。它可以对<strong>typedef enum</strong> 或者 <strong>typedef struct</strong> 的类型进行注释。<br>根据注释的对象的不同，它会包含与定义的类型相关的二级标签。</p>\n<p>以 enum 为例，它会包含 @constant 标签，用于每个常量（对于struct，则会是 @field 标签）。</p>\n<p>找到 <strong>enum OldCarType</strong>。它包含两个常量，是用于古典汽车的。在<strong>typedef</strong> 声明之上，将原来的注释替换为：</p>\n<pre><code>/*!  * @typedef OldCarType\n\n     * @brief A list of older car types.\n\n     * @constant OldCarTypeModelT A cool old car.\n\n     * @constant OldCarTypeModelA A sophisticated old car.\n*/\n\ntypedef enum {\n        /// A cool, old car.\n\n         OldCarTypeModelT,\n\n        /// A sophisticated older car.\n\n        OldCarTypeModelA\n\n} OldCarType;\n</code></pre><p> 编译，然后在 <strong>OldCarType</strong> 或上<strong>OldCarTypeModelT</strong>使用<strong>alt + 左键</strong>。</p>\n<p>在这个类中只有一个 <strong>NS_ENUM</strong>，因此接下来进行进行文档化。常量已经注释了，只要对整个<strong>NS_ENUM</strong> 进行一个总体的注释就可以了。</p>\n<pre><code>/*!  * @typedefCarType\n\n     * @brief Alist of newer car types.\n\n     * @constantCarTypeHatchback Hatchbacks are fun, but small.\n\n     * @constantCarTypeSedan Sedans should have enough room to put your kids, and your golfclubs\n\n     * @constantCarTypeEstate Estate cars should hold your kids, groceries, sport equipment,etc.\n\n     * @constantCarTypeSport Sport cars should be fast, fun, and hard on the back.\n*/\n</code></pre><p>注意:这个enum 是通过宏来声明的，悲催的 Xcode 不能完全支持和 <strong>typedef enum</strong> 一样的文档特性，虽然<strong>NS_ENUM</strong> 实际上是声明 enums 的推荐的方法。</p>\n<h4 id=\"typedef-block-文档化\"><a href=\"#typedef-block-文档化\" class=\"headerlink\" title=\"typedef block 文档化\"></a>typedef block 文档化</h4><pre><code>/*!  * @brief A block that makes the car drive.\n     * @param distance The distance is equal to a distance driven when the block is ready to execute. It could be miles, or kilometers, but not both. Just pick one and stick with it. ;]\n*/\n\ntypedef void(^driveCompletion)(CGFloat distance);\n</code></pre><p><strong>typedef block</strong> 的文档化和之前的并无多少不同，它包含了：</p>\n<ul>\n<li>一个 @brief 标签，简单说明了一下这个块的作用。</li>\n<li>一个 @param 标签，说明调用块时需要传递的参数。</li>\n</ul>\n<h4 id=\"添加格式化代码到文档中\"><a href=\"#添加格式化代码到文档中\" class=\"headerlink\" title=\"添加格式化代码到文档中\"></a>添加格式化代码到文档中</h4><p>例如，Car 类的 <strong>driveCarWithComplete:</strong> 方法。</p>\n<p>这个方法以块作为参数，因为块对于新手来说一般比较困难，因此最好是告诉程序员如何使用这个方法。</p>\n<p>这需要使用 <strong>@code 标签</strong>。在 <strong>driveCarWithCompletion</strong>方法声明之前添加如下内容：</p>\n<pre><code>/*!  * @brief The car will drive, and then execute the drive block\n\n     * @param completion A driveCompletion block\n\n     * @code [car driveCarWithCompletion:^(CGFloat distance){\n\n                            NSLog(@&quot;Distance driven %f&quot;, distance);\n\n                         }];\n*/\n</code></pre><p>编译，在方法名上使用<strong>alt+左键</strong>。如下图所示：<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/driveCar.jpg?imageMogr2/2/w/800\"></p>\n<h4 id=\"检查文档\"><a href=\"#检查文档\" class=\"headerlink\" title=\"检查文档\"></a>检查文档</h4><p>学会了如何添加注释，如果 <strong>Xcode</strong> 能帮你检查你的工作，就像Xcode会自动检查代码中的语法错误，那岂不是更好？有一个好消息，Clang 有一个标志，叫做“<strong>CLANG_WARN_DOCUMENTATION_COMMENTS</strong>”,可以用于检查 <strong>HeaderDoc</strong> 格式的注释。</p>\n<p>打开 <strong>DocumentationExamples</strong>的项目设置，点击 <strong>Build Settings</strong>，找到 <strong>DocumentationComments</strong>, 将值设置为 <strong>YES</strong>。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/buildsetting.jpg?imageMogr2/2/w/800\"><br>如下，打开 <strong>MathAPI.h</strong>，将第一个 @param 标签的参数名由<strong>firstNumber</strong> 修改为 <strong>thirdNumber</strong>,然后编译。<br>有一个警告发生，甚至提出了修改建议。它不会影响任何事情，但有助于检查文档中的错误。<br> <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/RW_Documentation_WarningEx.png?imageMogr2/2/w/800\"></p>\n<h4 id=\"特殊注释\"><a href=\"#特殊注释\" class=\"headerlink\" title=\"特殊注释\"></a>特殊注释</h4><p><strong>Xcode</strong> 还支持几种特殊注释，对于你或者使用你代码的人非常有用。</p>\n<p>打开 Car.m，在 <strong>driveCarWithCompletion:</strong> 方法中，在调用<strong>completion</strong> 块之前添加下列注释：</p>\n<pre><code>// FIXME: This is broken\n\n// !!!: Holy cow, it should be checked!\n\n// ???: Perhaps check if the block is not nil first?\n</code></pre><p>这里出现了3中注释：</p>\n<ul>\n<li>FIXME: 某个地方需要修正</li>\n<li>!!!: 某个地方需要注意。</li>\n<li>???: 代码中有问题，或者代码是可疑的。</li>\n</ul>\n<p>这些注释不但有助于浏览代码，而且 Xcode 绘制 <strong>Jump Bar</strong> 中显示它们。点击<strong>Jump Bar</strong>，如下图所示：</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/RW_Documentation_JumpBar-700x151.png?imageMogr2/2/w/800\">\n<p> 你将看到这3个注释以粗体显示：</p>\n <img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/RW_Documentation_JumpBarSelect-700x287.png?imageMogr2/2/w/800\">\n<p> 到此，你已经完全掌握了如何对项目进行文档化。花一些时间对项目的其他属性和方法操作一番，并加入一些自己的东西。看看在注释块中改变一些东西或者删除某个标签会发生什么。这将让你明白注释格式如何对文档造成影响的。</p>\n<p>#用headerdoc2html 创建 HTML文档<br>文档化是由一个 <strong>HeaderDoc 工具</strong>完成的。当 Xcode 安装时，它就已经安装好了。<br>它除了解释已添加的注释，显示一个弹出菜单以及将注释在<strong>Quick Help</strong> 中显示之外，还可以在文档化之后创建 HTML、XML 以及联机帮助手册。</p>\n<p>本节介绍 HTML 文件的制作。如果你对用 HeaderDoc 如何创建在线文档感兴趣，请参考<a href=\"https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/HeaderDoc/usage/usage.html\" target=\"_blank\" rel=\"noopener\">HeaderDoc 用户指南</a>.</p>\n<p>打开终端，转到 DocumentationExamples 项目目录：</p>\n<pre><code>cd /path/to/your/folder\n\n确保该路径下包含了 Xcodeproject  文件(“DocumentationExamples.xcodeproj”)。\n</code></pre><p>然后用下列命令创建 HTML 文档：</p>\n<pre><code>headerdoc2html -o ~/Desktop/documentation DocumentationExamples/\n</code></pre><p>此时终端会有许多输出。当创建完毕，返回桌面，出现一个名为documentation 的目录。双击打开，找到 Car_h 目录，打开 index.html：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/Screen-Shot-2014-04-05-at-5.58.18-PM.png?imageMogr2/2/w/800\"></p>\n<p><strong>headerdoc2html 脚本</strong>有两个参数：</p>\n<p>So what justhappened? Well, you ran the headerdoc2htmlscript with 2 options:</p>\n<ul>\n<li>-o ~/Desktop/documentation – 这个参数指定输出的 Html 文件路径——即桌面的 documentation 目录。</li>\n<li>DocumentationExamples/ – 该参数指定要解析的源文件位于 DocumentationExamples 目录（不包含项目目录下的其他目录，因为它们并不包含源代码）</li>\n</ul>\n<p>问题:</p>\n<ol>\n<li>最新版本<strong>headerdoc2html</strong>有个问题，用 google chrome打开 index.html后，左边的目录显示不正常，但 Safari打开正常。</li>\n<li>最新版本的<strong>headerdoc2html</strong> 不能正确解析 /// 类的注释，可以使用 /*! 类型的注释代替。</li>\n</ol>\n<p>这很酷，但还可以更进一步。除了手动进入到输出目录中进行导航，<strong>HeaderDoc</strong>还会创建一个主目录索引。<br>返回终端，导航至新建的 <strong>documentation</strong> 目录，输入：</p>\n<pre><code>cd ~/Desktop/documentation\n</code></pre><p>然后输入命令，创建内容索引:</p>\n<pre><code>gatherheaderdoc .\n</code></pre><p><strong>gatherheaderdoc</strong>自动查找目录，为 <strong>.</strong> 目录（表示当前目录）创建索引。<br>用 Finder 打开 documentation  目录。你会发现多出一个 <strong>masterTOC.html</strong> 文件。打开它，它将列出所有已文档化的属性、方法、枚举和块的链接。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/Screen-Shot-2014-04-05-at-6.01.35-PM.png?imageMogr2/2/w/800\"><br>你可以将所有 HTML 文件放到 web 服务器上，然后所有人都可以访问你的文档！</p>\n<p>#VVDocumenter-Xcode</p>\n<p>最后的内容是 <strong>VVDocumenter-Xcode</strong>，一个第三方 Xcode插件，它能让你的文档化工作简单至比使用早先介绍的 <strong>Code Snippet</strong> 更容易。</p>\n<p>首先，从 <a href=\"https://github.com/onevcat/VVDocumenter-Xcode\" target=\"_blank\" rel=\"noopener\">Github</a> 下载插件。</p>\n<p>你所需要做的全部工作就是打开项目，然后 <strong>Build</strong>。它会将插件自动安装到~/Library/ApplicationSupport/Developer/Shared/Xcode/Plug-ins 目录。</p>\n<p>然后重启 Xcode。再次打开 DocumentationExamples项目。在 MathAPI.h，删除 <strong><code>addNumber:toNumber</code></strong> 方法的注释块，然后在方法声明上面输入：</p>\n<pre><code>///\n</code></pre><p><strong>VVDocumenter-Xcode</strong> 将自动创建注释块，包括所有必要的 <strong>@param</strong> 标签以及自动完成 <strong>token</strong>。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/RW_Documentation_VVDocumentor-700x184.png?imageMogr2/2/w/800\"></p>\n<p>打开 Car.h，删除 <strong>NS_ENUM CarType</strong> 的注释，以及每个常量的注释。在<strong>NS_ENUM</strong> 声明之上，输入：</p>\n<pre><code>///\n</code></pre><p>这回，它会在 enum 之上创建 <strong>discussion</strong> 标签，甚至还每个常量上面放入了必要的注释！</p>\n<p><strong>VVDocumenter-Xcode</strong> 使你的生活更加轻松。如果你想定制<strong>VVDocumenter-Xcode</strong>，在Xcode中，使用 <strong>Window&gt;VVDocumenter菜单</strong>。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/VW_Documentation_VVDocPrefs-700x410.png?imageMogr2/2/w/800\"></p>\n<p>这里，你可以改变自动完成关键字、注释风格以及其他。你想怎样定制 VVDocumenter-Xcode都行。VVDocumenter-Xcode 为我省下了大量的时间！<br>接下来做什么？</p>\n<p>最终完成的示例项目在 这里<a href=\"http://cdn2.raywenderlich.com/wp-content/uploads/2014/03/DocumentationExamples_Final.zip\" target=\"_blank\" rel=\"noopener\">下载</a>。</p>\n<p>在你自己的代码中进行文档化。尝试自己编写 <strong>code snippet</strong> 并使用<strong>VVDocumentor</strong>。</p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"文档","path":"api/categories/文档.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"}]},{"title":"Storyboard之Segue","slug":"iOS/Storyboard之Segue","date":"2014-07-22T10:59:49.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/Storyboard之Segue.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h5 id=\"Segue原理\"><a href=\"#Segue原理\" class=\"headerlink\" title=\"Segue原理:\"></a>Segue原理:</h5><p>在iOS开发中，segue用来实现storyboard中源视图控制器和目标视图控制器连接，当segue被触发时，系统将完成下列操作：</p>\n<ol>\n<li>实例化目标视图控制器</li>\n<li>实例化一个新segue对象，该对象持有所有的信息</li>\n<li>调用源视图控制器的prepareForSegue:sender:方法，</li>\n<li>调用segue的 perform 方法将目标控制器带到屏幕上。<br>这个动作行为依赖segue的类型如modal,push,custom,modal segue告诉源视图控制器present目标视图控制器。</li>\n</ol>\n<p>在源视图控制器的prepareForSegue:sender:的方法中，执行对目标视图控制器所有必要的属性配置，包括委托设置（如目标视图控制器有协议）。<br><a id=\"more\"></a><br>在apple的文档库中第二个示例应用开发文档中，介绍了这样一个segue的使用例子。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>) prepareForSegue:(<span class=\"built_in\">UIStoryboardSegue</span> *)segue sender:(<span class=\"keyword\">id</span>)sender  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([[segue identifier] isEqualToString:<span class=\"string\">@\"ShowSightingsDetails\"</span>])  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">    <span class=\"comment\">//当用户选择表视图中的一行时，触发**segue**事件，传输数据到目标视图控制器，使目标控制器上能显示`sighting`</span></span><br><span class=\"line\">        DetailViewController *detailViewController = [segue destinationViewController];  </span><br><span class=\"line\">        detailViewController.sighting = [<span class=\"keyword\">self</span>.dataController objectInListAtIndex:[<span class=\"keyword\">self</span>.tableView indexPathForSelectedRow].row];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([[segue identifier] isEqualToString:<span class=\"string\">@\"ShowAddSightingView\"</span>])  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        AddSightingViewController *addSightingViewController = [[[segue destinationViewController] viewControllers] objectAtIndex:<span class=\"number\">0</span>];  </span><br><span class=\"line\">        addSightingViewController.delegate = <span class=\"keyword\">self</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure><br>在<code>storyboard</code>中，这个实现方法代码是用来处理从主视图控制器到两个不同的目标视图控制器的<strong>segue</strong>。这两个<strong>segue</strong>通过它们的<code>identifier</code>属性进行判断，具体解释如下：  </p>\n<ul>\n<li><p><code>identifier</code>为”<strong>ShowSightingsDetails</strong>“时，目标视图控制器是一个展示明细信息的视图控制器,使用的<strong>segue</strong>类型为<code>push</code>。这种通常用于<strong>navigator</strong>视图控制器中。  </p>\n</li>\n<li><p>在<code>identifier</code>为”<strong>ShowAddSightingView</strong>“时，目标视图控制器管理的是一个新加的<strong>sighting</strong>信息视图，我们称之为<strong>add</strong>视图控制器。它是不需要从主视图控制器（源）传什么数据过来的。但是，主视图控制器需要获取在add视图控制器（目标）上输入的数据。  </p>\n<ul>\n<li><ul>\n<li>实现方式是采用<code>delegate</code>，将主视图控制器设置为add视图控制器(目标)的委托。在add目标视图控制器上执行它的委托中方法，该方法需要先在主视图控制器的实现代码中实现，方法包括如何读取add视图控制器的数据，并dismiss掉add视图控制器。  </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>在add视图控制器上，有两个按钮，用于执行<strong>cancel</strong>和<strong>done</strong>操作。这两个按钮操作的方法在主视图控制器中实现。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)addSightingViewControllerDidCancel:(AddSightingViewController *)controller  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">\t[<span class=\"keyword\">self</span> dismissViewControllerAnimated:<span class=\"literal\">YES</span> completion:<span class=\"literal\">NULL</span>];  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)addSightingViewControllerDidFinish:(AddSightingViewController *)controller name:(<span class=\"built_in\">NSString</span> *)name location:(<span class=\"built_in\">NSString</span> *)location &#123;  </span><br><span class=\"line\"><span class=\"keyword\">if</span> ([name length] || [location length]) &#123;  </span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.dataController addBirdSightingWithName:name location:location];  </span><br><span class=\"line\">\t[[<span class=\"keyword\">self</span> tableView] reloadData];  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">\t[<span class=\"keyword\">self</span> dismissModalViewControllerAnimated:<span class=\"literal\">YES</span>];  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在add视图控制器实现代码中，调用它的委托中这两个方法。  </p>\n<h5 id=\"segue三种类型-modal-segue、push-segue、custom-segue\"><a href=\"#segue三种类型-modal-segue、push-segue、custom-segue\" class=\"headerlink\" title=\"segue三种类型:modal segue、push segue、custom segue\"></a>segue三种类型:modal segue、push segue、custom segue</h5><ul>\n<li><h6 id=\"modal-segue\"><a href=\"#modal-segue\" class=\"headerlink\" title=\"modal segue\"></a>modal segue</h6>是一个视图控制器（源）为了完成一个任务而模态地（<strong>modally</strong>）呈现另一个视图控制器（目标）。这个目标视图控制器不是导航视图控制器(<strong>navigation view controller</strong>)的栈中的一部分。<br>在任务完成后，使用<code>delegate</code>将呈现的视图控制器（目标）释放掉，应用界面切换到原来的视图控制器（源）上。  </li>\n</ul>\n<p>这个过程的实现代码可以看成是<code>present</code>和<code>dismiss</code>两个操作。  </p>\n<ul>\n<li><h6 id=\"push-segue\"><a href=\"#push-segue\" class=\"headerlink\" title=\"push segue\"></a>push segue</h6>是将另一个视图控制器压入到导航控制器的栈中。它通常和导航视图控制器(<strong>navigation view controller</strong>)一起使用。<br>新压入的视图控制器会有一个回退按钮，可以退回来上一层。</li>\n</ul>\n<p>这个过程的实现代码可以看成是<code>push</code>和<code>pop</code>两个操作。</p>\n","raw":null,"categories":[{"name":"xcode","path":"api/categories/xcode.json"},{"name":"SB","path":"api/categories/SB.json"}],"tags":[{"name":"转场","path":"api/tags/转场.json"},{"name":"Storyboard","path":"api/tags/Storyboard.json"}]},{"title":"TextKit之便笺实战","slug":"iOS/TextKit之便笺实战","date":"2014-07-03T17:29:00.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/TextKit之便笺实战.json","excerpt":null,"keywords":null,"cover":"/images/bianqian.png","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"便笺练习功能点\"><a href=\"#便笺练习功能点\" class=\"headerlink\" title=\"便笺练习功能点:\"></a>便笺练习功能点:</h2><p>通过实现以下特效，练习并掌握布局管理器（layout manger），文本容器（text containers）和文本存储器（text storage）等用法。</p>\n<ul>\n<li>动态样式（Dynamic type）  </li>\n<li>凸版印刷效果（Letterpress effects）  </li>\n<li>环绕路径（Exclusion paths）  </li>\n<li>动态文本格式及存储（Dynamic text formatting and storage）  </li>\n</ul>\n<p>这个应用中我们将实现回流文本，字体大小的动态变换，以及闪回文本等效果。<br>效果图:<br><img src=\"/images/bianqian.png\" alt=\"image\"><br>App开始运行后自动生成一组便笺实例并利用<code>tableViewController</code>显示出来。<code>Storyboards</code>和<code>segues</code>会将被选中的单元格所对应的便笺内容显示出来以供用户编辑。<br>项目开发包：<a href=\"http://cdn4.raywenderlich.com/wp-content/uploads/2013/09/TextKitNotepad-starter.zip\" target=\"_blank\" rel=\"noopener\">Notepad.zip</a></p>\n<h2 id=\"动态样式\"><a href=\"#动态样式\" class=\"headerlink\" title=\"动态样式\"></a>动态样式</h2><p><code>动态样式（Dynamic type）</code>是iOS 7里面变化最大的特性之一; 它使得app可以遵从用户选择的字体大小和粗细。<br>选择 <strong>通用-&gt;文字大小</strong> 或 <strong>通用-&gt;辅助功能</strong> 来查看app中的字体设置。</p>\n<p><img src=\"/images/UserTextPreferences.png\" alt=\"image\"><br>iOS 7 支持通过<code>粗体</code>、<code>设置字体大小</code>等方式提高支持动态文本的应用的易读性。<br>例如<strong><code>UIFont</code></strong>新增的一个方法： <strong><code>preferredFontForTextStyle</code></strong> 用来根据用户对字体大小的设置来自动制定字体样式。<br>下面表格中是六种可用字体样式的示例：<br><img src=\"/images/TextStyles.png\" alt=\"image\"><br>最左边一列是最小字体；中间一列是最大字体；最右边一列是粗体效果。  </p>\n<h3 id=\"使用系统动态字体样式\"><a href=\"#使用系统动态字体样式\" class=\"headerlink\" title=\"使用系统动态字体样式\"></a>使用系统动态字体样式</h3><p>使用动态文本，是通过给<code>文本字体</code>设置字体样式<strong>style</strong>而不是指定具体的<code>字体名称</code>和<code>大小</code>。这样，系统会在运行时自动根据这一样式以及用户的字体大小设置来选择使用合适的字体。</p>\n<h4 id=\"preferredFontForTextStyle-方法设置字体样式\"><a href=\"#preferredFontForTextStyle-方法设置字体样式\" class=\"headerlink\" title=\"preferredFontForTextStyle:方法设置字体样式\"></a><code>preferredFontForTextStyle:</code>方法设置字体样式</h4><ol>\n<li>打开 <code>NoteEditorViewController.m/swift</code> 在<code>viewDidLoad：</code>方法实现的最后面加入以下代码：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.textView.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.textView.font = <span class=\"type\">UIFont</span>.preferredFont(forTextStyle: .body)</span><br></pre></td></tr></table></figure></li>\n<li>打开 <code>NotesListViewController.m/swift</code> 在 <code>tableView:cellForRowAtIndexPath:</code> 方法中增加如下代码:<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cell.textLabel.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleHeadline</span>];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cell.textLabel?.font = <span class=\"type\">UIFont</span>.preferredFont(forTextStyle: .headline)</span><br></pre></td></tr></table></figure>\n上面两行代码都用到了新版iOS的字体样式.   <blockquote>\n<p>字体样式：通过语义法命名字体，例如 <code>UIFontTextStyleSubHeadline</code>, 可以避免在代码里每一处都指定具体的字体名称和样式， 而且确保app能对用户的字体大小设置做出恰当的回应。</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"APP响应用户字体设置\"><a href=\"#APP响应用户字体设置\" class=\"headerlink\" title=\"APP响应用户字体设置\"></a>APP响应用户字体设置</h4><ol>\n<li>设置系统字体<br>返回到<strong>通用-&gt;文字大小</strong>重新修改字体设置.<br>再运行App, <strong>Note</strong>页面的文字大小是当前设定的字体大小；前后截屏对比,分辨率小了一半。<br><img src=\"/images/NotepadWithDynamicType.png\" alt=\"image\"> </li>\n<li>设置系统字体生效<br>当我们返回到<strong>通用-&gt;文字大小</strong>重新修改字体设置. 再打开<strong>Note</strong>页面, 会发现app并没有<strong>立即</strong>对字体设置的变化做出相应反应。</li>\n</ol>\n<h5 id=\"监听系统通知：实现APP响应用户字体设置\"><a href=\"#监听系统通知：实现APP响应用户字体设置\" class=\"headerlink\" title=\"监听系统通知：实现APP响应用户字体设置\"></a>监听系统通知：实现APP响应用户字体设置</h5><p>当用户修改了他们的字体大小设置之后，这一样式对应的字体并不会自动更新，必须重新请求才能获取新的值。用户设置变化后，<code>preferredFontForTextStyle:</code>方法返回的字体也会变化。</p>\n<ol>\n<li>添加监听系统通知<code>UIContentSizeCategoryDidChangeNotification</code>通知APP响应用户字体设置的变化<br>打开 <code>NoteEditorViewController.m</code> 并在 <code>viewDidLoad</code> 方法的实现的最后加入以下代码：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter]</span><br><span class=\"line\">                              addObserver:<span class=\"keyword\">self</span></span><br><span class=\"line\">                                 selector:<span class=\"keyword\">@selector</span>(preferredContentSizeChanged:)</span><br><span class=\"line\">                                     name:<span class=\"built_in\">UIContentSizeCategoryDidChangeNotification</span></span><br><span class=\"line\">                                   object:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//字体变化通知:调用preferredContentSizeChanged:方法</span></span><br><span class=\"line\"><span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(<span class=\"keyword\">self</span>, selector: #selector(<span class=\"type\">NoteEditorViewController</span>.preferredContentSizeChanged(<span class=\"number\">_</span>:)), name: <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>.<span class=\"type\">UIContentSizeCategoryDidChange</span>, object: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure></li>\n<li>添加系统通知响应事件<br>收到用于指定本类接收字体设定变化的通知后，调用<code>preferredContentSizeChanged:</code>方法<br>在<code>NoteEditorViewController.m</code>中<code>viewDidLoad</code>方法之后紧接着添加以下方法：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)preferredContentSizeChanged:(<span class=\"built_in\">NSNotification</span> *)notification</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.textView.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//字体变化通知时调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">preferredContentSizeChanged</span><span class=\"params\">(<span class=\"number\">_</span> notification:NSNotification)</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.textView.font = <span class=\"type\">UIFont</span>.preferredFont(forTextStyle: .body)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n这一方法作用是根据新的字体设置来设定<code>textView</code>中的字体。<br>Build并运行app，修改字体大小设置，Note页面就可以即时更新字体大小了。<a id=\"more\"></a>\n</li>\n</ol>\n<h3 id=\"更新布局\"><a href=\"#更新布局\" class=\"headerlink\" title=\"更新布局\"></a>更新布局</h3><p>现在，如果你把字体设置到很小，那每个单元格的空白区域是不是太多了，看上去文字比较稀疏，如下面所示：<br>  <img src=\"/images/ChangingLayout.png\" alt=\"image\">  </p>\n<p>这是<strong>动态样式</strong>有点小复杂的部分：要保证App在字体大小变化后，同时也修改文字表格的行高。<br>在<code>NotesListViewController.m</code>中实现<code>tableView:heightForRowAtIndexPath:</code> 代理方法:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">UILabel</span>* label;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!label) &#123;</span><br><span class=\"line\">        label = [[<span class=\"built_in\">UILabel</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, FLT_MAX, FLT_MAX)];</span><br><span class=\"line\">        label.text = <span class=\"string\">@\"test\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    label.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleHeadline</span>];</span><br><span class=\"line\">    [label sizeToFit];  <span class=\"comment\">//自适应文本内容大小</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> label.frame.size.height * <span class=\"number\">1.7</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, heightForRowAt indexPath: IndexPath)</span></span> -&gt; <span class=\"type\">CGFloat</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> label = <span class=\"type\">UILabel</span>.<span class=\"keyword\">init</span>(frame: <span class=\"type\">CGRect</span>.<span class=\"keyword\">init</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"type\">FLT_MAX</span>, height: <span class=\"type\">FLT_MAX</span>))</span><br><span class=\"line\">    label.text = <span class=\"string\">\"test\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> font = <span class=\"type\">UIFont</span>.preferredFont(forTextStyle: .headline)</span><br><span class=\"line\">    label.font = font</span><br><span class=\"line\">    label.sizeToFit()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> label.frame.size.height * <span class=\"number\">1.7</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上代码创建了一个共享的——或者说静态的——<strong>UILabel</strong>实例，设定它的字体和表中单元格内文本字体一致。然后调用它的<code>sizeToFit</code>方法，使这个<code>label</code>的<code>frame</code>恰好能放得下它的内容文字, 然后把这个<code>label</code>的高度乘个<code>1.7</code>作为表内单元格高度。<br>Build并运行app，修改字体大小设置，行高也会随着字体大小的变化而变化。 如下图所示：<br><img src=\"/images/TableViewAdaptsHeights.png\" alt=\"image\">  </p>\n<h3 id=\"凸版印刷效果（Letterpress-effects）\"><a href=\"#凸版印刷效果（Letterpress-effects）\" class=\"headerlink\" title=\"凸版印刷效果（Letterpress effects）\"></a>凸版印刷效果（Letterpress effects）</h3><p>凸版印刷效果（Letterpress effects）给文字加上精致的阴影和高光是文字看上去有一定立体感——就好像轻轻嵌入屏幕里一样。  </p>\n<blockquote>\n<font size=\"3\">注: 使用“凸版印刷（letterpress）”这一印刷术语是向早期印刷业的致敬。所谓凸版印刷，就是将涂上油墨的图文凸版嵌在印版上，然后在纸面上按压就把图文凸版上的油墨转移到纸面上了——纸面受力在文字边缘形成好看的突起。现在这一工艺已广泛被数码打印所取代。</font>  \n\n</blockquote>\n<p>打开NotesListViewController.m 将<code>tableView:cellForRowAtIndexPath:</code>方法中的代码用以下代码替换:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">NSString</span> *CellIdentifier = <span class=\"string\">@\"Cell\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier </span><br><span class=\"line\">                                                        forIndexPath:indexPath];</span><br><span class=\"line\">Note* note = [<span class=\"keyword\">self</span> notes][indexPath.row];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UIFont</span>* font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleHeadline</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UIColor</span>* textColor = [<span class=\"built_in\">UIColor</span> colorWithRed:<span class=\"number\">0.175</span>f green:<span class=\"number\">0.458</span>f blue:<span class=\"number\">0.831</span>f alpha:<span class=\"number\">1.0</span>f];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *attrs = @&#123; <span class=\"built_in\">NSForegroundColorAttributeName</span> : textColor,</span><br><span class=\"line\">                                    <span class=\"built_in\">NSFontAttributeName</span> : font,</span><br><span class=\"line\">                              <span class=\"built_in\">NSTextEffectAttributeName</span> : <span class=\"built_in\">NSTextEffectLetterpressStyle</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSAttributedString</span>* attrString = [[<span class=\"built_in\">NSAttributedString</span> alloc]</span><br><span class=\"line\">                                       initWithString:note.title</span><br><span class=\"line\">                                           attributes:attrs];</span><br><span class=\"line\">cell.textLabel.attributedText = attrString;</span><br><span class=\"line\"><span class=\"keyword\">return</span> cell;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class=\"type\">UITableViewCell</span></span><br><span class=\"line\">&#123;    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class=\"string\">\"noteListCell\"</span>, <span class=\"keyword\">for</span>: indexPath)</span><br><span class=\"line\">    <span class=\"comment\">// Configure the cell...</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> note = notes[indexPath.row] <span class=\"keyword\">as</span>! <span class=\"type\">NoteModel</span></span><br><span class=\"line\">    <span class=\"comment\">//cell.textLabel?.text = note.title</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> font = <span class=\"type\">UIFont</span>.preferredFont(forTextStyle: .headline)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> textColor = <span class=\"type\">UIColor</span>.<span class=\"keyword\">init</span>(red: <span class=\"number\">0.175</span>, green: <span class=\"number\">0.458</span>, blue: <span class=\"number\">0.831</span>, alpha: <span class=\"number\">1.0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//字体凸版印刷效果</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> store:[<span class=\"type\">String</span>:<span class=\"type\">Any</span>] = [<span class=\"type\">NSForegroundColorAttributeName</span>:textColor,</span><br><span class=\"line\">    <span class=\"type\">NSFontAttributeName</span>:font,</span><br><span class=\"line\">    <span class=\"type\">NSTextEffectAttributeName</span>:<span class=\"type\">NSTextEffectLetterpressStyle</span>]</span><br><span class=\"line\">    cell.textLabel?.attributedText = <span class=\"type\">NSAttributedString</span>.<span class=\"keyword\">init</span>(string: note.title, attributes: store)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cell</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码为单元格的标题创建了一个使用了凸版印刷效果的<strong><code>NSAttributedString</code></strong>。  </p><p><br>Build并运行app， 表格将显示凸版印刷效果，如下图所示：<br><img src=\"/images/Letterpress.png\" alt=\"image\"><br>凸版印刷效果是很精巧——但是并不表示你可以随意过度使用它。视觉特效能让文字看上去更有趣，但并不表示一定能让你的文字更清晰易读。</p>\n<h3 id=\"环绕路径（Exclusion-paths）\"><a href=\"#环绕路径（Exclusion-paths）\" class=\"headerlink\" title=\"环绕路径（Exclusion paths）\"></a>环绕路径（Exclusion paths）</h3><p>文字环绕图片或其它内容分布是大多数文字处理软件的标准特性之一。<code>Text Kit</code>允许你通过环绕路径（<code>exclusion paths</code>）将文字按照复杂路径和形状分布。  </p>\n<p>在便笺右上角添加一个曲线形视图，告知用户便笺创建的日期：   </p>\n<ul>\n<li>首先添加一个视图  </li>\n<li>创建一个环绕路径，使文字按照这个路径分布。 </li>\n</ul>\n<h4 id=\"添加视图\"><a href=\"#添加视图\" class=\"headerlink\" title=\"添加视图\"></a>添加视图</h4><p>打开 <code>NoteEditorViewController.m</code> 在顶部的<code>imports</code>和接口实现中添加变量加入以下代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"TimeIndicatorView.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NoteEditorViewController</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TimeIndicatorView* _timeView;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>实例化这个用以显示文本创建日期的视图实例，并把它作为一个子视图添加进去<br>在NoteEditorViewController.m的<code>viewDidLoad</code>方法的最后添加以下代码：<br><figure class=\"highlight objc\"><figcaption><span>objc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_timeView = [[TimeIndicatorView alloc] initWithDate:_note.timestamp];</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:_timeView];</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"设置视图位置及自动适应布局：viewDidLayoutSubviews\"><a href=\"#设置视图位置及自动适应布局：viewDidLayoutSubviews\" class=\"headerlink\" title=\"设置视图位置及自动适应布局：viewDidLayoutSubviews\"></a>设置视图位置及自动适应布局：<code>viewDidLayoutSubviews</code></h4><p>当<strong>NoteEditor</strong>视图的控件调用系统方法<code>viewDidLayoutSubviews</code>方法，对子视图进行布局时，<code>TimeIndicatorView</code>作为子控件也需要有相应的变化。<br>在控件接收到文本内容的尺寸发生了变化的时候调用<code>updateTimeIndicatorFrame</code>： </p>\n<ol>\n<li>第一调用<code>updateSize</code>来设定<code>_timeView</code>的尺寸  </li>\n<li>第二将<code>_timeView</code>放在右上角<br>在NoteEditorViewController.m 的最后添加如下代码：<figure class=\"highlight objc\"><figcaption><span>objc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLayoutSubviews </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> updateTimeIndicatorFrame];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)updateTimeIndicatorFrame</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [_timeView updateSize];</span><br><span class=\"line\">    _timeView.frame = <span class=\"built_in\">CGRectOffset</span>(_timeView.frame,</span><br><span class=\"line\">                          <span class=\"keyword\">self</span>.view.frame.size.width - _timeView.frame.size.width, <span class=\"number\">0.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//视图的控件调用viewDidLayoutSubviews对子视图进行布局时，TimeIndicatorView作为子控件也需要有相应的变化。</span></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLayoutSubviews</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    updateTimeIndicatorFrame()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">updateTimeIndicatorFrame</span><span class=\"params\">()</span></span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//第一调用updateSize来设定_timeView的尺寸</span></span><br><span class=\"line\">    timeIndicatorView.updateSize()</span><br><span class=\"line\">    <span class=\"comment\">//通过偏移frame参数，将timeIndicatorView放在右上角</span></span><br><span class=\"line\">    timeIndicatorView.frame = timeIndicatorView.frame.offsetBy(dx: ibTextView.frame.width - timeIndicatorView.frame.width,</span><br><span class=\"line\">                                                               dy: <span class=\"number\">0.0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"响应系统偏好设置字体样式\"><a href=\"#响应系统偏好设置字体样式\" class=\"headerlink\" title=\"响应系统偏好设置字体样式\"></a>响应系统偏好设置字体样式</h4><p>修改<code>NoteEditorViewController.m</code>中<code>preferredContentSizeChanged:</code>方法如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)preferredContentSizeChanged:(<span class=\"built_in\">NSNotification</span> *)n </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.textView.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> updateTimeIndicatorFrame];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>Build并运行app，点击选择一个便笺，日期显示视图将出现在右上角，如下图所示：<br><img src=\"/images/TimIndicator.png\" alt=\"修改设备中文本大小设置，这个视图也将自动调整到相应的合适尺寸\">    </p>\n<h3 id=\"文本环绕视图\"><a href=\"#文本环绕视图\" class=\"headerlink\" title=\"文本环绕视图\"></a>文本环绕视图</h3><ol>\n<li>根据日期视图<code>_timeView</code>创建基于贝赛尔路径的环绕路径</li>\n<li>设置文本容器的环绕路径：使用文本容器的exclusionPaths属性指定。它是一个UIBezierPath数组类型。</li>\n</ol>\n<h4 id=\"curvePathWithOrigin-创建文本容器的赛尔路径\"><a href=\"#curvePathWithOrigin-创建文本容器的赛尔路径\" class=\"headerlink\" title=\"curvePathWithOrigin:创建文本容器的赛尔路径\"></a>curvePathWithOrigin:创建文本容器的赛尔路径</h4><p>根据日期视图<code>_timeView</code>创建基于贝赛尔路径的环绕路径<br>添加<code>curvePathWithOrigin:</code>方法，定义文本遵循的环绕路径：<br><figure class=\"highlight objc\"><figcaption><span>objc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIBezierPath</span> *)curvePathWithOrigin:(<span class=\"built_in\">CGPoint</span>)origin</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">UIBezierPath</span> bezierPathWithArcCenter:origin</span><br><span class=\"line\">                                          radius: [<span class=\"keyword\">self</span> radiusToSurroundFrame:_label.frame]</span><br><span class=\"line\">                                      startAngle: <span class=\"number\">-180.0</span>f</span><br><span class=\"line\">                                        endAngle: <span class=\"number\">180.0</span>f</span><br><span class=\"line\">                                       clockwise: <span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">curvePathWithOrigin</span><span class=\"params\">(origin:CGPoint)</span></span>-&gt;<span class=\"type\">UIBezierPath</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//画弧形</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = <span class=\"type\">UIBezierPath</span>.<span class=\"keyword\">init</span>(arcCenter: origin,</span><br><span class=\"line\">    radius: radiusToSurroundFrame(frame: timeLabel.frame),</span><br><span class=\"line\">                             startAngle: -<span class=\"number\">180</span>,                <span class=\"comment\">//-180.0</span></span><br><span class=\"line\">                               endAngle: <span class=\"number\">180.0</span>,               <span class=\"comment\">//CGFloat(M_PI * 2),   //180.0</span></span><br><span class=\"line\">                              clockwise: <span class=\"literal\">true</span>)</span><br><span class=\"line\">    <span class=\"comment\">//        UIColor.blueColor().set()</span></span><br><span class=\"line\">    <span class=\"comment\">//        path.fill()</span></span><br><span class=\"line\">    <span class=\"comment\">//        UIColor.blueColor().set()</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> path</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"设置文本容器的环绕路径：exclusionPaths\"><a href=\"#设置文本容器的环绕路径：exclusionPaths\" class=\"headerlink\" title=\"设置文本容器的环绕路径：exclusionPaths\"></a>设置文本容器的环绕路径：exclusionPaths</h4><p><code>exclusionPaths</code>是<code>NSArray</code>类型，因此一个文本容器是可以支持多个环绕路径，文本<strong>环绕路径</strong>发生改变后会通知文本管理器，然后<strong>环绕路径</strong>的变化就可以动态地，甚至是动画式地体现到文本上！<br>在<code>updateTimeIndicatorFrame</code>方法实现的最后面添加如下代码：<br><figure class=\"highlight objc\"><figcaption><span>objc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIBezierPath</span>* exclusionPath = [_timeView curvePathWithOrigin:_timeView.center];</span><br><span class=\"line\">    _textView.textContainer.exclusionPaths  = @[exclusionPath];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> exclusionPath = timeIndicatorView.curvePathWithOrigin(origin: timeIndicatorView.center)</span><br><span class=\"line\">    ibTextView.textContainer.exclusionPaths = [exclusionPath]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>Build并运行app，选择一个便笺项，如下图所示：<br><img src=\"/images/ExclusionPath.png\" alt=\"实现文本环绕效果\">  </p>\n<h2 id=\"动态文本格式及存储（Dynamic-text-formatting-and-storage）\"><a href=\"#动态文本格式及存储（Dynamic-text-formatting-and-storage）\" class=\"headerlink\" title=\"动态文本格式及存储（Dynamic text formatting and storage）\"></a>动态文本格式及存储（Dynamic text formatting and storage）</h2><p>你已经看到了<code>Text Kit</code>可以根据用户设置的字体大小动态地调整字体。但是如果字体也可以根据实际的文字本身来进行动态更新是不是会更酷呢？<br>实现类似markdown语法的效果：  </p>\n<ul>\n<li>把波浪线(~)之间的文本变为艺术字体  </li>\n<li>把下划线(_)之间的文本变为斜体  </li>\n<li>为破折号(-)之间的文本添加删除线  </li>\n<li>把字母全部大写的单词变为红色<br><img src=\"/images/DynamicTextExample.png\" alt=\"利用Text Kit framework来实现的效果\">   </li>\n</ul>\n<h3 id=\"Text-Kit文本系统工作机制\"><a href=\"#Text-Kit文本系统工作机制\" class=\"headerlink\" title=\"Text Kit文本系统工作机制\"></a>Text Kit文本系统工作机制</h3><p><code>Text Kit 堆栈</code>存储、处理以及显示文本：<br><img src=\"/images/TextKitStack-443x320.png\" alt=\"image\"><br>当你创建<code>UITextView</code>, <code>UILabel</code> or <code>UITextField</code>的时候，Apple系统自动在后台帮你创建了这些类。你可以使用这些默认的实现或者是自定义一部分，以便达到想要的效果。</p>\n<ul>\n<li><strong><code>NSTextStorage</code>文本存储器</strong>: 作为一个<code>NSMutableAttributedString</code>的子类，动态处理的文本可以通过<code>attributedString</code>的方式存储，并且将文本内容的任何变化都通知给布局管理器。可以自定义<code>NSTextStorage</code>的子类，当文本发生变化时，动态地对文本属性做出相应改变。  </li>\n<li><strong><code>NSLayoutManager</code>布局引擎</strong>: 获取存储的文本并经过修饰处理再显示在屏幕上； </li>\n<li><strong><code>NSTextContainer</code>文本容器</strong>: 描述所要处理的文本在屏幕上的位置信息。每一个文本容器都有一个关联的<code>UITextView</code>. 可以创建 <code>NSTextContainer</code>的子类来定义<strong>一个复杂的形状</strong>，然后在这个形状内处理文本。  </li>\n</ul>\n<h3 id=\"NSTextStorage文本存储器动态添加文本属性\"><a href=\"#NSTextStorage文本存储器动态添加文本属性\" class=\"headerlink\" title=\"NSTextStorage文本存储器动态添加文本属性\"></a><code>NSTextStorage</code>文本存储器动态添加文本属性</h3><ol>\n<li>需要创建一个<code>NSTextStorage</code>的子类，用以在用户输入文本的时候，动态地添加文本属性。</li>\n<li>将<code>UITextView</code>的默认文本存储器,用自定义的实现替换掉。</li>\n</ol>\n<h4 id=\"创建文本存储器NSTextStorage子类\"><a href=\"#创建文本存储器NSTextStorage子类\" class=\"headerlink\" title=\"创建文本存储器NSTextStorage子类\"></a>创建文本存储器NSTextStorage子类</h4><p>新建<strong><code>NSTextStorage</code></strong>的子类，类命名为<strong><code>SyntaxHighlightTextStorage</code></strong><br>打开<strong>SyntaxHighlightTextStorage.m</strong>并添加实例变量并初始化：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"SyntaxHighlightTextStorage.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">SyntaxHighlightTextStorage</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableAttributedString</span> *\t_backingStore;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _backingStore = [<span class=\"built_in\">NSMutableAttributedString</span> new];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyntaxHighlightTextStorage</span>: <span class=\"title\">NSTextStorage</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//文本存储器子类必须提供它自己的“数据持久化层”。</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> backingStore = <span class=\"type\">NSMutableAttributedString</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"重载文本存储器的数据持久化层方法\"><a href=\"#重载文本存储器的数据持久化层方法\" class=\"headerlink\" title=\"重载文本存储器的数据持久化层方法\"></a>重载文本存储器的数据持久化层方法</h4><p>要使用<strong><code>NSMutableAttributedString</code></strong>作为“后台存储” (后面会详细讲解)，文本存储器子类必须提供它自己的“数据持久化层”：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)string</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [_backingStore string];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSDictionary</span> *)attributesAtIndex:(<span class=\"built_in\">NSUInteger</span>)location</span><br><span class=\"line\">                     effectiveRange:(<span class=\"built_in\">NSRangePointer</span>)range</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [_backingStore attributesAtIndex:location</span><br><span class=\"line\">                             effectiveRange:range];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">var</span> string: <span class=\"type\">String</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> backingStore.string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">attributes</span><span class=\"params\">(at location: Int, effectiveRange range: NSRangePointer?)</span></span> -&gt; [<span class=\"type\">String</span> : <span class=\"type\">Any</span>]</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> range == <span class=\"literal\">nil</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [:]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//print(\"backingStore:location\\(location),effectiveRange:\\(range!)\")</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> backingStore.attributes(at: location, effectiveRange: range!)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>上面两个方法直接把任务代理给了后台存储。  </p>\n<h4 id=\"重载编辑文本时通知布局管理器的方法\"><a href=\"#重载编辑文本时通知布局管理器的方法\" class=\"headerlink\" title=\"重载编辑文本时通知布局管理器的方法\"></a>重载编辑文本时通知布局管理器的方法</h4><p>同样的，这些方法也是把任务代理给后台存储。它们通过调用<code>beginEditing</code> / <code>edited</code> / <code>endEditing</code>这些方法来完成一些编辑任务。这样做是为了在编辑发生后让文本存储器的类通知相关的布局管理器。<br>最后，还在这个文件中，重载以下方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)replaceCharactersInRange:(<span class=\"built_in\">NSRange</span>)range withString:(<span class=\"built_in\">NSString</span> *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"replaceCharactersInRange:%@ withString:%@\"</span>, <span class=\"built_in\">NSStringFromRange</span>(range), str);</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> beginEditing];</span><br><span class=\"line\">    [_backingStore replaceCharactersInRange:range withString:str];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> edited:<span class=\"built_in\">NSTextStorageEditedCharacters</span> | <span class=\"built_in\">NSTextStorageEditedAttributes</span></span><br><span class=\"line\">              range:range</span><br><span class=\"line\">     changeInLength:str.length - range.length];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> endEditing];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setAttributes:(<span class=\"built_in\">NSDictionary</span> *)attrs range:(<span class=\"built_in\">NSRange</span>)range</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"setAttributes:%@ range:%@\"</span>, attrs, <span class=\"built_in\">NSStringFromRange</span>(range));</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> beginEditing];</span><br><span class=\"line\">    [_backingStore setAttributes:attrs range:range];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> edited:<span class=\"built_in\">NSTextStorageEditedAttributes</span> range:range changeInLength:<span class=\"number\">0</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> endEditing];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">replaceCharacters</span><span class=\"params\">(<span class=\"keyword\">in</span> range: NSRange, with str: String)</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"replaceCharactersInRange:\\(NSStringFromRange(range)) withString:\\(str)\"</span>)</span><br><span class=\"line\">    beginEditing()</span><br><span class=\"line\">    backingStore.replaceCharacters(<span class=\"keyword\">in</span>: range, with: str)</span><br><span class=\"line\">    edited([.editedAttributes,.editedCharacters], range: range, changeInLength: str.utf16.<span class=\"built_in\">count</span> - range.length)</span><br><span class=\"line\">    endEditing()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setAttributes</span><span class=\"params\">(<span class=\"number\">_</span> attrs: [String : Any]?, range: NSRange)</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//Sets the attributes for the characters in the specified range to the specified attributes.</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"setAttributes:\\(attrs!) range:\\(NSStringFromRange(range))\"</span>)</span><br><span class=\"line\">    beginEditing()</span><br><span class=\"line\">    backingStore.setAttributes(attrs!, range: range)</span><br><span class=\"line\">    edited(.editedAttributes, range: range, changeInLength: <span class=\"number\">0</span>)</span><br><span class=\"line\">    endEditing()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"类族介绍\"><a href=\"#类族介绍\" class=\"headerlink\" title=\"类族介绍\"></a>类族介绍</h4><p>类族是Apple的framework中广泛用到的一种设计模式。类族就是抽象工厂模式的实现，无需指定具体的类就可以为创建一族相关或从属的对象提供一个公共接口。一些我们很熟悉的类<code>NSArray</code>和<code>NSNumber</code>类似的就是一族类的公共接口。</p>\n<p>上例中<code>NSTextStorage</code>文本存储器就是一个类族的公共接口，需要大量代码来创建文本存储器的子类。在扩展功能时，通过创建子类及重载几个方法之外，有些特定需求是要自己实现的，比方<code>attributedString</code>数据的后台存储。</p>\n<p>Apple使用类族来封装同一个公共<code>抽象超类</code>下的私有具体子类，<code>抽象超类</code>声明了客户在创建<code>私有子类实例</code>时必须要实现的方法。客户是完全无法知道工厂正在用哪一个私有类，它只和公共接口相互协作。<br>使用类族当然可以简化接口，使学习和使用类更加容易，但是必须要需要指出的是要在功能扩展和接口简化之间达到平衡。创建一个类族的抽象超类的定制子类也常常是非常难的。 </p>\n<h3 id=\"创建UITextView使用自定义Text-Kit堆栈\"><a href=\"#创建UITextView使用自定义Text-Kit堆栈\" class=\"headerlink\" title=\"创建UITextView使用自定义Text Kit堆栈\"></a>创建UITextView使用自定义Text Kit堆栈</h3><p>现在有了一个自定义的<code>NSTextStorage</code>，还需创建一个<code>UITextView</code>来使用它。 </p>\n<h4 id=\"storyboard创建UITextView时，Text-Kit组件只读问题\"><a href=\"#storyboard创建UITextView时，Text-Kit组件只读问题\" class=\"headerlink\" title=\"storyboard创建UITextView时，Text Kit组件只读问题\"></a>storyboard创建UITextView时，Text Kit组件只读问题</h4><p>从<strong>storyboard</strong>编辑器实例化<code>UITextView</code>会自动创建<strong><code>NSTextStorage</code></strong>, <strong><code>NSLayoutManager</code></strong>和<strong><code>NSTextContainer</code></strong> (例如<strong>Text Kit</strong>堆栈)实例以及所有的这三个只读属性。<br>虽然没有办法从<strong>storyboard</strong>编辑器中改变这种设定，但可以手动编程创建<code>UITextView</code>和<strong>Text Kit</strong>堆栈。  </p>\n<h4 id=\"在UITextView中使用自定义的SyntaxHighlightTextStorage\"><a href=\"#在UITextView中使用自定义的SyntaxHighlightTextStorage\" class=\"headerlink\" title=\"在UITextView中使用自定义的SyntaxHighlightTextStorage\"></a>在UITextView中使用自定义的SyntaxHighlightTextStorage</h4><h5 id=\"清理IB相关设置\"><a href=\"#清理IB相关设置\" class=\"headerlink\" title=\"清理IB相关设置\"></a>清理IB相关设置</h5><ul>\n<li>在IB中打开<strong>Main.storyboard</strong> 找到<strong>NoteEditorViewController</strong>。 删除<code>UITextView</code>实例。<br>然后，打开<strong>NoteEditorViewController.m</strong>删除<strong>UITextView outlet</strong>。<br>既然不再为文本视图使用<code>IBOutlet</code>，而是要编程添加，所以也就不需要这些代码了。<br>从<code>viewDidLoad</code> 方法中删除以下代码：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.textView.text = <span class=\"keyword\">self</span>.note.contents;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.textView.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.textView.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"手动创建UITextView和Text-Kit堆栈\"><a href=\"#手动创建UITextView和Text-Kit堆栈\" class=\"headerlink\" title=\"手动创建UITextView和Text Kit堆栈\"></a>手动创建<code>UITextView</code>和Text Kit堆栈</h5><ul>\n<li>在<strong>NoteEditorViewController.m</strong>最上面，添加下面一行代码:<figure class=\"highlight objc\"><figcaption><span>objc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"SyntaxHighlightTextStorage.h\"</span></span></span><br></pre></td></tr></table></figure>\n在NoteEditorViewController.m中<code>TimeIndicatorView</code>实例变量后面紧接着添加以下代码：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SyntaxHighlightTextStorage* _textStorage;</span><br><span class=\"line\"><span class=\"built_in\">UITextView</span>* _textView;</span><br></pre></td></tr></table></figure>\n文本存储器子类有两个实例变量，还有一个文本视图稍后需要添加。  </li>\n</ul>\n<h5 id=\"创建Text-Kit堆栈\"><a href=\"#创建Text-Kit堆栈\" class=\"headerlink\" title=\"创建Text Kit堆栈\"></a>创建<code>Text Kit</code>堆栈</h5><ul>\n<li>创建自定义的<code>NSTextStorage</code>文本存储器实例，一个用来承载便笺内容的<code>NSAttributedString</code>  </li>\n<li>创建一个<code>NSLayoutManager</code>布局管理器，并添加到文本存储器。</li>\n<li>创建一个<code>NSTextContainer</code>文本容器，并添加到布局管理器。然后把布局管理器和文本存储器联系起来  </li>\n<li>最后用你自定义的文本容器和代理组创建实际的文本视图，  并把文本视图添加为子视图<br>在NoteEditorViewController.m中，添加下面方法：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)createTextView</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. Create the text storage that backs the editor</span></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* attrs = @&#123;<span class=\"built_in\">NSFontAttributeName</span>:</span><br><span class=\"line\">        [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>]&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">NSAttributedString</span>* attrString = [[<span class=\"built_in\">NSAttributedString</span> alloc]</span><br><span class=\"line\">                                   initWithString:_note.contents</span><br><span class=\"line\">                                       attributes:attrs];</span><br><span class=\"line\">    _textStorage = [SyntaxHighlightTextStorage new];</span><br><span class=\"line\">    [_textStorage appendAttributedString:attrString];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CGRect</span> newTextViewRect = <span class=\"keyword\">self</span>.view.bounds;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. Create the layout manager</span></span><br><span class=\"line\">    <span class=\"built_in\">NSLayoutManager</span> *layoutManager = [[<span class=\"built_in\">NSLayoutManager</span> alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. Create a text container</span></span><br><span class=\"line\">    <span class=\"built_in\">CGSize</span> containerSize = <span class=\"built_in\">CGSizeMake</span>(newTextViewRect.size.width,  <span class=\"built_in\">CGFLOAT_MAX</span>);</span><br><span class=\"line\">    <span class=\"built_in\">NSTextContainer</span> *container = [[<span class=\"built_in\">NSTextContainer</span> alloc] initWithSize:containerSize];</span><br><span class=\"line\">    container.widthTracksTextView = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    [layoutManager addTextContainer:container];</span><br><span class=\"line\">    [_textStorage addLayoutManager:layoutManager];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4. Create a UITextView</span></span><br><span class=\"line\">    _textView = [[<span class=\"built_in\">UITextView</span> alloc] initWithFrame:newTextViewRect</span><br><span class=\"line\">                                    textContainer:container];</span><br><span class=\"line\">    _textView.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:_textView];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建文本区域</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createTextView</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. Create the text storage that backs the editor</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bodyFont = <span class=\"type\">UIFont</span>.preferredFont(forTextStyle: <span class=\"type\">UIFontTextStyle</span>.body)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> attrs = [<span class=\"type\">NSFontAttributeName</span>:bodyFont]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> attrString = <span class=\"type\">NSAttributedString</span>(string: note.contents,attributes: attrs)</span><br><span class=\"line\">    textStorage = <span class=\"type\">SyntaxHighlightTextStorage</span>()</span><br><span class=\"line\">    textStorage.append(attrString)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// --------使用Storyboard声明TextView时,只需一行，可惜为只读属性----------</span></span><br><span class=\"line\">    textStorage.addLayoutManager(ibTextView.layoutManager)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**--------使用代码声明TextView时，4步骤----------</span></span><br><span class=\"line\"><span class=\"comment\">    let newTextViewRect = view.bounds</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    // 2. Create the layout manager</span></span><br><span class=\"line\"><span class=\"comment\">    let layoutManager = NSLayoutManager()</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    // 3. Create a text container</span></span><br><span class=\"line\"><span class=\"comment\">    //文本容器的宽度会自动匹配视图的宽度，但是它的高度是无限高的——或者说无限接近于CGFloat.max，它的值可以是无限大。</span></span><br><span class=\"line\"><span class=\"comment\">    let containerSize = CGSize.init(width: newTextViewRect.size.width,</span></span><br><span class=\"line\"><span class=\"comment\">    height: CGFloat.greatestFiniteMagnitude)</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    let container = NSTextContainer.init(size: containerSize)</span></span><br><span class=\"line\"><span class=\"comment\">    //A Boolean that controls whether the receiver adjusts the width of its bounding rectangle when its text view is resized.</span></span><br><span class=\"line\"><span class=\"comment\">    container.widthTracksTextView = true</span></span><br><span class=\"line\"><span class=\"comment\">    //</span></span><br><span class=\"line\"><span class=\"comment\">    layoutManager.addTextContainer(container)</span></span><br><span class=\"line\"><span class=\"comment\">    textStorage.addLayoutManager(layoutManager)</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    // 4. Create a UITextView</span></span><br><span class=\"line\"><span class=\"comment\">    textView = UITextView()//.init(frame: newTextViewRect, textContainer: container)</span></span><br><span class=\"line\"><span class=\"comment\">    textView.isScrollEnabled = true</span></span><br><span class=\"line\"><span class=\"comment\">    textView.delegate = self</span></span><br><span class=\"line\"><span class=\"comment\">    view.addSubview(textView)</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>现在回顾之前那个图表所展示的四个关键类(文本存储器<code>storage</code>, 布局管理器<code>layout manager</code>, 文本容器<code>container</code> 和文本视图<code>textView</code>)之间的关系，是不是觉得理解起来容易多了。<br><img src=\"/images/TextKitStack-443x320.png\" alt=\"image\"></p>\n<blockquote>\n<font size=\"3\">注意:文本容器的宽度会自动匹配视图的宽度，但是它的高度是无限高的——或者说无限接近于<code>CGFLOAT_MAX</code>，它的值可以是无限大。不管怎么说，它的高度足够让<code>UITextView</code>上下滚动以容纳很长的文本。</font>    \n\n</blockquote>\n<p>在<code>viewDidLoad</code>方法中调用超类的<code>viewDidLoad</code>方法的语句后面添加以下一行代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span> createTextView];</span><br></pre></td></tr></table></figure><br>然后修改<code>preferredContentSizeChanged</code>的第一行代码为：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_textView.font = [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"自定义视图实现在storyboard中自动布局约束的效果\"><a href=\"#自定义视图实现在storyboard中自动布局约束的效果\" class=\"headerlink\" title=\"自定义视图实现在storyboard中自动布局约束的效果\"></a>自定义视图实现在<code>storyboard</code>中自动布局约束的效果</h5><p>用自定义的实例变量来替换掉旧的<code>outlet</code>属性。自定义视图不会自动继承<code>storyboard</code>中的布局约束组的规则。当设备方向变化后，视图的边界是不会自动随之改变的，这样就需要自己来编程设定视图边界。  </p>\n<p>可以在<code>viewDidLayoutSubviews</code>方法的最后添加以下代码来实现：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_textView.frame = <span class=\"keyword\">self</span>.view.bounds;</span><br></pre></td></tr></table></figure><br>Build并运行app，打开一个便笺项，在Xcode控制台上有<code>SyntaxHighlightTextStorage</code>生成的运行日志，用来告诉你这些文本处理的代码确实被调用：<br><img src=\"/images/LogMessages-480x266.png\" alt=\"image\"><br>看来你的文本解析器的基础非常可靠了 —— 那现在来添加动态格式。</p>\n<h3 id=\"通过正则修改文本存储器的动态格式（Dynamic-formatting）\"><a href=\"#通过正则修改文本存储器的动态格式（Dynamic-formatting）\" class=\"headerlink\" title=\"通过正则修改文本存储器的动态格式（Dynamic formatting）\"></a>通过正则修改文本存储器的动态格式（Dynamic formatting）</h3><p>接下来将对你的自定义文本存储器进行修改以将＊星号符之间的文本＊变为黑体：</p>\n<h4 id=\"processEditing：将文本的变化通知给布局管理器\"><a href=\"#processEditing：将文本的变化通知给布局管理器\" class=\"headerlink\" title=\"processEditing：将文本的变化通知给布局管理器\"></a><code>processEditing</code>：将文本的变化通知给布局管理器</h4><p><code>processEditing</code> 将文本的变化通知给布局管理器。它也为文本编辑之后的处理提供便利。<br>打开<strong>SyntaxHighlightTextStorage.m</strong> 添加以下方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)processEditing</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> performReplacementsForRange:[<span class=\"keyword\">self</span> editedRange]];</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> processEditing];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>####<br>NSUnionRange：在range1和range2之间比较，如果一个range完全包含在另一个range内，则返回较大的range<br>上面的代码拓展了受黑体格式类型影响的文本范围。因为<code>changedRange</code>一般只是作用到单独的一个字符； 而<code>lineRangeForRange</code> 则扩展到一整行<br>在 <code>processEditing</code>方法之后紧接着添加以下代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)performReplacementsForRange:(<span class=\"built_in\">NSRange</span>)changedRange</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSRange</span> extendedRange = <span class=\"built_in\">NSUnionRange</span>(changedRange, [[_backingStore string]</span><br><span class=\"line\">                             lineRangeForRange:<span class=\"built_in\">NSMakeRange</span>(changedRange.location, <span class=\"number\">0</span>)]);</span><br><span class=\"line\">    extendedRange = <span class=\"built_in\">NSUnionRange</span>(changedRange, [[_backingStore string] </span><br><span class=\"line\">                          lineRangeForRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"built_in\">NSMaxRange</span>(changedRange), <span class=\"number\">0</span>)]);</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> applyStylesToRange:extendedRange];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight swift\"><figcaption><span>swift</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在指定的区域中进行替换</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">performReplacementsForRange</span><span class=\"params\">(<span class=\"number\">_</span> changedRange:NSRange)</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//定位正在编辑文本的位置区间</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> locationRange = <span class=\"type\">NSMakeRange</span>(changedRange.location, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//定位到文本当前行的位置区间</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> range1 = (backingStore.string <span class=\"keyword\">as</span> <span class=\"type\">NSString</span>).lineRange(<span class=\"keyword\">for</span>: locationRange)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//扩展范围</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> extendedRange = <span class=\"type\">NSUnionRange</span>(changedRange, range1)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> maxRange = <span class=\"type\">NSMakeRange</span>(<span class=\"type\">NSMaxRange</span>(changedRange), <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> range2 = (backingStore.string <span class=\"keyword\">as</span> <span class=\"type\">NSString</span>).lineRange(<span class=\"keyword\">for</span>: maxRange)</span><br><span class=\"line\">    extendedRange = <span class=\"type\">NSUnionRange</span>(changedRange, range2)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"在指定的区域中进行替换:\\(extendedRange)\"</span>)</span><br><span class=\"line\">    applyStylesToRange(searchRange: extendedRange)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>在 <code>performReplacementsForRange</code>方法之后紧接着添加以下代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)applyStylesToRange:(<span class=\"built_in\">NSRange</span>)searchRange</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. create some fonts</span></span><br><span class=\"line\">    <span class=\"built_in\">UIFontDescriptor</span>* fontDescriptor = [<span class=\"built_in\">UIFontDescriptor</span></span><br><span class=\"line\">                             preferredFontDescriptorWithTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br><span class=\"line\">    <span class=\"built_in\">UIFontDescriptor</span>* boldFontDescriptor = [fontDescriptor</span><br><span class=\"line\">                           fontDescriptorWithSymbolicTraits:<span class=\"built_in\">UIFontDescriptorTraitBold</span>];</span><br><span class=\"line\">    <span class=\"built_in\">UIFont</span>* boldFont =  [<span class=\"built_in\">UIFont</span> fontWithDescriptor:boldFontDescriptor size: <span class=\"number\">0.0</span>];</span><br><span class=\"line\">    <span class=\"built_in\">UIFont</span>* normalFont =  [<span class=\"built_in\">UIFont</span> preferredFontForTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. match items surrounded by asterisks</span></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span>* regexStr = <span class=\"string\">@\"(*w+(sw+)**)s\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSRegularExpression</span>* regex = [<span class=\"built_in\">NSRegularExpression</span></span><br><span class=\"line\">                                   regularExpressionWithPattern:regexStr</span><br><span class=\"line\">                                                        options:<span class=\"number\">0</span></span><br><span class=\"line\">                                                          error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* boldAttributes = @&#123; <span class=\"built_in\">NSFontAttributeName</span> : boldFont &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* normalAttributes = @&#123; <span class=\"built_in\">NSFontAttributeName</span> : normalFont &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. iterate over each match, making the text bold</span></span><br><span class=\"line\">    [regex enumerateMatchesInString:[_backingStore string]</span><br><span class=\"line\">              options:<span class=\"number\">0</span></span><br><span class=\"line\">                range:searchRange</span><br><span class=\"line\">           usingBlock:^(<span class=\"built_in\">NSTextCheckingResult</span> *match,</span><br><span class=\"line\">                        <span class=\"built_in\">NSMatchingFlags</span> flags,</span><br><span class=\"line\">                        <span class=\"built_in\">BOOL</span> *stop)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">NSRange</span> matchRange = [match rangeAtIndex:<span class=\"number\">1</span>];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> addAttributes:boldAttributes range:matchRange];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 4. reset the style to the original</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">NSMaxRange</span>(matchRange)+<span class=\"number\">1</span> &lt; <span class=\"keyword\">self</span>.length) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span> addAttributes:normalAttributes</span><br><span class=\"line\">                range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"built_in\">NSMaxRange</span>(matchRange)+<span class=\"number\">1</span>, <span class=\"number\">1</span>)];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码有以下作用：  </p>\n<ol>\n<li>创建一个粗体及一个正常字体并使用字体描述器（<strong>Font descriptors</strong>）来格式化文本。字体描述器能使你无需对字体手动编码来设置字体和样式。  </li>\n<li>创建一个正则表达式来定位星号符包围的文本。例如，在字符串“iOS 7 is *awesome*”中，存储在regExStr中的正则表达式将会匹配并返回文本“*awesome*”。</li>\n<li>对正则表达式匹配到并返回的文本进行枚举并添加粗体属性。  </li>\n</ol>\n<p>将后一个星号符之后的文本都重置为“常规”样式。以保证添加在后一个星号符之后的文本不被粗体风格所影响。</p>\n<blockquote>\n<font size=\"3\">注： 字体描述器（<strong>Font descriptors</strong>）是一种描述性语言，它使你可以通过设置属性来修改字体，或者无需初始化<code>UIFont</code>实例便可获取字体规格的细节。</font>    \n\n</blockquote>\n<p>Build并运行app；向便笺中输入文本，并将其中一个词用星号符包围。这个词将会自动变为黑体，如下面截图所示：<br><img src=\"/images/BoldText.png\" alt=\"image\">  </p>\n<p>##进一步添加样式<br>为限定文本添加风格的基本原则很简单：<strong>使用正则表达式来寻找和替换限定字符，然后用applyStylesToRange来设置想要的文本样式即可。</strong><br>在SyntaxHighlightTextStorage.m中添加以下实例变量：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>) createHighlightPatterns &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIFontDescriptor</span> *scriptFontDescriptor =</span><br><span class=\"line\">      [<span class=\"built_in\">UIFontDescriptor</span> fontDescriptorWithFontAttributes:</span><br><span class=\"line\">          @&#123;<span class=\"built_in\">UIFontDescriptorFamilyAttribute</span>: <span class=\"string\">@\"Zapfino\"</span>&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. base our script font on the preferred body font size</span></span><br><span class=\"line\">    <span class=\"built_in\">UIFontDescriptor</span>* bodyFontDescriptor = [<span class=\"built_in\">UIFontDescriptor</span></span><br><span class=\"line\">      preferredFontDescriptorWithTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSNumber</span>* bodyFontSize = bodyFontDescriptor.</span><br><span class=\"line\">                  fontAttributes[<span class=\"built_in\">UIFontDescriptorSizeAttribute</span>];</span><br><span class=\"line\">    <span class=\"built_in\">UIFont</span>* scriptFont = [<span class=\"built_in\">UIFont</span></span><br><span class=\"line\">              fontWithDescriptor:scriptFontDescriptor size:[bodyFontSize floatValue]];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. create the attributes</span></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* boldAttributes = [<span class=\"keyword\">self</span></span><br><span class=\"line\">     createAttributesForFontStyle:<span class=\"built_in\">UIFontTextStyleBody</span></span><br><span class=\"line\">                        withTrait:<span class=\"built_in\">UIFontDescriptorTraitBold</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* italicAttributes = [<span class=\"keyword\">self</span></span><br><span class=\"line\">     createAttributesForFontStyle:<span class=\"built_in\">UIFontTextStyleBody</span></span><br><span class=\"line\">                        withTrait:<span class=\"built_in\">UIFontDescriptorTraitItalic</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* strikeThroughAttributes = @&#123; <span class=\"built_in\">NSStrikethroughStyleAttributeName</span> : @<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* scriptAttributes = @&#123; <span class=\"built_in\">NSFontAttributeName</span> : scriptFont&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span>* redTextAttributes =</span><br><span class=\"line\">                          @&#123; <span class=\"built_in\">NSForegroundColorAttributeName</span> : [<span class=\"built_in\">UIColor</span> redColor]&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// construct a dictionary of replacements based on regexes</span></span><br><span class=\"line\">    _replacements = @&#123;</span><br><span class=\"line\">              <span class=\"string\">@\"(\\*w+(sw+)\\*\\*)s\"</span> : boldAttributes,</span><br><span class=\"line\">              <span class=\"string\">@\"(_w+(sw+)\\*_)s\"</span> : italicAttributes,</span><br><span class=\"line\">              <span class=\"string\">@\"([0-9]+.)s\"</span> : boldAttributes,</span><br><span class=\"line\">              <span class=\"string\">@\"(-w+(sw+)\\*-)s\"</span> : strikeThroughAttributes,</span><br><span class=\"line\">              <span class=\"string\">@\"(~w+(sw+)\\*~)s\"</span> : scriptAttributes,</span><br><span class=\"line\">              <span class=\"string\">@\"s([A-Z]&#123;2,&#125;)s\"</span> : redTextAttributes&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个方法的作用：</p>\n<ol>\n<li>首先，它使用Zapfino字体来创建了“<code>script</code>”风格。<strong>Font descriptors</strong>会决定当前正文的首选字体，以保证<code>script</code>不会影响到用户的字体大小设置。  </li>\n<li>然后，它会为每种匹配的字体样式构造各个属性。你稍后将用到 <strong><code>createAttributesForFontStyle:withTrait:</code></strong>。</li>\n<li>最后，它将创建一个<code>NSDictionary</code>并将正则表达式映射到上面声明的属性上。</li>\n</ol>\n<p>如果你对正则表达式不是非常熟悉，上面的的dictionary对你来说可能很陌生。但是，如果你一点一点仔细分析它其中包含的正则表达式，其实不用很费力就能理解了。  </p>\n<p>以上面实现的第一个正则表达式为例，它的工作是匹配星号符包围的文本：<br>(*w+(sw+)**)s<br>上面两个两个相连的斜杠，其中一个是用来将Objective-C中的特殊字符转义成实体字符。去掉用来转义的斜杠，来看下这个正则表达式的核心部分：<br>(*w+(sw+)**)s<br>现在，逐步来分析这个正则表达式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*\t \t \t  ——  匹配星号符  </span><br><span class=\"line\">w+   \t \t —— 后接一个或多个 “word”式 字符串  </span><br><span class=\"line\">(sw+)*\t   —— 后接零个或多组空格然后再接 “word” 式字符串  </span><br><span class=\"line\">*)   \t  —— 后接星号符  </span><br><span class=\"line\">s   \t  —— 以空格结尾  </span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<font size=\"3\">注：如果你想对正则表达式有更多了解，请参考 <a href=\"http://www.raywenderlich.com/30288/nsregularexpression-tutorial-and-cheat-sheet\" target=\"_blank\" rel=\"noopener\">NSRegularExpression tutorial and cheat sheet</a>.</font>  \n\n</blockquote>\n<p>现在你需要调用<code>createHighlightPatterns：</code><br>将<strong>SyntaxHighlightTextStorage.m</strong> 中的<code>init</code>方法更新如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</span><br><span class=\"line\">        _backingStore = [<span class=\"built_in\">NSMutableAttributedString</span> new];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> createHighlightPatterns];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在SyntaxHighlightTextStorage.m方法中添加以下代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSDictionary</span>*)createAttributesForFontStyle:(<span class=\"built_in\">NSString</span>*)style</span><br><span class=\"line\">                                    withTrait:(uint32_t)trait &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIFontDescriptor</span> *fontDescriptor = [<span class=\"built_in\">UIFontDescriptor</span></span><br><span class=\"line\">                               preferredFontDescriptorWithTextStyle:<span class=\"built_in\">UIFontTextStyleBody</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">UIFontDescriptor</span> *descriptorWithTrait = [fontDescriptor</span><br><span class=\"line\">                                    fontDescriptorWithSymbolicTraits:trait];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">UIFont</span>* font =  [<span class=\"built_in\">UIFont</span> fontWithDescriptor:descriptorWithTrait size: <span class=\"number\">0.0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> @&#123; <span class=\"built_in\">NSFontAttributeName</span> : font &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码作用是将提供的字体样式作用到正文字体上。它给<code>fontWithDescriptor:size:</code> 提供的<code>size</code>值为0，这样做会迫使<code>UIFont</code>返回用户设置的字体大小。</p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"控件","path":"api/categories/控件.json"}],"tags":[{"name":"TextKit","path":"api/tags/TextKit.json"},{"name":"案例","path":"api/tags/案例.json"}]},{"title":"iOS Document Interaction 编程指南","slug":"iOS/iOSDocumentInteraction编程指南","date":"2014-07-01T23:12:01.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/iOS/iOSDocumentInteraction编程指南.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"关于-Document-Interaction\"><a href=\"#关于-Document-Interaction\" class=\"headerlink\" title=\"关于 Document Interaction\"></a>关于 Document Interaction</h4><p>  iOS支持在你的app中通过调用其他app来预览和显示文档。iOS还支持文件关联，允许其他app调用你的app打开文件。这些技术包括了UIKit中提供的<a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIDocumentInteractionController_class/Reference/Reference.html\" target=\"_blank\" rel=\"noopener\">UIDocumentInteractionController</a>类，以及<a href=\"https://developer.apple.com/library/ios/documentation/QuickLook/Reference/QuickLookFrameworkReference_iPhoneOS/_index.html\" target=\"_blank\" rel=\"noopener\">Quick Look</a>框架。</p>\n<ul>\n<li>######预览文档和呈现选项菜单<br>如果app需要打开自身并不支持的文件时，就需要使用<strong>UIDocumentInteractionController</strong>。一个<strong>document interaction controller</strong>通过<strong>Quick Look框架</strong>判断文档是否能被另一个app打开和预览。也就是说，app可以通过<strong>documentinteraction controller</strong>提供一些支持打开该文件方式的菜单。</li>\n</ul>\n<p>具体实现需要以下步骤：</p>\n<ul>\n<li><ul>\n<li>需要通过其他APP打开的文件，来实例化<code>UIDocumentInteractionController</code>实例对象。  </li>\n</ul>\n</li>\n<li><ul>\n<li>在自己的APP UI中提供一个代表这种文件的图像标（一般显示文件名或者图标）。</li>\n</ul>\n</li>\n<li><ul>\n<li>用户交互，如触摸这个控件，则调用<code>documentinteractioncontroller</code>对象。  </li>\n</ul>\n</li>\n</ul>\n<p>三种交互界面:</p>\n<pre><code>1. 预览文件的内容。\n2. 一个包含预览和打开操作的菜单。可以通过实现某些委托方法，向菜单中加入其他操作，比如复制、打印。\n3. 一个菜单，仅包含“以其它方式打开”操作。\n</code></pre><p>同时，<code>documentinteractioncontroller</code>内置了一些手势，必要时可以直接实现它们。  </p>\n<ul>\n<li><p>######使用<code>documentinteractioncontroller</code>的场景:<strong>与文件交互的app都可以使用。</strong></p>\n</li>\n<li><ul>\n<li>需要从网络下载文件的APP:<br>例如，email程序需要打开和预览邮件附件。</li>\n</ul>\n</li>\n<li><ul>\n<li>不下载文件的APP:<br>例如，APP需要支持文件共享（参考“File-Sharing Support” in <a href=\"https://developer.apple.com/library/ios/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007898\" target=\"_blank\" rel=\"noopener\">iOS Technology Overview</a>), 即可以对同步到app Documents/Shared目录下的文件使用<code>documentinteractioncontroller</code>。<a id=\"more\"></a>\n<h4 id=\"创建Document-Interaction-Controller\"><a href=\"#创建Document-Interaction-Controller\" class=\"headerlink\" title=\"创建Document Interaction Controller\"></a>创建Document Interaction Controller</h4>创建时，通过需要其他APP打开的文件，来实例化<code>UIDocumentInteractionController</code>实例对象，并设置它的<code>delegate</code>属性。<br><code>delegate</code>对象负责告诉<strong>document  interaction controller</strong>呈现视图时需要的信息，以及当视图显示和用户交互时要执行的动作。<br>如以下代码所示。注意方法的调用者必须返回对象。<figure class=\"highlight objc\"><figcaption><span>实例化document interaction controller</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIDocumentInteractionController</span> *) setupControllerWithURL: (<span class=\"built_in\">NSURL</span>) fileURL</span><br><span class=\"line\">    \t\t\t\t\t\t\t\t\t\t\t usingDelegate: (<span class=\"keyword\">id</span> &lt;<span class=\"built_in\">UIDocumentInteractionControllerDelegate</span>&gt;) interactionDelegate </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t   <span class=\"built_in\">UIDocumentInteractionController</span> *interactionController =</span><br><span class=\"line\">\t       \t\t\t\t\t\t\t\t\t[<span class=\"built_in\">UIDocumentInteractionController</span> interactionControllerWithURL: fileURL];</span><br><span class=\"line\">\t   interactionController.delegate = interactionDelegate;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t   <span class=\"keyword\">return</span> interactionController;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>实例创建后，可以通过它的属性来读取与之关联的文件信息，包括文件名、类型和URL。该实例中还有一个<code>icons</code>属性，其中包含了多个 <code>UIImage</code> 对象,可以用于表示该文档的多个大小的图标。这些信息可用于UI。</p>\n<p>如果用其他APP打开该文件，可以利用该实例的 <code>annotation</code> 属性，该属性包含了其他APP所需的附加信息。当然信息的格式必须能够被该APP识别。<br>例如:当程序想与套件中的其他程序进行交互时，就可以使用<code>annotation</code> 属性。当被调用应用程序打开一个文件时，<code>option</code> 字典中会包含 <code>annotation</code> 的值，可以使用<font color=\"red\" size=\"1\">UIApplicationLaunchOptionsAnnotationKey</font> 作为键在<code>option</code>字典中检索它。</p>\n<h4 id=\"呈现-Document-Interaction-Controller\"><a href=\"#呈现-Document-Interaction-Controller\" class=\"headerlink\" title=\"呈现 Document Interaction Controller\"></a>呈现 Document Interaction Controller</h4><p>用户可以通过 <code>Document interaction controller</code>实例，来预览该文件，或者通过弹出菜单让用户选择相应的动作。  </p>\n<ul>\n<li><p>模式化显示文件预览窗口，调用如下方法:</p>\n<figure class=\"highlight objc\"><figcaption><span>模式化预览窗口调用的方法 Declared In UIDocumentInteractionController.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Displays a full-screen preview of the target document.</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)presentPreviewAnimated:(<span class=\"built_in\">BOOL</span>)animated;</span><br></pre></td></tr></table></figure>\n<p>预览窗口是以模式视图显示的，同时必须实现以下协议方法:</p>\n<figure class=\"highlight objc\"><figcaption><span>Declared In UIDocumentInteractionController.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Called when a document interaction controller needs the starting point for animating the display of a document preview.</span></span><br><span class=\"line\">- (<span class=\"built_in\">UIViewController</span> *) documentInteractionControllerViewControllerForPreview: (<span class=\"built_in\">UIDocumentInteractionController</span> *) controller</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注:该方法最终需要返回一个<strong><code>VC</code></strong>，来作为预览窗口的父窗口。假如没有实现该方法，或者在该方法中返回 nil，或者返回的<strong><code>VC</code></strong>无法呈现模式窗口，则该预览窗口不会显示。<br>最终会被<strong><code>documentinteractioncontroller</code></strong>会自动解散它呈现出来的窗口。或调用系统提供销毁模态视图的方法，手动销毁如下：</p>\n<figure class=\"highlight objc\"><figcaption><span>Declared In UIDocumentInteractionController.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Dismisses the currently active menu.</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dismissMenuAnimated:(<span class=\"built_in\">BOOL</span>)animated  </span><br><span class=\"line\"><span class=\"comment\">//Dismisses the currently active document preview.</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dismissPreviewAnimated:(<span class=\"built_in\">BOOL</span>)animated</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>通过弹出菜单提示用户选择相应动作，调用如下方法:</p>\n<figure class=\"highlight objc\"><figcaption><span>弹出\"通过其他方式打开\"菜单 Declared In UIDocumentInteractionController.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Displays an options menu and anchors it to the specified location in the view.</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)presentOptionsMenuFromRect:(<span class=\"built_in\">CGRect</span>)rect inView:(<span class=\"built_in\">UIView</span> *)view animated:(<span class=\"built_in\">BOOL</span>)animated</span><br><span class=\"line\"><span class=\"comment\">//Displays an options menu and anchors it to the specified bar button item.</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)presentOptionsMenuFromBarButtonItem:(<span class=\"built_in\">UIBarButtonItem</span> *)item animated:(<span class=\"built_in\">BOOL</span>)animated</span><br></pre></td></tr></table></figure></li>\n<li>提示用户用其他程序打开该文件，调用如下方法:<figure class=\"highlight objc\"><figcaption><span>提示用户用其他程序打开 Declared In UIDocumentInteractionController.h</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Displays a menu for opening the document and anchors that menu to the specified view.</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)presentOpenInMenuFromRect:(<span class=\"built_in\">CGRect</span>)rect inView:(<span class=\"built_in\">UIView</span> *)view animated:(<span class=\"built_in\">BOOL</span>)animated</span><br><span class=\"line\"><span class=\"comment\">//Displays a menu for opening the document and anchors that menu to the specified bar button item.</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)presentOpenInMenuFromBarButtonItem:(<span class=\"built_in\">UIBarButtonItem</span> *)item animated:(<span class=\"built_in\">BOOL</span>)animated</span><br></pre></td></tr></table></figure>\n以上几种方法都会显示一个视图或一个预览窗口或是弹出菜单。任何一个方法的调用，都要检查返回值。返回值为 <code>NO</code>，表示这个视图没有任何内容，将不能显示。<br>例如，<strong><code>presentOpenInMenuFromRect:inView:animated:</code></strong>方法返回<code>NO</code>,表明已安装的程序中没有任何程序能够打开该文档。</li>\n</ul>\n<h4 id=\"注册应用程序支持的文档类型\"><a href=\"#注册应用程序支持的文档类型\" class=\"headerlink\" title=\"注册应用程序支持的文档类型\"></a>注册应用程序支持的文档类型</h4><p>如果你的程序可以打开某种特定的文件类型，则可以通过<strong>Info.plist</strong>文件注册程序所能打开的文档类型。当其他程序向系统询问哪些程序可以识别该类型的文件时，你的程序就会被列到选项菜单中，供用户选择。  </p>\n<ul>\n<li>有如下概念:  </li>\n<li><ul>\n<li>需要在程序的<strong><code>Info.plist</code></strong>文件中添加新字段<strong><code>CFBundleDocumentTypes</code></strong> 键 (查看 “<a href=\"https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html#//apple_ref/doc/uid/TP40009249\" target=\"_blank\" rel=\"noopener\">CoreFoundation Keys</a>”) 。系统会将该键中包含的内容进行登记，这样其他程序就可以通过<strong><code>document interaction controller</code></strong>访问到这些信息。</li>\n</ul>\n</li>\n<li><ul>\n<li><strong><code>CFBundleDocumentTypes</code></strong> 键是一个<code>dictionary</code>数组，一个<code>dictionary</code>表示了一个指定的文档类型。一个文档类型通常与某种文件类型是一一对应的。但是，如果你的程序对多个文件类型采用同样的处理方式，你也可以把这些类型都分成一个组，统一视作一个文档类型。<br>例如，你的程序中使用到的本地文档类型，有一个是旧格式的，还有一个新格式（似乎是影射微软<strong>office</strong>文档），这样就可以将二者分成一组，都放到同一个文档类型下。这样，旧格式和新格式的文件都将显示为同一个文档类型，并以同样的方式打开。  </li>\n</ul>\n</li>\n</ul>\n<p><strong><code>CFBundleDocumentTypes</code></strong> 数组中的每个<code>dictionary</code>包含以下键：<br><figure class=\"highlight objc\"><figcaption><span>字典键名称</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFBundleTypeName</span> \t\t\t<span class=\"comment\">//指定文档类型名称。</span></span><br><span class=\"line\"><span class=\"built_in\">CFBundleTypeIconFiles</span>    <span class=\"comment\">//是一个数组，包含多个图片文件名，用于作为该文档的图标。</span></span><br><span class=\"line\">LSItemContentTypes \t\t<span class=\"comment\">//是一个数组，包含多个 UTI 类型的字符串。UTI 类型是本文档类型（组）所包含的文件类型。</span></span><br><span class=\"line\">LSHandlerRank \t\t\t\t<span class=\"comment\">//表示应用程序是“拥有”还是仅仅是“打开”这种类型而已。</span></span><br></pre></td></tr></table></figure><br>在应用程序的角度而言，一个文档类型其实就是一种文件类型（或者多个文件类型），该程序将一个文档类型的文件都视作同样的东西对待。例如，一个图片处理程序可能将各种图片文件都看成不同的文档类型，这样便于根据每个类型进行相应的优化。但是，对于字处理程序来说，它并不关心真正的图形格式，它把所有的图片格式都作为一个文档类型对待。</p>\n<ul>\n<li><strong><code>CFBundleDocumentTypes</code></strong>字典数组示例:<figure class=\"highlight html\"><figcaption><span>自定义文件格式的文档类型</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>CFBundleTypeName<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>My File Format<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>CFBundleTypeIconFiles<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>MySmallIcon.png<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>MyLargeIcon.png<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>LSItemContentTypes<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>com.example.myformat<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>LSHandlerRank<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>Owner<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"打开支持的文件类型\"><a href=\"#打开支持的文件类型\" class=\"headerlink\" title=\"打开支持的文件类型\"></a>打开支持的文件类型</h4><p>系统可能会请求某个程序打开某种文件，并呈现给用户。这种情况通常发生在某个应用程序调用 <strong><code>document interaction controller</code></strong> 去处理某个文件的时候。<br>这时应用程序可以通过委托方法:<br><figure class=\"highlight objc\"><figcaption><span>获得文件的信息 Declared In UIApplication.h</span><a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/UIApplicationDelegate/application:didFinishLaunchingWithOptions:\" target=\"_blank\" rel=\"noopener\">link</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Tells the delegate that the launch process is almost done and the app is almost ready to run.</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<font size=\"1\">注:如果你的程序要处理某些自定义的文件类型，就必须实现这个委托方法（而不是<strong><code>applicationDidFinishLaunching:</code></strong>方法) 并用这个方法启动应用程序</font>  \n\n</blockquote>\n<p>该方法的<strong><code>option</code></strong>包含了要打开的文件的相关信息，可以通过以下键名一一解析：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIApplicationLaunchOptionsURLKey</span> \t\t\t\t\t <span class=\"comment\">//该文件的NSURL</span></span><br><span class=\"line\"><span class=\"built_in\">UIApplicationLaunchOptionsSourceApplicationKey</span> \t<span class=\"comment\">//发送请求的应用程序的Bundle ID</span></span><br><span class=\"line\"><span class=\"built_in\">UIApplicationLaunchOptionsSourceApplicationKey</span>\t\t<span class=\"comment\">//源程序向目标程序传递的与该文件相关的属性列表对象</span></span><br></pre></td></tr></table></figure><br>如果 <strong><code>UIApplicationLaunchOptionsURLKey</code></strong> 键存在，你的程序应当立即用该<strong><code>URL</code></strong>打开该文件并将内容呈现给用户。其他键可用于收集与打开的文件相关的参数和信息。</p>\n<h4 id=\"使用-Quick-Look-框架\"><a href=\"#使用-Quick-Look-框架\" class=\"headerlink\" title=\"使用 Quick Look 框架\"></a>使用 Quick Look 框架</h4><p><strong><code>Quick Look</code></strong>框架提供了增强的预览功能，可以选择呈现预览窗口时的动画风格，并可以像预览单个文件一样预览多个文件。<br>该框架主要提供了 <strong><code>QLPreviewController</code></strong> 类。该类依赖于委托对象响应预览动作，以及一个用于提供预览文件的数据源，内置了所支持的文件类型的 <strong>AirPrint</strong> 打印。  </p>\n<ul>\n<li><h6 id=\"Quick-Look-Previews-中的预览及打印\"><a href=\"#Quick-Look-Previews-中的预览及打印\" class=\"headerlink\" title=\"Quick Look Previews 中的预览及打印\"></a>Quick Look Previews 中的预览及打印</h6>从 iOS 4.2 开始，<strong><code>QLPreviewController</code></strong> 提供了包含了一个 <code>action</code> 按钮（即打印按钮）的预览视图。对于 <strong><code>QLPreviewController</code></strong> 能预览的文件，不用编写任何打印代码，只需点击<code>action</code>按钮就能直接打印该文档。  </li>\n</ul>\n<p>通过以下方式显示<strong><code>QLPreviewController</code></strong>:</p>\n<ul>\n<li><ul>\n<li>通过导航控制器，将预览窗口以“<strong><code>push</code> 方式</strong>”显示。</li>\n</ul>\n</li>\n<li><ul>\n<li>通过 <strong>UIViewController</strong> 的 <strong><code>presentModalViewController:animated:</code></strong>方法，将预览窗口以模态窗口的方式全屏显示。</li>\n</ul>\n</li>\n<li><ul>\n<li>显示一个<strong><code>document interaction controller</code></strong>(如 “预览及打开文件” 中所述），再在选项菜单中选择“<strong><code>Quick Look</code></strong>”即可。  </li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<font size=\"1\">预览窗口中会包括一个标题，显示文件 URL 的最后一段路径。如果要重载标题，可以定制<strong><code>PreviewItem</code></strong> 类，并实现<strong><code>QLPreviewItem</code></strong> 协议中的 <strong>previewItemTitle</strong>方法。</font>\n\n</blockquote>\n<ul>\n<li><h6 id=\"QLPreviewController能够预览下列文件：\"><a href=\"#QLPreviewController能够预览下列文件：\" class=\"headerlink\" title=\"QLPreviewController能够预览下列文件：\"></a><strong><code>QLPreviewController</code></strong>能够预览下列文件：</h6></li>\n<li><ul>\n<li>iWork 文档</li>\n</ul>\n</li>\n<li><ul>\n<li>Microsoft Office 文档(Office ‘97 以后版本)</li>\n</ul>\n</li>\n<li><ul>\n<li>Rich Text Format (RTF) 文档</li>\n</ul>\n</li>\n<li><ul>\n<li>PDF 文档</li>\n</ul>\n</li>\n<li><ul>\n<li>图片</li>\n</ul>\n</li>\n<li><ul>\n<li>文本文件，其 uniform type identifier (UTI)  在 public.text 文件中定义 (查看UniformType Identifiers 参考)</li>\n</ul>\n</li>\n<li><ul>\n<li>Comma-separated value (csv) 文件  </li>\n</ul>\n</li>\n</ul>\n<p>使用<strong><code>QLPreviewController</code></strong>，必须指定数据源对象（即实现 <strong><code>QLPreviewControllerDataSource</code></strong> 协议，请查看<a href=\"https://developer.apple.com/library/ios/documentation/NetworkingInternet/Reference/QLPreviewControllerDataSource_Protocol/Reference/Reference.html#//apple_ref/doc/uid/TP40009665\" target=\"_blank\" rel=\"noopener\">QLPreviewControllerDataSource</a>协议参考）。数据源为 <strong><code>QLPreviewController</code></strong>提供预览对象（<strong><code>preivew item</code></strong>），及指明它们的数量以便在一个预览导航列表中包含它们。在这个列表中包含多个对象，在模态预览窗口（全屏显示）显示了导航箭头，以便用户在多个预览对象间切换。对于用导航控制器“push方式”显示的<strong><code>QLPreviewController</code></strong>，你可以在导航条上提供按钮以便在预览对象列表见切换。</p>\n","raw":null,"categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"API","path":"api/categories/API.json"}],"tags":[{"name":"指南","path":"api/tags/指南.json"}]}]}