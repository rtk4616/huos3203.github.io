{"name":"macOS","postlist":[{"title":"MacOS系统下运行exe小程序","slug":"macOS/MacOS系统下运行exe小程序","date":"2018-06-19T18:09:18.000Z","updated":"2018-06-19T19:44:09.000Z","comments":true,"path":"api/articles/macOS/MacOS系统下运行exe小程序.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h3><p>例如，当急需在Mac系统上，安装abletonLive，涉及到破解机exe小程序，使用文中提到的两种方法，就解了燃眉之急。</p>\n<h3 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h3><p><a href=\"http://xiazai.crossoverchina.com/trial/Mac/crossover_mac_17.5.5.zip\" target=\"_blank\" rel=\"noopener\">crossover</a></p>\n<h3 id=\"Wrappe-k-小应用\"><a href=\"#Wrappe-k-小应用\" class=\"headerlink\" title=\"Wrappe[k]小应用\"></a>Wrappe[k]小应用</h3><p>这款软件适用于一些小型exe程序，其他，推荐方法一<br><a href=\"https://pan.baidu.com/s/1ujHKuXNr8G6m8PTPMO9ajQ\" target=\"_blank\" rel=\"noopener\">下载</a> 密码: khqa<br><a href=\"http://www.sdifen.com/mac-exe.html\" target=\"_blank\" rel=\"noopener\">参看</a></p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"}],"tags":[]},{"title":"Perfect开发天气接口API","slug":"macOS/Perfect开发天气接口API","date":"2017-06-26T17:01:24.000Z","updated":"2017-06-26T17:12:47.000Z","comments":true,"path":"api/articles/macOS/Perfect开发天气接口API.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"Perfect介绍\"><a href=\"#Perfect介绍\" class=\"headerlink\" title=\"Perfect介绍\"></a>Perfect介绍</h2><p>Perfect提供一系列代表请求和响应的对象组件，并允许在服务器上增加管理句柄用于产生页面内容。<br>所有对象都是在服务器对象创建后开始工作。服务器对象会被执行配置，随后会根据配置绑定并监听特定端口。一旦出现连接，服务器会读取请求数据，请求数据读取完成后，服务器会将request object请求对象传递给请求过滤器。</p>\n<h3 id=\"请求过滤器\"><a href=\"#请求过滤器\" class=\"headerlink\" title=\"请求过滤器\"></a>请求过滤器</h3><p>过滤器可能会根据需要修改查询请求。服务器会使用请求的URI路径检索routing请求／响应路由以获取处理该请求的具体句柄。如果找到了合适的处理句柄，服务器会传递给句柄对应的response object响应对象。当句柄反馈响应完成时，响应对象会被传递给响应过滤器。这些过滤器会根据需要修改最终输出的数据内容。最后响应结果数据会被推送给客户端浏览器，而客户端到服务器的连接或者被关闭、或者被拒绝维持HTTP持久连接、或者为后续请求和响应维持HTTP活动连接。</p>\n<h3 id=\"HTTP请求-响应路由\"><a href=\"#HTTP请求-响应路由\" class=\"headerlink\" title=\"HTTP请求/响应路由\"></a>HTTP请求/响应路由</h3><p>HTTP请求/响应路由是用于决定在当前请求下，哪一个句柄去接收和响应。</p>\n<ol>\n<li><code>句柄</code>:可以是一个函数、过程或者方法，只要能够接收特定类型的请求并做出反应即可。</li>\n<li><p><code>路由</code>:主要依据请求的方法<code>HTTP request method</code>和请求内容包括的<code>路径信息</code>来决定的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">routes.add(method: .post, uris: [<span class=\"string\">\"HostMonitor/client/log/addLog\"</span>])&#123;</span><br><span class=\"line\">    (request,response) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\">//处理请求,并响应请求</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>URI路由变量<br>URI变量是用于处理动态请求的好方法。比如，一个包含用户id的URL可以用该方法实现相关请求的用户管理。<br>每个变量组件是通过一个<code>程序块{ }</code>声明的。在程序块中是变量名称。每个变量名称都可以使用出了括号<code>}</code>之外的任何字符。变量名有点像单功能通配符一样，这样就可以匹配任何符合变量模式的路径。<br><code>变量值</code>:在匹配该模式下URL能够通过<code>HTTPRequest.urlVariables</code>字典查询变量值。该字典是[String:String]类型。</p>\n</li>\n</ol>\n<h3 id=\"请求对象HTTPRequest\"><a href=\"#请求对象HTTPRequest\" class=\"headerlink\" title=\"请求对象HTTPRequest\"></a>请求对象HTTPRequest</h3><p>当处理一个HTTP请求时，所有客户端的互动操作都是通过HTTPRequest请求对象和HTTPResponse响应对象实现的。<br>HTTPRequest对象包含了客户端浏览器发过来的全部数据，包括请求消息头、查询参数、POST表单数据以及其它所有相关信息，比如客户IP地址和URL变量。</p>\n<p>HTTPRequest对象将采用application/x-www-form-urlencoded编码格式对客户请求进行解析解码。而如果请求中采用multipart/form-data“多段”编码方式，则HTTP请求可以把各种未处理的原始格式表单传输过来。当处理“多段”表单数据时，HTTPRequest对象会为请求上传的文件自动创建临时目录并执行解码。这些文件会在请求过程中一直保持直到请求处理完毕，随后自动被删除。</p>\n<p>以上涉及到的各种属性和函数都是HTTPRequest请求协议的部分内容。</p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"终端","path":"api/categories/终端.json"}],"tags":[]},{"title":"Perfect服务器开发环境搭建","slug":"macOS/Perfect服务器开发环境搭建","date":"2017-06-25T09:21:56.000Z","updated":"2017-06-25T09:21:56.000Z","comments":true,"path":"api/articles/macOS/Perfect服务器开发环境搭建.json","excerpt":null,"keywords":null,"cover":"http://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIhEpimhI2nAp5KeoIp9INNABqf9BNBEpyalKYXAJU422oeKbsUcbRpOk_x9xcrFUrgVhrluV4BRqvahkFAJibAJInI20tpXpFpIekJKOXWt834vEp4zbOiBAgwWgmLIRVLiruJd2ngVxfhC1LK1atYoR-wBhTEUxsu1MiK5bxHIo4lCJLMmLL1wkN3dyzdhdaxeLKAI1FebFRMa62J_PDVofvCRqUHJKWjIyr9Iyv8pKo6Aa2nHua8upah1EIUn6Am4xa0bBWUWNc180G00","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>Perfect是一组完整、强大的工具箱、软件框架体系和Web应用服务器，可以在Linux、iOS和macOS (OS X)上使用。该软件体系为Swift工程师量身定制了一整套用于开发轻量、易维护、规模可扩展的Web应用及其它REST服务的解决方案，这样Swift工程师就可以实现同时在服务器和客户端上采用同一种语言开发软件项目。</p>\n<p>由于建立在一个高性能异步网络引擎基础上，Perfect还能够在FastCGI上运行，支持安全套接字加密（SSL）。该软件体系还包含很多其它互联网服务器所需要的特点，包括WebSockets和iOS消息推送，而且很快会有更多强大的功能支持。</p>\n<h2 id=\"SPM-软件包管理器编译项目\"><a href=\"#SPM-软件包管理器编译项目\" class=\"headerlink\" title=\"SPM:软件包管理器编译项目\"></a>SPM:软件包管理器编译项目</h2><p><a href=\"https://github.com/PerfectlySoft/PerfectDocs/blob/master/guide.zh_CN/buildingWithSPM.md\" target=\"_blank\" rel=\"noopener\">https://github.com/PerfectlySoft/PerfectDocs/blob/master/guide.zh_CN/buildingWithSPM.md</a><br>在Perfect Template项目模板是一个标准的SPM项目：</p>\n<ol>\n<li><code>Sources</code> 目录: 包含了所有Perfect项目的Swift源程序文件</li>\n<li><code>Package.swift</code>SPM文件管理清单: 包含了整个项目对其它库函数的依存关系<br>所有的SPM项目至少要包括一个 Sources 目录和一个 Package.swift 文件。而项目模板中目前只有一个依存关系：Perfect-HTTPServer服务器项目<br><img src=\"http://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIhEpimhI2nAp5KeoIp9INNABqf9BNBEpyalKYXAJU422oeKbsUcbRpOk_x9xcrFUrgVhrluV4BRqvahkFAJibAJInI20tpXpFpIekJKOXWt834vEp4zbOiBAgwWgmLIRVLiruJd2ngVxfhC1LK1atYoR-wBhTEUxsu1MiK5bxHIo4lCJLMmLL1wkN3dyzdhdaxeLKAI1FebFRMa62J_PDVofvCRqUHJKWjIyr9Iyv8pKo6Aa2nHua8upah1EIUn6Am4xa0bBWUWNc180G00\"><h3 id=\"swift-SPM文件管理清单\"><a href=\"#swift-SPM文件管理清单\" class=\"headerlink\" title=\"swift SPM文件管理清单\"></a>swift SPM文件管理清单</h3>参数配置的相关含义:<br><code>name</code>: 当前项目的目标名称，可执行文件的名字也会按照这个名称进行编译。<br><code>dependencies[]</code>:依存关系清单组。该内容说明了您的应用程序需要的所有子项目列表，在这个数组中其中每一个条目都包含了一个“.Package”软件包，及其来源URL和版本。<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> PackageDescription</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> package = <span class=\"type\">Package</span>(</span><br><span class=\"line\">    name: <span class=\"string\">\"PerfectTemplate\"</span>, <span class=\"comment\">// 当前项目的目标名称，可执行文件的名字也会按照这个名称进行编译。</span></span><br><span class=\"line\">    targets: [],</span><br><span class=\"line\">    dependencies: [</span><br><span class=\"line\">        .<span class=\"type\">Package</span>(url: <span class=\"string\">\"https://github.com/PerfectlySoft/Perfect-HTTPServer.git\"</span>, majorVersion: <span class=\"number\">2</span>, minor: <span class=\"number\">0</span>),</span><br><span class=\"line\">        .<span class=\"type\">Package</span>(url: <span class=\"string\">\"https://github.com/PerfectlySoft/Perfect-CURL.git\"</span>, majorVersion: <span class=\"number\">2</span>, minor: <span class=\"number\">0</span>),</span><br><span class=\"line\">        .<span class=\"type\">Package</span>(url: <span class=\"string\">\"https://github.com/iamjono/JSONConfig.git\"</span>, majorVersion: <span class=\"number\">0</span>, minor: <span class=\"number\">1</span>),</span><br><span class=\"line\">        .<span class=\"type\">Package</span>(url: <span class=\"string\">\"https://github.com/PerfectlySoft/Perfect-libcurl.git\"</span>, majorVersion: <span class=\"number\">2</span>, minor: <span class=\"number\">0</span>),</span><br><span class=\"line\">        <span class=\"comment\">//        .Package(url: \"https://github.com/dabfleming/Perfect-RequestLogger.git\", majorVersion: 0)</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"SPM项目编译命令\"><a href=\"#SPM项目编译命令\" class=\"headerlink\" title=\"SPM项目编译命令\"></a>SPM项目编译命令</h3><p>SPM提供以下命令用于编译项目，并且清理旧的编译结果</p>\n<ol>\n<li><p>初始化项目，开始编译调试版本<br>先自动下载需要的依存文件，再开始编译，默认生成是调试版本</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swift build</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动调试版本<br>默认编译生成的调试程序在<code>.build/debug/</code>目录下</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.build/debug/PerfectTemplate</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译发行版本<br>执行后可发行版本的可执行程序所在的目录<code>.build/release/</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swift build -c release</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>clean 编译命令<br>删除.build目录，然后重新开始一个全新的编译</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swift build --clean</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>clean磁盘命令<br>删除.build目录和Packages目录，重新下载所有依存关系以获得最新版本对项目的支持。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swift build --clean=dist</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>支持Xcode调试项目命令<br>在同一目录下生成xcode项目，该项目允许编译和调试</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swift package generate-xcodeproj</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>最好不要在这个Xcode项目上直接编辑或增加文件。如果需要更多的依存关系，或者需要下载更新的版本，您需要重新生成这个Xcode项目。因此，在之前您做的任何修改都会被Xcode覆盖。</p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"终端","path":"api/categories/终端.json"}],"tags":[]},{"title":"mupdf使用说明","slug":"编译/mupdf的使用说明","date":"2017-06-19T18:25:32.000Z","updated":"2017-06-19T18:25:32.000Z","comments":true,"path":"api/articles/编译/mupdf的使用说明.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"需求描述\"><a href=\"#需求描述\" class=\"headerlink\" title=\"需求描述\"></a>需求描述</h3><p>目前手机端使用mupdf，通过在底层添加加密方法实现定制pbb阅读器功能。<br>资源获取如下：<br><blockquote><p>Download packages of the latest release for your system:<br>Source code for all platforms.<br>Windows viewer and tools.<br>Android viewer on Google Play.<br>Android viewer APK installer files.<br>iPad and iPhone version on the App Store.<br>The latest development source is available directly from the git repository:<br>git clone –recursive git://git.ghostscript.com/mupdf.git</p>\n</blockquote></p>\n<p>总结：没有适配osx版本，放弃。</p>\n<h3 id=\"使用apple-官方提供的demo，来分析pdf结构，显示pdf内容。\"><a href=\"#使用apple-官方提供的demo，来分析pdf结构，显示pdf内容。\" class=\"headerlink\" title=\"使用apple 官方提供的demo，来分析pdf结构，显示pdf内容。\"></a>使用apple 官方提供的demo，来分析pdf结构，显示pdf内容。</h3><p>猜想：这样以来，使用苹果提供相关API，将无法定制底层操作，即无法实现密文浏览功能，故先从明文阅读器开发开始。</p>\n<h3 id=\"mupdf源码库集成加密\"><a href=\"#mupdf源码库集成加密\" class=\"headerlink\" title=\"mupdf源码库集成加密\"></a>mupdf源码库集成加密</h3><p>最新整合集成加密到源码库，并发布到git服务器上，便于协作维护:<a href=\"https://server.local/git/mupdf.git\" target=\"_blank\" rel=\"noopener\">https://server.local/git/mupdf.git</a><br>协作过程：<br>在服务器端添加账号：test  test123<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone <span class=\"symbol\">https:</span>/<span class=\"regexp\">/server.local/git</span><span class=\"regexp\">/mupdf.git mupdf</span></span><br><span class=\"line\"><span class=\"regexp\">$ cd mupdf/thirdparty</span><span class=\"regexp\">/</span></span><br><span class=\"line\"><span class=\"regexp\">$ git submodule init</span></span><br><span class=\"line\"><span class=\"regexp\">$ git submodule update</span></span><br><span class=\"line\"><span class=\"regexp\">$ open mupdf/platform</span><span class=\"regexp\">/ios/</span>MuPDF.xcodeproj</span><br><span class=\"line\">$ build &amp; run</span><br></pre></td></tr></table></figure></p>\n<p>封装MuPDFFramework便于集成至PBBReader中：<br>初始化mupdf页面接口：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MuPDFViewController *bindingPhone = [[MuPDFViewController alloc] initWithNibName:<span class=\"literal\">nil</span> bundle:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">bindingPhone.filename=filename;</span><br><span class=\"line\">bindingPhone.openfilepath=select_files;</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view.window.contentViewController presentViewControllerAsSheet:bindingPhone];</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"PDF","path":"api/categories/PDF.json"}],"tags":[]},{"title":"swift开发macOS系统的终端命令行应用","slug":"macOS/swift开发macOS系统的终端命令行应用","date":"2017-05-29T13:00:08.000Z","updated":"2017-05-29T13:00:08.000Z","comments":true,"path":"api/articles/macOS/swift开发macOS系统的终端命令行应用.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h3><p><a href=\"https://www.raywenderlich.com:443/128039/command-line-programs-macos-tutorial\" target=\"_blank\" rel=\"noopener\">命令行程序MacOS的教程</a></p>\n<p>使用swift创建一个命令行程序，相比其他语言如C、Perl、Ruby或java。<br>选用SWIFT的理由：<br>Swift可以用作解释脚本语言，也可以用作编译语言。这使您具有脚本语言的优势，如零编译时间和易于维护，以及选择编译应用程序，以提高执行时间或捆绑出售给公众。</p>\n<h3 id=\"main-swift主体\"><a href=\"#main-swift主体\" class=\"headerlink\" title=\"main.swift主体\"></a>main.swift主体</h3><p>许多C语言的main函数作为切入点，例如当操作系统调用这个程序时执行的代码入口。这意味着程序的执行始于这个函数的第一行。<br>Swift没有一个main函数，而是main.swift文件。这样在运行Swift项目时，直接运行的事main.swift文件，执行入口开始于第一行代码。</p>\n<h3 id=\"终端调用程序\"><a href=\"#终端调用程序\" class=\"headerlink\" title=\"终端调用程序\"></a>终端调用程序</h3><p>命令行可分两种模式</p>\n<ul>\n<li>静态可执行模式：通过终端app直接运行命令行工具，执行固有功能。</li>\n<li>交互命令行模式 ：需要用户通过使用说明信息，对命令行程序输入交互命令，执行相应的功能。</li>\n</ul>\n<ol>\n<li><p>在同一个目录下执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./Panagram</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>相对路径执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Debug/Panagram</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"终端","path":"api/categories/终端.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"}]},{"title":"从UIKit到AppKit","slug":"macOS/从UIKit到AppKit","date":"2017-03-03T17:55:16.000Z","updated":"2017-03-03T17:55:16.000Z","comments":true,"path":"api/articles/macOS/从UIKit到AppKit.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/ViewEffectsInspector.jpg?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h2><h3 id=\"NSWindowController\"><a href=\"#NSWindowController\" class=\"headerlink\" title=\"NSWindowController\"></a>NSWindowController</h3><p>在<code>Mac</code>上应用都支持多窗口（<code>NSWindowController</code>），<code>AppKit</code> 中都有 <code>NSWindowController</code>担当着类似在<code>iOS</code>中的<code>view controller</code>处理的任务。</p>\n<blockquote>\n<p><code>window</code>在<code>iOS</code>占据整个屏幕，几乎不怎么不用。</p>\n<h3 id=\"NSViewController\"><a href=\"#NSViewController\" class=\"headerlink\" title=\"NSViewController\"></a>NSViewController</h3><p><code>AppKit</code> 中的 <code>NSViewController</code>默认不支持交互，缺少生命周期相关方法和<code>UIKit</code>中熟悉的特性。<br>但在OS X 10.10 Yosemite之后，<code>NSViewController</code>改进很多，默认支持交互中的响应链。</p>\n</blockquote>\n<h3 id=\"NSWindow-和-UIWindow\"><a href=\"#NSWindow-和-UIWindow\" class=\"headerlink\" title=\"NSWindow 和 UIWindow\"></a>NSWindow 和 UIWindow</h3><p>在<code>UIKit</code>中<code>UIWindow</code>是一个 <code>view</code> 的子类.<br>在<code>AppKit</code>中<code>NSWindow</code>用 <code>contentView</code> 属性持有一个指向其顶层 <code>view</code> 的引用。</p>\n<h2 id=\"响应者链（responder-chain）\"><a href=\"#响应者链（responder-chain）\" class=\"headerlink\" title=\"响应者链（responder chain）\"></a>响应者链（responder chain）</h2><p>如果你在为 OS X 10.9 或者更低版本的系统开发，请注意在默认情况下<code>view controller</code> 并不是响应者链的一环。相反，事件会沿着视图树向上传递然后直接到达 <code>window</code> 和 <code>window</code> <code>controller</code>。在这种情况下，如果你想在 <code>view controller</code> 处理事件，你需要手动把它添加到响应者链中。</p>\n<h3 id=\"Target-Action消息传递方式\"><a href=\"#Target-Action消息传递方式\" class=\"headerlink\" title=\"Target-Action消息传递方式\"></a>Target-Action消息传递方式</h3><p><code>Target-Action</code> 是回应 <code>UI 事件</code>时典型的消息传递方式。<code>iOS</code> 上的 <code>UIControl</code> 和 <code>Mac</code> 上的 <code>NSControl/NSCell</code> 都支持这个机制。<br><code>Target-Action</code> 在消息的发送者和接收者之间建立了一个松散的关系。消息的接收者不知道发送者，甚至消息的发送者也不知道消息的接收者会是什么。如果 <code>target</code> 是 <code>nil</code>，<code>action</code> 会在响应链 (responder chain) 中被传递下去，直到找到一个响应它的对象。</p>\n<h4 id=\"传递机制的局限\"><a href=\"#传递机制的局限\" class=\"headerlink\" title=\"传递机制的局限\"></a>传递机制的局限</h4><p>基于 <code>target-action</code> 传递机制的一个局限是，发送的消息不能携带自定义的信息：</p>\n<ol>\n<li>在<code>iOS</code> 中，可以选择性的把发送者和触发 <code>action</code> 的事件作为参数。</li>\n<li>在 <code>Mac</code> 平台上 <code>action</code> 方法的第一个参数永远是发送者，否则将不视为无效方法。<br>在<code>AppKit</code>唯一有效的<code>action</code> 方法声明方式：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)performAction:(<span class=\"keyword\">id</span>)sender;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"控件关联Action事件的区别\"><a href=\"#控件关联Action事件的区别\" class=\"headerlink\" title=\"控件关联Action事件的区别\"></a>控件关联Action事件的区别</h4><p><code>iOS</code> 上的 <code>UIControl</code> 和 <code>Mac</code> 上的 <code>NSControl/NSCell</code> 都支持这个机制。</p>\n<ol>\n<li>在 <code>iOS</code> 中，每个控件可以通过<code>addTarget:action:forControlEvents:</code>和多个 <code>target-action</code> 关联。</li>\n<li>在<code>AppKit</code>中通常一个<code>控件</code>仅对应一个 <code>target-action</code>对。</li>\n</ol>\n<h2 id=\"View视图系统\"><a href=\"#View视图系统\" class=\"headerlink\" title=\"View视图系统\"></a>View视图系统</h2><p>因为历史遗留问题，<code>Mac</code> 的视图系统和 <code>iOS</code>的视图系统有很大区别。</p>\n<ol>\n<li>绘图处理器差异<br><code>iOS</code>由 <code>Core Animation layer</code> 驱动，使用<code>GPU</code>处理。<br><code>AppKit</code>视图系统相关的任务主要靠 <code>CPU</code> 处理，因为在<code>AppKit</code>设计之初，<code>GPU</code>还没有诞生。<br>Mac开发参考资料：<br><a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CocoaViewsGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40002978\" target=\"_blank\" rel=\"noopener\">Introduction to View Programming Guide for Cocoa</a><br><a href=\"https://developer.apple.com/videos/wwdc/2012/#217\" target=\"_blank\" rel=\"noopener\">WWDC session：Layer-Backed Views: AppKit + Core Animation</a><br><a href=\"https://developer.apple.com/videos/wwdc/2013/#215\" target=\"_blank\" rel=\"noopener\">Optimizing Drawing and Scrolling</a></li>\n</ol>\n<h3 id=\"Layer-Backed-View-iOS反哺AppKit层支持视图\"><a href=\"#Layer-Backed-View-iOS反哺AppKit层支持视图\" class=\"headerlink\" title=\"Layer-Backed View: iOS反哺AppKit层支持视图\"></a>Layer-Backed View: iOS反哺AppKit层支持视图</h3><ol>\n<li><code>iOS</code>反哺<code>AppKit</code><br>默认情况下，<code>AppKit</code> 的 <code>view</code> 不是由 <code>Core Animation layer</code> 驱动的；<code>AppKit</code> 整合 <code>layer-backing</code> 是 <code>iOS</code> 反哺的结果。</li>\n</ol>\n<h4 id=\"layer-backing启用／禁用-wantsLayer\"><a href=\"#layer-backing启用／禁用-wantsLayer\" class=\"headerlink\" title=\"layer backing启用／禁用:wantsLayer\"></a>layer backing启用／禁用:wantsLayer</h4><p><code>AppKit</code> 区分 <code>layer-backed view</code> 和 <code>layer-hosting view</code>，可以在每个视图树的根节点启用或者禁用 <code>layer backing</code>。<br>启用 <code>layer backing</code></p>\n<ol>\n<li>方法一：把窗口的 <code>contentView</code> 的 <code>wantsLayer</code> 属性设置为 <code>YES</code></li>\n<li>方法二：在 <code>Interface Builder</code> 的 <code>View Effects Inspector</code> 面板完成<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/ViewEffectsInspector.jpg?imageMogr2/2/w/800\">\n这会导致 <code>window</code> 的视图树中所有的 <code>view</code> 都启用 <code>layer backing</code>，这样就没必要反复设置每个 <code>view</code> 的 <code>wantsLayer</code> 属性了。</li>\n</ol>\n<h4 id=\"修改layer属性\"><a href=\"#修改layer属性\" class=\"headerlink\" title=\"修改layer属性\"></a>修改layer属性</h4><p>在<code>AppKit</code>上开启<code>layer backing</code>之后，<code>layer</code>的拥有者是<code>AppKit</code>，这就意味着不能直接编辑 <code>layer</code>的属性。<br>在 <code>iOS</code> 上可以直接编辑：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.layer.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor].CGColor;</span><br></pre></td></tr></table></figure><br>在 <code>AppKit</code>编辑<code>layer</code>属性需要以下步骤：</p>\n<ol>\n<li>重写 <code>NSView</code> 的 <code>wantsUpdateLayer</code> 方法并返回 <code>YES</code>,这能让你可以改变 <code>layer</code> 的属性。<br>这样以来，在<code>view</code> 更新周期中，将不会再调用 <code>view</code> 的 <code>drawRect:</code> 方法。取而代之，调用<code>updateLayer</code>方法来更新<code>Layer</code>。<br>举个例子，用这方法去实现一个非常简单的有纯色背景的 <code>view</code>（没错，<code>NSView</code> 没有<code>backgroundColor</code> 属性）：<br>这个例子的前提是这个 <code>view</code> 的<code>父 view</code> 已经为其视图树启用了 <code>layer backing</code>。<br>另一种可行的实现则只需要重写 <code>drawRect:</code> 方法并在其中绘制背景颜色。<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ColoredView</span>: <span class=\"title\">NSView</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSColor</span> *backgroundColor;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ColoredView</span></span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)wantsUpdateLayer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)updateLayer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.layer.backgroundColor = <span class=\"keyword\">self</span>.backgroundColor.CGColor;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setBackgroundColor:(<span class=\"built_in\">NSColor</span> *)backgroundColor</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _backgroundColor = backgroundColor;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setNeedsDisplay:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"合并-Layer\"><a href=\"#合并-Layer\" class=\"headerlink\" title=\"合并 Layer\"></a>合并 Layer</h4><p>当APP启动过多的<code>layer-backed view</code> 会带来巨大的内存消耗（每一个 <code>layer</code> 有其自己的 <code>backing store</code>，还有可能和其他 <code>view</code>的 <code>backing store</code> 重叠）而且会带来潜在的合成这些 <code>layer</code> 的消耗。</p>\n<h5 id=\"canDrawSubviewsIntoLayer合并Layer\"><a href=\"#canDrawSubviewsIntoLayer合并Layer\" class=\"headerlink\" title=\"canDrawSubviewsIntoLayer合并Layer\"></a>canDrawSubviewsIntoLayer合并Layer</h5><p>从 OS X 10.9 开始，如果不单独对一个 <code>view</code> 中的子 <code>view</code> 做动画，可以通过设置 <code>canDrawSubviewsIntoLayer</code> 属性来让 <code>AppKit</code> 合并一个<code>视图树</code>中所有 <code>layer</code> 的内容到一个共有的 <code>layer</code>。</p>\n<h5 id=\"隐式layer-backed合并Layer\"><a href=\"#隐式layer-backed合并Layer\" class=\"headerlink\" title=\"隐式layer-backed合并Layer\"></a>隐式layer-backed合并Layer</h5><p>所有隐式 <code>layer-backed</code> 的<code>子 view</code>（比如，没有显式地对这些<code>子 view</code> 设置 <code>wantsLayer = YES</code>）现在将会被绘制到同一个 <code>layer</code> 中。不过<code>wantsLayer</code> 设置为 <code>YES</code> 的<code>子 view</code> 仍然持有它们自己的 <code>backing layer</code>， 而且不管 <code>wantsUpdateLayer</code> 返回什么，它们的 <code>drawRect:</code> 方法仍然会被调用。</p>\n<h4 id=\"Layer-重绘策略\"><a href=\"#Layer-重绘策略\" class=\"headerlink\" title=\"Layer 重绘策略\"></a>Layer 重绘策略</h4><h5 id=\"layer-backed-view-默认的自动重绘策略\"><a href=\"#layer-backed-view-默认的自动重绘策略\" class=\"headerlink\" title=\"layer-backed view 默认的自动重绘策略\"></a>layer-backed view 默认的自动重绘策略</h5><p><code>layer-backed view</code> 会默认设置重绘策略为 <code>NSViewLayerContentsRedrawDuringViewResize</code>。在行为上，这个非 <code>layer-backed view</code> 是类似的，不过如果动画的每一帧都引入一个绘制步骤的话可能会对动画的性能造成不利影响。</p>\n<h5 id=\"设置layer-backed-view手动重绘策略\"><a href=\"#设置layer-backed-view手动重绘策略\" class=\"headerlink\" title=\"设置layer-backed view手动重绘策略\"></a>设置layer-backed view手动重绘策略</h5><ol>\n<li>设置手动重绘策略：把 <code>layerContentsRedrawPolicy</code> 属性设置为 <code>NSViewLayerContentsRedrawOnSetNeedsDisplay</code> </li>\n<li>实现手动重绘操作：调用 <code>-setNeedsDisplay:</code>方法来触发重绘操作<br>这样便由你来决定 <code>layer</code> 的内容何时需要重绘。帧的改变将不再自动触发重绘。</li>\n</ol>\n<h5 id=\"设置view的属性来重绘Layer\"><a href=\"#设置view的属性来重绘Layer\" class=\"headerlink\" title=\"设置view的属性来重绘Layer\"></a>设置view的属性来重绘Layer</h5><ol>\n<li>view中<code>layerContentsPlacement</code>属性：等价<code>layer</code>中的 <code>contentGravity</code> 属性。<br>这个属性允许你指定在调整大小的时候当前的 <code>layer</code> 内容该怎么映射到 <code>layer</code> 上。</li>\n</ol>\n<h3 id=\"Layer-Hosting-View-使用-Core-Animation-layer\"><a href=\"#Layer-Hosting-View-使用-Core-Animation-layer\" class=\"headerlink\" title=\"Layer-Hosting View:使用 Core Animation layer\"></a>Layer-Hosting View:使用 Core Animation layer</h3><p><code>layer-hosting view</code> 是视图树中的叶子节点，使用这种模式可以对<code>layer</code> 及其<code>子 layer</code> 做任何操作，代价是你再也不能给该 <code>view</code> 添加任何<code>子 view</code>。</p>\n<h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><ol>\n<li>为 <code>view</code> 的 <code>layer</code> 属性分配一个 <code>layer 对象</code>，</li>\n<li>设置<code>wantsLayer</code> 为 <code>YES</code><br>这些步骤的顺序是非常关键：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithFrame:(<span class=\"type\">NSRect</span>)frame</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> initWithFrame:frame];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.layer = [[<span class=\"type\">CALayer</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.wantsLayer = <span class=\"type\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n在你设置了自定义的 <code>layer</code> 之后，再设置 <code>wantsLayer</code> 是非常重要的。</li>\n</ol>\n<h3 id=\"其他与-View-相关的陷阱\"><a href=\"#其他与-View-相关的陷阱\" class=\"headerlink\" title=\"其他与 View 相关的陷阱\"></a>其他与 View 相关的陷阱</h3><h4 id=\"坐标系统原点设置左下／左上角\"><a href=\"#坐标系统原点设置左下／左上角\" class=\"headerlink\" title=\"坐标系统原点设置左下／左上角\"></a>坐标系统原点设置左下／左上角</h4><p>通过重写<code>isFlipped</code> 并返回 <code>YES</code> 来恢复到你熟悉的左上角。</p>\n<h4 id=\"View背景颜色属性drawsBackground\"><a href=\"#View背景颜色属性drawsBackground\" class=\"headerlink\" title=\"View背景颜色属性drawsBackground\"></a>View背景颜色属性drawsBackground</h4><p>由于 <code>AppKit</code> 中的 <code>view</code> 没有背景颜色属性可以让你直接设置为 <code>[NSColor clearColor]</code> 来让其变得透明，许多 <code>NSView</code> 的子类比如 <code>NSTextView</code> 和 <code>NSScrollView</code> 开放了一个 <code>drawsBackground</code> 属性，如果你想让这一类 <code>view</code> 透明，你必须设置该属性为 <code>NO</code>。</p>\n<h4 id=\"设置光标追踪区域\"><a href=\"#设置光标追踪区域\" class=\"headerlink\" title=\"设置光标追踪区域\"></a>设置光标追踪区域</h4><p>为了能接收光标进出一个 view 或者在 view 里面移动的事件，你需要创建一个追踪区域。你可以在 <code>NSView</code> 中指定的 <code>updateTrackingAreas</code> 方法中来做这件事情。一个通用的写法看起来是这样子的：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)updateTrackingAreas</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> removeTrackingArea:<span class=\"keyword\">self</span>.trackingArea];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.trackingArea = [[<span class=\"type\">NSTrackingArea</span> alloc] initWithRect:<span class=\"type\">CGRectZero</span> </span><br><span class=\"line\">                                                     options:<span class=\"type\">NSTrackingMouseEnteredAndExited</span>|<span class=\"type\">NSTrackingInVisibleRect</span>|<span class=\"type\">NSTrackingActiveInActiveApp</span></span><br><span class=\"line\">                                                       owner:<span class=\"keyword\">self</span> </span><br><span class=\"line\">                                                    userInfo:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> addTrackingArea:<span class=\"keyword\">self</span>.trackingArea];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"NSCell困惑\"><a href=\"#NSCell困惑\" class=\"headerlink\" title=\"NSCell困惑\"></a>NSCell困惑</h4><p><code>AppKit</code> 的控件之前是由 <code>NSCell</code> 的子类驱动的，可以被所有同类型的控件重用。<br><code>AppKit</code> 最初区分 <code>view</code> 和 <code>cell</code> 是为了节省资源 - <code>view</code> 可以把所有的绘制工作代理给更轻量级的可以被所有同类型的 <code>view</code> 重用的 <code>cell</code> 对象。<br>不要混淆这些 <code>cell</code> 和 <code>UIKit</code> 里 <code>table view</code> 的 <code>cell</code> 及 <code>collection view</code> 的 <code>cell</code>。</p>\n<h5 id=\"自定义一个按钮控件\"><a href=\"#自定义一个按钮控件\" class=\"headerlink\" title=\"自定义一个按钮控件\"></a>自定义一个按钮控件</h5><p>Apple 正在一步步地抛弃这样的实现方法了，但是你还是会时不时碰到这样的问题。<br>举个例子，如果你想创建一个自定义的按钮，</p>\n<ol>\n<li>首先要继承 <code>NSButton</code> 和 <code>NSButtonCell</code></li>\n<li>然后在这个 <code>cell 子类</code>里面进行你自定义的绘制，</li>\n<li>然后通过重写 <code>+[NSControl cellClass]</code>方法告诉自定义按钮使用你的 <code>cell 子类</code></li>\n</ol>\n<h4 id=\"获取-Core-Graphics-上下文\"><a href=\"#获取-Core-Graphics-上下文\" class=\"headerlink\" title=\"获取 Core Graphics 上下文\"></a>获取 Core Graphics 上下文</h4><p>最后，如果你想知道在你自己的 <code>drawRect:</code> 方法里怎么获取当前的 <code>Core Graphics</code> 上下文，答案是 <code>NSGraphicsContext</code> 的 <code>graphicsPort</code> 属性。详细内容请查看 <a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CocoaDrawingGuide/\" target=\"_blank\" rel=\"noopener\">Cocoa Drawing Guide</a>。</p>\n<h2 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h2><p>如果你的 <code>view</code> 不是由 <code>layer</code> 驱动的，那你的动画自然是完全由 <code>CPU</code> 处理，这意味着动画的每一步都必须相应地绘制到 <code>window-backing store</code> 上。</p>\n<h3 id=\"对-layer-backed-view做动画\"><a href=\"#对-layer-backed-view做动画\" class=\"headerlink\" title=\"对 layer-backed view做动画\"></a>对 layer-backed view做动画</h3><p>正如上面说的，在 <code>AppKit</code> 中,这些 <code>layer</code> 由 <code>AppKit</code> 管理，你不应该修改 <code>layer-backed view</code> 中的 <code>layer</code>。 </p>\n<h4 id=\"几何属性\"><a href=\"#几何属性\" class=\"headerlink\" title=\"几何属性\"></a>几何属性</h4><p>与<code>iOS</code> 相反，<code>view</code> 的几何属性并不仅仅是对应的 <code>layer</code> 的几何属性的映射，但 <code>AppKit</code> 却会把 <code>view</code> 内部的几何属性同步到 <code>layer</code>。</p>\n<h4 id=\"的animator-proxy动画\"><a href=\"#的animator-proxy动画\" class=\"headerlink\" title=\"的animator proxy动画\"></a>的animator proxy动画</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view.animator.alphaValue = <span class=\"number\">.5</span>;</span><br></pre></td></tr></table></figure>\n<p>在幕后，这句代码会启用 <code>layer</code> 的隐式动画，设置其透明度，然后再次禁用 <code>layer</code> 的隐式动画。</p>\n<h4 id=\"NSAnimationContext动画\"><a href=\"#NSAnimationContext动画\" class=\"headerlink\" title=\"NSAnimationContext动画\"></a>NSAnimationContext动画</h4><ol>\n<li>结束回调<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSAnimationContext</span> runAnimationGroup:^(<span class=\"built_in\">NSAnimationContext</span> *context)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//持续时间</span></span><br><span class=\"line\">    context.duration = <span class=\"number\">1</span>;  </span><br><span class=\"line\">    <span class=\"comment\">//缓动类型</span></span><br><span class=\"line\">    context.timingFunction = [<span class=\"built_in\">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseIn];</span><br><span class=\"line\">    view.animator.alphaValue = <span class=\"number\">.5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; completionHandler:^&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;]; </span><br></pre></td></tr></table></figure></li>\n<li>无结束回调<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSAnimationContext</span> currentContext].duration = <span class=\"number\">1</span>;</span><br><span class=\"line\">view.animator.alphaValue = <span class=\"number\">.5</span>; </span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"启用隐式动画\"><a href=\"#启用隐式动画\" class=\"headerlink\" title=\"启用隐式动画\"></a>启用隐式动画</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSAnimationContext</span> currentContext].allowsImplicitAnimations = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">view.alphaValue = <span class=\"number\">.5</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"CAAnimations控制动画\"><a href=\"#CAAnimations控制动画\" class=\"headerlink\" title=\"CAAnimations控制动画\"></a>CAAnimations控制动画</h4><p>使用 <code>CAAnimation</code> 实例更全面地控制动画。和 <code>iOS</code> 相反，你不能直接把它们加到 <code>layer</code> 上（因为 <code>layer</code> 不应该由你来修改），不过你可以使用 <code>NSAnimatablePropertyContainer</code> 协议中定义的 <code>API</code>，<code>NSView</code> 和 <code>NSWindow</code> 已经实现了该协议。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CAKeyframeAnimation</span> *animation = [<span class=\"built_in\">CAKeyframeAnimation</span> animation];</span><br><span class=\"line\">animation.values = @[@<span class=\"number\">1</span>, @<span class=\"number\">.9</span>, @<span class=\"number\">.8</span>, @<span class=\"number\">.7</span>, @<span class=\"number\">.6</span>];</span><br><span class=\"line\">view.animations = @&#123;<span class=\"string\">@\"alphaValue\"</span>: animation&#125;;</span><br><span class=\"line\">view.animator.alphaValue = <span class=\"number\">.5</span>;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"帧动画\"><a href=\"#帧动画\" class=\"headerlink\" title=\"帧动画\"></a>帧动画</h5><p>对于帧动画来说，把 <code>view</code> 的 <code>layerContentsRedrawPolicy</code> 设置为 <code>NSViewLayerContentsRedrawOnSetNeedsDisplay</code> 是非常重要的，不然的话 <code>view</code> 的内容在每一帧都会被重绘。</p>\n<p>很遗憾，<code>NSView</code> 没有开放 <code>Core Animation layer</code> 所有可以进行动画的属性，<code>transform</code> 是其中最重要的例子。看看 Jonathan Willings 的这篇文章，它描述了你可以如何解决这些限制。不过注意，文章中的解决方案是不受官方支持的。</p>\n<p>上面提到的所有东西都适用于 <code>layer-backed view</code>。对于 l<code>ayer-hosting view</code> 来说，你可以直接对 <code>view</code> 的 <code>layer</code> 或者<code>子 layer</code> 使用 <code>CAAnimations</code>，因为你拥有它们的控制权。</p>\n<h3 id=\"文字系统\"><a href=\"#文字系统\" class=\"headerlink\" title=\"文字系统\"></a>文字系统</h3><p>有了 <code>TextKit</code>，<code>iOS 7</code> 终于有了和 <code>Mac</code> 上早就有了的 <code>Cocoa Text System</code> 等效的东西。但 Apple 并不仅仅是把文字系统从 Mac 上转移到 <code>iOS</code>；相反，Apple 对其做了些显著的改变。<br>举个例子，<code>AppKit</code> 开放 <code>NSTypesetter</code> 和 <code>NSGlyphGenerator</code>，你可以通过继承这两者来自定义它们的一些特性。<code>iOS</code> 并不开放这些类，但是你可以通过 <code>NSLayoutManagerDelegate</code> 协议达到定制的目的。<br>总体来说，两个平台的文字系统还是非常相似的，所有你在 <code>iOS</code> 上能做的在 <code>Mac</code> 上都可以做（甚至更多），但对于一些东西，你必须从不同的地方寻找合适的方法实现。</p>\n<h3 id=\"沙盒\"><a href=\"#沙盒\" class=\"headerlink\" title=\"沙盒\"></a>沙盒</h3><p>符合沙盒机制的 <code>Mac 应用</code>才能通过 <code>Mac App Store</code> 销售。然而，我们已经习惯了沙盒机制还没出现之前的 <code>Mac</code> 开发环境，所以有时候会忽视一些你想要实现的功能会和沙盒的限制出现冲突。<br>管理Mac应用对沙盒支持：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/sandbox.jpg?imageMogr2/2/w/800\"></p>\n<h2 id=\"独有特性\"><a href=\"#独有特性\" class=\"headerlink\" title=\"独有特性\"></a>独有特性</h2><p>有很多事情你只能在 Mac 上做，这主要是因为它不同的交互模型和它更为宽松的安全策略。在本期话题中，我们有一些文章深入探讨了其中的一些内容：<a href=\"http://objccn.io/issue-14-4/\" target=\"_blank\" rel=\"noopener\">进程间通讯</a>，<a href=\"http://objccn.io/issue-14-1/\" target=\"_blank\" rel=\"noopener\">使 Mac 应用脚本化</a>,<a href=\"http://objccn.io/issue-14-2/\" target=\"_blank\" rel=\"noopener\">在沙盒中脚本化其他应用</a> , <a href=\"http://objccn.io/issue-14-3/\" target=\"_blank\" rel=\"noopener\">为你的应用构建插件</a>。<br>当然，这只是 Mac 独有特性中很小的一部分，但这给了你一个很好的视角看待 iOS 8 从头开始打造其可扩展性和 app 间通讯。最后，还有很多东西等待你去探索：Drag and Drop，Printing，Bindings，OpenCL 等等，这里仅仅是举几个例子。</p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"视图","path":"api/categories/视图.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"混编","path":"api/tags/混编.json"}]},{"title":"JavaScript自动化组件OC桥接","slug":"macOS/JavaScript自动化组件OC桥接","date":"2017-02-15T17:19:30.000Z","updated":"2017-02-16T13:43:01.000Z","comments":true,"path":"api/articles/macOS/JavaScript自动化组件OC桥接.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><a href=\"https://developer.apple.com/library/content/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/OSX10-10.html#//apple_ref/doc/uid/TP40014508-CH109-SW8\" target=\"_blank\" rel=\"noopener\">文档</a><br><code>JavaScript自动化</code>有一个内置的<code>Objective-C Bridge</code>，使您能够访问文件系统，创建Cocoa应用程序。<br><code>Objective-C Bridge</code>的主要接入点是全局属性<code>objc</code>和<code>$</code>。</p>\n<h2 id=\"Frameworks\"><a href=\"#Frameworks\" class=\"headerlink\" title=\"Frameworks\"></a>Frameworks</h2><p><code>Foundation framework</code>中的语法默认支持<code>JavaScript自动化</code>。也可以通过使用<code>ObjC.import()</code>方法导入其他Frameworks 和 libraries。<br>例如，使用<code>Cocoa框架</code>中的<code>NSBeep()</code>函数，需要导入<code>Cocoa框架</code><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjC.import(<span class=\"string\">'Cocoa'</span>)</span><br><span class=\"line\">$.NSBeep()</span><br></pre></td></tr></table></figure><br>除了系统框架之外，一些系统库的功能也被暴露出来。这个功能可以通过<code>头文件</code>的名称来暴漏出来（不带.h）<br>例如：<br>arpa/inet, asl, copyfile, dispatch, dyld, errno, getopt, glob, grp, ifaddrs, launch, membership, netdb, netinet/in, notify, objc, paths, pwd, readline, removefile, signal, spawn, sqlite3, stdio, stdlib, string, sys/fcntl, sys/file, sys/ioctl, sys/mount, sys/param, sys/resource, sys/socket, sys/stat, sys/sysctl, sys/time, sys/times, sys/types, sys/wait, sys/xattr, syslog, time, unistd, uuid/uuid, vImage, vecLib, vmnet, xpc, 和 zlib.<br>导入框架时，系统将参考桥接支持文件。除了内置的框架和库，您可以导入任何具有桥接支持的框架，只需要将完整路径传递给框架，如下示例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjC.import(<span class=\"string\">'/Library/Frameworks/Awesome.framework'</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>原始的<code>JavaScript数据类型</code>映射到<code>C数据类型</code>。例如，一个<code>JavaScript字符串</code>映射为<code>char *</code>，而<code>JavaScript整数</code>映射到<code>int</code>。使用<code>objc API</code>返回一个<code>char *</code>时，会得到一个<code>JS 字符串</code></p>\n<p>原始的<code>JavaScript数据类型</code>将被自动转换为<code>ObjC对象类型</code>，并能作为一个预期的对象类型的参数传递给ObjC方法。<br>例如，一个<code>JS字符串</code>将被转换为一个<code>NSString对象</code>如果是什么方法签名说应该是输入。</p>\n<blockquote>\n<p>注意，然而，ObjC方法返回的ObjC对象类型是不会自动转换为原始的JavaScript的数据类型。</p>\n</blockquote>\n<h2 id=\"实例化的类和调用方法\"><a href=\"#实例化的类和调用方法\" class=\"headerlink\" title=\"实例化的类和调用方法\"></a>实例化的类和调用方法</h2><p>所有类都定义为<code>$对象</code>的属性。ObjC对象的方法有两种方式调用，根据是否需要参数的方法。<br>如果ObjC方法不带参数，然后调用<code>JavaScript属性名</code>访问<code>属性值</code>。这个例子中实例化一个空的字符串。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = $.NSMutableString.alloc.init</span><br></pre></td></tr></table></figure><br>如果ObjC方法不带参数，根据<code>JSExport</code>规范来命名，通过JavaScript的方法调用（function-typed property）；<br>对于多参数的方法，Objective-C的方法每个部分都合并在一起，冒号后的字母变为大写并移除冒号。比如下边协议中的方法，在JavaScript调用就是：doFooWithBar(foo, bar);<br>这个例子说明<code>JavaScript字符串</code>转为<code>NSString</code>然后写入到一个文件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = $.NSString.alloc.initWithUTF8String(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\">str.writeToFileAtomically(<span class=\"string\">'/tmp/foo'</span>, <span class=\"literal\">true</span>)</span><br></pre></td></tr></table></figure></p>\n<p>如果你调用一个方法，如<code>-intValue</code>，返回<code>C数据类型</code>而不是一个对象，然后你会回到原始的<code>JavaScript数据类型</code>。<br>此示例返回原始的JavaScript的整数，99。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.NSNumber.numberWithInt(<span class=\"number\">99</span>).intValue</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"访问-ObjC-Properties\"><a href=\"#访问-ObjC-Properties\" class=\"headerlink\" title=\"访问 ObjC Properties\"></a>访问 ObjC Properties</h3><p><code>ObjC属性</code>也可以通过<code>JavaScript属性</code>来访问，很像调用无参数方法。<br>当一个<code>桥接对象属性</code>的被访问时，ObjC属性列表是第一参考，如果列表中存在该名称对应的属性，那么就调用相应属性的<code>getter</code>或<code>setter</code>选择器。如果该名称的ObjC属性不在类中属性的列表中，那么该属性名称就作为<code>方法选择器</code>来调用。<br>使用自定义<code>getter</code>名定义一个属性，你可以使用<code>属性</code>名 或 <code>getter</code>名，并得到相同的结果。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task = $.NSTask.alloc.init</span><br><span class=\"line\">task.running == task.isRunning</span><br></pre></td></tr></table></figure><br>另外，不同的参数方法，<code>桥接对象属性</code>映射到<code>ObjC属性</code>也可以设置为（read/write属性）。下面的两行定义了一个ObjC属性：<code>launchPath</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task.launchPath = <span class=\"string\">'/bin/sleep'</span></span><br><span class=\"line\">task.setLaunchPath(<span class=\"string\">'/bin/sleep'</span>)</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"JS","path":"api/categories/JS.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"混编","path":"api/tags/混编.json"}]},{"title":"shell命令+AppleScript脚本+Swift代码相互调用","slug":"macOS/shell命令+AppleScript脚本+Swift代码相互调用","date":"2017-02-15T17:19:30.000Z","updated":"2017-02-15T17:19:30.000Z","comments":true,"path":"api/articles/macOS/shell命令+AppleScript脚本+Swift代码相互调用.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>当想让自己的app支持播放，但有没有足够的时间来开发自己的播放器，可以先考虑用mpv播放器来实现相关功能，这是<code>AppleScript</code>作为互通的桥梁。</p>\n<h2 id=\"NSTask调用AppleScript\"><a href=\"#NSTask调用AppleScript\" class=\"headerlink\" title=\"NSTask调用AppleScript\"></a><code>NSTask</code>调用<code>AppleScript</code></h2><h3 id=\"调用脚本文件main-scpt\"><a href=\"#调用脚本文件main-scpt\" class=\"headerlink\" title=\"调用脚本文件main.scpt\"></a>调用脚本文件<code>main.scpt</code></h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//let bundle = NSBundle.init(forClass: self.dynamicType)</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bundle = <span class=\"type\">NSBundle</span>.mainBundle()</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> scriptPath = bundle.pathForResource(<span class=\"string\">\"main\"</span>, ofType: <span class=\"string\">\"scpt\"</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> paths = [scriptPath]</span><br><span class=\"line\">    <span class=\"type\">NSTask</span>.launchedTaskWithLaunchPath(<span class=\"string\">\"/usr/bin/osascript\"</span>, arguments: paths)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"调用APPleScript脚本片段\"><a href=\"#调用APPleScript脚本片段\" class=\"headerlink\" title=\"调用APPleScript脚本片段\"></a>调用<code>APPleScript脚本片段</code></h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bundle = <span class=\"type\">NSBundle</span>.mainBundle()</span><br><span class=\"line\"><span class=\"keyword\">let</span> videoPath = bundle.pathForResource(<span class=\"string\">\"BigBuck\"</span>, ofType: <span class=\"string\">\"m4v\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//https://developer.apple.com/library/mac/technotes/tn2084/_index.html</span></span><br><span class=\"line\"><span class=\"comment\">//open -na /Applications/mpv.app命令行必须是 -na 才能调用当前指定的播放器，否则会调用系统默认播发器</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAppleScript = <span class=\"string\">\"on run\\ndo shell script \\\"open -na /Applications/mpv.app \\(videoPath!)\\\"\\ntell application \\\"mpv\\\" to activate\\n end run\"</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(myAppleScript)</span><br><span class=\"line\"><span class=\"keyword\">var</span> error: <span class=\"type\">NSDictionary</span>?</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> scriptObject = <span class=\"type\">NSAppleScript</span>(source: myAppleScript) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> output: <span class=\"type\">NSAppleEventDescriptor</span> = scriptObject.executeAndReturnError(</span><br><span class=\"line\">    &amp;error) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(output.stringValue)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (error != <span class=\"literal\">nil</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"error: \\(error)\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"AppleScript调用shell\"><a href=\"#AppleScript调用shell\" class=\"headerlink\" title=\"AppleScript调用shell\"></a><code>AppleScript</code>调用<code>shell</code></h2><p>AppleScript语句中为on run {变量名称，逗号隔开} 以endrun结束。中间为AppleScript语句。</p>\n<h3 id=\"do-shell-script\"><a href=\"#do-shell-script\" class=\"headerlink\" title=\"do shell script\"></a>do shell script</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on run [变量1,变量2...]  #开始 多个变量名称，用逗号隔开</span><br><span class=\"line\">    do shell script \"open -n /Applications/mpv.app\" #AppleScript语句  </span><br><span class=\"line\">end run #结束</span><br></pre></td></tr></table></figure>\n<h2 id=\"终端osascript调用AppleScript\"><a href=\"#终端osascript调用AppleScript\" class=\"headerlink\" title=\"终端osascript调用AppleScript\"></a>终端<code>osascript</code>调用<code>AppleScript</code></h2><p><a href=\"http://www.hackmac.org/tutorials/run-applescript-from-the-command-line/\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">osascript -e 'applescript command' #单引号</span><br></pre></td></tr></table></figure>\n<h3 id=\"打开Finder窗口\"><a href=\"#打开Finder窗口\" class=\"headerlink\" title=\"打开Finder窗口\"></a>打开Finder窗口</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">osascript -e 'tell app \"Finder\" to make new Finder window'</span><br></pre></td></tr></table></figure>\n<h3 id=\"打开某个程序同时弹出”Hello-World”提示框\"><a href=\"#打开某个程序同时弹出”Hello-World”提示框\" class=\"headerlink\" title=\"打开某个程序同时弹出”Hello World”提示框\"></a>打开某个程序同时弹出”Hello World”提示框</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">osascript -e <span class=\"string\">'tell app \"applicationname\" to display dialog \"Hello World\"'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"设置音量，音量大小范围（0-7）\"><a href=\"#设置音量，音量大小范围（0-7）\" class=\"headerlink\" title=\"设置音量，音量大小范围（0-7）\"></a>设置音量，音量大小范围（0-7）</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">osascript -e <span class=\"string\">\"set volume number\"</span></span><br></pre></td></tr></table></figure>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"JS","path":"api/categories/JS.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"混编","path":"api/tags/混编.json"},{"name":"脚本","path":"api/tags/脚本.json"},{"name":"AppleScript","path":"api/tags/AppleScript.json"},{"name":"shell","path":"api/tags/shell.json"}]},{"title":"macOS支持JavaScript自动化组件基础","slug":"macOS/macOS支持JavaScript自动化组件基础","date":"2017-02-15T17:19:30.000Z","updated":"2017-02-16T13:43:01.000Z","comments":true,"path":"api/articles/macOS/macOS支持JavaScript自动化组件基础.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>苹果 <code>OS X Yosemite系统</code>把 <code>JavaScript</code>作为<code>AppleScript</code>的另一选择。<code>Automation</code> 是 <code>OS X 10.10版本</code>中的新特性，苹果在官网发布<a href=\"https://developer.apple.com/library/prerelease/mac/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/index.html#//apple_ref/doc/uid/TP40014508\" target=\"_blank\" rel=\"noopener\">JavaScript for Automation Release Notes</a>有篇文章介绍了用<code>JavaScript</code>写自动化<code>Automation</code>脚本。<br><code>JavaScript</code>凭借其简单的语法，良好的性能，超轻量的框架，极小耦合的模块系统等等优势已经吸引了很多大厂的关注。<br>再加上<code>JavaScript</code>先天开放且无版权专利纠纷的问题，拥有非常广泛的开发者（开源）群体，苹果将其引入<code>OS X平台</code>代替私有的<code>AppleScript</code>，可能也有着一部分开放性平台的考虑，从而吸引广泛的第三方开发者。<br>资源<br><a href=\"https://github.com/tylergaw/js-osx-app-examples\" target=\"_blank\" rel=\"noopener\">JavaScript OS X App Examples</a><br><a href=\"https://github.com/dtinth/JXA-Cookbook\" target=\"_blank\" rel=\"noopener\">JavaScript for Automation Cookbook</a></p>\n<h2 id=\"OSA框架-Open-Scripting-Architecture\"><a href=\"#OSA框架-Open-Scripting-Architecture\" class=\"headerlink\" title=\"OSA框架:Open Scripting Architecture\"></a>OSA框架:<code>Open Scripting Architecture</code></h2><p><code>OSA</code>组件用于实现MacAPP自动化操作。这些框架组件使用场景包括：<code>Script Editor</code>编辑器，全系统的<code>Script菜单</code>，<code>Run JavaScript Automator</code>命令的操作，<code>applets</code>小程序，命令行<code>osascript</code>工具，<code>NSUserScriptTask API</code>中，还可以运用在其他的<code>OSA</code>组件中例如：<code>AppleScript</code>。这也就包括了<code>Mail</code>规则、<code>Folder</code>操作、<code>Address Book</code>插件、日历闹钟和消息触发器。</p>\n<h2 id=\"脚本字典\"><a href=\"#脚本字典\" class=\"headerlink\" title=\"脚本字典\"></a>脚本字典</h2><p>脚本字典详细介绍APP的对象模型。在脚本字典映射到有效的JavaScript标识符遵循一套规范的术语。在<code>Script Editor</code>脚本字典浏览器已经更新到显示术语<code>AppleScript</code>，<code>JavaScript</code>和O<code>bjective-C</code>（Scripting Bridge framework）格式。</p>\n<h3 id=\"打开脚本字典\"><a href=\"#打开脚本字典\" class=\"headerlink\" title=\"打开脚本字典\"></a>打开脚本字典</h3><p>启动<code>Script Editor</code> (/Applications/Utilities/) –&gt;<code>File &gt; Open Dictionary or Window &gt; Library</code>。</p>\n<h2 id=\"object-specifier\"><a href=\"#object-specifier\" class=\"headerlink\" title=\"object specifier\"></a>object specifier</h2><p>在<code>JavaScript自动化主机</code>环境中的大部分对象指的是外部实例，如：其他APP，window或在这些APP的相关数据。当访问一个APP对象或APP中的某个元素的<code>JavaScript属性</code>时，会返回一个新的<code>object specifier</code>，也就是这个对象的<code>specifier 属性</code>。</p>\n<blockquote>\n<p>object specifier不是外部实例属性的实际值，是这个对象的引用指针。如果要获取这个属性的实际值，使用get／set方法。</p>\n</blockquote>\n<h2 id=\"访问APP\"><a href=\"#访问APP\" class=\"headerlink\" title=\"访问APP\"></a>访问APP</h2><p>六种方式:<br><figure class=\"highlight js\"><figcaption><span>By name</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application(<span class=\"string\">'Mail'</span>)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><figcaption><span>By bundle ID</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application(<span class=\"string\">'com.apple.mail'</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>By path</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application(<span class=\"string\">'/Applications/Mail.app'</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>By process ID</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application(<span class=\"number\">763</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>On a remote machine</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application(<span class=\"string\">'eppc://127.0.0.1/Mail'</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>currentApplication</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application.currentApplication()</span><br></pre></td></tr></table></figure>\n<h2 id=\"语法示例\"><a href=\"#语法示例\" class=\"headerlink\" title=\"语法示例\"></a>语法示例</h2><figure class=\"highlight js\"><figcaption><span>Access properties</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.name</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>Access elements</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.outgoingMessages[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>Call commands</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.open(...)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>Create new objects</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.OutgoingMessage(...)</span><br></pre></td></tr></table></figure>\n<h3 id=\"属性的get-set方法\"><a href=\"#属性的get-set方法\" class=\"headerlink\" title=\"属性的get/set方法\"></a>属性的get/set方法</h3><p>点运算符访问脚本对象，是JavaScript语法特性之一。<br>如上所述，返回的对象是一个<code>object specifier</code>是一个对象的引用，而不是属性实际值。<br>当访问属性时，会作为一个get函数，返回实际值：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subject = Mail.inbox.messages[<span class=\"number\">0</span>].subject()</span><br></pre></td></tr></table></figure><br>当赋值属性时，会作为一个set函数，把参数赋值该属性：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.outgoingMessages[<span class=\"number\">0</span>].subject = <span class=\"string\">'Hello world'</span></span><br></pre></td></tr></table></figure><br>获取数组中的每个元素属性（在这种情况下，得到邮件收件箱中的每份邮件的标题）<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subjects = Mail.inbox.messages.subject()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"元素数组\"><a href=\"#元素数组\" class=\"headerlink\" title=\"元素数组\"></a>元素数组</h3><p>通过在数组中调用特定元素检索方法，或使用方括号并指定要检索的元素的名称或索引来访问数组中的元素。返回值是对象相关，与自己的属性和元素，引用数组元素。他们可以访问<br><figure class=\"highlight js\"><figcaption><span>索引</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span> = Mail.windows.at(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">window</span> = Mail.windows[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure><br><figure class=\"highlight js\"><figcaption><span>name</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span> = Mail.windows.byName(<span class=\"string\">'New Message'</span>)</span><br><span class=\"line\"><span class=\"built_in\">window</span> = Mail.windows[<span class=\"string\">'New Message'</span>]</span><br></pre></td></tr></table></figure><br><figure class=\"highlight js\"><figcaption><span>ID</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span> = Mail.windows.byId(<span class=\"number\">412</span>)</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Note: 使用ID来访问不是方括号[]而是().</p>\n</blockquote>\n<h3 id=\"调用命令\"><a href=\"#调用命令\" class=\"headerlink\" title=\"调用命令\"></a>调用命令</h3><p>命令被称为函数。</p>\n<ol>\n<li>直接参数的函数，该参数作为命令的第一个参数传递。</li>\n<li>如果函数需要带参数名的参数，那么这个参数可以接受一个键值对对象。</li>\n<li>如果函数需要一个直接参数，就需要传递一个带参数名的参数作为第二个参数。</li>\n<li>如果函数不存在直接参数，那么带参数名的参数作为第一个参数传递，并且唯一参数。</li>\n<li>直接参数是可选的，可以不用传递任何值，当第一个参数存在参数名时，则传递NULL作为第一个参数。<figure class=\"highlight js\"><figcaption><span>无参数命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message.open()</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>无参数名的命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mail.open(message)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>带参数名的命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response = message.reply(&#123;</span><br><span class=\"line\">replayAll: <span class=\"literal\">true</span>,</span><br><span class=\"line\">openingWindow: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>Command with direct parameter and named parameters</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Safari.doJavaScript(<span class=\"string\">'alert(\"Hello world\")'</span>, &#123;</span><br><span class=\"line\"><span class=\"keyword\">in</span>: Safari.windows[<span class=\"number\">0</span>].tabs[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Creating-Objects\"><a href=\"#Creating-Objects\" class=\"headerlink\" title=\"Creating Objects\"></a>Creating Objects</h2><p>通过调用<code>类构造函数</code>初始化<code>属性</code>和<code>数据</code>来创建新对象。<br>在创建对象时,需要执行的其中步骤：</p>\n<ol>\n<li><code>make()</code>方法：调用对象上的<code>make()</code>方法来实例化对象。</li>\n<li><code>push()</code>方法：调用对象数组上的<code>push</code>方法来实例化对象。<br>在调用这些方法中的一个之前，对象实际上并不存在于应用程序中。</li>\n</ol>\n<h3 id=\"Create-a-new-object\"><a href=\"#Create-a-new-object\" class=\"headerlink\" title=\"Create a new object.\"></a>Create a new object.</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message = Mail.OutgoingMessage().make()</span><br></pre></td></tr></table></figure>\n<h3 id=\"Create-a-new-object-with-properties\"><a href=\"#Create-a-new-object-with-properties\" class=\"headerlink\" title=\"Create a new object with properties.\"></a>Create a new object with properties.</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message = Mail.OutgoingMessage(&#123;</span><br><span class=\"line\">subject: <span class=\"string\">'Hello world'</span>,</span><br><span class=\"line\">visible: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Mail.outgoingMessages.push(message)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Create-a-new-object-with-data\"><a href=\"#Create-a-new-object-with-data\" class=\"headerlink\" title=\"Create a new object with data.\"></a>Create a new object with data.</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">para = TextEdit.Paragraph(&#123;&#125;, <span class=\"string\">'Some text'</span>)</span><br><span class=\"line\">TextEdit.documents[<span class=\"number\">0</span>].paragraphs.push(para)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用对象\"><a href=\"#使用对象\" class=\"headerlink\" title=\"使用对象\"></a>使用对象</h3><p>一旦你在应用程序中创建一个新的对象（通过调用<code>make</code>或<code>push</code>），可以像任何现有的应用程序对象一样进行交互。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message = Mail.OutgoingMessage().make()</span><br><span class=\"line\">message.subject = <span class=\"string\">'Hello world'</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Scripting-Additions\"><a href=\"#Scripting-Additions\" class=\"headerlink\" title=\"Scripting Additions\"></a>Scripting Additions</h3><p>使用脚本添加（脚本插件）来增强应用程序的功能。操作系统有一套标准的脚本添加提供speak text,展示用户交互对话，等。<br>使用这些，必须明确设置<code>includeStandardAdditions</code>的<code>flag</code>为 <code>true</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app = Application.currentApplication()</span><br><span class=\"line\">app.includeStandardAdditions = <span class=\"literal\">true</span></span><br><span class=\"line\">app.say(<span class=\"string\">'Hello world'</span>)</span><br><span class=\"line\">app.displayDialog(<span class=\"string\">'Please enter your email address'</span>, &#123;</span><br><span class=\"line\">withTitle: <span class=\"string\">'Email'</span>,</span><br><span class=\"line\">defaultAnswer: <span class=\"string\">'your_email@site.com'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Applets\"><a href=\"#Applets\" class=\"headerlink\" title=\"Applets\"></a>Applets</h2><p>在<code>Script Editor</code>编写脚本并保存为一个应用程序，且可以被双击独立运行的程序称为<code>Applet</code>。<br>程序支持以下事件处理：<br>当Applet运行时，<code>run</code>处理事件被调用：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<p>用于拖放操作的<code>openDocuments</code>处理事件程序包配置小程序，当文档被拖放到该小程序上时，这个处理操作将被执行：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">openDocuments</span>(<span class=\"params\">docs</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><br>传递的参数是一个文件路径字符串数组。<br><a href=\"https://developer.apple.com/library/content/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/OSX10-10.html#//apple_ref/doc/uid/TP40014508-CH109-SW8\" target=\"_blank\" rel=\"noopener\">更多样例</a></p>\n<h2 id=\"UI-Automation\"><a href=\"#UI-Automation\" class=\"headerlink\" title=\"UI Automation\"></a>UI Automation</h2><p>通过编写系统事件应用程序，可以自动化应用程序的用户界面。在脚本编辑器<code>Script Editor</code>中浏览<code>System Events</code>的脚本字典，特别是进程套件<code>Processes Suite</code>，以查看支持此类型自动化的应用程序接口元素的列表。<br>下面的示例使用UI脚本创建Notes中的新注释。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Notes = Application(<span class=\"string\">'Notes'</span>)</span><br><span class=\"line\">Notes.activate()</span><br><span class=\"line\"></span><br><span class=\"line\">delay(<span class=\"number\">1</span>)</span><br><span class=\"line\">SystemEvents = Application(<span class=\"string\">'System Events'</span>)</span><br><span class=\"line\">Notes = SystemEvents.processes[<span class=\"string\">'Notes'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">Notes.windows[<span class=\"number\">0</span>].splitterGroups[<span class=\"number\">0</span>].groups[<span class=\"number\">1</span>].groups[<span class=\"number\">0</span>].buttons[<span class=\"number\">0</span>].click()</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"JS","path":"api/categories/JS.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"混编","path":"api/tags/混编.json"},{"name":"JavaScript","path":"api/tags/JavaScript.json"}]},{"title":"通过沙盒中JS脚本访问其他APP","slug":"macOS/通过沙盒中JS脚本访问其他APP","date":"2017-02-14T18:25:29.000Z","updated":"2017-02-16T13:43:01.000Z","comments":true,"path":"api/articles/macOS/通过沙盒中JS脚本访问其他APP.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>如何使用脚本字典里的命令和对象来与其他的应用进行通讯?<br>这个教程将向您展示现在使用 <code>AppleScript</code> 来控制别的应用的最佳方式。我也会告诉您一些小技巧以帮助您和您的用户用最小的努力就架设起 <code>AppleScript</code>。</p>\n<h2 id=\"在自己的APP中编写\"><a href=\"#在自己的APP中编写\" class=\"headerlink\" title=\"在自己的APP中编写\"></a>在自己的APP中编写</h2><h3 id=\"编写AppleScript代码\"><a href=\"#编写AppleScript代码\" class=\"headerlink\" title=\"编写AppleScript代码\"></a>编写AppleScript代码</h3><p><a href=\"https://developer.apple.com/library/mac/documentation/applescript/conceptual/applescriptlangguide/introduction/ASLR_intro.html#//apple_ref/doc/uid/TP40000983-CH208-SW1\" target=\"_blank\" rel=\"noopener\">AppleScript 脚本指南</a><br>与其他应用进行通讯的脚本一般来说都很短，也容易理解。<code>AppleScript</code> 可以被想做一种传送的机制，而不是一种处理环境。<br>典型脚本:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on chockify(inputString)</span><br><span class=\"line\">    set resultString to <span class=\"string\">\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        repeat <span class=\"keyword\">with</span> inputStringCharacter <span class=\"keyword\">in</span> inputString</span><br><span class=\"line\">            set asciiValue to (ASCII number inputStringCharacter)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (asciiValue &gt; <span class=\"number\">96</span> and asciiValue &lt; <span class=\"number\">123</span>) then</span><br><span class=\"line\">                set resultString to resultString &amp; (ASCII character (asciiValue - <span class=\"number\">32</span>))</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((asciiValue &gt; <span class=\"number\">64</span> and asciiValue &lt; <span class=\"number\">91</span>) or (asciiValue = <span class=\"number\">32</span>)) then</span><br><span class=\"line\">                    set resultString to resultString &amp; inputStringCharacter</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (asciiValue &gt; <span class=\"number\">47</span> and asciiValue &lt; <span class=\"number\">58</span>) then</span><br><span class=\"line\">                        set numberStrings to &#123;<span class=\"string\">\"ZERO\"</span>, <span class=\"string\">\"ONE\"</span>, <span class=\"string\">\"TWO\"</span>, <span class=\"string\">\"THREE\"</span>, <span class=\"string\">\"FOR\"</span>, <span class=\"string\">\"FIVE\"</span>, <span class=\"string\">\"SIX\"</span>, <span class=\"string\">\"SEVEN\"</span>, <span class=\"string\">\"EIGHT\"</span>, <span class=\"string\">\"NINE\"</span>&#125;</span><br><span class=\"line\">                        set itemIndex to asciiValue - <span class=\"number\">47</span></span><br><span class=\"line\">                        set numberString to item itemIndex <span class=\"keyword\">of</span> numberStrings</span><br><span class=\"line\">                        set resultString to resultString &amp; numberString &amp; <span class=\"string\">\" \"</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (asciiValue = <span class=\"number\">33</span>) then</span><br><span class=\"line\">                            set resultString to resultString &amp; <span class=\"string\">\" DUH\"</span></span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (asciiValue = <span class=\"number\">63</span>) then</span><br><span class=\"line\">                                set resultString to resultString &amp; <span class=\"string\">\" IF YOU KNOW WHAT I MEAN\"</span></span><br><span class=\"line\">                            end <span class=\"keyword\">if</span></span><br><span class=\"line\">                        end <span class=\"keyword\">if</span></span><br><span class=\"line\">                    end <span class=\"keyword\">if</span></span><br><span class=\"line\">                end <span class=\"keyword\">if</span></span><br><span class=\"line\">            end <span class=\"keyword\">if</span></span><br><span class=\"line\">        end repeat</span><br><span class=\"line\">        resultString</span><br><span class=\"line\">end chockify</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"创建事件描述符-event-descriptor\"><a href=\"#创建事件描述符-event-descriptor\" class=\"headerlink\" title=\"创建事件描述符 (event descriptor)\"></a>创建事件描述符 (event descriptor)</h3><ol>\n<li>导入Carbon.h<br>它有关于所有的 AppleEvent 的定义。<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Carbon/Carbon.h&gt;</span> // for AppleScript definitions</span></span><br></pre></td></tr></table></figure></li>\n<li>OC中创建<code>chockify</code>事件描述符<br>这是可以在你的脚本和应用之间互相传递的一个数据块。可以把它理解成一个封装好的会去执行某个事件的目标，一个将被调用的函数，以及这个函数的参数。使用一个 <code>NSString</code> 作为参数，创建<code>chockify</code>事件描述符：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSAppleEventDescriptor</span> *)chockifyEventDescriptorWithString:(<span class=\"built_in\">NSString</span> *)inputString</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// parameter</span></span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *parameter = [<span class=\"built_in\">NSAppleEventDescriptor</span> descriptorWithString:inputString];</span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *parameters = [<span class=\"built_in\">NSAppleEventDescriptor</span> listDescriptor];</span><br><span class=\"line\">    [parameters insertDescriptor:parameter atIndex:<span class=\"number\">1</span>]; <span class=\"comment\">// you have to love a language with indices that start at 1 instead of 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// target</span></span><br><span class=\"line\">    ProcessSerialNumber psn = &#123;<span class=\"number\">0</span>, kCurrentProcess&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *target = [<span class=\"built_in\">NSAppleEventDescriptor</span> descriptorWithDescriptorType:typeProcessSerialNumber bytes:&amp;psn length:<span class=\"keyword\">sizeof</span>(ProcessSerialNumber)];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// function</span></span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *function = [<span class=\"built_in\">NSAppleEventDescriptor</span> descriptorWithString:<span class=\"string\">@\"chockify\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// event</span></span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *event = [<span class=\"built_in\">NSAppleEventDescriptor</span> appleEventWithEventClass:kASAppleScriptSuite eventID:kASSubroutineEvent targetDescriptor:target returnID:kAutoGenerateReturnID transactionID:kAnyTransactionID];</span><br><span class=\"line\">    [event setParamDescriptor:function forKeyword:keyASSubroutineName];</span><br><span class=\"line\">    [event setParamDescriptor:parameters forKeyword:keyDirectObject];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> event;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"OC中加载-AppleScript\"><a href=\"#OC中加载-AppleScript\" class=\"headerlink\" title=\"OC中加载 AppleScript\"></a>OC中加载 AppleScript</h3><p>通过应用包(Application bundle)的一个 <code>URL</code> 可以创建 <code>NSAppleScript</code>的实例。而反过来，脚本也要和上面创建的 <code>chockify 事件描述符</code>一起使用。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURL</span> *URL = [[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"Automation\"</span> withExtension:<span class=\"string\">@\"scpt\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (URL) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAppleScript</span> *appleScript = [[<span class=\"built_in\">NSAppleScript</span> alloc] initWithContentsOfURL:URL error:<span class=\"literal\">NULL</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *event = [<span class=\"keyword\">self</span> chockifyEventDescriptorWithString:[<span class=\"keyword\">self</span>.chockifyInputTextField stringValue]];</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *error = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *resultEventDescriptor = [appleScript executeAppleEvent:event error:&amp;error];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! resultEventDescriptor) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s AppleScript run error = %@\"</span>, __PRETTY_FUNCTION__, error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> *string = [<span class=\"keyword\">self</span> stringForResultEventDescriptor:resultEventDescriptor];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> updateChockifyTextFieldWithString:string];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如果一切正常的话，你会得到另一个事件描述符。如果出错了，你会得到一个包含了描述错误信息的字典。虽说这个模式和很多其他 <code>Foundation 类</code>很相似，但是返回的错误并不是一个 <code>NSError</code> 的实例。</p>\n<h3 id=\"调用事件描述符\"><a href=\"#调用事件描述符\" class=\"headerlink\" title=\"调用事件描述符\"></a>调用事件描述符</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)stringForResultEventDescriptor:(<span class=\"built_in\">NSAppleEventDescriptor</span> *)resultEventDescriptor</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *result = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resultEventDescriptor)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([resultEventDescriptor descriptorType] != kAENullEvent)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ([resultEventDescriptor descriptorType] == kTXNUnicodeTextData) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result = [resultEventDescriptor stringValue];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>InputString 输入可以被正确整形输出，并且你现在也看到想在你的应用里运行 AppleScripts 的方法</p>\n<h2 id=\"调用沙盒中脚本代码与访问其他应用\"><a href=\"#调用沙盒中脚本代码与访问其他应用\" class=\"headerlink\" title=\"调用沙盒中脚本代码与访问其他应用\"></a>调用沙盒中脚本代码与访问其他应用</h2><h3 id=\"了解APP沙盒限制\"><a href=\"#了解APP沙盒限制\" class=\"headerlink\" title=\"了解APP沙盒限制\"></a>了解APP沙盒限制</h3><p>如果一段脚本可以轻易地拿到浏览器当前页面上的内容，甚至是在任意标签和窗口运行<code>JavaScript</code>。想象一下如果这些页面里有你的银行账号，或者包含你的信用卡信息什么的。</p>\n<p>对于沙盒应用，Apple 所提倡的是通过用户的需要来驱动安全策略。这意味着是否运行你的脚本完全取决于用户。这些脚本可能是来自互联网，也可能是你应用的一部分。一旦得到了权限，脚本就可以以一种受限的方式与系统其他部分进行交互了。<code>NSUserScriptTask</code>使这一切变得可能。<br>由此：Apple 引入了一个新的抽象类 <code>NSUserScriptTask</code>,有三个具体的子类实现:</p>\n<ol>\n<li><code>NSUserUnixTask</code>: 执行 Unix shell 命令</li>\n<li><code>NSUserAutomatorTask</code>: Automator 工作流</li>\n<li><code>NSUserAppleScriptTask</code>:执行<code>AppleScript脚本</code>,脚本是异步执行的,所以脚本不能对用户界面做更新操作。</li>\n</ol>\n<h3 id=\"开始安装运行脚本\"><a href=\"#开始安装运行脚本\" class=\"headerlink\" title=\"开始安装运行脚本\"></a>开始安装运行脚本</h3><p>怎么向用户请求运行脚本的许可，让你的应用与用户的其他应用更好地工作在一起？<br>两种策略:</p>\n<ol>\n<li>帮助用户来存放运行脚本的位置</li>\n<li>获取行脚本目录可读写</li>\n</ol>\n<h4 id=\"帮用户存放运行脚本的位置\"><a href=\"#帮用户存放运行脚本的位置\" class=\"headerlink\" title=\"帮用户存放运行脚本的位置\"></a>帮用户存放运行脚本的位置</h4><p>只能把把这些脚本放到用户的脚本文件夹(<code>User &gt; Library &gt; Application Scripts/bundle identifier/</code>)中，以只读的方式来运行你的脚本。<br>脚本想要进入这个特定的文件夹的唯一方式就是用用户把它们复制到那里。再者<code>Library 文件夹</code>在 OS X 里默认还是隐藏的。这样对用户都很不友好。<br>让代码来帮助用户打开这个隐藏文件夹：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\"><span class=\"built_in\">NSURL</span> *directoryURL = [[<span class=\"built_in\">NSFileManager</span> defaultManager] URLForDirectory:<span class=\"built_in\">NSApplicationScriptsDirectory</span> inDomain:<span class=\"built_in\">NSUserDomainMask</span> appropriateForURL:<span class=\"literal\">nil</span> create:<span class=\"literal\">YES</span> error:&amp;error];</span><br><span class=\"line\">[[<span class=\"built_in\">NSWorkspace</span> sharedWorkspace] openURL:directoryURL];</span><br></pre></td></tr></table></figure><br>通过你的应用的某个控件打开这个文件夹，然后进行编辑。这对于用户自己写的脚本来说是个很好的解决方案。</p>\n<h4 id=\"设置运行脚本目录的读写权限\"><a href=\"#设置运行脚本目录的读写权限\" class=\"headerlink\" title=\"设置运行脚本目录的读写权限\"></a>设置运行脚本目录的读写权限</h4><ol>\n<li>在 Xcode 里，你需要更新 <code>Capabilities</code>，让其包括 <code>User Selected File to Read/Write</code>。在 <code>App Sandbox &gt; File Access</code>里找到相关选项。</li>\n<li>用户的意愿是关键，因为你需要获取权限以将脚本添加到文件夹：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\"><span class=\"built_in\">NSURL</span> *directoryURL = [[<span class=\"built_in\">NSFileManager</span> defaultManager] URLForDirectory:<span class=\"built_in\">NSApplicationScriptsDirectory</span> inDomain:<span class=\"built_in\">NSUserDomainMask</span> appropriateForURL:<span class=\"literal\">nil</span> create:<span class=\"literal\">YES</span> error:&amp;error];</span><br><span class=\"line\"><span class=\"built_in\">NSOpenPanel</span> *openPanel = [<span class=\"built_in\">NSOpenPanel</span> openPanel];</span><br><span class=\"line\">[openPanel setDirectoryURL:directoryURL];</span><br><span class=\"line\">[openPanel setCanChooseDirectories:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">[openPanel setCanChooseFiles:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">[openPanel setPrompt:<span class=\"string\">@\"Select Script Folder\"</span>];</span><br><span class=\"line\">[openPanel setMessage:<span class=\"string\">@\"Please select the User &gt; Library &gt; Application Scripts &gt; com.iconfactory.Scriptinator folder\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">[openPanel beginWithCompletionHandler:^(<span class=\"built_in\">NSInteger</span> result) &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (result == <span class=\"built_in\">NSFileHandlingPanelOKButton</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *selectedURL = [openPanel URL];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([selectedURL isEqual:directoryURL])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSURL</span> *destinationURL = [selectedURL URLByAppendingPathComponent:<span class=\"string\">@\"Automation.scpt\"</span>];</span><br><span class=\"line\">        <span class=\"built_in\">NSFileManager</span> *fileManager = [<span class=\"built_in\">NSFileManager</span> defaultManager];</span><br><span class=\"line\">        <span class=\"built_in\">NSURL</span> *sourceURL = [[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"Automation\"</span> withExtension:<span class=\"string\">@\"scpt\"</span>];</span><br><span class=\"line\">        <span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\">        <span class=\"built_in\">BOOL</span> success = [fileManager copyItemAtURL:sourceURL toURL:destinationURL error:&amp;error];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (success)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSAlert</span> *alert = [<span class=\"built_in\">NSAlert</span> alertWithMessageText:<span class=\"string\">@\"Script Installed\"</span> defaultButton:<span class=\"string\">@\"OK\"</span> alternateButton:<span class=\"literal\">nil</span> otherButton:<span class=\"literal\">nil</span> informativeTextWithFormat:<span class=\"string\">@\"The Automation script was installed succcessfully.\"</span>];</span><br><span class=\"line\">            [alert runModal];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s error = %@\"</span>, __PRETTY_FUNCTION__, error);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ([error code] == <span class=\"built_in\">NSFileWriteFileExistsError</span>) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// this is where you could update the script, by removing the old one and copying in a new one</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// the item couldn't be copied, try again</span></span><br><span class=\"line\">                [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(installAutomationScript:) withObject:<span class=\"keyword\">self</span> afterDelay:<span class=\"number\">0.0</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// try again because the user changed the folder path</span></span><br><span class=\"line\">        [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(installAutomationScript:) withObject:<span class=\"keyword\">self</span> afterDelay:<span class=\"number\">0.0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n这么一来，应用包中的 <code>Automation.scpt</code> 文件现在暴露在常规的文件系统中了。</li>\n</ol>\n<h3 id=\"执行脚本任务\"><a href=\"#执行脚本任务\" class=\"headerlink\" title=\"执行脚本任务\"></a>执行脚本任务</h3><p>使用 <code>NSUserAppleScriptTask</code> 来替代 <code>NSAppleScript</code>，来运行上面创建的<code>事件描述符</code>。<br>你大概会经常用到这些脚本任务。文档警告说对于给定的类的某个实例， <code>NSUserAppleScriptTask</code> 不应该被执行多次。所以写一个<code>工厂函数</code>来在需要的时候创建任务：<br><figure class=\"highlight objc\"><figcaption><span>工厂函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSUserAppleScriptTask</span> *)automationScriptTask</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSUserAppleScriptTask</span> *result = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *error;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *directoryURL = [[<span class=\"built_in\">NSFileManager</span> defaultManager] URLForDirectory:<span class=\"built_in\">NSApplicationScriptsDirectory</span> inDomain:<span class=\"built_in\">NSUserDomainMask</span> appropriateForURL:<span class=\"literal\">nil</span> create:<span class=\"literal\">YES</span> error:&amp;error];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (directoryURL) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSURL</span> *scriptURL = [directoryURL URLByAppendingPathComponent:<span class=\"string\">@\"Automation.scpt\"</span>];</span><br><span class=\"line\">        result = [[<span class=\"built_in\">NSUserAppleScriptTask</span> alloc] initWithURL:scriptURL error:&amp;error];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! result) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s no AppleScript task error = %@\"</span>, __PRETTY_FUNCTION__, error);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> if you're not running in a sandbox, the directory URL will always be nil</span></span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s no Application Scripts folder error = %@\"</span>, __PRETTY_FUNCTION__, error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>如果你正在写一个同时适用于沙盒和非沙盒的 Mac 应用的话，在获取 <code>directoryURL</code> 时你需要特别小心。<code>NSApplicationScriptsDirectory</code>只在沙盒中有效。</p>\n</blockquote>\n<p>在创建脚本任务后，你需要使用 <code>AppleEvent</code> 并提供一个结束处理来执行它：<br><figure class=\"highlight objc\"><figcaption><span>AppleEvent</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSUserAppleScriptTask</span> *automationScriptTask = [<span class=\"keyword\">self</span> automationScriptTask];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (automationScriptTask) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAppleEventDescriptor</span> *event = [<span class=\"keyword\">self</span> safariURLEventDescriptor];</span><br><span class=\"line\">    [automationScriptTask executeWithAppleEvent:event completionHandler:^(<span class=\"built_in\">NSAppleEventDescriptor</span> *resultEventDescriptor, <span class=\"built_in\">NSError</span> *error) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! resultEventDescriptor) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s AppleScript task error = %@\"</span>, __PRETTY_FUNCTION__, error);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSURL</span> *URL = [<span class=\"keyword\">self</span> URLForResultEventDescriptor:resultEventDescriptor];</span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> The completion handler for the script is not run on the main thread. Before you update any UI, you'll need to get</span></span><br><span class=\"line\">            <span class=\"comment\">// on that thread by using libdispatch or performing a selector.</span></span><br><span class=\"line\">            [<span class=\"keyword\">self</span> performSelectorOnMainThread:<span class=\"keyword\">@selector</span>(updateURLTextFieldWithURL:) withObject:URL waitUntilDone:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>对于用户写的脚本，用户可能期望你的应用只是简单地’运行’脚本 (而不去调用事件描述符中指定的函数)。在这种情况下，你可以为 <code>event</code> 传递一个 <code>nil</code>，脚本就会像用户在 <code>Finder</code> 中双击那样的行为进行执行。<br><code>NSUserAppleScriptTask</code>脚本是异步执行的，所以你的用户界面并不会被一个 (比较长) 的脚本锁住，在结束后会执行回调处理。</p>\n<h2 id=\"同步操作\"><a href=\"#同步操作\" class=\"headerlink\" title=\"同步操作\"></a>同步操作</h2><p><code>NSAppleScript</code> 和 <code>NSUserAppleScriptTask</code> 有一个微妙的区别：新的机制是异步执行的。对于大部分情况，使用一个结束回调来处理会是一个好得多的方式，因为这样就不会因为执行脚本而阻碍你的应用。<br>然而有时候如果你想带有依赖地来执行任务的时候，事情就变得有些取巧了。比方说一个任务需要在另一个任务开始之前必须完成。这种情况下你就会想念 <code>NSAppleScript</code> 的同步特性了。<br>要获得传统方式的行为，一种简单的方法是使用一个<code>信号量(semaphore)</code> 来确保同时只有一个任务运行、在你的类或者应用的初始化方法中，使用 <code>libdispatch</code> 创建一个信号量：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.appleScriptTaskSemaphore = dispatch_semaphore_create(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure><br>接下来在初始化脚本任务之前，简单地等待信号量。当任务完成时，标记相同的这个信号量：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// wait for any previous tasks to complete before starting a new one — remember that you're blocking the main thread here!</span></span><br><span class=\"line\">dispatch_semaphore_wait(<span class=\"keyword\">self</span>.appleScriptTaskSemaphore, DISPATCH_TIME_FOREVER);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// run the script task</span></span><br><span class=\"line\"><span class=\"built_in\">NSAppleEventDescriptor</span> *event = [<span class=\"keyword\">self</span> openNetworkPreferencesEventDescriptor];</span><br><span class=\"line\">[automationScriptTask executeWithAppleEvent:event completionHandler:^(<span class=\"built_in\">NSAppleEventDescriptor</span> *resultEventDescriptor, <span class=\"built_in\">NSError</span> *error) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! resultEventDescriptor)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s AppleScript task error = %@\"</span>, __PRETTY_FUNCTION__, error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> performSelectorOnMainThread:<span class=\"keyword\">@selector</span>(showNetworkAlert) withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// the task has completed, so let any pending tasks proceed</span></span><br><span class=\"line\">    dispatch_semaphore_signal(<span class=\"keyword\">self</span>.appleScriptTaskSemaphore);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure><br>再强调一下，除非确实有所需要，否则最好别这么做。</p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"JS","path":"api/categories/JS.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"沙盒","path":"api/tags/沙盒.json"},{"name":"脚本","path":"api/tags/脚本.json"},{"name":"AppleScript","path":"api/tags/AppleScript.json"}]},{"title":"macOS之PDFKit基础","slug":"macOS/macOS之PDFKit基础","date":"2017-02-14T14:29:18.000Z","updated":"2018-01-08T14:10:41.000Z","comments":true,"path":"api/articles/macOS/macOS之PDFKit基础.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/view_vspage_space.gif?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>一个PDF的基本构建块是Documents本身。Documents通常作为文件存储在磁盘上。<br>作为文件版本，可以支持元数据标记如作者，创建日期，等等。<br>一个文件可以加密，需要密码才能查看它。两级加密存在：</p>\n<ul>\n<li>用户级加密：如果用户成功地获得用户级权限，他或她可以查看文档，但可以限制打印或复制文档。</li>\n<li>所有者级别加密：获得所有者级别权限的用户可以查看文档并具有完全使用权限。<br>许多加密的PDF文件有一个“dummy”的用户密码为<code>空字符串</code>。大多数PDF文档解析器（包括PDF套件）自动尝试空字符串密码加密后的文件，如果成功，只显示文档。因此，在技术上加密的文档不一定提示用户口令。</li>\n</ul>\n<h2 id=\"PDF页面\"><a href=\"#PDF页面\" class=\"headerlink\" title=\"PDF页面\"></a>PDF页面</h2><p>一个PDF文档由若干页面组成。这个页面看起来就像一本物理书页面显示在屏幕上。同时PDF页面可以包含<code>超链接</code>和<code>注释</code>。页面可以支持<code>裁剪</code>，还有其他使用功能：例如隐藏多余的部分（如注册标记）。</p>\n<h3 id=\"view-VS-page空间坐标\"><a href=\"#view-VS-page空间坐标\" class=\"headerlink\" title=\"view VS page空间坐标\"></a>view VS page空间坐标</h3><p>页面上的大多数对象都是在<code>page</code>空间中指定的，而不是在<code>view</code>空间中。<br>也就是说，坐标系统是在点（每英寸72点），<code>坐标原点</code>在page左侧底部，而不是<code>view</code>。<code>page</code>空间不关心缩放，显示模式等等。一个有<code>bounds</code>的item，比如说32points，保留这些界限，无论显示大小。<br>图view和page坐标系比较<br><img title=\"view和page坐标系比较\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/view_vspage_space.gif?imageMogr2/2/w/800\"><br><code>PDFView class</code>包含几个转换方法，将坐标系统从<code>view space</code>的<code>page space</code>，反之亦然。</p>\n<h2 id=\"PDF-Kit-Classes\"><a href=\"#PDF-Kit-Classes\" class=\"headerlink\" title=\"PDF Kit Classes\"></a>PDF Kit Classes</h2><p><code>PDF Kit</code>套件提供了几个不同功能的<code>类</code>。<br><code>PDFView</code>和<code>PDFSelection</code>除外，这些<code>类</code>大致对应着各个<code>对象</code>在PDF格式的规范需求。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/pdfkit_inheritancehierarchy.gif?imageMogr2/2/w/800\"></p>\n<h3 id=\"PDFView-Class\"><a href=\"#PDFView-Class\" class=\"headerlink\" title=\"PDFView Class\"></a>PDFView Class</h3><p><code>PDFView类</code>，就好比Web工具包的<code>WebView类</code>，源于<code>Application Kit</code>中的<code>NSView类</code>。在项目开发中，你可以使用<code>Interface Builder</code>轻松拖动一个<code>PDFView对象</code>放在一个window中。<del>从/Developer/Extras/Palettes/PDFKit.palette得到调色板。</del><br><code>PDFView</code>可能是<code>PDF Kit</code>中唯一个需要你自定义的的类。在APP中显示PDF数据，允许用户选择文档内容和导航浏览PDF文档，设置缩放级别，复制文本内容到剪贴板。用户可以拖放PDF文档到<code>PDFView</code>。<br><code>PDFView</code>能通过调用其他<code>PDF实用类</code>来实现其大部分功能。如果要添加特殊功能，则需要用户自定义<code>实用类</code>的子类来扩展其特殊功能。<br>Utility classes as used by PDFView<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/pdfkit_uses_hierarchy.gif?imageMogr2/2/w/800\"></p>\n<h3 id=\"PDF-Kit-Utility-Classes\"><a href=\"#PDF-Kit-Utility-Classes\" class=\"headerlink\" title=\"PDF Kit Utility Classes\"></a>PDF Kit Utility Classes</h3><p>PDF套件工具类提供一种混合的<code>Foundation-like</code>和<code>Application Kit-like</code>的行为。他们有类似的<code>NSString类</code>和<code>NSString Additions</code>方法。这些类都系橙自<code>NSObject</code><br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/pdfkit_inheritancehierarchy.gif?imageMogr2/2/w/800\"></p>\n<h4 id=\"PDF-Document\"><a href=\"#PDF-Document\" class=\"headerlink\" title=\"PDF Document\"></a>PDF Document</h4><p><code>PDFDocument</code>是<code>PDF kit工具类</code>中重要类，代表着PDF data或PDF文件。其他实用工具类一般都在<code>PDFDocument</code>方法中的实例化。是<code>PDFPage</code>和<code>PDFOutline</code>；或相关支持操作：<code>PDFSelection</code>和<code>PDFDestination</code>。<br>你<code>PDFDocument对象</code>初始化，需要一个<code>PDF数据</code>或一个指向PDF文件的<code>URL</code>。实例化之后就可以访问<code>页数</code>，<code>添加</code>或<code>删除</code>页面，对所选内容为<code>NSString对象</code>进行<code>查找</code>或<code>分析</code>。</p>\n<h4 id=\"PDFPage\"><a href=\"#PDFPage\" class=\"headerlink\" title=\"PDFPage\"></a>PDFPage</h4><p><code>PDFPage</code>代表一个PDF文档的页面。你的应用程序获取一个<code>PDFPage</code>对象必须通过从<code>PDFDocument</code>对象来实例化。<code>PDFPage</code>对象是用户所看到的屏幕，和一个<code>view</code>可以同时显示多个<code>page</code>。你可以使用<code>PDFPage</code>把PDF文档内容渲染到屏幕上，添加<code>注释</code>，<code>计数字符串</code>，定义<code>选择</code>，获取一个<code>page</code>中的文本内容作为<code>NSString对象</code>或<code>NSAttributedString对象</code>。</p>\n<h4 id=\"PDFOutline\"><a href=\"#PDFOutline\" class=\"headerlink\" title=\"PDFOutline\"></a>PDFOutline</h4><p>除了显示实际的文件内容，<code>PDF Kit</code>也能呈现<code>PDFOutline</code>信息，前提是PDF文档中存在目录结构。在目录结构中，一个<code>PDFOutline对象</code>代表一个<code>父目录</code>或<code>子目录</code>。<br>目录是由一个层次的<code>PDFOutline对象</code>组层。顶层是<code>根目录对象</code>，它仅作为其他目录对象的容器。用户的<code>根目录</code>是不可见的。</p>\n<h4 id=\"PDFSelection\"><a href=\"#PDFSelection\" class=\"headerlink\" title=\"PDFSelection\"></a>PDFSelection</h4><p>一个<code>PDFSelection</code>对象包含一个跨PDF文档中文本。你不要直接创建<code>PDFSelection</code>。<code>PDFSelection</code>对象是作为返回值来实例化的。例如：通过调用<code>PDFPage</code>或<code>PDFDocument</code>对象中的selection方法，并从成功搜索的返回值来实例化<code>PDFSelection</code>对象。<br>在同时显示多个<code>PDFPage</code>的<code>PDFView</code>中，<code>PDFSelection</code>可以是不连续的，或两者兼具的。例如，可以选择在一个单柱连续两列页面的文本。可以在任何方向从一个选择区, 合并选择区, 或扩展选择区中得到文本和网页覆盖。</p>\n<h4 id=\"PDFAnnotation\"><a href=\"#PDFAnnotation\" class=\"headerlink\" title=\"PDFAnnotation\"></a>PDFAnnotation</h4><p>一个<code>PDFAnnotation</code>对象可以表示多种内容以外，在一个PDF文件的主要文本内容：链接、表单元素，突出圈子，等等。每个注释与页面上的特定位置相关，并且可以与用户提供交互性。<br><code>PDFAnnotation</code>是如图所示的具体类的抽象类。各种具体类代表<code>PDF Kit</code>支持的注释类型。<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/annotations.gif?imageMogr2/2/w/800\"></p>\n<h4 id=\"PDFBorder\"><a href=\"#PDFBorder\" class=\"headerlink\" title=\"PDFBorder\"></a>PDFBorder</h4><p><code>PDFBorder</code>对象封装的拉伸<code>PDFAnnotation</code>对象边框的行为。可以定义一个PDF的bord线的风格属性（例如，固体，破灭，或斜面），bord线的宽度，和圆角半径。</p>\n<p>过期:<del>从/Developer/Extras/Palettes/PDFKit.palette得到调色板。</del><br>Here’s what Apple says about it:<br><blockquote><p>“To add the PDFKit palette in Interface Builder, select the Palettes tab in the Preferences panel. Click the Add<br>button, navigate to the /Developer/Extras/Palettes folder, and select the PDFKit palette. Next, select the Customize Toolbar menu item in the Tools/Palettes menu and drag the PDFKit palette to the toolbar to make it visible.”</p>\n<footer><strong>老文档</strong><cite><a href=\"http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Conceptual/PDFKitGuide/PDFKit_Prog_Tasks/PDFKit_Prog_Tasks.html\" target=\"_blank\" rel=\"noopener\">PDFKit_Prog_Tasks</a></cite></footer></blockquote><br>So:<br>there’s no Palettes tab anywhere in the Preferences panel and the Xcode Help return a blank when searching for it.<br>There’s no PDFKit.palette file anywhere on my HD (says Spotlight).<br>I guess these instructions are for an older version of XCode but it’s all Apple seemed to have on it…</p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"PDF","path":"api/categories/PDF.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"},{"name":"UI","path":"api/tags/UI.json"},{"name":"PDF","path":"api/tags/PDF.json"},{"name":"阅读器","path":"api/tags/阅读器.json"}]},{"title":"Fabric对macOS系统的支持","slug":"macOS/Fabric对macOS系统的支持调研","date":"2017-02-14T11:14:35.000Z","updated":"2017-02-14T14:33:17.000Z","comments":true,"path":"api/articles/macOS/Fabric对macOS系统的支持调研.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"Fabric\"><a href=\"#Fabric\" class=\"headerlink\" title=\"Fabric\"></a>Fabric</h2><p><code>Fabric</code> 是Twitter的移动应用开发平台，一个模块化、跨平台的移动开发套件，该博文主要研究<code>crashlytics</code>在app中的运用。<br><a href=\"https://try.crashlytics.com/\" target=\"_blank\" rel=\"noopener\">注册新的账户</a>登录，审核通过时间为几个小时或者1到2天不等。然后注册时候输入的邮箱就会收到如下的邀请涵<br><a href=\"https://docs.fabric.io/apple/crashlytics/os-x.html#macos-support\" target=\"_blank\" rel=\"noopener\">浏览官方文档</a></p>\n<h3 id=\"crashlytics支持macOS\"><a href=\"#crashlytics支持macOS\" class=\"headerlink\" title=\"crashlytics支持macOS\"></a>crashlytics支持macOS</h3><p>对<code>macOS</code>的支持中出现的问题<br>问题：<code>NSApplicationCrashOnExceptions</code> is not set. This will result in poor <code>top-level</code> uncaught exception reporting<br>官方解释：<br><blockquote><p>Uncaught Exceptions<br>Intercepting and reporting uncaught exceptions on macOS is more complex than it is on iOS. On macOS, AppKit will catch exceptions thrown on the main thread, preventing the application from crashing, but also preventing Crashlytics from reporting them. To make matters worse, Apple’s frameworks are not exception safe. This means that while AppKit will prevent your app from crashing, it will also likely corrupt your process’s state, often including AppKit itself. Typically, once an exception involving UI interaction is thrown, it will prevent your app from working correctly from that moment on.<br>Thankfully, AppKit has a little-known feature you can turn on to make the behavior much more predictable. We strongly recommend that you do the following in your application, right before you initialize Crashlytics.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] registerDefaults:@&#123; <span class=\"string\">@”NSApplicationCrashOnExceptions”</span>: @YES &#125;];</span><br></pre></td></tr></table></figure>\n\n<p>This will make your application’s behavior much closer to iOS. It will mean that your app will crash on uncaught exceptions, and will also allow Crashlytics to report them with useful stack traces. It will also give you the ability to override this behavior with the user defaults system, even on per-user basis.<br>Of course, this is all optional. Crashlytics will warn about NSApplicationCrashOnExceptions not being set, but will otherwise preserve normal AppKit behavior by default.</p>\n<footer><strong>官方文档</strong><cite><a href=\"https://docs.fabric.io/apple/crashlytics/os-x.html#macos-support\" target=\"_blank\" rel=\"noopener\">macOS Support</a></cite></footer></blockquote><br>拦截和报告未捕获的异常在MacOS比iOS更复杂。在MacOS，AppKit会抓住扔在主线程异常，防止应用程序崩溃，也防止crashlytics报告他们。更糟糕的是，Apple’s frameworks也不例外。这意味着AppKit可以防止你的应用程序崩溃，也可能破坏你的进程的状态，包括AppKit本身。通常情况下，一旦涉及到用户界面交互的异常被抛出，它将阻止您的应用程序从正确的工作从那一刻起。<br>以上情况，可以通过设置：<code>NSApplicationCrashOnExceptions</code> 改变系统默认的值，达到像iOS端一样抓去异常。如果没有设置会提示：NSApplicationCrashOnExceptions not set</p>\n<h3 id=\"Cause-a-Test-Crash教程\"><a href=\"#Cause-a-Test-Crash教程\" class=\"headerlink\" title=\"Cause a Test Crash教程\"></a><a href=\"https://docs.fabric.io/apple/crashlytics/test-crash.html\" target=\"_blank\" rel=\"noopener\">Cause a Test Crash教程</a></h3><p>崩溃日志是在重启APP程序的同时进行的，要确保程序在前台全屏显示。<br>Xcode调试器会阻止我们捕捉崩溃报告，所以在抓取崩溃报告时，要保证在非调试状态下进行。如果你的移动设备连接到Mac机上，Xcode仍然可以进入调试状态。</p>\n<ol>\n<li><code>run</code>在模拟器上安装运行APP</li>\n<li>点击<code>Stop</code>断开Xcode和模拟器，确保在非调试状态</li>\n<li>在模拟器上启动APP，并执行崩溃操作</li>\n<li>在Xcode上点击<code>run</code><br>在Xcode的控制台console中输出显示奔溃报告，以及上传日志的相关提示。<br>macOS系统中的日志目录：<br>运行日志目录：/private/var/log/system.log<br>奔溃日志目录：/Users/pyc/Library/Logs/DiagnosticReports/APPNAME_2016-11-10-165115.crash</li>\n</ol>\n<blockquote><p>It’s possible, but rare, that we are missing a dSYM to symbolicate any crash reports. There will be an alert on your dashboard if this is the case. Click through to upload the missing dSYM. Keep in mind that exceptions are not guaranteed to crash. The full code path, including code in system libraries, matters here. If you aren’t seeing the dSYM alert, you can go to your app’s settings page, and append “/mappings” to the URL to reach it, e.g. <a href=\"https://fabric.io/settings/apps/some_app_id/mappings\" target=\"_blank\" rel=\"noopener\">https://fabric.io/settings/apps/some_app_id/mappings</a></p>\n<footer><strong>官方文档</strong><cite><a href=\"https://docs.fabric.io/apple/crashlytics/test-crash.html\" target=\"_blank\" rel=\"noopener\">Cause a Test Crash教程</a></cite></footer></blockquote>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"调试","path":"api/categories/调试.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"SDK","path":"api/tags/SDK.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"发布","path":"api/tags/发布.json"},{"name":"macOS","path":"api/tags/macOS.json"}]},{"title":"bilibiliForMac版之mpv依赖编译","slug":"编译/bilibili之Mac版ffmpeg依赖编译","date":"2017-02-10T10:45:03.000Z","updated":"2017-05-26T18:13:12.000Z","comments":true,"path":"api/articles/编译/bilibili之Mac版ffmpeg依赖编译.json","excerpt":null,"keywords":null,"cover":"https://cloud.githubusercontent.com/assets/4022953/16513398/fba07b2a-3f96-11e6-8358-b93275ed0a09.png","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"Bilibili-Mac-Client\"><a href=\"#Bilibili-Mac-Client\" class=\"headerlink\" title=\"Bilibili Mac Client\"></a><a href=\"https://github.com/typcn/bilibili-mac-client\" target=\"_blank\" rel=\"noopener\">Bilibili Mac Client</a></h2><p>一款基于mpv和ffmpeg底层库实现的播放器.</p>\n<h2 id=\"项目依赖库\"><a href=\"#项目依赖库\" class=\"headerlink\" title=\"项目依赖库\"></a>项目依赖库</h2><p>编译在项目中所需的相关依赖库</p>\n<h3 id=\"下载资源\"><a href=\"#下载资源\" class=\"headerlink\" title=\"下载资源\"></a>下载资源</h3><ol>\n<li><p>下载mpv-build</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/mpv-player/mpv-build.git</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行下载<code>ffmpeg</code>, <code>libass</code> 和<code>mpv资源</code>，同时完成编译的命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> mpv-build/ </span><br><span class=\"line\">./rebuild -j4  </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用参数 “–enable-shared ” 可以开启 ffmpeg 的动态版本:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ffmpeg/</span><br><span class=\"line\">./configure --<span class=\"built_in\">enable</span>-shared    </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装ffmpeg</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在ffmpeg目录下执行：</span><br><span class=\"line\">make </span><br><span class=\"line\">make install</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"开始编译mpv动态依赖库：\"><a href=\"#开始编译mpv动态依赖库：\" class=\"headerlink\" title=\"开始编译mpv动态依赖库：\"></a>开始编译mpv动态依赖库：</h3><ol>\n<li>开启libmpv动态库的支持：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ../mpv/</span><br><span class=\"line\">./waf configure --<span class=\"built_in\">enable</span>-libmpv-shared  --<span class=\"built_in\">disable</span>-libass</span><br><span class=\"line\">./waf build</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>变更去除static参数：./waf configure –enable-static-build –enable-libmpv-shared  –disable-libass</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"集成到项目中\"><a href=\"#集成到项目中\" class=\"headerlink\" title=\"集成到项目中\"></a>集成到项目中</h2><h3 id=\"指定libmpv-dylib相对路径\"><a href=\"#指定libmpv-dylib相对路径\" class=\"headerlink\" title=\"指定libmpv.dylib相对路径\"></a>指定libmpv.dylib相对路径</h3><p>直接编译出来的库会是绝对路径，需要先通过install_name_tool 修改 相对路径：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd build/</span><br><span class=\"line\">install_name_tool -id \"@executable_path/lib/libmpv.dylib\" libmpv.dylib</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"聚合ffmpeg相关依赖包\"><a href=\"#聚合ffmpeg相关依赖包\" class=\"headerlink\" title=\"聚合ffmpeg相关依赖包\"></a>聚合ffmpeg相关依赖包</h3><p>执行 mpv<code>tools/dylib-unhell</code> ，目标是 <code>libmpv.dylib</code><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TOOLS/dylib-unhell.py libmpv.dylib</span><br></pre></td></tr></table></figure><br>这样会多出一个 <code>lib文件夹</code>，里面会出现变为相对路径的文件，复制导入到项目即可。</p>\n<h2 id=\"相对路径脚本学习\"><a href=\"#相对路径脚本学习\" class=\"headerlink\" title=\"相对路径脚本学习\"></a>相对路径脚本学习</h2><p>使用otool -L 和install_name_tool完成了一系列操作：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">install_name_tool -change</span><br><span class=\"line\">install_name_tool -id </span><br></pre></td></tr></table></figure><br><img src=\"https://cloud.githubusercontent.com/assets/4022953/16513398/fba07b2a-3f96-11e6-8358-b93275ed0a09.png\" alt=\"编译后的资源目录位置\"></p>\n<h3 id=\"扩展一：\"><a href=\"#扩展一：\" class=\"headerlink\" title=\"扩展一：\"></a>扩展一：</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!bin/sh</span></span><br><span class=\"line\">mkdir \"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/dylib\"</span><br><span class=\"line\">cp -f /your/path/to/xcode_project_name/dylib/*.dylib \"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/dylib/\"</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"--------$(pwd)----------------\"</span><br><span class=\"line\">cur_dir=\"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/MacOS/lib\"</span><br><span class=\"line\">cd $&#123;cur_dir&#125;</span><br><span class=\"line\">echo \"--进入$(pwd)--\"</span><br><span class=\"line\"></span><br><span class=\"line\">for dirlist in $(ls $&#123;cur_dir&#125;)</span><br><span class=\"line\">    #查看它们的 rpath</span><br><span class=\"line\">    otool -L $&#123;dirlist&#125;</span><br><span class=\"line\">    #制作相对路径</span><br><span class=\"line\">    #方法一</span><br><span class=\"line\">    install_name_tool -change /usr/local/lib/$&#123;dirlist&#125; @executable_path/lib/$&#123;dirlist&#125; \"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/MacOS/$PRODUCT_NAME\"</span><br><span class=\"line\">    #方法二</span><br><span class=\"line\">    install_name_tool -id \"@executable_path/lib/$&#123;dirlist&#125;\" $&#123;dirlist&#125;</span><br><span class=\"line\">do</span><br><span class=\"line\"></span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"扩展二\"><a href=\"#扩展二\" class=\"headerlink\" title=\"扩展二\"></a>扩展二</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo \"--------$(pwd)----------------\"</span><br><span class=\"line\">cur_dir=\"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/MacOS/lib\"</span><br><span class=\"line\">cd $&#123;cur_dir&#125;</span><br><span class=\"line\">echo \"--进入$(pwd)--\"</span><br><span class=\"line\">lib=\"libmediainfo.0.dylib\"</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">-f 参数判断 <span class=\"variable\">$file</span> 是否存在</span></span><br><span class=\"line\">if [ -f \"$lib\" ]; then</span><br><span class=\"line\">    otool -L $&#123;lib&#125;</span><br><span class=\"line\">    install_name_tool -id \"@executable_path/lib/$&#123;lib&#125;\" $&#123;lib&#125;</span><br><span class=\"line\">    otool -L $&#123;lib&#125;</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"视频","path":"api/categories/视频.json"}],"tags":[{"name":"shell","path":"api/tags/shell.json"},{"name":"编译","path":"api/tags/编译.json"},{"name":"ffmpeg","path":"api/tags/ffmpeg.json"},{"name":"mpv","path":"api/tags/mpv.json"}]},{"title":"OSX 应用插件","slug":"macOS/OSX应用插件开发","date":"2017-02-07T12:38:58.000Z","updated":"2017-02-07T13:47:53.000Z","comments":true,"path":"api/articles/macOS/OSX应用插件开发.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/xcode8.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>在以前的 OS X 系统中，给你的 App 在运行时动态载入可执行代码比较困难。现在可以通过<code>NSBundle</code>和 <code>plug-ins</code>插件,可以很方便的向原有APP中添加新功能点。</p>\n<p>目的：在一个修改过的 TextEdit 里面加入加载 bundle 的功能</p>\n<h2 id=\"包-Bundles-和接口-Interfaces\"><a href=\"#包-Bundles-和接口-Interfaces\" class=\"headerlink\" title=\"包 (Bundles) 和接口 (Interfaces)\"></a>包 (Bundles) 和接口 (Interfaces)</h2><p>如果你打开 Xcode8 创建一个新项目，会看见 OS X 所有可以编写APP插件的模版，例如： <code>Screen Savers</code> 到 <code>Image Units</code>等。<br>在<code>Framework &amp; Library</code>中的 <code>Bundle</code> 条目。我会在今天探索一个非常简单的的项目，那就是在一个修改过的 TextEdit 里面加入加载 bundle 的功能。<br><img title=\"项目模版\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcode8.png?imageMogr2/2/w/800\"><br><code>bundle 模版</code>项目与APP项目比较：</p>\n<ol>\n<li>一个 <code>Contents</code> 目录，里面包含了 <code>Info.plist</code> 和 <code>Resource</code> 目录。</li>\n<li>如果你在你的项目下加入了新的类，你可以看见包含一个可执行文件的 <code>MacOS</code> 目录。</li>\n<li><code>Bundle</code> 工程里缺少的一个东西是 <code>main()</code> 函数。它是被宿主<code>App</code> 调用执行的。</li>\n</ol>\n<h2 id=\"为-TextEdit-加入-Plugin-支持\"><a href=\"#为-TextEdit-加入-Plugin-支持\" class=\"headerlink\" title=\"为 TextEdit 加入 Plugin 支持\"></a>为 TextEdit 加入 Plugin 支持</h2><p>两种插件的方式:<br>    第一个:用最少的工作来为你的 app 加入插件支持，希望让你知道实现这个有多简单。<br>    第二个:技术有点复杂，它展现来一个为你的 app 加入插件的合理的方式，这可以使你不会在未来陷入到被锁死在某一种实现的窘境中。<br>本文章的项目文件仍然会放在 <a href=\"https://github.com/objcio/issue-14-plugins\" target=\"_blank\" rel=\"noopener\">GitHub</a> 供大家参考。</p>\n<h3 id=\"在-TextEdit-中扫描-Bundle\"><a href=\"#在-TextEdit-中扫描-Bundle\" class=\"headerlink\" title=\"在 TextEdit 中扫描 Bundle\"></a>在 TextEdit 中扫描 Bundle</h3><p>请打开 “01 TextEdit” 目录下面的 <code>TextEdit.xcodeproj</code> 工程，同时浏览它里面包含的代码。<br><code>TextEdit</code> 里面有三个简单的组成部分：扫描 <code>bundle</code>，加载 <code>bundle</code>，调用 <code>bundle 的 UI</code><br><code>loadPlugins</code> 方法：<br>打开 <code>Controller.m</code>，你可以看见 <code>-(void)loadPlugins</code> 方法 (它在 <code>applicationDidFinishLaunching:</code> 中被调用)。</p>\n<ol>\n<li>扩展插件菜单：在界面菜单右侧加入了一个新的 <code>NSMenuItem</code>，为调用插件提供一个入口（通常你会在 <code>MainMenu.xib</code> 做这件事情并且链接 <code>outlets</code>，但是我们这次偷下懒）。</li>\n<li>扫描插件目录：获得插件目录（在 <code>~/Library/Application Support/Text Edit/Plug-Ins/</code> ）下，并且扫描这个目录。<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *pluginsFolder = [<span class=\"keyword\">self</span> pluginsFolder];</span><br><span class=\"line\"><span class=\"built_in\">NSFileManager</span> *fm = [<span class=\"built_in\">NSFileManager</span> defaultManager];</span><br><span class=\"line\"><span class=\"built_in\">NSError</span> *outErr;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *item <span class=\"keyword\">in</span> [fm contentsOfDirectoryAtPath:pluginsFolder error:&amp;outErr]) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (![item hasSuffix:<span class=\"string\">@\".bundle\"</span>])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *bundlePath = [pluginsFolder stringByAppendingPathComponent:item];</span><br><span class=\"line\">    <span class=\"built_in\">NSBundle</span> *b = [<span class=\"built_in\">NSBundle</span> bundleWithPath:bundlePath];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!b) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Could not make a bundle from %@\"</span>, bundlePath);</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取实现插件代理协议方法的类</span></span><br><span class=\"line\">    <span class=\"keyword\">id</span> &lt;TextEditPlugin&gt; plugin = [[b principalClass] new];</span><br><span class=\"line\">    <span class=\"built_in\">NSMenuItem</span> *item = [pluginsMenu addItemWithTitle:[plugin menuItemTitle] action:<span class=\"keyword\">@selector</span>(pluginMenuItemCalledAction:) keyEquivalent:<span class=\"string\">@\"\"</span>];</span><br><span class=\"line\">    [item setRepresentedObject:plugin];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：扫描插件目录，确保得到的是一个 <code>.bundle</code> 文件，然后用 <code>NSBundle</code> 载入你找到的 <code>bundle</code> 并且实例化里面的类。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"插件代理\"><a href=\"#插件代理\" class=\"headerlink\" title=\"插件代理\"></a>插件代理</h3><p>你会注意到一个 <code>TextEditPlugin</code> 的 <code>protocol</code> 的引用。在 <code>TextEditMisc.h</code> 能找它的定义:<br><figure class=\"highlight objc\"><figcaption><span>声明代理协议</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">TextEditPlugin</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span>*)menuItemTitle;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)actionCalledWithTextView:(<span class=\"built_in\">NSTextView</span>*)textView inDocument:(<span class=\"keyword\">id</span>)document;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure><br>这说明你实例化的类需要响应这两个方法。你可以验证这个类是否响应这两个方法。</p>\n<h3 id=\"NSPrincipalClass键-值–实现插件代理协议方法的类名称\"><a href=\"#NSPrincipalClass键-值–实现插件代理协议方法的类名称\" class=\"headerlink\" title=\"NSPrincipalClass键:值–实现插件代理协议方法的类名称\"></a>NSPrincipalClass键:值–实现插件代理协议方法的类名称</h3><p>在 <code>bundle</code> 里面调用的 <code>principalClass</code> 方法是什么呢？<br>当你创建一个 <code>Bundle</code> 的时候，你可以在里面创建一个或者多个类，同时你需要让 <code>TextEdit</code> 知道哪一个类需要被实例化。为了帮助宿主 App 调用，你可以在 <code>Info.plist</code> 文件加入一个 <code>NSPrincipalClass</code> 的键，同时设置它的值为实现插件方法的类的名字。你可以用 <code>[NSBundle principalClass]</code> 方便地从 <code>NSPrincipalClass</code> 的值里面寻找并创建这个类。</p>\n<h3 id=\"添加扩展插件菜单的响应事件\"><a href=\"#添加扩展插件菜单的响应事件\" class=\"headerlink\" title=\"添加扩展插件菜单的响应事件\"></a>添加扩展插件菜单的响应事件</h3><p>在 <code>Plug-Ins</code> 菜单加入一个新的按钮，设置 <code>action</code> 为 <code>pluginMenuItemCalledAction:</code>，并且设置它表示你已经实例化的对象。</p>\n<blockquote>\n<p>如果在 <code>menu item</code> 里面没有设置一个<code>target</code>，即目标是<code>nil</code>，那么它会寻找响应链，来寻找第一个实现 <code>pluginMenuItemCalledAction:</code> 方法的对象。如果它找不到，那么这个菜单选项将会不能用。<br>举一个例子，实现 <code>pluginMenuItemCalledAction</code> 的最好的地方是在 <code>Document</code> 的 <code>window controller</code> 类中。打开 <code>DocumentWindowController.m</code>，然后定位到<code>pluginMenuItemCalledAction</code><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)pluginMenuItemCalledAction:(<span class=\"keyword\">id</span>)sender </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">id</span> &lt;TextEditPlugin&gt;plugin = [sender representedObject];</span><br><span class=\"line\">    [plugin actionCalledWithTextView:[<span class=\"keyword\">self</span> firstTextView] inDocument:[<span class=\"keyword\">self</span> document]];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>代码本身很清晰，搜集插件实例，调用 <code>actionCalledWithTextView:inDocument:</code> 方法（被定义在 <code>protocol</code> 里面的），运行你插件里面的代码。</p>\n<h2 id=\"制作插件\"><a href=\"#制作插件\" class=\"headerlink\" title=\"制作插件\"></a>制作插件</h2><ol>\n<li>新建模版项目<br>打开 “01 MarkYellow” 工程看一下。这是一个 Xcode (通过<code>OS X ▸ Framework &amp; Library ▸ Bundle template</code> 建立) 的标准工程，里面只添加了一个类：<code>TEMarkYellow</code>。</li>\n<li>设置NSPrincipalClass键值<br>如果你打开<code>MarkYellow-Info.plist</code>，你可以看到 <code>NSPrincipalClass</code> 的值设置成了上面提到的 <code>TEMarkYellow</code>。</li>\n<li>实现协议代理<br>接着，打开 <code>TEMarkYellow.m</code>，你将会看见定义在协议里面的方法。<ul>\n<li>第一个方法（<code>menuItemTitle</code>）返回插件的名字，最为入口名显示在 <code>menu</code> 里面。</li>\n<li>第二个方法 (<code>actionCalledWithTextView:inDocument:</code>)，把所有选中的文字变成黄色的背景。<figure class=\"highlight objc\"><figcaption><span>改变字体颜色</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)actionCalledWithTextView:(<span class=\"built_in\">NSTextView</span>*)textView inDocument:(<span class=\"keyword\">id</span>)document </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([textView selectedRange].length) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableAttributedString</span> *ats = [[[textView textStorage] attributedSubstringFromRange:[textView selectedRange]] mutableCopy];</span><br><span class=\"line\">        [ats addAttribute:<span class=\"built_in\">NSBackgroundColorAttributeName</span> value:[<span class=\"built_in\">NSColor</span> yellowColor] range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, [ats length])];</span><br><span class=\"line\">        <span class=\"comment\">//  先测试text view是否能改变文字内容，这样可以自动做正确的撤销操作。</span></span><br><span class=\"line\">        By asking the text view <span class=\"keyword\">if</span> you can change the text first, it will automatically <span class=\"keyword\">do</span> the right thing to enable undoing of attribute changes</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([textView shouldChangeTextInRange:[textView selectedRange] replacementString:[ats string]])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            [[textView textStorage] replaceCharactersInRange:[textView selectedRange] withAttributedString:ats];</span><br><span class=\"line\">            [textView didChangeText];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"集成插件\"><a href=\"#集成插件\" class=\"headerlink\" title=\"集成插件\"></a>集成插件</h2><p>运行 <code>TextEdit</code> （它会创建<code>Plug-Ins</code>目录），然后构建 <code>MarkYellow</code> 工程。把 <code>MarkYellow.bundle</code> 丢到你的 <code>~/Library/Application Support/Text Edit/Plug-Ins/</code> 目录下面，重启你的 <code>TextEdit</code> 应用。<br>一切看起来都很好，扫描，加载，插入一个菜单，然后，当你使用菜单项的时候，传递到参数到插件里面。试一试，点击 <code>Plug-Ins ▸ Mark Selected Text Yellow</code>，选择的文字的背景颜色就变成黄色的了。</p>\n<h2 id=\"XCode8版本问题\"><a href=\"#XCode8版本问题\" class=\"headerlink\" title=\"XCode8版本问题\"></a>XCode8版本问题</h2><p>Xcode8 不再支持<code>Application Plug-in</code>插件<br><img title=\"项目创建模版\" src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/xcode6.jpg?imageMogr2/2/w/800\"><br><a href=\"http://www.jianshu.com/p/39443429f71d\" target=\"_blank\" rel=\"noopener\">XCode8.2.1继续使用xcode插件</a><br>这个是因为苹果解决xcode ghost，把插件屏蔽了。<br>解决方法<br><code>sudo /usr/libexec/xpccachectl</code><br>然后必须重启电脑后生效.</p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"}],"tags":[{"name":"macOS","path":"api/tags/macOS.json"},{"name":"插件","path":"api/tags/插件.json"},{"name":"objc","path":"api/tags/objc.json"}]}]}