{"title":"常见的后台实现","slug":"iOS/常见的后台实现","date":"2017-09-24T11:03:35.000Z","updated":"2017-09-24T11:03:35.000Z","comments":true,"path":"api/articles/iOS/常见的后台实现.json","excerpt":null,"covers":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h2><p>本文主要探讨一些常用后台任务的最佳实践：</p>\n<ol>\n<li>如何做异步网络请求</li>\n<li>如何异步处理大型文件，以保持较低的内存占用</li>\n</ol>\n<h3 id=\"操作队列-Operation-Queues-还是-GCD\"><a href=\"#操作队列-Operation-Queues-还是-GCD\" class=\"headerlink\" title=\"操作队列 (Operation Queues) 还是 GCD ?\"></a>操作队列 (Operation Queues) 还是 GCD ?</h3><p>操作队列提供了在 GCD 中不那么容易复制的有用特性。其中最重要的一个就是可以取消在任务处理队列中的任务，而且操作队列在管理操作间的依赖关系方面也容易一些。<br>GCD 给予你更多的控制权力以及操作队列中所不能使用的底层函数。详细介绍可以参考<a href=\"http://www.objccn.io/issue-2-3/\" target=\"_blank\" rel=\"noopener\">底层并发 API</a> 这篇文章。</p>\n<h2 id=\"后台-UI-代码\"><a href=\"#后台-UI-代码\" class=\"headerlink\" title=\"后台 UI 代码\"></a>后台 UI 代码</h2><p>首先要强调：UIKit 只能在主线程上运行。而那部分不与 UIKit 直接相关，却会消耗大量时间的 UI 代码可以被移动到后台去处理，以避免其将主线程阻塞太久。</p>\n<h3 id=\"后台获取UI数据\"><a href=\"#后台获取UI数据\" class=\"headerlink\" title=\"后台获取UI数据\"></a>后台获取UI数据</h3><p>例如使用操作队列隔离以下昂贵操作：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">id</span> weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.operationQueue addOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSNumber</span>* result = findLargestMersennePrime();</span><br><span class=\"line\">    [[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class=\"line\">        MyClass* strongSelf = weakSelf;</span><br><span class=\"line\">        strongSelf.textLabel.text = [result stringValue];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></p>\n<p>如你所见，这些代码其实一点也不直接明了。我们首先声明了一个 weak 引用来参照 self，否则会形成循环引用（ block 持有了 self，私有的 <code>operationQueue</code> retain 了 block，而 self 又 retain 了 <code>operationQueue</code> ）。为了避免在运行 block 时访问到已被释放的对象，在 block 中我们又需要将其转回 strong 引用。</p>\n<blockquote>\n<p>这在 ARC 和 block 主导的编程范式中是解决 retain cycle 的一种常见也是最标准的方法。</p>\n</blockquote>\n<h3 id=\"后台绘制UI\"><a href=\"#后台绘制UI\" class=\"headerlink\" title=\"后台绘制UI\"></a>后台绘制UI</h3><p>如果你确定 <code>drawRect:</code> 是你的应用的性能瓶颈，那么你可以将这些绘制代码放到后台去做。但是在你这样做之前，检查下看看是不是有其他方法来解决，比如、考虑使用 core animation layers 或者预先渲染图片而不去做 Core Graphics 绘制。</p>\n<p>如果你确实认为在后台执行绘制代码会是你的最好选择时再这么做。其实解决起来也很简单，把 <code>drawRect:</code> 中的代码放到一个后台操作中去做就可以了。然后将原本打算绘制的视图用一个 image view 来替换，等到操作执行完后再去更新。在绘制的方法中，使用 <code>UIGraphicsBeginImageContextWithOptions</code> 来取代 <code>UIGraphicsGetCurrentContext</code> ：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIGraphicsBeginImageContextWithOptions</span>(size, <span class=\"literal\">NO</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// drawing code here</span></span><br><span class=\"line\"><span class=\"built_in\">UIImage</span> *i = <span class=\"built_in\">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class=\"line\"><span class=\"built_in\">UIGraphicsEndImageContext</span>();</span><br><span class=\"line\"><span class=\"keyword\">return</span> i;</span><br></pre></td></tr></table></figure></p>\n<p>通过在第三个参数中传入 0 ，设备的主屏幕的 scale 将被自动传入，这将使图片在普通设备和 retina 屏幕上都有良好的表现。</p>\n<h4 id=\"cell在操作队列中异步绘制\"><a href=\"#cell在操作队列中异步绘制\" class=\"headerlink\" title=\"cell在操作队列中异步绘制\"></a>cell在操作队列中异步绘制</h4><p>如果你在 table view 或者是 collection view 的 cell 上做了自定义绘制的话，最好将它们放入 operation 的子类中去。你可以将它们添加到后台操作队列，也可以在用户将 cell 滚动出边界时的 <code>didEndDisplayingCell</code> 委托方法中进行取消。这些技巧都在 2012 年的WWDC <a href=\"https://developer.apple.com/videos/wwdc/2012/\" target=\"_blank\" rel=\"noopener\">Session 211 – Building Concurrent User Interfaces on iOS</a>中有详细阐述。</p>\n<h4 id=\"其他方案\"><a href=\"#其他方案\" class=\"headerlink\" title=\"其他方案\"></a>其他方案</h4><p>除了在后台自己调度绘制代码，以也可以试试看使用 <code>CALayer</code> 的 <code>drawsAsynchronously</code> 属性。然而你需要精心衡量这样做的效果，因为有时候它能使绘制加速，有时候却适得其反。</p>\n<h2 id=\"异步网络请求处理\"><a href=\"#异步网络请求处理\" class=\"headerlink\" title=\"异步网络请求处理\"></a>异步网络请求处理</h2><p>你的所有网络请求都应该采取异步的方式完成。</p>\n<p>然而，在 GCD 下，有时候你可能会看到这样的代码<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 警告：不要使用这些代码。</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(backgroundQueue, ^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSData</span>* contents = [<span class=\"built_in\">NSData</span> dataWithContentsOfURL:url]</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理取到的日期</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>乍看起来没什么问题，但是这段代码却有致命缺陷。你没有办法去取消这个同步的网络请求。它将阻塞主线程直到它完成。如果请求一直没结果，那就只能干等到超时（比如 <code>dataWithContentsOfURL:</code> 的超时时间是 30 秒）。</p>\n<h3 id=\"分析状况\"><a href=\"#分析状况\" class=\"headerlink\" title=\"分析状况\"></a>分析状况</h3><ol>\n<li>当队列是串行执行时，它将一直被阻塞住。</li>\n<li>当队列是并行执行时，GCD 需要重开一个线程来补凑你阻塞住的线程。</li>\n</ol>\n<p>两种结果都不太妙，所以最好还是不要阻塞线程。</p>\n<h3 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h3><p>要解决上面的困境，我们可以使用 <code>NSURLConnection</code> 的异步方法，并且把所有操作转化为 operation 来执行。通过这种方法，我们可以从操作队列的强大功能和便利中获益良多：我们能轻易地控制并发操作的数量，添加依赖，以及取消操作。<br>例如：在<code>NSOperation</code>子类<code>DownloadOperation</code>中重写<code>start</code>方法，并实现<code>NSURLConnectionDelegate</code>代理方法。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">DownloadOperation</span> : <span class=\"title\">NSOperation</span>&lt;<span class=\"title\">NSURLConnectionDelegate</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)start</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequest</span>* request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:<span class=\"keyword\">self</span>.url];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.isExecuting = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.isConcurrent = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.isFinished = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    [[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.connection = [<span class=\"built_in\">NSURLConnection</span> connectionWithRequest:request delegate:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然而，在这里还有一些事情值得注意： <code>NSURLConnection</code> 是通过 run loop 来发送事件的。因为发送事件不会花多少时间，因此最简单的是就只使用 main run loop 来做这个。然后，我们就可以用后台线程来处理输入的数据了。</p>\n<h3 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h3><p>另一种可能的方式是使用像 <a href=\"http://afnetworking.com\" target=\"_blank\" rel=\"noopener\">AFNetworking</a> 这样的框架：建立一个独立的线程，为建立的线程设置自己的 run loop，然后在其中调度 URL 连接。但是并不推荐你自己去实现这些事情。</p>\n<p>要处理URL 连接，我们重写自定义的 operation 子类中的 <code>start</code> 方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)start</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequest</span>* request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:<span class=\"keyword\">self</span>.url];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.isExecuting = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.isFinished = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    [[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.connection = [<span class=\"built_in\">NSURLConnectionconnectionWithRequest</span>:request</span><br><span class=\"line\">        delegate:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于重写的是 <code>start</code> 方法，所以我们需要自己要管理操作的 <code>isExecuting</code> 和 <code>isFinished</code> 状态。要取消一个操作，我们需要取消 connection ，并且设定合适的标记，这样操作队列才知道操作已经完成。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)cancel</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> cancel];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.connection cancel];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.isFinished = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.isExecuting = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当连接完成加载后，它向代理发送回调：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)connectionDidFinishLoading:(<span class=\"built_in\">NSURLConnection</span> *)connection</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.data = <span class=\"keyword\">self</span>.buffer;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.buffer = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.isExecuting = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.isFinished = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>就这么多了。完整的代码可以参见<a href=\"https://github.com/objcio/issue-2-background-networking\" target=\"_blank\" rel=\"noopener\">GitHub上的示例工程</a>。</p>\n<p>总结来说，我们建议要么你花时间来把事情做对做好，要么就直接使用像 <a href=\"http://afnetworking.com/\" target=\"_blank\" rel=\"noopener\">AFNetworking</a> 这样的框架。其实 <a href=\"http://afnetworking.com/\" target=\"_blank\" rel=\"noopener\">AFNetworking</a> 还提供了不少好用的小工具，比如有个 <code>UIImageView</code> 的 category，来负责异步地从一个 URL 加载图片。在你的 table view 里使用的话，还能自动帮你处理取消加载操作，非常方便。</p>\n<p>扩展阅读：</p>\n<ul>\n<li><a href=\"http://developer.apple.com/library/ios/#documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091-CH1-SW1\" target=\"_blank\" rel=\"noopener\">Concurrency Programming Guide</a></li>\n<li><a href=\"http://developer.apple.com/library/ios/#documentation/Cocoa/Reference/NSOperation_class/Reference/Reference.html%23http://developer.apple.com/library/ios/#documentation/Cocoa/Reference/NSOperation_class/Reference/Reference.html%23//apple_ref/doc/uid/TP40004591-RH2-SW15\" target=\"_blank\" rel=\"noopener\">NSOperation Class Reference: Concurrent vs. Non-Concurrent Operations</a></li>\n<li><a href=\"http://www.cocoaintheshell.com/2011/04/nsurlconnection-synchronous-asynchronous/\" target=\"_blank\" rel=\"noopener\">Blog: synchronous vs. asynchronous NSURLConnection</a></li>\n<li><a href=\"https://github.com/rs/SDWebImage/blob/master/SDWebImage/SDWebImageDownloaderOperation.m\" target=\"_blank\" rel=\"noopener\">GitHub: <code>SDWebImageDownloaderOperation.m</code></a></li>\n<li><a href=\"http://www.cocoaintheshell.com/2011/05/progressive-images-download-imageio/\" target=\"_blank\" rel=\"noopener\">Blog: Progressive image download with ImageIO</a></li>\n<li><a href=\"https://developer.apple.com/videos/wwdc/2012/\" target=\"_blank\" rel=\"noopener\">WWDC 2012 Session 211: Building Concurrent User Interfaces on iOS</a></li>\n</ul>\n<h2 id=\"进阶：后台文件-I-O\"><a href=\"#进阶：后台文件-I-O\" class=\"headerlink\" title=\"进阶：后台文件 I/O\"></a>进阶：后台文件 I/O</h2><p>构建一个类，负责一行一行读取文件而不是一次将整个文件读入内存，另外要在后台队列处理文件，以保持应用相应用户的操作。<br>为了达到这个目的，我们使用能让我们异步处理文件的 <code>NSInputStream</code> 。根据<a href=\"http://developer.apple.com/library/ios/#documentation/FileManagement/Conceptual/FileSystemProgrammingGUide/TechniquesforReadingandWritingCustomFiles/TechniquesforReadingandWritingCustomFiles.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>的描述：</p>\n<blockquote>\n<p>如果你总是需要从头到尾来读/写文件的话，streams 提供了一个简单的接口来异步完成这个操作</p>\n</blockquote>\n<p>不管你是否使用 streams，大体上逐行读取一个文件的模式是这样的：</p>\n<ol>\n<li>建立一个中间缓冲层以提供，当没有找到换行符号的时候可以向其中添加数据</li>\n<li>从 stream 中读取一块数据</li>\n<li>对于这块数据中发现的每一个换行符，取中间缓冲层，向其中添加数据，直到（并包括）这个换行符，并将其输出</li>\n<li>将剩余的字节添加到中间缓冲层去</li>\n<li>回到 2，直到 stream 关闭</li>\n</ol>\n<p>为了将其运用到实践中，我们又建立了一个<a href=\"https://github.com/objcio/issue-2-background-file-io\" target=\"_blank\" rel=\"noopener\">示例应用</a>，里面有一个 <code>Reader</code> 类完成了这件事情，它的接口十分简单<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Reader</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)enumerateLines:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSString</span>*))block completion:(<span class=\"keyword\">void</span> (^)())completion;</span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)initWithFileAtPath:(<span class=\"built_in\">NSString</span>*)path;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"runloop分发NSInputStream事件\"><a href=\"#runloop分发NSInputStream事件\" class=\"headerlink\" title=\"runloop分发NSInputStream事件\"></a>runloop分发NSInputStream事件</h4><p>注意，这个类不是 NSOperation 的子类。与 URL connections 类似，输入的 streams 通过 run loop 来传递它的事件。这里，我们仍然采用 main run loop 来分发事件，然后将数据处理过程派发至后台操作线程里去处理。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)enumerateLines:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSString</span>*))block</span><br><span class=\"line\">completion:(<span class=\"keyword\">void</span> (^)())completion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.queue == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.queue.maxConcurrentOperationCount = <span class=\"number\">1</span>;  <span class=\"comment\">//串行队列</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.callback = block;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.completion = completion;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.inputStream = [<span class=\"built_in\">NSInputStream</span> inputStreamWithURL:<span class=\"keyword\">self</span>.fileURL];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.inputStream.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    <span class=\"comment\">//分发NSInputStream事件</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.inputStream scheduleInRunLoop:[<span class=\"built_in\">NSRunLoop</span> currentRunLoop]</span><br><span class=\"line\">                                forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.inputStream open];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用时的代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)import:(<span class=\"keyword\">id</span>)sender</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> *fileURL = [[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"Clarissa Harlowe\"</span> withExtension:<span class=\"string\">@\"txt\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSAssert</span>([[<span class=\"built_in\">NSFileManager</span> defaultManager] fileExistsAtPath:[fileURL path]], <span class=\"string\">@\"Please download the sample data\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.reader = [[Reader alloc] initWithFileAtURL:fileURL];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.reader enumerateLinesWithBlock:^(<span class=\"built_in\">NSUInteger</span> i, <span class=\"built_in\">NSString</span> *line)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((i % <span class=\"number\">2000</span>ull) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"i: %d\"</span>, i);</span><br><span class=\"line\">        [[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span>.button setTitle:line forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; completionHandler:^(<span class=\"built_in\">NSUInteger</span> numberOfLines)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"lines: %d\"</span>, numberOfLines);</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.button setTitle:<span class=\"string\">@\"Done\"</span> forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"NSInputStream代理方法\"><a href=\"#NSInputStream代理方法\" class=\"headerlink\" title=\"NSInputStream代理方法\"></a>NSInputStream代理方法</h4><p>现在，input stream 将（在主线程）向我们发送代理消息，然后我们可以在操作队列中加入一个 block 操作来执行处理了：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)stream:(<span class=\"built_in\">NSStream</span>*)stream handleEvent:(<span class=\"built_in\">NSStreamEvent</span>)eventCode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (eventCode) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"built_in\">NSStreamEventHasBytesAvailable</span>: &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSMutableData</span> *buffer = [<span class=\"built_in\">NSMutableData</span> dataWithLength:<span class=\"number\">4</span> * <span class=\"number\">1024</span>];</span><br><span class=\"line\">            <span class=\"built_in\">NSUInteger</span> length = [<span class=\"keyword\">self</span>.inputStream read:[buffer mutableBytes]</span><br><span class=\"line\">                                             maxLength:[buffer length]];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"number\">0</span> &lt; length) &#123;</span><br><span class=\"line\">                [buffer setLength:length];</span><br><span class=\"line\">                __<span class=\"keyword\">weak</span> <span class=\"keyword\">id</span> weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">                [<span class=\"keyword\">self</span>.queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//在后台串行队列的线程池中逐行处理缓冲区</span></span><br><span class=\"line\">                    [weakSelf processDataChunk:buffer];</span><br><span class=\"line\">                &#125;];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"缓冲区处理\"><a href=\"#缓冲区处理\" class=\"headerlink\" title=\"缓冲区处理\"></a>缓冲区处理</h4><p>处理数据块的过程是先查看当前已缓冲的数据，并将新加入的数据附加上去。接下来它将按照换行符分解成小的部分，并逐行处理。<br>数据处理过程中会不断的从buffer中获取已读入的数据。然后把这些新读入的数据按行分开并存储。剩余的数据被再次存储到缓冲区中：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)processDataChunk:(<span class=\"built_in\">NSMutableData</span> *)buffer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.remainder != <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.remainder appendData:buffer];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.remainder = buffer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.remainder obj_enumerateComponentsSeparatedBy:<span class=\"keyword\">self</span>.delimiter</span><br><span class=\"line\">                            usingBlock:^(<span class=\"built_in\">NSData</span>* component, <span class=\"built_in\">BOOL</span> last) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!last) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span> emitLineWithData:component];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"number\">0</span> &lt; [component length]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.remainder = [component mutableCopy];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.remainder = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)emitLineWithData:(<span class=\"built_in\">NSData</span> *)data;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSUInteger</span> lineNumber = <span class=\"keyword\">self</span>.lineNumber;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.lineNumber = lineNumber + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">0</span> &lt; data.length) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> *line = [[<span class=\"built_in\">NSString</span> alloc] initWithData:data encoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.callback(lineNumber, line);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在你运行示例应用的话，会发现它在响应事件时非常迅速，内存的开销也保持很低（在我们测试时，不论读入的文件有多大，堆所占用的内存量始终低于 800KB）。绝大部分时候，使用逐块读入的方式来处理大文件，是非常有用的技术。</p>\n<p>延伸阅读：</p>\n<ul>\n<li><a href=\"http://developer.apple.com/library/ios/#documentation/FileManagement/Conceptual/FileSystemProgrammingGUide/TechniquesforReadingandWritingCustomFiles/TechniquesforReadingandWritingCustomFiles.html\" target=\"_blank\" rel=\"noopener\">File System Programming Guide: Techniques for Reading and Writing Files Without File Coordinators</a></li>\n<li><a href=\"http://stackoverflow.com/questions/3707427/how-to-read-data-from-nsfilehandle-line-by-line\" target=\"_blank\" rel=\"noopener\">StackOverflow: How to read data from NSFileHandle line by line?</a></li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过我们所列举的几个示例，我们展示了如何异步地在后台执行一些常见任务。在所有的解决方案中，我们尽力保持了代码的简单，这是因为在并发编程中，稍不留神就会捅出篓子来。</p>\n<p>很多时候为了避免麻烦，你可能更愿意在主线程中完成你的工作，在你能这么做事，这确实让你的工作轻松不少，但是当你发现性能瓶颈时，你可以尝试尽可能用最简单的策略将那些繁重任务放到后台去做。</p>\n<p>我们在上面例子中所展示的方法对于其他任务来说也是安全的选择。在主队列中接收事件或者数据，然后用后台操作队列来执行实际操作，然后回到主队列去传递结果，遵循这样的原则来编写尽量简单的并行代码，将是保证高效正确的不二法则。</p>\n<hr>\n<p><a href=\"http://objccn.io/issue-2\" target=\"_blank\" rel=\"noopener\">话题 #2 下的更多文章</a></p>\n<p>原文 <a href=\"http://www.objc.io/issue-2/common-background-practices.html\" target=\"_blank\" rel=\"noopener\">Common Background Practices</a></p>\n<p>译文 <a href=\"http://onevcat.com/2014/03/common-background-practices/\" target=\"_blank\" rel=\"noopener\">常见的后台实践</a></p>\n","categories":[{"name":"iOS","path":"api/categories/iOS.json"},{"name":"API","path":"api/categories/API.json"}],"tags":[]}