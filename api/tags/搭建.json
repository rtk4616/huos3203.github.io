{"name":"搭建","postlist":[{"title":"腾讯云docker服务器上部署jira系统","slug":"远程操作mysql数据库","date":"2017-05-24T17:07:47.000Z","updated":"2017-05-24T17:49:46.000Z","comments":true,"path":"api/articles/远程操作mysql数据库.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"腾讯云服务器\"><a href=\"#腾讯云服务器\" class=\"headerlink\" title=\"腾讯云服务器\"></a>腾讯云服务器</h2><ol>\n<li><p>申请账户，体验5天，搭建一个jira服务，还有微信小程序服务</p>\n</li>\n<li><p>需要在服务器上安装docker （腾讯服务器提供了一款支持docker的Ubuntu系统）</p>\n</li>\n<li>想使用daocloud加速器，就要更新docker版本<br>docker run –detach –publish 8080:8080 cptactionhank/atlassian-jira:latest<br><a href=\"http://[dockerhost]:8080\" target=\"_blank\" rel=\"noopener\">http://[dockerhost]:8080</a> and finish the configuration</li>\n</ol>\n<h3 id=\"远程服务器的基本操作\"><a href=\"#远程服务器的基本操作\" class=\"headerlink\" title=\"远程服务器的基本操作\"></a>远程服务器的基本操作</h3><ol>\n<li>登录：<code>ssh -l username 服务ip／域名</code><br> ssh ubuntu@123.<strong><em>.</em>.<em>6   5<em>*</em></em></strong>RtH<br> sudo docker pull cptactionhank/atlassian-jira</li>\n<li>服务器端拷贝文件目录<br> scp -i localDir serveruser@serverip:serverDir</li>\n</ol>\n<h3 id=\"docker下安装mysql数据库镜像\"><a href=\"#docker下安装mysql数据库镜像\" class=\"headerlink\" title=\"docker下安装mysql数据库镜像\"></a>docker下安装mysql数据库镜像</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker pull mysql </span><br><span class=\"line\">sudo docker run --name jiradb -e MYSQL_ROOT_PASSWORD=jiradb -d mysql/mysql-server:latest</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>-name : 容器名<br>MYSQL_ROOT_PASSWORD : 数据库密码<br>-d : 镜像名:tag 版本</p>\n</blockquote>\n<h4 id=\"终端：单行登录mysql\"><a href=\"#终端：单行登录mysql\" class=\"headerlink\" title=\"终端：单行登录mysql\"></a>终端：单行登录mysql</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker exec -it jiradb mysql -ujira -pjira</span><br></pre></td></tr></table></figure>\n<h4 id=\"进入mysql终端-访问数据库\"><a href=\"#进入mysql终端-访问数据库\" class=\"headerlink\" title=\"进入mysql终端,访问数据库\"></a>进入mysql终端,访问数据库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker exec -it jiradb bash</span><br><span class=\"line\">#登录数据库  默认用户root 密码为空，如果前边设置了MYSQL_ROOT_PASSWORD的值，则需要密码</span><br><span class=\"line\">mysql -uroot -p   #登录本地数据库 可以 省略-h参数 -h 127.0.0.1</span><br><span class=\"line\">回车</span><br><span class=\"line\">输入密码：jiradb  #就是$MYSQL_ROOT_PASSWORD的值</span><br><span class=\"line\">即登录</span><br></pre></td></tr></table></figure>\n<h4 id=\"用户权限控制\"><a href=\"#用户权限控制\" class=\"headerlink\" title=\"用户权限控制\"></a>用户权限控制</h4><ol>\n<li><p>查看sql服务器的状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">status;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建用户名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create user jira identified by &apos;jira&apos;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>赋予权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grant all privileges on *.* to &apos;jira&apos;@&apos;%&apos; identified by &apos;jira&apos; with grant option;</span><br><span class=\"line\">grant all privileges on *.* to &apos;jira&apos;@&apos;localhost&apos; identified by &apos;jira&apos; with grant option;</span><br><span class=\"line\">flush privileges;</span><br><span class=\"line\">quit;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"数据库操作\"><a href=\"#数据库操作\" class=\"headerlink\" title=\"数据库操作\"></a>数据库操作</h4><ol>\n<li><p>创建数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create database jiradb character set &apos;UTF8&apos;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看当前数据库名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select database();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>切换指定数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use jiradb;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看数据库表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show tables;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>创建表</p>\n<h5 id=\"jira和数据库关联结果\"><a href=\"#jira和数据库关联结果\" class=\"headerlink\" title=\"jira和数据库关联结果\"></a>jira和数据库关联结果</h5><p>无法通过 docker 中mysql镜像的盒子来实现jira和数据库关联：<br>从另一个容器中的应用来访问jiradb容器中的mysql服务：没成功<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Connect to MySQL from an application in another Docker container</span><br><span class=\"line\">sudo docker run --name jirad --link jiradb:mysql/mysql-server -d cptactionhank/atlassian-jira:latest</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure></p>\n<p>最终采用在ubuntu系统中安装mysql：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$sudo apt-get -y install mysql-server</span><br></pre></td></tr></table></figure></p>\n<p>##问题：Could not reach any registry endpoint<br>安装Linux加速器：<br>curl -sSL <a href=\"https://get.daocloud.io/daotools/set_mirror.sh\" target=\"_blank\" rel=\"noopener\">https://get.daocloud.io/daotools/set_mirror.sh</a> | sh -s <a href=\"http://142900b5.m.daocloud.io\" target=\"_blank\" rel=\"noopener\">http://142900b5.m.daocloud.io</a><br>该脚本可以将 –registry-mirror 加入到你的 Docker 配置文件 /etc/default/docker 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。<br>ubuntu 系统安装daocloud检测工具：<br>curl -sSL <a href=\"https://get.daocloud.io/daomonit/install.sh\" target=\"_blank\" rel=\"noopener\">https://get.daocloud.io/daomonit/install.sh</a> | sh -s d0312f829e9807ee0bf157cdc9c9cca42380395c </p>\n<h3 id=\"更新服务器上的docker\"><a href=\"#更新服务器上的docker\" class=\"headerlink\" title=\"更新服务器上的docker\"></a>更新服务器上的docker</h3><p><a href=\"https://docs.docker.com/engine/installation/linux/ubuntulinux/#/prerequisites-by-ubuntu-version\" target=\"_blank\" rel=\"noopener\">官网教程</a></p>\n<h3 id=\"Update-your-apt-sources\"><a href=\"#Update-your-apt-sources\" class=\"headerlink\" title=\"Update your apt sources\"></a>Update your apt sources</h3><p>To set APT to use packages from the Docker repository:</p>\n<ol>\n<li>Log into your machine as a user with sudo or root privileges.</li>\n<li>Open a terminal window.</li>\n<li><p>Update package information, ensure that APT works with the https method, and that CA certificates are installed.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install apt-transport-https ca-certificates</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Docker资源库<br>|Ubuntu version|    Repository|<br>|—|—-|<br>|Precise 12.04 (LTS)|deb <a href=\"https://apt.dockerproject.org/repo\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo</a> ubuntu-precise main|<br>|Trusty 14.04 (LTS)    |deb <a href=\"https://apt.dockerproject.org/repo\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo</a> ubuntu-trusty main|<br>|Wily 15.10         |deb <a href=\"https://apt.dockerproject.org/repo\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo</a> ubuntu-wily main|<br>|Xenial 16.04 (LTS)    |deb <a href=\"https://apt.dockerproject.org/repo\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo</a> ubuntu-xenial main|</p>\n<blockquote>\n<p>Note: Docker does not provide packages for all architectures. Binary artifacts are built nightly, and you can download them from <a href=\"https://master.dockerproject.org\" target=\"_blank\" rel=\"noopener\">https://master.dockerproject.org</a>. To install docker on a multi-architecture system, add an [arch=…] clause to the entry. Refer to Debian Multiarch wiki for details.</p>\n</blockquote>\n</li>\n<li>导入库<br><repo> = deb <a href=\"https://apt.dockerproject.org/repo\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo</a> ubuntu-precise main<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">\"&lt;REPO&gt;\"</span> | sudo tee /etc/apt/sources.list.d/docker.list</span><br></pre></td></tr></table></figure>\n</repo></li>\n</ol>\n<p>`<br>6.Update the APT package index.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br></pre></td></tr></table></figure></p>\n<p>7.Verify that APT is pulling from the right repository.<br>When you run the following command, an entry is returned for each version of Docker that is available for you to install. Each entry should have the URL <a href=\"https://apt.dockerproject.org/repo/\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo/</a>. The version currently installed is marked with <em>*</em>.The output below is truncated.</p>\n<p>$ apt-cache policy docker-engine</p>\n<p>docker-engine:<br>Installed: 1.12.2-0~trusty<br>Candidate: 1.12.2-0~trusty<br>Version table:<br><em>*</em> 1.12.2-0~trusty 0<br>500 <a href=\"https://apt.dockerproject.org/repo/\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo/</a> ubuntu-trusty/main amd64 Packages<br>100 /var/lib/dpkg/status<br>1.12.1-0~trusty 0<br>500 <a href=\"https://apt.dockerproject.org/repo/\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo/</a> ubuntu-trusty/main amd64 Packages<br>1.12.0-0~trusty 0<br>500 <a href=\"https://apt.dockerproject.org/repo/\" target=\"_blank\" rel=\"noopener\">https://apt.dockerproject.org/repo/</a> ubuntu-trusty/main amd64 Packages</p>\n<p>From now on when you run apt-get upgrade, APT pulls from the new repository.</p>\n<p>To upgrade your kernel and install the additional packages, do the following:</p>\n<p>Open a terminal on your Ubuntu host.<br>Update your package manager.<br>$ sudo apt-get update<br>Install both the required and optional packages.<br>$ sudo apt-get install linux-image-generic-lts-trusty<br>Repeat this step for other packages you need to install.<br>Reboot your host to use the updated kernel.<br>$ sudo reboot<br>After your system reboots, go ahead and install Docker.</p>\n<p>Install the latest version<br>Make sure you have satisfied all the prerequisites, then follow these steps.</p>\n<p>Note: For production systems, it is recommended that you install a specific version so that you do not accidentally update Docker. You should plan upgrades for production systems carefully.<br>Log into your Ubuntu installation as a user with sudo privileges.<br>Update your APT package index.<br>$ sudo apt-get update<br>Install Docker.<br>$ sudo apt-get install docker-engine<br>Start the docker daemon.<br>$ sudo service docker start<br>Verify that docker is installed correctly by running the hello-world image.<br>$ sudo docker run hello-world<br>This command downloads a test image and runs it in a container. When the container runs, it prints an informational message and exits.</p>\n","raw":null,"categories":[{"name":"docker","path":"api/categories/docker.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"}]},{"title":"使用Cocoapods创建私有podspec","slug":"工具/使用Cocoapods创建私有podspec","date":"2017-02-28T15:46:16.000Z","updated":"2018-06-21T21:43:37.000Z","comments":true,"path":"api/articles/工具/使用Cocoapods创建私有podspec.json","excerpt":null,"keywords":null,"cover":"http://p27uwfdhv.bkt.clouddn.com/static/images/repo目录.png?imageMogr2/2/w/800","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"创建一个版本库来托管pod索引-pod-repo-add命令\"><a href=\"#创建一个版本库来托管pod索引-pod-repo-add命令\" class=\"headerlink\" title=\"创建一个版本库来托管pod索引:pod repo add命令\"></a>创建一个版本库来托管pod索引:pod repo add命令</h2><p>第一步：在github登录个人账号，创建一个库作为pod索引托管库。也可根据具体情况可以选择：<code>github</code>、<code>CODING</code>、<code>开源中国</code>、<code>Bitbucket</code>以及<code>CSDN</code>等，代码托管平台。<br>当索引库托管在github私有的仓库时，如果有其他同事共同开发维护，则需要配置Git仓库的权限。<br>第二步：pod化版本库，使其专门用户管理个人的<code>*podspec</code>索引文件<br><figure class=\"highlight ruby\"><figcaption><span>repo add命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># pod repo add [Private Repo Name] [GitHub HTTPS clone URL]</span></span><br><span class=\"line\">$ pod repo add PodRepo <span class=\"symbol\">https:</span>/<span class=\"regexp\">/github.com/huos</span>3203/PodRepo.git</span><br><span class=\"line\"><span class=\"comment\">#输出：</span></span><br><span class=\"line\">&gt; Cloning spec repo <span class=\"string\">`PodRepo`</span> from <span class=\"string\">`https://github.com/huos3203/PodRepo.git`</span></span><br></pre></td></tr></table></figure><br>此时在本地会生成<code>~/.cocoapods/repos/PodRepo</code>目录，这个目录就可以用来存储你所有的开源包。<br>每当一个或多个<code>*.podspec</code>文件测试无误时，就可以使用<code>pod repo push</code>命令向私有索引库中提交该文件。<br><figure class=\"highlight ruby\"><figcaption><span>lib create命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod repo push PodRepo LogSwift.podspec  <span class=\"comment\">#PodRepo是本地Repo名字 后面是podspec名字</span></span><br></pre></td></tr></table></figure><br>完成之后这个组件库就添加到私有索引库中，自动生成的<code>pod 库</code>标准结构：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/repo目录.png?imageMogr2/2/w/800\"><br>同时<code>push命令</code>会将新增的索引目录推送至自己的远程仓库中，即索引托管库<code>PodRepo.git</code>中。</p>\n<p>下面详述<code>podspec文件</code>的配置，检测，使用的过程。</p>\n<h2 id=\"使用模板命令创建Pod工程项目-lib-create\"><a href=\"#使用模板命令创建Pod工程项目-lib-create\" class=\"headerlink\" title=\"使用模板命令创建Pod工程项目 lib create\"></a>使用模板命令创建Pod工程项目 lib create</h2><p>初始化Pod模板项目：<br><figure class=\"highlight ruby\"><figcaption><span>lib create命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod lib create LogSwift</span><br></pre></td></tr></table></figure><br>有以下五步命令行交互：<br><figure class=\"highlight ruby\"><figcaption><span>交互</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">What is your email?</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">What language <span class=\"keyword\">do</span> you want to use?? [ Swift / ObjC ]</span><br><span class=\"line\">&gt;Swift</span><br><span class=\"line\">Would you like to <span class=\"keyword\">include</span> a demo application with your library? [ Yes / No ]</span><br><span class=\"line\">&gt;Yes</span><br><span class=\"line\">Which testing frameworks will you use? [ Quick / None ]</span><br><span class=\"line\">&gt;Quick</span><br><span class=\"line\">Would you like to <span class=\"keyword\">do</span> view based testing? [ Yes / No ]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure><br>会自动执行<code>pod install</code>命令创建项目并生成依赖。</p>\n<h3 id=\"添加库文件和资源\"><a href=\"#添加库文件和资源\" class=\"headerlink\" title=\"添加库文件和资源\"></a>添加库文件和资源</h3><p>例如：把一个网络模块的共有组件放入<code>Pod/Classes</code>中，然后进入<code>Example</code>文件夹执行<code>pod update</code>命令，再打开项目工程可以看到，刚刚添加的组件已经在<code>Pods</code>子工程下<code>Development Pods/PodTestLibrary</code>中了，然后编辑demo工程，测试组件。<br>测试无误后需要将该项目添加并推送到远端仓库，并编辑podspec文件。</p>\n<h3 id=\"配置podspec文件及验证命令lib-lint\"><a href=\"#配置podspec文件及验证命令lib-lint\" class=\"headerlink\" title=\"配置podspec文件及验证命令lib lint\"></a>配置podspec文件及验证命令lib lint</h3><h4 id=\"打tag号作为podspec版本号\"><a href=\"#打tag号作为podspec版本号\" class=\"headerlink\" title=\"打tag号作为podspec版本号\"></a>打tag号作为podspec版本号</h4><p>因为<code>podspec文件</code>中获取<code>Git版本控制</code>的项目还需要<code>tag号</code>，所以我们要打上一个<code>tag</code><br><figure class=\"highlight ruby\"><figcaption><span>打标签</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -m <span class=\"string\">\"first release\"</span> <span class=\"number\">0</span>.<span class=\"number\">1.0</span></span><br><span class=\"line\">$ git push --tags     <span class=\"comment\">#推送tag到远端仓库</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"编辑podspec文件\"><a href=\"#编辑podspec文件\" class=\"headerlink\" title=\"编辑podspec文件\"></a>编辑podspec文件</h4><p><code>podspec文件</code>是一个Ruby格式：<br><figure class=\"highlight ruby\"><figcaption><span>podspec文件</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pod::Spec.new <span class=\"keyword\">do</span> <span class=\"params\">|s|</span></span><br><span class=\"line\">s.name             = <span class=\"string\">\"PodTestLibrary\"</span>    <span class=\"comment\">#名称</span></span><br><span class=\"line\">s.version          = <span class=\"string\">\"0.1.0\"</span>             <span class=\"comment\">#版本号</span></span><br><span class=\"line\">s.summary          = <span class=\"string\">\"Just Testing.\"</span>     <span class=\"comment\">#简短介绍，下面是详细介绍</span></span><br><span class=\"line\">s.description      = <span class=\"string\">&lt;&lt;-DESC</span></span><br><span class=\"line\"><span class=\"string\">Testing Private Podspec.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* Markdown format.</span></span><br><span class=\"line\"><span class=\"string\">* Don't worry about the indent, we strip it!</span></span><br><span class=\"line\"><span class=\"string\">DESC</span></span><br><span class=\"line\">s.homepage         = <span class=\"string\">\"https://coding.net/u/boyers/p/podTestLibrary\"</span>                           <span class=\"comment\">#主页,这里要填写可以访问到的地址，不然验证不通过</span></span><br><span class=\"line\"><span class=\"comment\"># s.screenshots     = \"www.example.com/screenshots_1\", \"www.example.com/screenshots_2\"           #截图</span></span><br><span class=\"line\">s.license          = <span class=\"string\">'MIT'</span>              <span class=\"comment\">#开源协议</span></span><br><span class=\"line\">s.author           = &#123; <span class=\"string\">\"boyers\"</span> =&gt; <span class=\"string\">\"boyers@foxmail.com\"</span> &#125;  <span class=\"comment\">#作者信息</span></span><br><span class=\"line\">s.source           = &#123; <span class=\"symbol\">:git</span> =&gt; <span class=\"string\">\"https://coding.net/boyers/podTestLibrary.git\"</span>, <span class=\"symbol\">:tag</span> =&gt; <span class=\"string\">\"0.1.0\"</span> &#125;      <span class=\"comment\">#项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS</span></span><br><span class=\"line\"><span class=\"comment\"># s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;'                       #多媒体介绍地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.platform     = <span class=\"symbol\">:ios</span>, <span class=\"string\">'7.0'</span>            <span class=\"comment\">#支持的平台及版本</span></span><br><span class=\"line\">s.requires_arc = <span class=\"literal\">true</span>                   <span class=\"comment\">#是否使用ARC，如果指定具体文件，则具体的问题使用ARC</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.source_files = <span class=\"string\">'Pod/Classes/**/*'</span>     <span class=\"comment\">#代码源文件地址，**/*表示Classes目录及其子目录下所有文件，如果有多个目录下则用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置</span></span><br><span class=\"line\">s.resource_bundles = &#123;</span><br><span class=\"line\"><span class=\"string\">'PodTestLibrary'</span> =&gt; [<span class=\"string\">'Pod/Assets/*.png'</span>]</span><br><span class=\"line\">&#125;                                       <span class=\"comment\">#资源文件地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.public_header_files = <span class=\"string\">'Pod/Classes/**/*.h'</span>   <span class=\"comment\">#公开头文件地址</span></span><br><span class=\"line\">s.frameworks = <span class=\"string\">'UIKit'</span>                  <span class=\"comment\">#所需的framework，多个用逗号隔开</span></span><br><span class=\"line\">s.dependency <span class=\"string\">'AFNetworking'</span>, <span class=\"string\">'~&gt; 2.3'</span>   <span class=\"comment\">#依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependency</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"验证podspec文件可用性\"><a href=\"#验证podspec文件可用性\" class=\"headerlink\" title=\"验证podspec文件可用性\"></a>验证podspec文件可用性</h4><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod lib lint</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">-&gt; PodTestLibrary (<span class=\"number\">0</span>.<span class=\"number\">1.0</span>)</span><br><span class=\"line\">PodTestLibrary passed validation.</span><br></pre></td></tr></table></figure>\n<p>说明验证通过了，不过这只是这个<code>podspec文件</code>是合格的，不一定说明这个Pod是可以用的，Pod需要在本地做一下验证。</p>\n<h3 id=\"将源码托管到远程仓库\"><a href=\"#将源码托管到远程仓库\" class=\"headerlink\" title=\"将源码托管到远程仓库\"></a>将源码托管到远程仓库</h3><p>通过<code>Cocoapods</code>创建出来的目录本身就在本地的<code>Git</code>管理下，我们需要做的就是给它添加远端仓库，同样去<code>GitHub</code>或其他的Git服务提供商那里创建一个<code>私有的仓库</code>，拿到<code>SSH地址</code>，然后<code>cd</code>到<code>LogSwift</code>目录<br><figure class=\"highlight ruby\"><figcaption><span>添加到远程仓库</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -s -m <span class=\"string\">\"Initial Commit of Library\"</span></span><br><span class=\"line\">$ git remote add origin <span class=\"symbol\">https:</span>/<span class=\"regexp\">/coding.net/git</span><span class=\"regexp\">/LogSwift.git   #添加远端仓库</span></span><br><span class=\"line\"><span class=\"regexp\">$ git push origin master        #提交到远端仓库</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"手动配置Pod私库项目支持：spec-create\"><a href=\"#手动配置Pod私库项目支持：spec-create\" class=\"headerlink\" title=\"手动配置Pod私库项目支持：spec create\"></a>手动配置Pod私库项目支持：spec create</h2><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod spec create LogSwift git@coding.<span class=\"symbol\">net:</span>boyers/LogSwift.git</span><br></pre></td></tr></table></figure>\n<p>执行完之后，就创建了一个<code>podspec文件</code>，他其中会包含很多内容，可以按照我之前介绍的进行编辑，没用的删掉。编辑完成之后使用验证命令<code>pod lib lint</code>验证一下。</p>\n<h2 id=\"path-gt-在新项目配置检测podspec文件\"><a href=\"#path-gt-在新项目配置检测podspec文件\" class=\"headerlink\" title=\":path =&gt; 在新项目配置检测podspec文件\"></a>:path =&gt; 在新项目配置检测podspec文件</h2><p>在这个项目的<code>Podfile</code>文件中直接指定刚才创建编辑好的<code>podspec文件</code>，看是否可用。</p>\n<ol>\n<li>指定本地依赖的两种方式:<figure class=\"highlight ruby\"><figcaption><span>Podfile</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">platform <span class=\"symbol\">:ios</span>, <span class=\"string\">'7.0'</span></span><br><span class=\"line\">pod <span class=\"string\">'LogSwift'</span>, <span class=\"symbol\">:path</span> =&gt; <span class=\"string\">'~/code/Cocoapods/podTest/LogSwift'</span>      <span class=\"comment\"># 指定路径</span></span><br><span class=\"line\">pod <span class=\"string\">'LogSwift'</span>, <span class=\"symbol\">:podspec</span> =&gt; <span class=\"string\">'~/code/Cocoapods/podTest/LogSwift/LogSwift.podspec'</span>  <span class=\"comment\"># 指定podspec文件</span></span><br></pre></td></tr></table></figure></li>\n<li>指定源码的远程仓库作为依赖<br>前提时索引文件中指定的tag版本的源码必须推送到远程仓库<figure class=\"highlight ruby\"><figcaption><span>Podfile</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">platform <span class=\"symbol\">:ios</span>, <span class=\"string\">'7.0'</span></span><br><span class=\"line\">pod <span class=\"string\">'MusicLrc'</span>, <span class=\"symbol\">:git</span> =&gt; <span class=\"string\">'https://github.com/huos3203/MusicLrcTest.git'</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>然后执行<code>pod install</code>命令安装依赖，打开项目工程，可以看到<code>库文件</code>和<code>资源</code>都被加载到<code>Pods子项目</code>中了，不过它们并没有在<code>Pods目录</code>下，而是跟测试项目一样存在于<code>Development Pods/LogSwift</code>中，这是因为我们是在本地测试，而没有把<code>podspec文件</code>添加到<code>Spec Repo</code>中的缘故。</p>\n<h2 id=\"万事具备，向私有索引库中提交podspec文件：repo-push\"><a href=\"#万事具备，向私有索引库中提交podspec文件：repo-push\" class=\"headerlink\" title=\"万事具备，向私有索引库中提交podspec文件：repo push\"></a>万事具备，向私有索引库中提交podspec文件：repo push</h2><p>每当一个或多个<code>*.podspec</code>文件测试无误时，就可以使用<code>pod repo push</code>命令向私有索引库中提交该文件。<br><figure class=\"highlight ruby\"><figcaption><span>lib create命令</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod repo push PodRepo LogSwift.podspec  <span class=\"comment\">#PodRepo是本地Repo名字 后面是podspec名字</span></span><br></pre></td></tr></table></figure><br>完成之后这个组件库就添加到私有索引库中，自动生成的<code>pod 库</code>标准结构：<br><img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/repo目录.png?imageMogr2/2/w/800\"><br>同时<code>push命令</code>会将新增的索引目录推送至自己的远程仓库中，即索引托管库<code>PodRepo.git</code>中。</p>\n<h2 id=\"trunk-push-添加到Cocoapods的官方索引库\"><a href=\"#trunk-push-添加到Cocoapods的官方索引库\" class=\"headerlink\" title=\"trunk push 添加到Cocoapods的官方索引库\"></a>trunk push 添加到Cocoapods的官方索引库</h2><h3 id=\"注册trunk，邮箱验证\"><a href=\"#注册trunk，邮箱验证\" class=\"headerlink\" title=\"注册trunk，邮箱验证\"></a>注册trunk，邮箱验证</h3><p>在注册trunk之前，我们需要确认当前的CocoaPods版本是否足够新:<br>sudo gem install cocoapods<br>开始注册trunk：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod trunk register boyer@163.com <span class=\"string\">'boyers1250'</span>  --verbose</span><br></pre></td></tr></table></figure><br><code>-verbose</code>参数是为了便于输出注册过程中的调试信息。<br>执行上面的语句后，你的邮箱将会受到一封带有验证链接的邮件，如果没有请去垃圾箱找找，有可能被屏蔽了。点击邮件的链接就完成了trunk注册流程。<br>使用下面的命令可以向trunk服务器查询自己的注册信息：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod trunk me</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"通过trunk推送podspec文件\"><a href=\"#通过trunk推送podspec文件\" class=\"headerlink\" title=\"通过trunk推送podspec文件\"></a>通过trunk推送podspec文件</h3><p>现在我们已经有了自己的podspec文件，但是在推送podspec文件之前你需要确认以下几点：</p>\n<ol>\n<li>确保你的源码已经push到Github上。</li>\n<li>确保你所push的代码已经打上”version tag”版本号标签：<br>只有确保了以上两点，CocoaPods才能更准确地找到你的repo。<br>现在我们开始通过trunk上传你的podspec文件。先cd到podspec文件所在目录，执行：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod trunk push WZLBadge.podspec</span><br></pre></td></tr></table></figure>\n执行上面的push操作，就相当于你把你的源代码提交给CocoaPods团队审核了，CocoaPods审核只需要几秒钟或者几分钟就可以完成。</li>\n</ol>\n<h2 id=\"使用远程的私有Pod库\"><a href=\"#使用远程的私有Pod库\" class=\"headerlink\" title=\"使用远程的私有Pod库\"></a>使用远程的私有Pod库</h2><p>我们的这个组件库就已经制作添加完成了，现在可以<code>pod search</code>命令查到这个库，当使用时配置Podfile依赖文件即可。</p>\n<ol>\n<li>pod search 查找库<figure class=\"highlight ruby\"><figcaption><span>查找库</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod search PodTestLibrary</span><br><span class=\"line\"></span><br><span class=\"line\">-&gt; PodTestLibrary (<span class=\"number\">0</span>.<span class=\"number\">1.0</span>)</span><br><span class=\"line\">Just Testing.</span><br><span class=\"line\">pod <span class=\"string\">'PodTestLibrary'</span>, <span class=\"string\">'~&gt; 0.1.0'</span></span><br><span class=\"line\">- <span class=\"symbol\">Homepage:</span> <span class=\"symbol\">https:</span>/<span class=\"regexp\">/coding.net/u</span><span class=\"regexp\">/boyers/p</span><span class=\"regexp\">/podTestLibrary</span></span><br><span class=\"line\"><span class=\"regexp\">- Source:   https:/</span><span class=\"regexp\">/coding.net/boyers</span><span class=\"regexp\">/podTestLibrary.git</span></span><br><span class=\"line\"><span class=\"regexp\">- Versions: 0.1.0 [WTSpecs repo]</span></span><br></pre></td></tr></table></figure></li>\n<li>在Podfile文件中配置库依赖<figure class=\"highlight ruby\"><figcaption><span>配置库依赖</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod <span class=\"string\">'PodTestLibrary'</span>, <span class=\"string\">'~&gt; 0.1.0'</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"更新维护podspec文件配置，升级库版本\"><a href=\"#更新维护podspec文件配置，升级库版本\" class=\"headerlink\" title=\"更新维护podspec文件配置，升级库版本\"></a>更新维护podspec文件配置，升级库版本</h2><p><code>subspec</code>特性，可以在库原有基础上，添加更多的模块，相应创建了多个子目录。现在尝试添加包括<code>工具类</code>，底层<code>Model</code>及<code>UIKit</code>扩展等。</p>\n<h3 id=\"添加模块库文件和资源\"><a href=\"#添加模块库文件和资源\" class=\"headerlink\" title=\"添加模块库文件和资源\"></a>添加模块库文件和资源</h3><p>具体做法是先将源文件添加到<code>Pod/Classes</code>中，然后按照不同的模块对文件目录进行整理，因为我有四个模块，所以在<code>Pod/Classes</code>下有创建了四个子目录</p>\n<h3 id=\"打tag号作为podspec版本号-1\"><a href=\"#打tag号作为podspec版本号-1\" class=\"headerlink\" title=\"打tag号作为podspec版本号\"></a>打tag号作为podspec版本号</h3><p>因为<code>podspec文件</code>中获取<code>Git版本控制</code>的项目还需要<code>tag号</code>，所以我们要打上一个<code>tag</code><br><figure class=\"highlight ruby\"><figcaption><span>打标签</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -m <span class=\"string\">\"first release\"</span> <span class=\"number\">0</span>.<span class=\"number\">1.0</span></span><br><span class=\"line\">$ git push --tags     <span class=\"comment\">#推送tag到远端仓库</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"更新podspec配置文件\"><a href=\"#更新podspec配置文件\" class=\"headerlink\" title=\"更新podspec配置文件\"></a>更新podspec配置文件</h3><p>当创建了<code>subspec</code>，之前项目整体的依赖<code>dependency</code>:</p>\n<ol>\n<li>源文件:<code>source_files</code></li>\n<li>头文件:<code>public_header_files</code></li>\n<li>资源文件:<code>resource</code><br>都移动到了各自的<code>subspec</code>中，每个<code>subspec</code>之间也可以有相互的依赖关系，比如<code>UIKitAdditio</code>n就依赖于<code>CommonTools</code>。<figure class=\"highlight ruby\"><figcaption><span>更新podspec配置文件</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pod::Spec.new <span class=\"keyword\">do</span> <span class=\"params\">|s|</span></span><br><span class=\"line\">s.name             = <span class=\"string\">\"PodTestLibrary\"</span></span><br><span class=\"line\">s.version          = <span class=\"string\">\"1.0.0\"</span></span><br><span class=\"line\">s.summary          = <span class=\"string\">\"Just Testing.\"</span></span><br><span class=\"line\">s.description      = <span class=\"string\">&lt;&lt;-DESC</span></span><br><span class=\"line\"><span class=\"string\">                         Testing Private Podspec.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">                        * Markdown format.</span></span><br><span class=\"line\"><span class=\"string\">                        * Don't worry about the indent, we strip it!</span></span><br><span class=\"line\"><span class=\"string\">                    DESC</span></span><br><span class=\"line\">s.homepage         = <span class=\"string\">\"https://coding.net/u/boyers/p/podTestLibrary\"</span></span><br><span class=\"line\"><span class=\"comment\"># s.screenshots     = \"www.example.com/screenshots_1\", \"www.example.com/screenshots_2\"</span></span><br><span class=\"line\">s.license          = <span class=\"string\">'MIT'</span></span><br><span class=\"line\">s.author           = &#123; <span class=\"string\">\"boyers\"</span> =&gt; <span class=\"string\">\"boyers@foxmail.com\"</span> &#125;</span><br><span class=\"line\">s.source           = &#123; <span class=\"symbol\">:git</span> =&gt; <span class=\"string\">\"https://coding.net/boyers/podTestLibrary.git\"</span>, <span class=\"symbol\">:tag</span> =&gt; <span class=\"string\">\"1.0.0\"</span> &#125;</span><br><span class=\"line\"><span class=\"comment\"># s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;'</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.platform     = <span class=\"symbol\">:ios</span>, <span class=\"string\">'7.0'</span></span><br><span class=\"line\">s.requires_arc = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#s.source_files = 'Pod/Classes/**/*'</span></span><br><span class=\"line\"><span class=\"comment\">#s.resource_bundles = &#123; 'PodTestLibrary' =&gt; ['Pod/Assets/*.png'] &#125;</span></span><br><span class=\"line\"><span class=\"comment\">#s.public_header_files = 'Pod/Classes/**/*.h'</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.subspec <span class=\"string\">'NetWorkEngine'</span> <span class=\"keyword\">do</span> <span class=\"params\">|networkEngine|</span></span><br><span class=\"line\">    networkEngine.source_files = <span class=\"string\">'Pod/Classes/NetworkEngine/**/*'</span></span><br><span class=\"line\">    networkEngine.public_header_files = <span class=\"string\">'Pod/Classes/NetworkEngine/**/*.h'</span></span><br><span class=\"line\">    networkEngine.dependency <span class=\"string\">'AFNetworking'</span>, <span class=\"string\">'~&gt; 2.3'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.subspec <span class=\"string\">'DataModel'</span> <span class=\"keyword\">do</span> <span class=\"params\">|dataModel|</span></span><br><span class=\"line\">    dataModel.source_files = <span class=\"string\">'Pod/Classes/DataModel/**/*'</span></span><br><span class=\"line\">    dataModel.public_header_files = <span class=\"string\">'Pod/Classes/DataModel/**/*.h'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.subspec <span class=\"string\">'CommonTools'</span> <span class=\"keyword\">do</span> <span class=\"params\">|commonTools|</span></span><br><span class=\"line\">    commonTools.source_files = <span class=\"string\">'Pod/Classes/CommonTools/**/*'</span></span><br><span class=\"line\">    commonTools.public_header_files = <span class=\"string\">'Pod/Classes/CommonTools/**/*.h'</span></span><br><span class=\"line\">    commonTools.dependency <span class=\"string\">'OpenUDID'</span>, <span class=\"string\">'~&gt; 1.0.0'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.subspec <span class=\"string\">'UIKitAddition'</span> <span class=\"keyword\">do</span> <span class=\"params\">|ui|</span></span><br><span class=\"line\">    ui.source_files = <span class=\"string\">'Pod/Classes/UIKitAddition/**/*'</span></span><br><span class=\"line\">    ui.public_header_files = <span class=\"string\">'Pod/Classes/UIKitAddition/**/*.h'</span></span><br><span class=\"line\">    ui.resource = <span class=\"string\">\"Pod/Assets/MLSUIKitResource.bundle\"</span></span><br><span class=\"line\">    ui.dependency <span class=\"string\">'PodTestLibrary/CommonTools'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.frameworks = <span class=\"string\">'UIKit'</span></span><br><span class=\"line\">    <span class=\"comment\">#s.dependency 'AFNetworking', '~&gt; 2.3'</span></span><br><span class=\"line\">    <span class=\"comment\">#s.dependency 'OpenUDID', '~&gt; 1.0.0'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n编辑完成之后，在测试项目里<code>pod update</code>一下，几个子项目都被加进项目工程了，写代码验证无误之后，就可以将这个工程push到远端仓库，并打上新的<code>tag-&gt;1.0.0</code>。<blockquote>\n<p>但是如果你的代码版本号没变(podspec里的version自然也没变)就会提示push失败，即使你更改了podspec的其他地方，pod也会认为这两个文件是同一个。 我目前为止找不到trunk的相关update接口，所以只能顺水推舟，更新源代码版本号（如：1.1.1-&gt;1.1.2），重新push version tag，然后再执行pod trunk push操作。</p>\n</blockquote>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"工具","path":"api/categories/工具.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"pod","path":"api/tags/pod.json"},{"name":"私库","path":"api/tags/私库.json"}]},{"title":"JavaScript自动化组件OC桥接","slug":"macOS/JavaScript自动化组件OC桥接","date":"2017-02-15T17:19:30.000Z","updated":"2017-02-16T13:43:01.000Z","comments":true,"path":"api/articles/macOS/JavaScript自动化组件OC桥接.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><a href=\"https://developer.apple.com/library/content/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/OSX10-10.html#//apple_ref/doc/uid/TP40014508-CH109-SW8\" target=\"_blank\" rel=\"noopener\">文档</a><br><code>JavaScript自动化</code>有一个内置的<code>Objective-C Bridge</code>，使您能够访问文件系统，创建Cocoa应用程序。<br><code>Objective-C Bridge</code>的主要接入点是全局属性<code>objc</code>和<code>$</code>。</p>\n<h2 id=\"Frameworks\"><a href=\"#Frameworks\" class=\"headerlink\" title=\"Frameworks\"></a>Frameworks</h2><p><code>Foundation framework</code>中的语法默认支持<code>JavaScript自动化</code>。也可以通过使用<code>ObjC.import()</code>方法导入其他Frameworks 和 libraries。<br>例如，使用<code>Cocoa框架</code>中的<code>NSBeep()</code>函数，需要导入<code>Cocoa框架</code><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjC.import(<span class=\"string\">'Cocoa'</span>)</span><br><span class=\"line\">$.NSBeep()</span><br></pre></td></tr></table></figure><br>除了系统框架之外，一些系统库的功能也被暴露出来。这个功能可以通过<code>头文件</code>的名称来暴漏出来（不带.h）<br>例如：<br>arpa/inet, asl, copyfile, dispatch, dyld, errno, getopt, glob, grp, ifaddrs, launch, membership, netdb, netinet/in, notify, objc, paths, pwd, readline, removefile, signal, spawn, sqlite3, stdio, stdlib, string, sys/fcntl, sys/file, sys/ioctl, sys/mount, sys/param, sys/resource, sys/socket, sys/stat, sys/sysctl, sys/time, sys/times, sys/types, sys/wait, sys/xattr, syslog, time, unistd, uuid/uuid, vImage, vecLib, vmnet, xpc, 和 zlib.<br>导入框架时，系统将参考桥接支持文件。除了内置的框架和库，您可以导入任何具有桥接支持的框架，只需要将完整路径传递给框架，如下示例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjC.import(<span class=\"string\">'/Library/Frameworks/Awesome.framework'</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>原始的<code>JavaScript数据类型</code>映射到<code>C数据类型</code>。例如，一个<code>JavaScript字符串</code>映射为<code>char *</code>，而<code>JavaScript整数</code>映射到<code>int</code>。使用<code>objc API</code>返回一个<code>char *</code>时，会得到一个<code>JS 字符串</code></p>\n<p>原始的<code>JavaScript数据类型</code>将被自动转换为<code>ObjC对象类型</code>，并能作为一个预期的对象类型的参数传递给ObjC方法。<br>例如，一个<code>JS字符串</code>将被转换为一个<code>NSString对象</code>如果是什么方法签名说应该是输入。</p>\n<blockquote>\n<p>注意，然而，ObjC方法返回的ObjC对象类型是不会自动转换为原始的JavaScript的数据类型。</p>\n</blockquote>\n<h2 id=\"实例化的类和调用方法\"><a href=\"#实例化的类和调用方法\" class=\"headerlink\" title=\"实例化的类和调用方法\"></a>实例化的类和调用方法</h2><p>所有类都定义为<code>$对象</code>的属性。ObjC对象的方法有两种方式调用，根据是否需要参数的方法。<br>如果ObjC方法不带参数，然后调用<code>JavaScript属性名</code>访问<code>属性值</code>。这个例子中实例化一个空的字符串。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = $.NSMutableString.alloc.init</span><br></pre></td></tr></table></figure><br>如果ObjC方法不带参数，根据<code>JSExport</code>规范来命名，通过JavaScript的方法调用（function-typed property）；<br>对于多参数的方法，Objective-C的方法每个部分都合并在一起，冒号后的字母变为大写并移除冒号。比如下边协议中的方法，在JavaScript调用就是：doFooWithBar(foo, bar);<br>这个例子说明<code>JavaScript字符串</code>转为<code>NSString</code>然后写入到一个文件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = $.NSString.alloc.initWithUTF8String(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\">str.writeToFileAtomically(<span class=\"string\">'/tmp/foo'</span>, <span class=\"literal\">true</span>)</span><br></pre></td></tr></table></figure></p>\n<p>如果你调用一个方法，如<code>-intValue</code>，返回<code>C数据类型</code>而不是一个对象，然后你会回到原始的<code>JavaScript数据类型</code>。<br>此示例返回原始的JavaScript的整数，99。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.NSNumber.numberWithInt(<span class=\"number\">99</span>).intValue</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"访问-ObjC-Properties\"><a href=\"#访问-ObjC-Properties\" class=\"headerlink\" title=\"访问 ObjC Properties\"></a>访问 ObjC Properties</h3><p><code>ObjC属性</code>也可以通过<code>JavaScript属性</code>来访问，很像调用无参数方法。<br>当一个<code>桥接对象属性</code>的被访问时，ObjC属性列表是第一参考，如果列表中存在该名称对应的属性，那么就调用相应属性的<code>getter</code>或<code>setter</code>选择器。如果该名称的ObjC属性不在类中属性的列表中，那么该属性名称就作为<code>方法选择器</code>来调用。<br>使用自定义<code>getter</code>名定义一个属性，你可以使用<code>属性</code>名 或 <code>getter</code>名，并得到相同的结果。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task = $.NSTask.alloc.init</span><br><span class=\"line\">task.running == task.isRunning</span><br></pre></td></tr></table></figure><br>另外，不同的参数方法，<code>桥接对象属性</code>映射到<code>ObjC属性</code>也可以设置为（read/write属性）。下面的两行定义了一个ObjC属性：<code>launchPath</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task.launchPath = <span class=\"string\">'/bin/sleep'</span></span><br><span class=\"line\">task.setLaunchPath(<span class=\"string\">'/bin/sleep'</span>)</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"JS","path":"api/categories/JS.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"混编","path":"api/tags/混编.json"}]},{"title":"Fabric对macOS系统的支持","slug":"macOS/Fabric对macOS系统的支持调研","date":"2017-02-14T11:14:35.000Z","updated":"2017-02-14T14:33:17.000Z","comments":true,"path":"api/articles/macOS/Fabric对macOS系统的支持调研.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"Fabric\"><a href=\"#Fabric\" class=\"headerlink\" title=\"Fabric\"></a>Fabric</h2><p><code>Fabric</code> 是Twitter的移动应用开发平台，一个模块化、跨平台的移动开发套件，该博文主要研究<code>crashlytics</code>在app中的运用。<br><a href=\"https://try.crashlytics.com/\" target=\"_blank\" rel=\"noopener\">注册新的账户</a>登录，审核通过时间为几个小时或者1到2天不等。然后注册时候输入的邮箱就会收到如下的邀请涵<br><a href=\"https://docs.fabric.io/apple/crashlytics/os-x.html#macos-support\" target=\"_blank\" rel=\"noopener\">浏览官方文档</a></p>\n<h3 id=\"crashlytics支持macOS\"><a href=\"#crashlytics支持macOS\" class=\"headerlink\" title=\"crashlytics支持macOS\"></a>crashlytics支持macOS</h3><p>对<code>macOS</code>的支持中出现的问题<br>问题：<code>NSApplicationCrashOnExceptions</code> is not set. This will result in poor <code>top-level</code> uncaught exception reporting<br>官方解释：<br><blockquote><p>Uncaught Exceptions<br>Intercepting and reporting uncaught exceptions on macOS is more complex than it is on iOS. On macOS, AppKit will catch exceptions thrown on the main thread, preventing the application from crashing, but also preventing Crashlytics from reporting them. To make matters worse, Apple’s frameworks are not exception safe. This means that while AppKit will prevent your app from crashing, it will also likely corrupt your process’s state, often including AppKit itself. Typically, once an exception involving UI interaction is thrown, it will prevent your app from working correctly from that moment on.<br>Thankfully, AppKit has a little-known feature you can turn on to make the behavior much more predictable. We strongly recommend that you do the following in your application, right before you initialize Crashlytics.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] registerDefaults:@&#123; <span class=\"string\">@”NSApplicationCrashOnExceptions”</span>: @YES &#125;];</span><br></pre></td></tr></table></figure>\n\n<p>This will make your application’s behavior much closer to iOS. It will mean that your app will crash on uncaught exceptions, and will also allow Crashlytics to report them with useful stack traces. It will also give you the ability to override this behavior with the user defaults system, even on per-user basis.<br>Of course, this is all optional. Crashlytics will warn about NSApplicationCrashOnExceptions not being set, but will otherwise preserve normal AppKit behavior by default.</p>\n<footer><strong>官方文档</strong><cite><a href=\"https://docs.fabric.io/apple/crashlytics/os-x.html#macos-support\" target=\"_blank\" rel=\"noopener\">macOS Support</a></cite></footer></blockquote><br>拦截和报告未捕获的异常在MacOS比iOS更复杂。在MacOS，AppKit会抓住扔在主线程异常，防止应用程序崩溃，也防止crashlytics报告他们。更糟糕的是，Apple’s frameworks也不例外。这意味着AppKit可以防止你的应用程序崩溃，也可能破坏你的进程的状态，包括AppKit本身。通常情况下，一旦涉及到用户界面交互的异常被抛出，它将阻止您的应用程序从正确的工作从那一刻起。<br>以上情况，可以通过设置：<code>NSApplicationCrashOnExceptions</code> 改变系统默认的值，达到像iOS端一样抓去异常。如果没有设置会提示：NSApplicationCrashOnExceptions not set</p>\n<h3 id=\"Cause-a-Test-Crash教程\"><a href=\"#Cause-a-Test-Crash教程\" class=\"headerlink\" title=\"Cause a Test Crash教程\"></a><a href=\"https://docs.fabric.io/apple/crashlytics/test-crash.html\" target=\"_blank\" rel=\"noopener\">Cause a Test Crash教程</a></h3><p>崩溃日志是在重启APP程序的同时进行的，要确保程序在前台全屏显示。<br>Xcode调试器会阻止我们捕捉崩溃报告，所以在抓取崩溃报告时，要保证在非调试状态下进行。如果你的移动设备连接到Mac机上，Xcode仍然可以进入调试状态。</p>\n<ol>\n<li><code>run</code>在模拟器上安装运行APP</li>\n<li>点击<code>Stop</code>断开Xcode和模拟器，确保在非调试状态</li>\n<li>在模拟器上启动APP，并执行崩溃操作</li>\n<li>在Xcode上点击<code>run</code><br>在Xcode的控制台console中输出显示奔溃报告，以及上传日志的相关提示。<br>macOS系统中的日志目录：<br>运行日志目录：/private/var/log/system.log<br>奔溃日志目录：/Users/pyc/Library/Logs/DiagnosticReports/APPNAME_2016-11-10-165115.crash</li>\n</ol>\n<blockquote><p>It’s possible, but rare, that we are missing a dSYM to symbolicate any crash reports. There will be an alert on your dashboard if this is the case. Click through to upload the missing dSYM. Keep in mind that exceptions are not guaranteed to crash. The full code path, including code in system libraries, matters here. If you aren’t seeing the dSYM alert, you can go to your app’s settings page, and append “/mappings” to the URL to reach it, e.g. <a href=\"https://fabric.io/settings/apps/some_app_id/mappings\" target=\"_blank\" rel=\"noopener\">https://fabric.io/settings/apps/some_app_id/mappings</a></p>\n<footer><strong>官方文档</strong><cite><a href=\"https://docs.fabric.io/apple/crashlytics/test-crash.html\" target=\"_blank\" rel=\"noopener\">Cause a Test Crash教程</a></cite></footer></blockquote>\n","raw":null,"categories":[{"name":"macOS","path":"api/categories/macOS.json"},{"name":"调试","path":"api/categories/调试.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"管理","path":"api/tags/管理.json"},{"name":"SDK","path":"api/tags/SDK.json"},{"name":"测试","path":"api/tags/测试.json"},{"name":"发布","path":"api/tags/发布.json"},{"name":"macOS","path":"api/tags/macOS.json"}]},{"title":"腾讯云之小直播开发","slug":"腾讯云之小直播开发","date":"2017-01-22T18:55:21.000Z","updated":"2017-05-26T11:03:05.000Z","comments":true,"path":"api/articles/腾讯云之小直播开发.json","excerpt":null,"keywords":null,"cover":"https://mc.qcloudimg.com/static/img/92a464fc26bbe52fea8816f8e6061ef3/image.jpg","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h1 id=\"视频服务\"><a href=\"#视频服务\" class=\"headerlink\" title=\"视频服务\"></a>视频服务</h1><ol>\n<li><p><a href=\"https://www.qcloud.com/product/LVB\" target=\"_blank\" rel=\"noopener\">直播LVB</a> </p>\n<ol>\n<li><a href=\"https://www.qcloud.com/document/product/267/7964\" target=\"_blank\" rel=\"noopener\">开发指南</a></li>\n</ol>\n</li>\n<li><p><a href=\"https://www.qcloud.com/product/mlvb\" target=\"_blank\" rel=\"noopener\">移动直播MLVB</a></p>\n<ol>\n<li><a href=\"https://www.qcloud.com/document/product/454/7876\" target=\"_blank\" rel=\"noopener\">开发指南</a><br>移动直播是一套移动终端直播解决方案的<code>集合</code>，它以免费源码的形式向您展示：如何利用腾讯云直播(LVB)、点播(VOD)、云通信(IM) 和 对象存储(COS)等几项服务组合构建出适合您的直播解决方案。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"快速集成方案\"><a href=\"#快速集成方案\" class=\"headerlink\" title=\"快速集成方案\"></a>快速集成方案</h2><img src=\"https://mc.qcloudimg.com/static/img/92a464fc26bbe52fea8816f8e6061ef3/image.jpg\" class=\"导图\" title=\"100% 200 集成导图 图片\">\n<p>如果您想要在自己的 APP 里集成直播推流和播放功能，下面三步就能达成目标：</p>\n<ol>\n<li>开通直播服务<br><a href=\"https://console.qcloud.com/live\" target=\"_blank\" rel=\"noopener\">文档</a></li>\n<li>集成 RTMP SDK<br><a href=\"https://www.qcloud.com/document/product/454/7880\" target=\"_blank\" rel=\"noopener\">RTMP SDK - iOS 平台播放</a></li>\n<li>对接直播流管理<ol>\n<li><a href=\"https://www.qcloud.com/document/product/454/7915\" target=\"_blank\" rel=\"noopener\">云端API - 如何获取推流URL？</a></li>\n<li><a href=\"https://www.qcloud.com/document/product/454/7916\" target=\"_blank\" rel=\"noopener\">云端API - 如何构建房间列表？</a></li>\n<li><a href=\"https://www.qcloud.com/document/product/454/7920\" target=\"_blank\" rel=\"noopener\">云端API - 如何管理直播流？</a><br>小直播是有腾讯云研发团队提供的一套开源源码集，致力于以 DEMO 的形式向您展示：如何利用腾讯云直播(LVB)、点播(VOD)、云通信(IM) 和 对象存储(COS)等几项服务组合构建出适合您的直播解决方案。</li>\n</ol>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"视频","path":"api/categories/视频.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"直播","path":"api/tags/直播.json"},{"name":"腾讯云","path":"api/tags/腾讯云.json"},{"name":"集成","path":"api/tags/集成.json"},{"name":"SDK","path":"api/tags/SDK.json"}]},{"title":"Docker安装使用","slug":"Docker使用","date":"2016-12-21T21:25:29.000Z","updated":"2017-02-07T13:47:53.000Z","comments":true,"path":"api/articles/Docker使用.json","excerpt":null,"keywords":null,"cover":"http://docs.daocloud.io/user/pages/03.faq/08.install-docker-daocloud/DashboardDaoCloudInstall.png","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"安装Docker-for-Mac\"><a href=\"#安装Docker-for-Mac\" class=\"headerlink\" title=\"安装Docker for Mac\"></a>安装<a href=\"https://www.docker.com/products/docker#/mac\" target=\"_blank\" rel=\"noopener\">Docker for Mac</a></h2><p>在Mac上运行Docker。系统要求，OS X 10.10.3 或者更高版本，至少4G内存，4.3.30版本以前的VirtualBox会与Docker for Mac产生冲突，所以请卸载旧版本的VitrualBox。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo <span class=\"string\">'下载dmg...'</span></span><br><span class=\"line\">curl -o Docker.dmg <span class=\"symbol\">https:</span>/<span class=\"regexp\">/dn-dao-github-mirror.qbox.me/docker</span><span class=\"regexp\">/install/mac</span><span class=\"regexp\">/Docker.dmg</span></span><br><span class=\"line\"><span class=\"regexp\">#安装Docker.dmg</span></span><br><span class=\"line\"><span class=\"regexp\">MOUNTDIR=$(echo `hdiutil mount Docker.dmg | tail -1 \\</span></span><br><span class=\"line\"><span class=\"regexp\">| awk '&#123;$1=$2=\"\"; print $0&#125;'` | xargs -0 echo) \\</span></span><br><span class=\"line\"><span class=\"regexp\">&amp;&amp; cd $&#123;MOUNTDIR&#125; &amp;&amp; cp -R Docker.app /</span>Applications/ \\</span><br><span class=\"line\">&amp;&amp; open /Applications/Docker.app</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"配置-Docker-加速器镜像源\"><a href=\"#配置-Docker-加速器镜像源\" class=\"headerlink\" title=\"配置 Docker 加速器镜像源\"></a>配置 Docker 加速器镜像源</h3><p>右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Advanced 标签下的 Registry mirrors 列表中加入下面的镜像地址:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://142*****.m.daocloud.io</span><br></pre></td></tr></table></figure></p>\n<p>点击 Apply &amp; Restart 按钮使设置生效。</p>\n<h3 id=\"安装主机监控程序加速器\"><a href=\"#安装主机监控程序加速器\" class=\"headerlink\" title=\"安装主机监控程序加速器\"></a>安装主机监控程序加速器</h3><hr>\n<ol>\n<li>登录到 <code>DaoCloud 控制台</code>，点击「我的集群」按钮，在「接入自有主机」界面，点击 Mac 按钮。</li>\n<li>安装<a href=\"https://github.com/docker/toolbox/releases/download/v1.12.5/DockerToolbox-1.12.5.pkg\" target=\"_blank\" rel=\"noopener\">DockerToolbox</a>，是一个完整的开发组件，通过安装和配置<code>DaoCloud加速器 v2</code>，提升下载 <code>Docker Hub 镜像</code>的速度。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//下载pkg</span><br><span class=\"line\">curl -o DockerToolbox.pkg https://github.com/docker/toolbox/releases/download/v1.12.5/DockerToolbox-1.12.5.pkg</span><br><span class=\"line\">//安装pkg</span><br><span class=\"line\">sudo installer -pkg DockerToolbox.pkg -target /</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<a id=\"more\"></a>\n<ol>\n<li>安装Toolbox好了，下一步：<br><img src=\"http://docs.daocloud.io/user/pages/03.faq/08.install-docker-daocloud/DashboardDaoCloudInstall.png\" alt=\"\"></li>\n<li><code>$ docker-machine start default</code>启动 Docker.<br>当执行后提示：<code>Host does not exist: &quot;default&quot;</code><figure class=\"highlight plain\"><figcaption><span>docker-machine create</span><a href=\"http://stackoverflow.com/a/38602630\" target=\"_blank\" rel=\"noopener\">stackoverflow</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-machine create -d virtualbox default</span><br></pre></td></tr></table></figure></li>\n<li><p>在 <code>Docker 主机</code> DaoCloud 加速器的组件包：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -sSL <span class=\"symbol\">https:</span>/<span class=\"regexp\">/get.daocloud.io/daomonit</span><span class=\"regexp\">/install.sh | sh -s d0312f829e9807ee0bf157******</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动组件包,会在「安装主机监控程序」的 DaoCloud 控制台页面下方显示一台已经接入的主机。</p>\n<img src=\"http://p27uwfdhv.bkt.clouddn.com/static/images/daoshell.png?imageMogr2/2/w/800\"></li>\n<li>执行<code>Dao Pull</code>命令,高速下载<code>Docker Hub</code>镜像文件<br>这台 Docker 主机已经被接入 DaoCloud 平台，用户可以在 DaoCloud 控制台的「我的集群」页面发现这台主机，可以执行管理和部署应用的操作。</li>\n</ol>\n<h3 id=\"从Docker-Hub-仓库中获取一个镜像\"><a href=\"#从Docker-Hub-仓库中获取一个镜像\" class=\"headerlink\" title=\"从Docker Hub 仓库中获取一个镜像\"></a>从Docker Hub 仓库中获取一个镜像</h3><hr>\n<p>Docker 使用类似 git 的方式管理镜像。通过基本的镜像可以定制创建出来不同种应用的 Docker 镜像。Docker Hub 是 Docker 官方提供的镜像中心。在这里可以很方便地找到各类应用、环境的镜像。由于 Docker 使用联合文件系统，所以镜像就像是夹心饼干一样一层层构成，相同底层的镜像可以共享。所以 Docker 还是相当节约磁盘空间的。要使用一 个镜像，需要先从远程的镜像注册中心拉取，这点非常类似 git。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull ubuntu</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Docker-命令创建管理容器\"><a href=\"#Docker-命令创建管理容器\" class=\"headerlink\" title=\"Docker 命令创建管理容器\"></a>Docker 命令创建管理容器</h2><hr>\n<h3 id=\"获取镜像的两种方式\"><a href=\"#获取镜像的两种方式\" class=\"headerlink\" title=\"获取镜像的两种方式\"></a>获取镜像的两种方式</h3><hr>\n<h4 id=\"1-docker-pull命令\"><a href=\"#1-docker-pull命令\" class=\"headerlink\" title=\"1. docker pull命令\"></a>1. <code>docker pull</code>命令</h4><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker search perfectlysoft/ubuntu</span><br><span class=\"line\">docker pull perfectlysoft/ubuntu</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-docker-import命令\"><a href=\"#2-docker-import命令\" class=\"headerlink\" title=\"2. docker import命令\"></a>2. <code>docker import</code>命令</h4><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker import myubuntu.tar.gz</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过镜像创建容器\"><a href=\"#通过镜像创建容器\" class=\"headerlink\" title=\"通过镜像创建容器\"></a>通过镜像创建容器</h3><hr>\n<p>创建一个容器有两种方式：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker create 镜像名</span><br><span class=\"line\">docker run   镜像名   /<span class=\"regexp\">/立即启动容器 等价于：create + start 命令组合</span></span><br></pre></td></tr></table></figure></p>\n<p>进入容器终端控制台如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@ec72dc76502e:/# ls</span><br><span class=\"line\">app  boot  etc   lib    media  opt   root  sbin  sys  usr</span><br><span class=\"line\">bin  dev   home  lib64  mnt    proc  run   srv   tmp  var</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"docker-run-images命令\"><a href=\"#docker-run-images命令\" class=\"headerlink\" title=\"docker run images命令\"></a><code>docker run images</code>命令</h4><ol>\n<li><p>样例1<br>执行<code>run images</code>，并将 Ubuntu 的 Shell 作为入口，进入Docker容器环境操作</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it <span class=\"symbol\">ubuntu:</span>latest sh -c <span class=\"string\">'/bin/bash'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>样例2<br>执行<code>docker start -i 容器</code>命令进入容器环境</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker start -i 容器ID/容器名</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"从KitematicGUI进入容器环境\"><a href=\"#从KitematicGUI进入容器环境\" class=\"headerlink\" title=\"从KitematicGUI进入容器环境\"></a>从<code>Kitematic</code>GUI进入容器环境</h4><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash -c <span class=\"string\">\"clear &amp;&amp; docker exec -it perfectswift sh\"</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>参数<br>-i 表示这是一个交互容器，会把当前标准输入重定向到容器的标准输入中，而不是终止程序运行<br>-t 指为这个容器分配一个终端</p>\n</blockquote>\n<p>这时候我们成功创建了一个 Ubuntu 的容器，并将当前终端连接为这个 Ubuntu 的 bash shell。这时候就可以愉快地使用 Ubuntu 的相关命令了。</p>\n<h3 id=\"ps-查看容器状态\"><a href=\"#ps-查看容器状态\" class=\"headerlink\" title=\"ps 查看容器状态\"></a>ps 查看容器状态</h3><hr>\n<p>在容器运行期间，我们可以通过 <code>docker ps</code> 命令看到所有当前正在运行的容器。<br>添加-a参数可以看到所有创建的容器：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps -a</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"容器ID标识\"><a href=\"#容器ID标识\" class=\"headerlink\" title=\"容器ID标识\"></a>容器ID标识</h3><hr>\n<p>每个容器都有一个唯一的 ID 标识，通过 ID 可以对这个容器进行管理和操作。在创建容器时，我们可以通过 –name 参数指定一个容器名称，如果没有指定系统将会分配一个，就像这里的「trusting_morse」。</p>\n<h3 id=\"启动-退出-移除容器\"><a href=\"#启动-退出-移除容器\" class=\"headerlink\" title=\"启动/退出/移除容器\"></a>启动/退出/移除容器</h3><hr>\n<p>启动：<code>start</code><br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker start -i trusting_morse</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意：每次执行 docker run 命令都会创建新的容器，建议一次创建后，使用 docker start/stop 来启动和停用容器。</p>\n</blockquote>\n<p>退出：<br>按 <code>Ctrl+D</code> 退出</p>\n<p>移除：<code>rm</code>ID/name<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm [CONTAINER ID/NAMES]</span><br></pre></td></tr></table></figure></p>\n<p>重命名：<code>rename</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rename 容器ID newName</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"创建管理镜像\"><a href=\"#创建管理镜像\" class=\"headerlink\" title=\"创建管理镜像\"></a>创建管理镜像</h2><hr>\n<p>Docker 强大的威力在于可以把自己开发的应用随同各种依赖环境一起打包、分发、运行。要创建一个新的 Docker 镜像，通常基于一个已有的 Docker 镜像来创建。<br>Docker 提供了两种方式来创建镜像：</p>\n<ol>\n<li>把容器创建为一个新的镜像</li>\n<li>使用 Dockerfile 创建镜像。</li>\n</ol>\n<h3 id=\"将容器创建为镜像\"><a href=\"#将容器创建为镜像\" class=\"headerlink\" title=\"将容器创建为镜像\"></a>将容器创建为镜像</h3><hr>\n<ol>\n<li><p>为了创建一个新的镜像，我们先创建一个新的容器作为基底：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it <span class=\"symbol\">ubuntu:</span>latest sh -c <span class=\"string\">'/bin/bash'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>定制这个容器，例如我们可以配置 PHP 环境、将我们的项目代码部署在里面等：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install php</span><br><span class=\"line\"><span class=\"comment\"># some other opreations ...</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>当执行完操作之后，我们按 Ctrl+D 退出容器.</p>\n<ol>\n<li><p>获取定制后的容器ID</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps -a</span><br><span class=\"line\">[root@localhost ~]# docker ps -a</span><br><span class=\"line\"></span><br><span class=\"line\">CONTAINER ID        IMAGE                        COMMAND                    CREATED             STATUS                      PORTS               NAMES</span><br><span class=\"line\">cb2b06c83a50        ubuntu:latest                &quot;sh -c /bin/bash&quot;          7 minutes ago       Exited (0) 7 seconds ago                       trusting_morse</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行<code>docker commit</code> 把这个容器变为一个镜像：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit cb2b06c83a50 ubuntu:myubuntu</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这时候 docker 容器会被创建为一个新的 Ubuntu 镜像，版本名称为 myubuntu。以后我们可以随时使用这个镜像来创建容器了，新的容器将自动包含上面对容器的操作。    </p>\n<ol>\n<li><p>打包/发布镜像</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker save -o myubuntu.tar.gz <span class=\"symbol\">ubuntu:</span>myubuntu</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>导入打包镜像</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker import myubuntu.tar.gz</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h3><hr>\n<h4 id=\"通过Dockerfile创建镜像\"><a href=\"#通过Dockerfile创建镜像\" class=\"headerlink\" title=\"通过Dockerfile创建镜像\"></a>通过<code>Dockerfile</code>创建镜像</h4><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build yourDir/Dockerfile</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>确保Dockerfile文件在一个目录中，否则会提示错误</p>\n</blockquote>\n<p>Docker Hub 提供了类似 GitHub 的镜像存管服务。一个镜像发布到 Docker Hub 不仅可以供更多人使用，而且便于镜像的版本管理。在一个企业内部可以通过自建 Docker Registry 的方式来统一管理和发布镜像。将 Docker Registry 集成到版本管理和上线发布的工作流之中，还有许多工作要做，在我整理出最佳实践后会第一时间分享。<br>使用命令行的方式创建 Docker 镜像通常难以自动化操作。在更多的时候，我们使用 Dockerfile 来创建 Docker 镜像。Dockerfile 是一个纯文本文件，它记载了从一个镜像创建另一个新镜像的步骤。撰写好 Dockerfile 文件之后，我们就可以轻而易举的使用 docker build 命令来创建镜像了。<br>Dockerfile 非常简单，仅有以下命令在 Dockerfile 中常被使用：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:right\">命令</th>\n<th style=\"text-align:right\">参数</th>\n<th style=\"text-align:right\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:right\">#</td>\n<td style=\"text-align:right\">-</td>\n<td style=\"text-align:right\">注释说明</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">FROM</td>\n<td style=\"text-align:right\"><image>[:<tag>]</tag></image></td>\n<td style=\"text-align:right\">从一个已有镜像创建，例如ubuntu:latest</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">MAINTAINER</td>\n<td style=\"text-align:right\">Author <a href=\"&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#115;&#111;&#109;&#101;&#x2d;&#x6f;&#x6e;&#x65;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#x65;&#x2e;&#x63;&#x6f;&#109;\">&#115;&#111;&#109;&#101;&#x2d;&#x6f;&#x6e;&#x65;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#x65;&#x2e;&#x63;&#x6f;&#109;</a></td>\n<td style=\"text-align:right\">镜像作者名字，如Max Liu <a href=\"&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#115;&#111;&#x6d;&#x65;&#45;&#111;&#110;&#101;&#x40;&#101;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#46;&#x63;&#111;&#109;\">&#115;&#111;&#x6d;&#x65;&#45;&#111;&#110;&#101;&#x40;&#101;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#46;&#x63;&#111;&#109;</a></td>\n</tr>\n<tr>\n<td style=\"text-align:right\">RUN</td>\n<td style=\"text-align:right\"><cmd>或者[‘cmd1’, ‘cmd2’…]</cmd></td>\n<td style=\"text-align:right\">在镜像创建用的临时容器里执行单行命令</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">ADD</td>\n<td style=\"text-align:right\"><src> <dest></dest></src></td>\n<td style=\"text-align:right\">将本地的<src>添加到镜像容器中的<dest>位置</dest></src></td>\n</tr>\n<tr>\n<td style=\"text-align:right\">VOLUME</td>\n<td style=\"text-align:right\"><path></path>或者[‘/var’, ‘home’]</td>\n<td style=\"text-align:right\">将指定的路径挂载为数据卷</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">EXPOSE</td>\n<td style=\"text-align:right\"><port> [<port>…]</port></port></td>\n<td style=\"text-align:right\">将指定的端口暴露给主机</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">ENV</td>\n<td style=\"text-align:right\"><key> <value> 或者 <key> = <value></value></key></value></key></td>\n<td style=\"text-align:right\">指定环境变量值</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">CMD</td>\n<td style=\"text-align:right\">[“executable”,”param1”,”param2”]</td>\n<td style=\"text-align:right\">容器启动时默认执行的命令。注意一个Dockerfile中只有最后一个CMD生效。</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">ENTRYPOINT</td>\n<td style=\"text-align:right\">[“executable”, “param1”, “param2”]</td>\n<td style=\"text-align:right\">容器的进入点</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"配置Dockerfile\"><a href=\"#配置Dockerfile\" class=\"headerlink\" title=\"配置Dockerfile\"></a>配置Dockerfile</h4><hr>\n<p>下面是一个 Dockerfile 的例子：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># This is a comment</span></span><br><span class=\"line\">FROM <span class=\"symbol\">ubuntu:</span><span class=\"number\">14.04</span></span><br><span class=\"line\">MAINTAINER Kate Smith &lt;ksmith@example.com&gt;</span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y ruby ruby-dev</span><br><span class=\"line\">RUN gem install sinatra</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"CMD命令\"><a href=\"#CMD命令\" class=\"headerlink\" title=\"CMD命令\"></a><code>CMD</code>命令</h5><hr>\n<p><code>CMD</code>: 命令可用指定 Docker 容器启动时默认的命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it ubuntu:latest sh -c &apos;/bin/bash&apos;</span><br></pre></td></tr></table></figure></p>\n<p>其中 <code>sh -c &#39;/bin/bash&#39;</code> 就是手工指定的<code>CMD</code>,否则容器将会使用默认 <code>CMD</code> 指定的命令启动。</p>\n<h5 id=\"ENTRYPOINT命令\"><a href=\"#ENTRYPOINT命令\" class=\"headerlink\" title=\"ENTRYPOINT命令\"></a><code>ENTRYPOINT</code>命令</h5><hr>\n<p>用来指定可执行文件、Shell 脚本，同时会并把启动参数或 CMD 指定的默认值，当作附加参数传递给 执行文件、Shell 脚本。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRYPOINT [<span class=\"string\">'/usr/bin/mysql'</span>]</span><br><span class=\"line\">CMD [<span class=\"string\">'-h 192.168.100.128'</span>, <span class=\"string\">'-p'</span>]</span><br></pre></td></tr></table></figure></p>\n<p>执行mysql启动程序，连接<code>192.168.100.128</code> 主机,也可以通过指定参数，来连接别的主机。</p>\n<p>因此，我们在使用 Dockerfile 创建文件的时候，可以创建一个 entrypoint.sh 脚本，作为系统入口。在这个文件里面，我们可以进行一些基础性的自举操作，比如检查环境变量，根据需要初始化数据库等等。下面两个文件是我在日常工作的项目中添加的 Dockerfile 和 entrypoint.sh，仅供参考：<br><a href=\"https://github.com/starlight36/SimpleOA/blob/master/Dockerfile\" target=\"_blank\" rel=\"noopener\">https://github.com/starlight36/SimpleOA/blob/master/Dockerfile</a><br><a href=\"https://github.com/starlight36/SimpleOA/blob/master/docker-entrypoint.sh\" target=\"_blank\" rel=\"noopener\">https://github.com/starlight36/SimpleOA/blob/master/docker-entrypoint.sh</a><br>在准备好 Dockerfile 之后，我们就可以创建镜像了：</p>\n<h4 id=\"创建镜像\"><a href=\"#创建镜像\" class=\"headerlink\" title=\"创建镜像\"></a>创建镜像</h4><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t starlight36/simpleoa .</span><br></pre></td></tr></table></figure>\n","raw":null,"categories":[{"name":"docker","path":"api/categories/docker.json"}],"tags":[{"name":"语法","path":"api/tags/语法.json"},{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"}]},{"title":"使用SmartSVN创建版本库","slug":"git/使用SmartSVN创建版本库","date":"2015-10-05T19:16:47.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/使用SmartSVN创建版本库.json","excerpt":null,"keywords":null,"cover":"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/adeb039a-b429-481a-ac25-2044b871e45e/screenshot.png?resizeSmall&amp;width=832","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>SmartSVN有以下版本：</p>\n<ol>\n<li>SmartSVN enterprise 9 企业版</li>\n<li>SmartSVN foundation 8 基础版</li>\n</ol>\n<p>由于企业版只能建立本地的版本库，无法创建&amp;使用svn://localhost方式。</p>\n<h4 id=\"用基础版来说明创建版本库。\"><a href=\"#用基础版来说明创建版本库。\" class=\"headerlink\" title=\"用基础版来说明创建版本库。\"></a>用基础版来说明创建版本库。</h4><p>参考：<a href=\"http://hammadk.com/how-to-create-repository-in-smartsvn-tutorial/\" target=\"_blank\" rel=\"noopener\">Create Repository in SmartSVN – Tutorial</a>  </p>\n<ol>\n<li>启动SmartSVN SmartSVN foundation 8 基础版  </li>\n<li>菜单栏Project-&gt; set up Local Repository…<br>需要设置如下两个参数：  <ol>\n<li>svnadmin 在终端执行： whereis svnadmin  </li>\n<li>svnserve 在终端执行： whereis svnserve<br>￼<img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/adeb039a-b429-481a-ac25-2044b871e45e/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\">  </li>\n</ol>\n</li>\n<li>指定版本库的目录位置：<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/a3f00903-101c-4848-a10a-3479643baea7/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\">  </li>\n<li>初始化账户密码：<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/140f257e-e452-47ea-8317-34a5ed8d6c7f/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\">  </li>\n<li>完成。<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/ed975623-72bb-4132-8d04-ac9a7b1d2fc9/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\"><br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/53306789-9d97-485c-a54d-a143e7b078f1/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\"><a id=\"more\"></a>    \n<h5 id=\"开始导入项目源码，来跟踪版本变化，实现版本控制。\"><a href=\"#开始导入项目源码，来跟踪版本变化，实现版本控制。\" class=\"headerlink\" title=\"开始导入项目源码，来跟踪版本变化，实现版本控制。\"></a>开始导入项目源码，来跟踪版本变化，实现版本控制。</h5></li>\n<li>新建SmartSVNRepos目录，存放APP源码，用于导入版本库的原始目录。导入后，该目录源码就被版本跟踪了，在开发时，不用再从版本库导出，可以用该目录的代码直接在版本上开发了。<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/ee02bf65-27e3-435a-8300-8189bc087eb8/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\"></li>\n<li>菜单栏Project -&gt; Import Into Repository…<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/eccc10f0-4c5a-435c-8397-062028d0d4f4.png?resizeSmall&amp;width=832\" alt=\"image\"></li>\n<li>选择以上新建的SmartSVN版本库：svn://localhost<br><img src=\"https://app.yinxiang.com/shard/s33/nl/2147483647/59a78b5d-81de-48f1-afe9-2fb2bde72da2//res/ecfe16b4-17ac-4fc1-a64f-1ce259d77b3b/screenshot.png?resizeSmall&amp;width=832\" alt=\"image\"> </li>\n</ol>\n<p>查看是否安装SVN服务：</p>\n<pre><code>svnserve —version\n</code></pre><p>SVN随系统一起启动：</p>\n<pre><code>vi /etc/rc.local   //(此文件Mac系统中默认是不存在的，需手动创建)\n\n添加启动SVN服务： \nsvnserve -d -r /data/svn/repos  \n</code></pre><p>关闭svn服务:</p>\n<pre><code>直接ps aux | grep svn，然后kill -9 进程号\n</code></pre><ol>\n<li><p>创建库:<br> 打印应用目录命令：</p>\n<pre><code>whereis svn\n</code></pre><p> 新建版本库目录：</p>\n<pre><code>sudo mkdir -p /data/svn/repos/local    \nchmod u+w 文件名\n</code></pre><p> 创建：</p>\n<pre><code>sudo svnadmin create /data/svn/repos/local\n查看文件权限： ls -l\n</code></pre></li>\n<li><p>配置版本库的访问权限</p>\n<pre><code>cd conf/ \n</code></pre><ol>\n<li><p>开启密码权限，普通用户/匿名用户</p>\n<pre><code>sudo vi svnserve.conf\n</code></pre></li>\n<li><p>设置用户：密码</p>\n<pre><code>sudo vi passwd\n</code></pre></li>\n<li><p>分组设置，组权限</p>\n<pre><code>sudo vi authz\n</code></pre></li>\n</ol>\n</li>\n<li><p>启动svnserve服务  </p>\n<pre><code>sudo svnserve -d -r /data/svn/repos —log-file=/var/log/svn.log\n</code></pre></li>\n<li><p>测试端口：</p>\n<pre><code>telnet localhost 3690\n</code></pre></li>\n<li><p>重启必先kill ：</p>\n<pre><code>sudo kill PID\n</code></pre></li>\n<li><p>版本库路径：</p>\n<pre><code>svn://localhost/local\n</code></pre><p>其他：</p>\n<pre><code>svn ls svn://svnpath 可以查询snv仓库内容  \nlsof -i :3690 查看svn是否启动  \nps aux | grep ‘svn’ 查找所有svn启动的进程id  \nkill -9 pid 将pid替换为上面查到的进程id可以杀掉svn进程  \n</code></pre></li>\n</ol>\n","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"svn","path":"api/categories/svn.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"svn","path":"api/tags/svn.json"}]},{"title":"Mac安装gitLab服务器","slug":"git/Mac安装gitLab服务器","date":"2015-09-27T19:25:38.000Z","updated":"2018-03-28T07:42:14.000Z","comments":true,"path":"api/articles/git/Mac安装gitLab服务器.json","excerpt":null,"keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h4 id=\"必要配置\"><a href=\"#必要配置\" class=\"headerlink\" title=\"必要配置\"></a>必要配置</h4><pre><code>*创建一个名称为&quot;gitlab&quot;管理员用户，然后再创建一个名称为&quot;gitlab&quot;的群组\n*开启gitlab用户的远程登录\n</code></pre><p>在系统启动界面:<br>隐藏gitlab用户 </p>\n<pre><code>sudo defaults write /Library/Preferences/com.apple.loginwindow HiddenUsersList -array-add gitlab\n</code></pre><p>显示git用户</p>\n<pre><code>sudo defaults delete /Library/Preferences/com.apple.loginwindow HiddenUsersList\n</code></pre><h4 id=\"添加系统账户gitlab\"><a href=\"#添加系统账户gitlab\" class=\"headerlink\" title=\"添加系统账户gitlab\"></a>添加系统账户gitlab</h4><h6 id=\"生成gitlab服务器目录，即用户根目录\"><a href=\"#生成gitlab服务器目录，即用户根目录\" class=\"headerlink\" title=\"生成gitlab服务器目录，即用户根目录\"></a>生成gitlab服务器目录，即用户根目录</h6><p>进入<strong>系统偏好设置…</strong>,在管理<strong>用户与群组</strong>中，添加其他用户，暂时定为：gitlab ，登录密码假设为：gitlab，添加完成后，会自动在/Users目录下，生成用户根目录gitlab.</p>\n<h6 id=\"安装-Gitlab-Shell\"><a href=\"#安装-Gitlab-Shell\" class=\"headerlink\" title=\"安装 Gitlab Shell\"></a>安装 Gitlab Shell</h6><pre><code>cd /Users/gitlab\nsudo -u gitlab git clone https://github.com/gitlabhq/gitlab-shell.git\ncd gitlab-shell\nsudo -u gitlab git checkout v1.9.1\nsudo -u gitlab cp config.yml.example config.yml\n</code></pre><p>打开 config.yml,然后进行编辑<br>设置  gitlab_url. 把 gitlab.example.com 替换成你自己的域名 （如果本地就不用了）<br>把所有的/home 替换成 /Users</p>\n<pre><code>sudo -u gitlab sed -i &quot;&quot; &quot;s/\\/home\\//\\/Users\\//g&quot; config.yml\nsudo -u gitlab sed -i &quot;&quot; &quot;s/\\/usr\\/bin\\/redis-cli/\\/usr\\/local\\/bin\\/redis-cli/&quot; config.yml\n</code></pre><p>然后执行安装脚本：<code>sudo -u gitlab -H ./bin/install</code>  <strong>//需在gitlab-shell目录下载执行</strong></p>\n<h6 id=\"安装gitlab\"><a href=\"#安装gitlab\" class=\"headerlink\" title=\"安装gitlab\"></a>安装gitlab</h6><p>先下载gitlab</p>\n<pre><code>cd /Users/gitlab\nsudo -u gitlab git clone https://github.com/gitlabhq/gitlabhq.git\ncd gitlab\nsudo -u gitlab git checkout 6-7-stable\n</code></pre><p>配置gitlab</p>\n<pre><code>sudo -u gitlab cp config/gitlab.yml.example config/gitlab.yml\nsudo -u gitlab sed -i &quot;&quot; &quot;s/\\/usr\\/bin\\/git/\\/usr\\/local\\/bin\\/git/g&quot; config/gitlab.yml\nsudo -u gitlab sed -i &quot;&quot; &quot;s/\\/home/\\/Users/g&quot; config/gitlab.yml\nsudo -u gitlab sed -i &quot;&quot; &quot;s/localhost/domain.com/g&quot; config/gitlab.yml\n</code></pre><p>配置MySQL数据库，创建gitlab用户，数据库，和gitlab用户的管理权限</p>\n<pre><code># Login to MySQL\n$ mysql -u root -p\n\n# Create the GitLab production database\nmysql&gt; CREATE DATABASE IF NOT EXISTS `gitlabhq_production` DEFAULT CHARACTER SET `utf8` COLLATE `utf8_unicode_ci`;\n\n# Create the MySQL User change $password to a real password\nmysql&gt; CREATE USER &apos;gitlab&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;$password&apos;;\n\n# Grant proper permissions to the MySQL User\nmysql&gt; GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER ON `gitlabhq_production`.* TO &apos;gitlab&apos;@&apos;localhost&apos;;\n</code></pre><h6 id=\"安装-Gitolite帮助管理git内部用户\"><a href=\"#安装-Gitolite帮助管理git内部用户\" class=\"headerlink\" title=\"安装 Gitolite帮助管理git内部用户\"></a>安装 Gitolite帮助管理git内部用户</h6><p>克隆gitlab的gitolite分支源代码：</p>\n<pre><code>sudo -H -u gitlab git clone -b gl-v304 https://github.com/gitlabhq/gitolite.git /Users/gitlab/gitolite\n</code></pre><p>安装：</p>\n<pre><code>cd /Users/gitlab\nsudo -u gitlab -H mkdir bin\nsudo -u gitlab sh -c &apos;echo -e &quot;PATH=\\$PATH:/Users/gitlab/bin\\nexport PATH&quot; &gt;&gt; /Users/gitlab/.profile&apos;\nsudo -u gitlab sh -c &apos;gitolite/install -ln /Users/gitlab/bin&apos;\n\nsudo cp ~/.ssh/id_rsa.pub /Users/gitlab/gitlab.pub\nsudo chmod 0444 /Users/gitlab/gitlab.pub\n\nsudo -u gitlab -H sh -c &quot;PATH=/Users/gitlab/bin:$PATH; gitolite setup -pk /Users/gitlab/gitlab.pub&quot;\n</code></pre><p>为 Git 创建用户：    </p>\n<pre><code>sudo adduser \\\n  --system \\\n  --shell /bin/sh \\\n  --gecos &apos;git version control&apos; \\\n  --group \\\n  --disabled-password \\\n  --home /home/git \\\n  git\n</code></pre><p>若干问题解决办法：<a href=\"http://www.cnblogs.com/whj198579/archive/2013/04/09/3009350.html\" target=\"_blank\" rel=\"noopener\">Mac搭建Git服务器—开启SSH</a></p>\n<pre><code>Cloning into &apos;/tmp/gitolite-admin&apos;...\nssh: connect to host localhost port 22: Connection refused\nfatal: Could not read from remote repository.\n</code></pre><p>SSH无密码登陆设置：</p>\n<pre><code>$ cd /etc\n$ chmod 666 sshd_config\n$ vim sshd_config\n\n#PermitRootLogin yes  改为：PermitRootLogin no\n#UsePAM yes             改为: UsePAM no\n</code></pre><p>Remove the # from the following</p>\n<pre><code>#RSAAuthentication yes\n#PubkeyAuthentication yes\n#AuthorizedKeysFile     .ssh/authorized_keys    \n#PasswordAuthentication no\n#PermitEmptyPasswords no\n</code></pre>","raw":null,"categories":[{"name":"git","path":"api/categories/git.json"},{"name":"gitLab","path":"api/categories/gitLab.json"}],"tags":[{"name":"搭建","path":"api/tags/搭建.json"},{"name":"工具","path":"api/tags/工具.json"},{"name":"git","path":"api/tags/git.json"},{"name":"gitLab","path":"api/tags/gitLab.json"}]}]}